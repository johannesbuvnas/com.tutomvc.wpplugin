/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js??ruleSet[1].rules[2].use[2]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[2].use[3]!./src/scss/tutomvc.scss":
/*!***********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js??ruleSet[1].rules[2].use[2]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[2].use[3]!./src/scss/tutomvc.scss ***!
  \***********************************************************************************************************************************************************************************************************************/
/***/ (() => {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js ***!
  \************************************************************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\r\n * Bootstrap-select v1.13.18 (https://developer.snapappointments.com/bootstrap-select)\r\n *\r\n * Copyright 2012-2020 SnapAppointments, LLC\r\n * Licensed under MIT (https://github.com/snapappointments/bootstrap-select/blob/master/LICENSE)\r\n */\r\n\r\n(function (root, factory) {\r\n  if (root === undefined && window !== undefined) root = window;\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module unless amdModuleId is set\r\n    define([\"jquery\"], function (a0) {\r\n      return (factory(a0));\r\n    });\r\n  } else if (typeof module === 'object' && module.exports) {\r\n    // Node. Does not work with strict CommonJS, but\r\n    // only CommonJS-like environments that support module.exports,\r\n    // like Node.\r\n    module.exports = factory(require(\"jquery\"));\r\n  } else {\r\n    factory(root[\"jQuery\"]);\r\n  }\r\n}(this, function (jQuery) {\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\r\n\r\n  var uriAttrs = [\r\n    'background',\r\n    'cite',\r\n    'href',\r\n    'itemtype',\r\n    'longdesc',\r\n    'poster',\r\n    'src',\r\n    'xlink:href'\r\n  ];\r\n\r\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\r\n\r\n  var DefaultWhitelist = {\r\n    // Global attributes allowed on any supplied element below.\r\n    '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],\r\n    a: ['target', 'href', 'title', 'rel'],\r\n    area: [],\r\n    b: [],\r\n    br: [],\r\n    col: [],\r\n    code: [],\r\n    div: [],\r\n    em: [],\r\n    hr: [],\r\n    h1: [],\r\n    h2: [],\r\n    h3: [],\r\n    h4: [],\r\n    h5: [],\r\n    h6: [],\r\n    i: [],\r\n    img: ['src', 'alt', 'title', 'width', 'height'],\r\n    li: [],\r\n    ol: [],\r\n    p: [],\r\n    pre: [],\r\n    s: [],\r\n    small: [],\r\n    span: [],\r\n    sub: [],\r\n    sup: [],\r\n    strong: [],\r\n    u: [],\r\n    ul: []\r\n  }\r\n\r\n  /**\r\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\r\n   *\r\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\r\n   */\r\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\r\n\r\n  /**\r\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\r\n   *\r\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\r\n   */\r\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;\r\n\r\n  function allowedAttribute (attr, allowedAttributeList) {\r\n    var attrName = attr.nodeName.toLowerCase()\r\n\r\n    if ($.inArray(attrName, allowedAttributeList) !== -1) {\r\n      if ($.inArray(attrName, uriAttrs) !== -1) {\r\n        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN))\r\n      }\r\n\r\n      return true\r\n    }\r\n\r\n    var regExp = $(allowedAttributeList).filter(function (index, value) {\r\n      return value instanceof RegExp\r\n    })\r\n\r\n    // Check if a regular expression validates the attribute.\r\n    for (var i = 0, l = regExp.length; i < l; i++) {\r\n      if (attrName.match(regExp[i])) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function sanitizeHtml (unsafeElements, whiteList, sanitizeFn) {\r\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\r\n      return sanitizeFn(unsafeElements);\r\n    }\r\n\r\n    var whitelistKeys = Object.keys(whiteList);\r\n\r\n    for (var i = 0, len = unsafeElements.length; i < len; i++) {\r\n      var elements = unsafeElements[i].querySelectorAll('*');\r\n\r\n      for (var j = 0, len2 = elements.length; j < len2; j++) {\r\n        var el = elements[j];\r\n        var elName = el.nodeName.toLowerCase();\r\n\r\n        if (whitelistKeys.indexOf(elName) === -1) {\r\n          el.parentNode.removeChild(el);\r\n\r\n          continue;\r\n        }\r\n\r\n        var attributeList = [].slice.call(el.attributes);\r\n        var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\r\n\r\n        for (var k = 0, len3 = attributeList.length; k < len3; k++) {\r\n          var attr = attributeList[k];\r\n\r\n          if (!allowedAttribute(attr, whitelistedAttributes)) {\r\n            el.removeAttribute(attr.nodeName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Polyfill for browsers with no classList support\r\n  // Remove in v2\r\n  if (!('classList' in document.createElement('_'))) {\r\n    (function (view) {\r\n      if (!('Element' in view)) return;\r\n\r\n      var classListProp = 'classList',\r\n          protoProp = 'prototype',\r\n          elemCtrProto = view.Element[protoProp],\r\n          objCtr = Object,\r\n          classListGetter = function () {\r\n            var $elem = $(this);\r\n\r\n            return {\r\n              add: function (classes) {\r\n                classes = Array.prototype.slice.call(arguments).join(' ');\r\n                return $elem.addClass(classes);\r\n              },\r\n              remove: function (classes) {\r\n                classes = Array.prototype.slice.call(arguments).join(' ');\r\n                return $elem.removeClass(classes);\r\n              },\r\n              toggle: function (classes, force) {\r\n                return $elem.toggleClass(classes, force);\r\n              },\r\n              contains: function (classes) {\r\n                return $elem.hasClass(classes);\r\n              }\r\n            }\r\n          };\r\n\r\n      if (objCtr.defineProperty) {\r\n        var classListPropDesc = {\r\n          get: classListGetter,\r\n          enumerable: true,\r\n          configurable: true\r\n        };\r\n        try {\r\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\r\n        } catch (ex) { // IE 8 doesn't support enumerable:true\r\n          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\r\n          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\r\n          if (ex.number === undefined || ex.number === -0x7FF5EC54) {\r\n            classListPropDesc.enumerable = false;\r\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\r\n          }\r\n        }\r\n      } else if (objCtr[protoProp].__defineGetter__) {\r\n        elemCtrProto.__defineGetter__(classListProp, classListGetter);\r\n      }\r\n    }(window));\r\n  }\r\n\r\n  var testElement = document.createElement('_');\r\n\r\n  testElement.classList.add('c1', 'c2');\r\n\r\n  if (!testElement.classList.contains('c2')) {\r\n    var _add = DOMTokenList.prototype.add,\r\n        _remove = DOMTokenList.prototype.remove;\r\n\r\n    DOMTokenList.prototype.add = function () {\r\n      Array.prototype.forEach.call(arguments, _add.bind(this));\r\n    }\r\n\r\n    DOMTokenList.prototype.remove = function () {\r\n      Array.prototype.forEach.call(arguments, _remove.bind(this));\r\n    }\r\n  }\r\n\r\n  testElement.classList.toggle('c3', false);\r\n\r\n  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\r\n  // support the second argument.\r\n  if (testElement.classList.contains('c3')) {\r\n    var _toggle = DOMTokenList.prototype.toggle;\r\n\r\n    DOMTokenList.prototype.toggle = function (token, force) {\r\n      if (1 in arguments && !this.contains(token) === !force) {\r\n        return force;\r\n      } else {\r\n        return _toggle.call(this, token);\r\n      }\r\n    };\r\n  }\r\n\r\n  testElement = null;\r\n\r\n  // shallow array comparison\r\n  function isEqual (array1, array2) {\r\n    return array1.length === array2.length && array1.every(function (element, index) {\r\n      return element === array2[index];\r\n    });\r\n  };\r\n\r\n  // <editor-fold desc=\"Shims\">\r\n  if (!String.prototype.startsWith) {\r\n    (function () {\r\n      'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\r\n      var defineProperty = (function () {\r\n        // IE 8 only supports `Object.defineProperty` on DOM elements\r\n        try {\r\n          var object = {};\r\n          var $defineProperty = Object.defineProperty;\r\n          var result = $defineProperty(object, object, object) && $defineProperty;\r\n        } catch (error) {\r\n        }\r\n        return result;\r\n      }());\r\n      var toString = {}.toString;\r\n      var startsWith = function (search) {\r\n        if (this == null) {\r\n          throw new TypeError();\r\n        }\r\n        var string = String(this);\r\n        if (search && toString.call(search) == '[object RegExp]') {\r\n          throw new TypeError();\r\n        }\r\n        var stringLength = string.length;\r\n        var searchString = String(search);\r\n        var searchLength = searchString.length;\r\n        var position = arguments.length > 1 ? arguments[1] : undefined;\r\n        // `ToInteger`\r\n        var pos = position ? Number(position) : 0;\r\n        if (pos != pos) { // better `isNaN`\r\n          pos = 0;\r\n        }\r\n        var start = Math.min(Math.max(pos, 0), stringLength);\r\n        // Avoid the `indexOf` call if no match is possible\r\n        if (searchLength + start > stringLength) {\r\n          return false;\r\n        }\r\n        var index = -1;\r\n        while (++index < searchLength) {\r\n          if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      };\r\n      if (defineProperty) {\r\n        defineProperty(String.prototype, 'startsWith', {\r\n          'value': startsWith,\r\n          'configurable': true,\r\n          'writable': true\r\n        });\r\n      } else {\r\n        String.prototype.startsWith = startsWith;\r\n      }\r\n    }());\r\n  }\r\n\r\n  if (!Object.keys) {\r\n    Object.keys = function (\r\n      o, // object\r\n      k, // key\r\n      r  // result array\r\n    ) {\r\n      // initialize object and result\r\n      r = [];\r\n      // iterate over object keys\r\n      for (k in o) {\r\n        // fill result array with non-prototypical keys\r\n        r.hasOwnProperty.call(o, k) && r.push(k);\r\n      }\r\n      // return result\r\n      return r;\r\n    };\r\n  }\r\n\r\n  if (HTMLSelectElement && !HTMLSelectElement.prototype.hasOwnProperty('selectedOptions')) {\r\n    Object.defineProperty(HTMLSelectElement.prototype, 'selectedOptions', {\r\n      get: function () {\r\n        return this.querySelectorAll(':checked');\r\n      }\r\n    });\r\n  }\r\n\r\n  function getSelectedOptions (select, ignoreDisabled) {\r\n    var selectedOptions = select.selectedOptions,\r\n        options = [],\r\n        opt;\r\n\r\n    if (ignoreDisabled) {\r\n      for (var i = 0, len = selectedOptions.length; i < len; i++) {\r\n        opt = selectedOptions[i];\r\n\r\n        if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {\r\n          options.push(opt);\r\n        }\r\n      }\r\n\r\n      return options;\r\n    }\r\n\r\n    return selectedOptions;\r\n  }\r\n\r\n  // much faster than $.val()\r\n  function getSelectValues (select, selectedOptions) {\r\n    var value = [],\r\n        options = selectedOptions || select.selectedOptions,\r\n        opt;\r\n\r\n    for (var i = 0, len = options.length; i < len; i++) {\r\n      opt = options[i];\r\n\r\n      if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {\r\n        value.push(opt.value);\r\n      }\r\n    }\r\n\r\n    if (!select.multiple) {\r\n      return !value.length ? null : value[0];\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  // set data-selected on select element if the value has been programmatically selected\r\n  // prior to initialization of bootstrap-select\r\n  // * consider removing or replacing an alternative method *\r\n  var valHooks = {\r\n    useDefault: false,\r\n    _set: $.valHooks.select.set\r\n  };\r\n\r\n  $.valHooks.select.set = function (elem, value) {\r\n    if (value && !valHooks.useDefault) $(elem).data('selected', true);\r\n\r\n    return valHooks._set.apply(this, arguments);\r\n  };\r\n\r\n  var changedArguments = null;\r\n\r\n  var EventIsSupported = (function () {\r\n    try {\r\n      new Event('change');\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  })();\r\n\r\n  $.fn.triggerNative = function (eventName) {\r\n    var el = this[0],\r\n        event;\r\n\r\n    if (el.dispatchEvent) { // for modern browsers & IE9+\r\n      if (EventIsSupported) {\r\n        // For modern browsers\r\n        event = new Event(eventName, {\r\n          bubbles: true\r\n        });\r\n      } else {\r\n        // For IE since it doesn't support Event constructor\r\n        event = document.createEvent('Event');\r\n        event.initEvent(eventName, true, false);\r\n      }\r\n\r\n      el.dispatchEvent(event);\r\n    } else if (el.fireEvent) { // for IE8\r\n      event = document.createEventObject();\r\n      event.eventType = eventName;\r\n      el.fireEvent('on' + eventName, event);\r\n    } else {\r\n      // fall back to jQuery.trigger\r\n      this.trigger(eventName);\r\n    }\r\n  };\r\n  // </editor-fold>\r\n\r\n  function stringSearch (li, searchString, method, normalize) {\r\n    var stringTypes = [\r\n          'display',\r\n          'subtext',\r\n          'tokens'\r\n        ],\r\n        searchSuccess = false;\r\n\r\n    for (var i = 0; i < stringTypes.length; i++) {\r\n      var stringType = stringTypes[i],\r\n          string = li[stringType];\r\n\r\n      if (string) {\r\n        string = string.toString();\r\n\r\n        // Strip HTML tags. This isn't perfect, but it's much faster than any other method\r\n        if (stringType === 'display') {\r\n          string = string.replace(/<[^>]+>/g, '');\r\n        }\r\n\r\n        if (normalize) string = normalizeToBase(string);\r\n        string = string.toUpperCase();\r\n\r\n        if (method === 'contains') {\r\n          searchSuccess = string.indexOf(searchString) >= 0;\r\n        } else {\r\n          searchSuccess = string.startsWith(searchString);\r\n        }\r\n\r\n        if (searchSuccess) break;\r\n      }\r\n    }\r\n\r\n    return searchSuccess;\r\n  }\r\n\r\n  function toInteger (value) {\r\n    return parseInt(value, 10) || 0;\r\n  }\r\n\r\n  // Borrowed from Lodash (_.deburr)\r\n  /** Used to map Latin Unicode letters to basic Latin letters. */\r\n  var deburredLetters = {\r\n    // Latin-1 Supplement block.\r\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\r\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\r\n    '\\xc7': 'C',  '\\xe7': 'c',\r\n    '\\xd0': 'D',  '\\xf0': 'd',\r\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\r\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\r\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\r\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\r\n    '\\xd1': 'N',  '\\xf1': 'n',\r\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\r\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\r\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\r\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\r\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\r\n    '\\xc6': 'Ae', '\\xe6': 'ae',\r\n    '\\xde': 'Th', '\\xfe': 'th',\r\n    '\\xdf': 'ss',\r\n    // Latin Extended-A block.\r\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\r\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\r\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\r\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\r\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\r\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\r\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\r\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\r\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\r\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\r\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\r\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\r\n    '\\u0134': 'J',  '\\u0135': 'j',\r\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\r\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\r\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\r\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\r\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\r\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\r\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\r\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\r\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\r\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\r\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\r\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\r\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\r\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\r\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\r\n    '\\u0174': 'W',  '\\u0175': 'w',\r\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\r\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\r\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\r\n    '\\u0132': 'IJ', '\\u0133': 'ij',\r\n    '\\u0152': 'Oe', '\\u0153': 'oe',\r\n    '\\u0149': \"'n\", '\\u017f': 's'\r\n  };\r\n\r\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\r\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\r\n\r\n  /** Used to compose unicode character classes. */\r\n  var rsComboMarksRange = '\\\\u0300-\\\\u036f',\r\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\r\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\r\n      rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff',\r\n      rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff',\r\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\r\n\r\n  /** Used to compose unicode capture groups. */\r\n  var rsCombo = '[' + rsComboRange + ']';\r\n\r\n  /**\r\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\r\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\r\n   */\r\n  var reComboMark = RegExp(rsCombo, 'g');\r\n\r\n  function deburrLetter (key) {\r\n    return deburredLetters[key];\r\n  };\r\n\r\n  function normalizeToBase (string) {\r\n    string = string.toString();\r\n    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\r\n  }\r\n\r\n  // List of HTML entities for escaping.\r\n  var escapeMap = {\r\n    '&': '&amp;',\r\n    '<': '&lt;',\r\n    '>': '&gt;',\r\n    '\"': '&quot;',\r\n    \"'\": '&#x27;',\r\n    '`': '&#x60;'\r\n  };\r\n\r\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\r\n  var createEscaper = function (map) {\r\n    var escaper = function (match) {\r\n      return map[match];\r\n    };\r\n    // Regexes for identifying a key that needs to be escaped.\r\n    var source = '(?:' + Object.keys(map).join('|') + ')';\r\n    var testRegexp = RegExp(source);\r\n    var replaceRegexp = RegExp(source, 'g');\r\n    return function (string) {\r\n      string = string == null ? '' : '' + string;\r\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\r\n    };\r\n  };\r\n\r\n  var htmlEscape = createEscaper(escapeMap);\r\n\r\n  /**\r\n   * ------------------------------------------------------------------------\r\n   * Constants\r\n   * ------------------------------------------------------------------------\r\n   */\r\n\r\n  var keyCodeMap = {\r\n    32: ' ',\r\n    48: '0',\r\n    49: '1',\r\n    50: '2',\r\n    51: '3',\r\n    52: '4',\r\n    53: '5',\r\n    54: '6',\r\n    55: '7',\r\n    56: '8',\r\n    57: '9',\r\n    59: ';',\r\n    65: 'A',\r\n    66: 'B',\r\n    67: 'C',\r\n    68: 'D',\r\n    69: 'E',\r\n    70: 'F',\r\n    71: 'G',\r\n    72: 'H',\r\n    73: 'I',\r\n    74: 'J',\r\n    75: 'K',\r\n    76: 'L',\r\n    77: 'M',\r\n    78: 'N',\r\n    79: 'O',\r\n    80: 'P',\r\n    81: 'Q',\r\n    82: 'R',\r\n    83: 'S',\r\n    84: 'T',\r\n    85: 'U',\r\n    86: 'V',\r\n    87: 'W',\r\n    88: 'X',\r\n    89: 'Y',\r\n    90: 'Z',\r\n    96: '0',\r\n    97: '1',\r\n    98: '2',\r\n    99: '3',\r\n    100: '4',\r\n    101: '5',\r\n    102: '6',\r\n    103: '7',\r\n    104: '8',\r\n    105: '9'\r\n  };\r\n\r\n  var keyCodes = {\r\n    ESCAPE: 27, // KeyboardEvent.which value for Escape (Esc) key\r\n    ENTER: 13, // KeyboardEvent.which value for Enter key\r\n    SPACE: 32, // KeyboardEvent.which value for space key\r\n    TAB: 9, // KeyboardEvent.which value for tab key\r\n    ARROW_UP: 38, // KeyboardEvent.which value for up arrow key\r\n    ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key\r\n  }\r\n\r\n  var version = {\r\n    success: false,\r\n    major: '3'\r\n  };\r\n\r\n  try {\r\n    version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');\r\n    version.major = version.full[0];\r\n    version.success = true;\r\n  } catch (err) {\r\n    // do nothing\r\n  }\r\n\r\n  var selectId = 0;\r\n\r\n  var EVENT_KEY = '.bs.select';\r\n\r\n  var classNames = {\r\n    DISABLED: 'disabled',\r\n    DIVIDER: 'divider',\r\n    SHOW: 'open',\r\n    DROPUP: 'dropup',\r\n    MENU: 'dropdown-menu',\r\n    MENURIGHT: 'dropdown-menu-right',\r\n    MENULEFT: 'dropdown-menu-left',\r\n    // to-do: replace with more advanced template/customization options\r\n    BUTTONCLASS: 'btn-default',\r\n    POPOVERHEADER: 'popover-title',\r\n    ICONBASE: 'glyphicon',\r\n    TICKICON: 'glyphicon-ok'\r\n  }\r\n\r\n  var Selector = {\r\n    MENU: '.' + classNames.MENU\r\n  }\r\n\r\n  var elementTemplates = {\r\n    div: document.createElement('div'),\r\n    span: document.createElement('span'),\r\n    i: document.createElement('i'),\r\n    subtext: document.createElement('small'),\r\n    a: document.createElement('a'),\r\n    li: document.createElement('li'),\r\n    whitespace: document.createTextNode('\\u00A0'),\r\n    fragment: document.createDocumentFragment()\r\n  }\r\n\r\n  elementTemplates.noResults = elementTemplates.li.cloneNode(false);\r\n  elementTemplates.noResults.className = 'no-results';\r\n\r\n  elementTemplates.a.setAttribute('role', 'option');\r\n  elementTemplates.a.className = 'dropdown-item';\r\n\r\n  elementTemplates.subtext.className = 'text-muted';\r\n\r\n  elementTemplates.text = elementTemplates.span.cloneNode(false);\r\n  elementTemplates.text.className = 'text';\r\n\r\n  elementTemplates.checkMark = elementTemplates.span.cloneNode(false);\r\n\r\n  var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);\r\n  var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);\r\n\r\n  var generateOption = {\r\n    li: function (content, classes, optgroup) {\r\n      var li = elementTemplates.li.cloneNode(false);\r\n\r\n      if (content) {\r\n        if (content.nodeType === 1 || content.nodeType === 11) {\r\n          li.appendChild(content);\r\n        } else {\r\n          li.innerHTML = content;\r\n        }\r\n      }\r\n\r\n      if (typeof classes !== 'undefined' && classes !== '') li.className = classes;\r\n      if (typeof optgroup !== 'undefined' && optgroup !== null) li.classList.add('optgroup-' + optgroup);\r\n\r\n      return li;\r\n    },\r\n\r\n    a: function (text, classes, inline) {\r\n      var a = elementTemplates.a.cloneNode(true);\r\n\r\n      if (text) {\r\n        if (text.nodeType === 11) {\r\n          a.appendChild(text);\r\n        } else {\r\n          a.insertAdjacentHTML('beforeend', text);\r\n        }\r\n      }\r\n\r\n      if (typeof classes !== 'undefined' && classes !== '') a.classList.add.apply(a.classList, classes.split(/\\s+/));\r\n      if (inline) a.setAttribute('style', inline);\r\n\r\n      return a;\r\n    },\r\n\r\n    text: function (options, useFragment) {\r\n      var textElement = elementTemplates.text.cloneNode(false),\r\n          subtextElement,\r\n          iconElement;\r\n\r\n      if (options.content) {\r\n        textElement.innerHTML = options.content;\r\n      } else {\r\n        textElement.textContent = options.text;\r\n\r\n        if (options.icon) {\r\n          var whitespace = elementTemplates.whitespace.cloneNode(false);\r\n\r\n          // need to use <i> for icons in the button to prevent a breaking change\r\n          // note: switch to span in next major release\r\n          iconElement = (useFragment === true ? elementTemplates.i : elementTemplates.span).cloneNode(false);\r\n          iconElement.className = this.options.iconBase + ' ' + options.icon;\r\n\r\n          elementTemplates.fragment.appendChild(iconElement);\r\n          elementTemplates.fragment.appendChild(whitespace);\r\n        }\r\n\r\n        if (options.subtext) {\r\n          subtextElement = elementTemplates.subtext.cloneNode(false);\r\n          subtextElement.textContent = options.subtext;\r\n          textElement.appendChild(subtextElement);\r\n        }\r\n      }\r\n\r\n      if (useFragment === true) {\r\n        while (textElement.childNodes.length > 0) {\r\n          elementTemplates.fragment.appendChild(textElement.childNodes[0]);\r\n        }\r\n      } else {\r\n        elementTemplates.fragment.appendChild(textElement);\r\n      }\r\n\r\n      return elementTemplates.fragment;\r\n    },\r\n\r\n    label: function (options) {\r\n      var textElement = elementTemplates.text.cloneNode(false),\r\n          subtextElement,\r\n          iconElement;\r\n\r\n      textElement.innerHTML = options.display;\r\n\r\n      if (options.icon) {\r\n        var whitespace = elementTemplates.whitespace.cloneNode(false);\r\n\r\n        iconElement = elementTemplates.span.cloneNode(false);\r\n        iconElement.className = this.options.iconBase + ' ' + options.icon;\r\n\r\n        elementTemplates.fragment.appendChild(iconElement);\r\n        elementTemplates.fragment.appendChild(whitespace);\r\n      }\r\n\r\n      if (options.subtext) {\r\n        subtextElement = elementTemplates.subtext.cloneNode(false);\r\n        subtextElement.textContent = options.subtext;\r\n        textElement.appendChild(subtextElement);\r\n      }\r\n\r\n      elementTemplates.fragment.appendChild(textElement);\r\n\r\n      return elementTemplates.fragment;\r\n    }\r\n  }\r\n\r\n  function showNoResults (searchMatch, searchValue) {\r\n    if (!searchMatch.length) {\r\n      elementTemplates.noResults.innerHTML = this.options.noneResultsText.replace('{0}', '\"' + htmlEscape(searchValue) + '\"');\r\n      this.$menuInner[0].firstChild.appendChild(elementTemplates.noResults);\r\n    }\r\n  }\r\n\r\n  var Selectpicker = function (element, options) {\r\n    var that = this;\r\n\r\n    // bootstrap-select has been initialized - revert valHooks.select.set back to its original function\r\n    if (!valHooks.useDefault) {\r\n      $.valHooks.select.set = valHooks._set;\r\n      valHooks.useDefault = true;\r\n    }\r\n\r\n    this.$element = $(element);\r\n    this.$newElement = null;\r\n    this.$button = null;\r\n    this.$menu = null;\r\n    this.options = options;\r\n    this.selectpicker = {\r\n      main: {},\r\n      search: {},\r\n      current: {}, // current changes if a search is in progress\r\n      view: {},\r\n      isSearching: false,\r\n      keydown: {\r\n        keyHistory: '',\r\n        resetKeyHistory: {\r\n          start: function () {\r\n            return setTimeout(function () {\r\n              that.selectpicker.keydown.keyHistory = '';\r\n            }, 800);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.sizeInfo = {};\r\n\r\n    // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a\r\n    // data-attribute)\r\n    if (this.options.title === null) {\r\n      this.options.title = this.$element.attr('title');\r\n    }\r\n\r\n    // Format window padding\r\n    var winPad = this.options.windowPadding;\r\n    if (typeof winPad === 'number') {\r\n      this.options.windowPadding = [winPad, winPad, winPad, winPad];\r\n    }\r\n\r\n    // Expose public methods\r\n    this.val = Selectpicker.prototype.val;\r\n    this.render = Selectpicker.prototype.render;\r\n    this.refresh = Selectpicker.prototype.refresh;\r\n    this.setStyle = Selectpicker.prototype.setStyle;\r\n    this.selectAll = Selectpicker.prototype.selectAll;\r\n    this.deselectAll = Selectpicker.prototype.deselectAll;\r\n    this.destroy = Selectpicker.prototype.destroy;\r\n    this.remove = Selectpicker.prototype.remove;\r\n    this.show = Selectpicker.prototype.show;\r\n    this.hide = Selectpicker.prototype.hide;\r\n\r\n    this.init();\r\n  };\r\n\r\n  Selectpicker.VERSION = '1.13.18';\r\n\r\n  // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.\r\n  Selectpicker.DEFAULTS = {\r\n    noneSelectedText: 'Nothing selected',\r\n    noneResultsText: 'No results matched {0}',\r\n    countSelectedText: function (numSelected, numTotal) {\r\n      return (numSelected == 1) ? '{0} item selected' : '{0} items selected';\r\n    },\r\n    maxOptionsText: function (numAll, numGroup) {\r\n      return [\r\n        (numAll == 1) ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)',\r\n        (numGroup == 1) ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'\r\n      ];\r\n    },\r\n    selectAllText: 'Select All',\r\n    deselectAllText: 'Deselect All',\r\n    doneButton: false,\r\n    doneButtonText: 'Close',\r\n    multipleSeparator: ', ',\r\n    styleBase: 'btn',\r\n    style: classNames.BUTTONCLASS,\r\n    size: 'auto',\r\n    title: null,\r\n    selectedTextFormat: 'values',\r\n    width: false,\r\n    container: false,\r\n    hideDisabled: false,\r\n    showSubtext: false,\r\n    showIcon: true,\r\n    showContent: true,\r\n    dropupAuto: true,\r\n    header: false,\r\n    liveSearch: false,\r\n    liveSearchPlaceholder: null,\r\n    liveSearchNormalize: false,\r\n    liveSearchStyle: 'contains',\r\n    actionsBox: false,\r\n    iconBase: classNames.ICONBASE,\r\n    tickIcon: classNames.TICKICON,\r\n    showTick: false,\r\n    template: {\r\n      caret: '<span class=\"caret\"></span>'\r\n    },\r\n    maxOptions: false,\r\n    mobile: false,\r\n    selectOnTab: false,\r\n    dropdownAlignRight: false,\r\n    windowPadding: 0,\r\n    virtualScroll: 600,\r\n    display: false,\r\n    sanitize: true,\r\n    sanitizeFn: null,\r\n    whiteList: DefaultWhitelist\r\n  };\r\n\r\n  Selectpicker.prototype = {\r\n\r\n    constructor: Selectpicker,\r\n\r\n    init: function () {\r\n      var that = this,\r\n          id = this.$element.attr('id'),\r\n          element = this.$element[0],\r\n          form = element.form;\r\n\r\n      selectId++;\r\n      this.selectId = 'bs-select-' + selectId;\r\n\r\n      element.classList.add('bs-select-hidden');\r\n\r\n      this.multiple = this.$element.prop('multiple');\r\n      this.autofocus = this.$element.prop('autofocus');\r\n\r\n      if (element.classList.contains('show-tick')) {\r\n        this.options.showTick = true;\r\n      }\r\n\r\n      this.$newElement = this.createDropdown();\r\n      this.buildData();\r\n      this.$element\r\n        .after(this.$newElement)\r\n        .prependTo(this.$newElement);\r\n\r\n      // ensure select is associated with form element if it got unlinked after moving it inside newElement\r\n      if (form && element.form === null) {\r\n        if (!form.id) form.id = 'form-' + this.selectId;\r\n        element.setAttribute('form', form.id);\r\n      }\r\n\r\n      this.$button = this.$newElement.children('button');\r\n      this.$menu = this.$newElement.children(Selector.MENU);\r\n      this.$menuInner = this.$menu.children('.inner');\r\n      this.$searchbox = this.$menu.find('input');\r\n\r\n      element.classList.remove('bs-select-hidden');\r\n\r\n      if (this.options.dropdownAlignRight === true) this.$menu[0].classList.add(classNames.MENURIGHT);\r\n\r\n      if (typeof id !== 'undefined') {\r\n        this.$button.attr('data-id', id);\r\n      }\r\n\r\n      this.checkDisabled();\r\n      this.clickListener();\r\n\r\n      if (this.options.liveSearch) {\r\n        this.liveSearchListener();\r\n        this.focusedParent = this.$searchbox[0];\r\n      } else {\r\n        this.focusedParent = this.$menuInner[0];\r\n      }\r\n\r\n      this.setStyle();\r\n      this.render();\r\n      this.setWidth();\r\n      if (this.options.container) {\r\n        this.selectPosition();\r\n      } else {\r\n        this.$element.on('hide' + EVENT_KEY, function () {\r\n          if (that.isVirtual()) {\r\n            // empty menu on close\r\n            var menuInner = that.$menuInner[0],\r\n                emptyMenu = menuInner.firstChild.cloneNode(false);\r\n\r\n            // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''\r\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\r\n            menuInner.scrollTop = 0;\r\n          }\r\n        });\r\n      }\r\n      this.$menu.data('this', this);\r\n      this.$newElement.data('this', this);\r\n      if (this.options.mobile) this.mobile();\r\n\r\n      this.$newElement.on({\r\n        'hide.bs.dropdown': function (e) {\r\n          that.$element.trigger('hide' + EVENT_KEY, e);\r\n        },\r\n        'hidden.bs.dropdown': function (e) {\r\n          that.$element.trigger('hidden' + EVENT_KEY, e);\r\n        },\r\n        'show.bs.dropdown': function (e) {\r\n          that.$element.trigger('show' + EVENT_KEY, e);\r\n        },\r\n        'shown.bs.dropdown': function (e) {\r\n          that.$element.trigger('shown' + EVENT_KEY, e);\r\n        }\r\n      });\r\n\r\n      if (element.hasAttribute('required')) {\r\n        this.$element.on('invalid' + EVENT_KEY, function () {\r\n          that.$button[0].classList.add('bs-invalid');\r\n\r\n          that.$element\r\n            .on('shown' + EVENT_KEY + '.invalid', function () {\r\n              that.$element\r\n                .val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened\r\n                .off('shown' + EVENT_KEY + '.invalid');\r\n            })\r\n            .on('rendered' + EVENT_KEY, function () {\r\n              // if select is no longer invalid, remove the bs-invalid class\r\n              if (this.validity.valid) that.$button[0].classList.remove('bs-invalid');\r\n              that.$element.off('rendered' + EVENT_KEY);\r\n            });\r\n\r\n          that.$button.on('blur' + EVENT_KEY, function () {\r\n            that.$element.trigger('focus').trigger('blur');\r\n            that.$button.off('blur' + EVENT_KEY);\r\n          });\r\n        });\r\n      }\r\n\r\n      setTimeout(function () {\r\n        that.buildList();\r\n        that.$element.trigger('loaded' + EVENT_KEY);\r\n      });\r\n    },\r\n\r\n    createDropdown: function () {\r\n      // Options\r\n      // If we are multiple or showTick option is set, then add the show-tick class\r\n      var showTick = (this.multiple || this.options.showTick) ? ' show-tick' : '',\r\n          multiselectable = this.multiple ? ' aria-multiselectable=\"true\"' : '',\r\n          inputGroup = '',\r\n          autofocus = this.autofocus ? ' autofocus' : '';\r\n\r\n      if (version.major < 4 && this.$element.parent().hasClass('input-group')) {\r\n        inputGroup = ' input-group-btn';\r\n      }\r\n\r\n      // Elements\r\n      var drop,\r\n          header = '',\r\n          searchbox = '',\r\n          actionsbox = '',\r\n          donebutton = '';\r\n\r\n      if (this.options.header) {\r\n        header =\r\n          '<div class=\"' + classNames.POPOVERHEADER + '\">' +\r\n            '<button type=\"button\" class=\"close\" aria-hidden=\"true\">&times;</button>' +\r\n              this.options.header +\r\n          '</div>';\r\n      }\r\n\r\n      if (this.options.liveSearch) {\r\n        searchbox =\r\n          '<div class=\"bs-searchbox\">' +\r\n            '<input type=\"search\" class=\"form-control\" autocomplete=\"off\"' +\r\n              (\r\n                this.options.liveSearchPlaceholder === null ? ''\r\n                :\r\n                ' placeholder=\"' + htmlEscape(this.options.liveSearchPlaceholder) + '\"'\r\n              ) +\r\n              ' role=\"combobox\" aria-label=\"Search\" aria-controls=\"' + this.selectId + '\" aria-autocomplete=\"list\">' +\r\n          '</div>';\r\n      }\r\n\r\n      if (this.multiple && this.options.actionsBox) {\r\n        actionsbox =\r\n          '<div class=\"bs-actionsbox\">' +\r\n            '<div class=\"btn-group btn-group-sm btn-block\">' +\r\n              '<button type=\"button\" class=\"actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '\">' +\r\n                this.options.selectAllText +\r\n              '</button>' +\r\n              '<button type=\"button\" class=\"actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '\">' +\r\n                this.options.deselectAllText +\r\n              '</button>' +\r\n            '</div>' +\r\n          '</div>';\r\n      }\r\n\r\n      if (this.multiple && this.options.doneButton) {\r\n        donebutton =\r\n          '<div class=\"bs-donebutton\">' +\r\n            '<div class=\"btn-group btn-block\">' +\r\n              '<button type=\"button\" class=\"btn btn-sm ' + classNames.BUTTONCLASS + '\">' +\r\n                this.options.doneButtonText +\r\n              '</button>' +\r\n            '</div>' +\r\n          '</div>';\r\n      }\r\n\r\n      drop =\r\n        '<div class=\"dropdown bootstrap-select' + showTick + inputGroup + '\">' +\r\n          '<button type=\"button\" tabindex=\"-1\" class=\"' + this.options.styleBase + ' dropdown-toggle\" ' + (this.options.display === 'static' ? 'data-display=\"static\"' : '') + 'data-toggle=\"dropdown\"' + autofocus + ' role=\"combobox\" aria-owns=\"' + this.selectId + '\" aria-haspopup=\"listbox\" aria-expanded=\"false\">' +\r\n            '<div class=\"filter-option\">' +\r\n              '<div class=\"filter-option-inner\">' +\r\n                '<div class=\"filter-option-inner-inner\"></div>' +\r\n              '</div> ' +\r\n            '</div>' +\r\n            (\r\n              version.major === '4' ? ''\r\n              :\r\n              '<span class=\"bs-caret\">' +\r\n                this.options.template.caret +\r\n              '</span>'\r\n            ) +\r\n          '</button>' +\r\n          '<div class=\"' + classNames.MENU + ' ' + (version.major === '4' ? '' : classNames.SHOW) + '\">' +\r\n            header +\r\n            searchbox +\r\n            actionsbox +\r\n            '<div class=\"inner ' + classNames.SHOW + '\" role=\"listbox\" id=\"' + this.selectId + '\" tabindex=\"-1\" ' + multiselectable + '>' +\r\n                '<ul class=\"' + classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '') + '\" role=\"presentation\">' +\r\n                '</ul>' +\r\n            '</div>' +\r\n            donebutton +\r\n          '</div>' +\r\n        '</div>';\r\n\r\n      return $(drop);\r\n    },\r\n\r\n    setPositionData: function () {\r\n      this.selectpicker.view.canHighlight = [];\r\n      this.selectpicker.view.size = 0;\r\n      this.selectpicker.view.firstHighlightIndex = false;\r\n\r\n      for (var i = 0; i < this.selectpicker.current.data.length; i++) {\r\n        var li = this.selectpicker.current.data[i],\r\n            canHighlight = true;\r\n\r\n        if (li.type === 'divider') {\r\n          canHighlight = false;\r\n          li.height = this.sizeInfo.dividerHeight;\r\n        } else if (li.type === 'optgroup-label') {\r\n          canHighlight = false;\r\n          li.height = this.sizeInfo.dropdownHeaderHeight;\r\n        } else {\r\n          li.height = this.sizeInfo.liHeight;\r\n        }\r\n\r\n        if (li.disabled) canHighlight = false;\r\n\r\n        this.selectpicker.view.canHighlight.push(canHighlight);\r\n\r\n        if (canHighlight) {\r\n          this.selectpicker.view.size++;\r\n          li.posinset = this.selectpicker.view.size;\r\n          if (this.selectpicker.view.firstHighlightIndex === false) this.selectpicker.view.firstHighlightIndex = i;\r\n        }\r\n\r\n        li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;\r\n      }\r\n    },\r\n\r\n    isVirtual: function () {\r\n      return (this.options.virtualScroll !== false) && (this.selectpicker.main.elements.length >= this.options.virtualScroll) || this.options.virtualScroll === true;\r\n    },\r\n\r\n    createView: function (isSearching, setSize, refresh) {\r\n      var that = this,\r\n          scrollTop = 0,\r\n          active = [],\r\n          selected,\r\n          prevActive;\r\n\r\n      this.selectpicker.isSearching = isSearching;\r\n      this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;\r\n\r\n      this.setPositionData();\r\n\r\n      if (setSize) {\r\n        if (refresh) {\r\n          scrollTop = this.$menuInner[0].scrollTop;\r\n        } else if (!that.multiple) {\r\n          var element = that.$element[0],\r\n              selectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\r\n\r\n          if (typeof selectedIndex === 'number' && that.options.size !== false) {\r\n            var selectedData = that.selectpicker.main.data[selectedIndex],\r\n                position = selectedData && selectedData.position;\r\n\r\n            if (position) {\r\n              scrollTop = position - ((that.sizeInfo.menuInnerHeight + that.sizeInfo.liHeight) / 2);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      scroll(scrollTop, true);\r\n\r\n      this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {\r\n        if (!that.noScroll) scroll(this.scrollTop, updateValue);\r\n        that.noScroll = false;\r\n      });\r\n\r\n      function scroll (scrollTop, init) {\r\n        var size = that.selectpicker.current.elements.length,\r\n            chunks = [],\r\n            chunkSize,\r\n            chunkCount,\r\n            firstChunk,\r\n            lastChunk,\r\n            currentChunk,\r\n            prevPositions,\r\n            positionIsDifferent,\r\n            previousElements,\r\n            menuIsDifferent = true,\r\n            isVirtual = that.isVirtual();\r\n\r\n        that.selectpicker.view.scrollTop = scrollTop;\r\n\r\n        chunkSize = Math.ceil(that.sizeInfo.menuInnerHeight / that.sizeInfo.liHeight * 1.5); // number of options in a chunk\r\n        chunkCount = Math.round(size / chunkSize) || 1; // number of chunks\r\n\r\n        for (var i = 0; i < chunkCount; i++) {\r\n          var endOfChunk = (i + 1) * chunkSize;\r\n\r\n          if (i === chunkCount - 1) {\r\n            endOfChunk = size;\r\n          }\r\n\r\n          chunks[i] = [\r\n            (i) * chunkSize + (!i ? 0 : 1),\r\n            endOfChunk\r\n          ];\r\n\r\n          if (!size) break;\r\n\r\n          if (currentChunk === undefined && scrollTop - 1 <= that.selectpicker.current.data[endOfChunk - 1].position - that.sizeInfo.menuInnerHeight) {\r\n            currentChunk = i;\r\n          }\r\n        }\r\n\r\n        if (currentChunk === undefined) currentChunk = 0;\r\n\r\n        prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1];\r\n\r\n        // always display previous, current, and next chunks\r\n        firstChunk = Math.max(0, currentChunk - 1);\r\n        lastChunk = Math.min(chunkCount - 1, currentChunk + 1);\r\n\r\n        that.selectpicker.view.position0 = isVirtual === false ? 0 : (Math.max(0, chunks[firstChunk][0]) || 0);\r\n        that.selectpicker.view.position1 = isVirtual === false ? size : (Math.min(size, chunks[lastChunk][1]) || 0);\r\n\r\n        positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;\r\n\r\n        if (that.activeIndex !== undefined) {\r\n          prevActive = that.selectpicker.main.elements[that.prevActiveIndex];\r\n          active = that.selectpicker.main.elements[that.activeIndex];\r\n          selected = that.selectpicker.main.elements[that.selectedIndex];\r\n\r\n          if (init) {\r\n            if (that.activeIndex !== that.selectedIndex) {\r\n              that.defocusItem(active);\r\n            }\r\n            that.activeIndex = undefined;\r\n          }\r\n\r\n          if (that.activeIndex && that.activeIndex !== that.selectedIndex) {\r\n            that.defocusItem(selected);\r\n          }\r\n        }\r\n\r\n        if (that.prevActiveIndex !== undefined && that.prevActiveIndex !== that.activeIndex && that.prevActiveIndex !== that.selectedIndex) {\r\n          that.defocusItem(prevActive);\r\n        }\r\n\r\n        if (init || positionIsDifferent) {\r\n          previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];\r\n\r\n          if (isVirtual === false) {\r\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements;\r\n          } else {\r\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);\r\n          }\r\n\r\n          that.setOptionStatus();\r\n\r\n          // if searching, check to make sure the list has actually been updated before updating DOM\r\n          // this prevents unnecessary repaints\r\n          if (isSearching || (isVirtual === false && init)) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements);\r\n\r\n          // if virtual scroll is disabled and not searching,\r\n          // menu should never need to be updated more than once\r\n          if ((init || isVirtual === true) && menuIsDifferent) {\r\n            var menuInner = that.$menuInner[0],\r\n                menuFragment = document.createDocumentFragment(),\r\n                emptyMenu = menuInner.firstChild.cloneNode(false),\r\n                marginTop,\r\n                marginBottom,\r\n                elements = that.selectpicker.view.visibleElements,\r\n                toSanitize = [];\r\n\r\n            // replace the existing UL with an empty one - this is faster than $.empty()\r\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\r\n\r\n            for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {\r\n              var element = elements[i],\r\n                  elText,\r\n                  elementData;\r\n\r\n              if (that.options.sanitize) {\r\n                elText = element.lastChild;\r\n\r\n                if (elText) {\r\n                  elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0];\r\n\r\n                  if (elementData && elementData.content && !elementData.sanitized) {\r\n                    toSanitize.push(elText);\r\n                    elementData.sanitized = true;\r\n                  }\r\n                }\r\n              }\r\n\r\n              menuFragment.appendChild(element);\r\n            }\r\n\r\n            if (that.options.sanitize && toSanitize.length) {\r\n              sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);\r\n            }\r\n\r\n            if (isVirtual === true) {\r\n              marginTop = (that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position);\r\n              marginBottom = (that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position);\r\n\r\n              menuInner.firstChild.style.marginTop = marginTop + 'px';\r\n              menuInner.firstChild.style.marginBottom = marginBottom + 'px';\r\n            } else {\r\n              menuInner.firstChild.style.marginTop = 0;\r\n              menuInner.firstChild.style.marginBottom = 0;\r\n            }\r\n\r\n            menuInner.firstChild.appendChild(menuFragment);\r\n\r\n            // if an option is encountered that is wider than the current menu width, update the menu width accordingly\r\n            // switch to ResizeObserver with increased browser support\r\n            if (isVirtual === true && that.sizeInfo.hasScrollBar) {\r\n              var menuInnerInnerWidth = menuInner.firstChild.offsetWidth;\r\n\r\n              if (init && menuInnerInnerWidth < that.sizeInfo.menuInnerInnerWidth && that.sizeInfo.totalMenuWidth > that.sizeInfo.selectWidth) {\r\n                menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\r\n              } else if (menuInnerInnerWidth > that.sizeInfo.menuInnerInnerWidth) {\r\n                // set to 0 to get actual width of menu\r\n                that.$menu[0].style.minWidth = 0;\r\n\r\n                var actualMenuWidth = menuInner.firstChild.offsetWidth;\r\n\r\n                if (actualMenuWidth > that.sizeInfo.menuInnerInnerWidth) {\r\n                  that.sizeInfo.menuInnerInnerWidth = actualMenuWidth;\r\n                  menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\r\n                }\r\n\r\n                // reset to default CSS styling\r\n                that.$menu[0].style.minWidth = '';\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        that.prevActiveIndex = that.activeIndex;\r\n\r\n        if (!that.options.liveSearch) {\r\n          that.$menuInner.trigger('focus');\r\n        } else if (isSearching && init) {\r\n          var index = 0,\r\n              newActive;\r\n\r\n          if (!that.selectpicker.view.canHighlight[index]) {\r\n            index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);\r\n          }\r\n\r\n          newActive = that.selectpicker.view.visibleElements[index];\r\n\r\n          that.defocusItem(that.selectpicker.view.currentActive);\r\n\r\n          that.activeIndex = (that.selectpicker.current.data[index] || {}).index;\r\n\r\n          that.focusItem(newActive);\r\n        }\r\n      }\r\n\r\n      $(window)\r\n        .off('resize' + EVENT_KEY + '.' + this.selectId + '.createView')\r\n        .on('resize' + EVENT_KEY + '.' + this.selectId + '.createView', function () {\r\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\r\n\r\n          if (isActive) scroll(that.$menuInner[0].scrollTop);\r\n        });\r\n    },\r\n\r\n    focusItem: function (li, liData, noStyle) {\r\n      if (li) {\r\n        liData = liData || this.selectpicker.main.data[this.activeIndex];\r\n        var a = li.firstChild;\r\n\r\n        if (a) {\r\n          a.setAttribute('aria-setsize', this.selectpicker.view.size);\r\n          a.setAttribute('aria-posinset', liData.posinset);\r\n\r\n          if (noStyle !== true) {\r\n            this.focusedParent.setAttribute('aria-activedescendant', a.id);\r\n            li.classList.add('active');\r\n            a.classList.add('active');\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    defocusItem: function (li) {\r\n      if (li) {\r\n        li.classList.remove('active');\r\n        if (li.firstChild) li.firstChild.classList.remove('active');\r\n      }\r\n    },\r\n\r\n    setPlaceholder: function () {\r\n      var that = this,\r\n          updateIndex = false;\r\n\r\n      if (this.options.title && !this.multiple) {\r\n        if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option');\r\n\r\n        // this option doesn't create a new <li> element, but does add a new option at the start,\r\n        // so startIndex should increase to prevent having to check every option for the bs-title-option class\r\n        updateIndex = true;\r\n\r\n        var element = this.$element[0],\r\n            selectTitleOption = false,\r\n            titleNotAppended = !this.selectpicker.view.titleOption.parentNode,\r\n            selectedIndex = element.selectedIndex,\r\n            selectedOption = element.options[selectedIndex],\r\n            navigation = window.performance && window.performance.getEntriesByType('navigation'),\r\n            // Safari doesn't support getEntriesByType('navigation') - fall back to performance.navigation\r\n            isNotBackForward = (navigation && navigation.length) ? navigation[0].type !== 'back_forward' : window.performance.navigation.type !== 2;\r\n\r\n        if (titleNotAppended) {\r\n          // Use native JS to prepend option (faster)\r\n          this.selectpicker.view.titleOption.className = 'bs-title-option';\r\n          this.selectpicker.view.titleOption.value = '';\r\n\r\n          // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.\r\n          // the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,\r\n          // if so, the select will have the data-selected attribute\r\n          selectTitleOption = !selectedOption || (selectedIndex === 0 && selectedOption.defaultSelected === false && this.$element.data('selected') === undefined);\r\n        }\r\n\r\n        if (titleNotAppended || this.selectpicker.view.titleOption.index !== 0) {\r\n          element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);\r\n        }\r\n\r\n        // Set selected *after* appending to select,\r\n        // otherwise the option doesn't get selected in IE\r\n        // set using selectedIndex, as setting the selected attr to true here doesn't work in IE11\r\n        if (selectTitleOption && isNotBackForward) {\r\n          element.selectedIndex = 0;\r\n        } else if (document.readyState !== 'complete') {\r\n          // if navigation type is back_forward, there's a chance the select will have its value set by BFCache\r\n          // wait for that value to be set, then run render again\r\n          window.addEventListener('pageshow', function () {\r\n            if (that.selectpicker.view.displayedValue !== element.value) that.render();\r\n          });\r\n        }\r\n      }\r\n\r\n      return updateIndex;\r\n    },\r\n\r\n    buildData: function () {\r\n      var optionSelector = ':not([hidden]):not([data-hidden=\"true\"])',\r\n          mainData = [],\r\n          optID = 0,\r\n          startIndex = this.setPlaceholder() ? 1 : 0; // append the titleOption if necessary and skip the first option in the loop\r\n\r\n      if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\r\n\r\n      var selectOptions = this.$element[0].querySelectorAll('select > *' + optionSelector);\r\n\r\n      function addDivider (config) {\r\n        var previousData = mainData[mainData.length - 1];\r\n\r\n        // ensure optgroup doesn't create back-to-back dividers\r\n        if (\r\n          previousData &&\r\n          previousData.type === 'divider' &&\r\n          (previousData.optID || config.optID)\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        config = config || {};\r\n        config.type = 'divider';\r\n\r\n        mainData.push(config);\r\n      }\r\n\r\n      function addOption (option, config) {\r\n        config = config || {};\r\n\r\n        config.divider = option.getAttribute('data-divider') === 'true';\r\n\r\n        if (config.divider) {\r\n          addDivider({\r\n            optID: config.optID\r\n          });\r\n        } else {\r\n          var liIndex = mainData.length,\r\n              cssText = option.style.cssText,\r\n              inlineStyle = cssText ? htmlEscape(cssText) : '',\r\n              optionClass = (option.className || '') + (config.optgroupClass || '');\r\n\r\n          if (config.optID) optionClass = 'opt ' + optionClass;\r\n\r\n          config.optionClass = optionClass.trim();\r\n          config.inlineStyle = inlineStyle;\r\n          config.text = option.textContent;\r\n\r\n          config.content = option.getAttribute('data-content');\r\n          config.tokens = option.getAttribute('data-tokens');\r\n          config.subtext = option.getAttribute('data-subtext');\r\n          config.icon = option.getAttribute('data-icon');\r\n\r\n          option.liIndex = liIndex;\r\n\r\n          config.display = config.content || config.text;\r\n          config.type = 'option';\r\n          config.index = liIndex;\r\n          config.option = option;\r\n          config.selected = !!option.selected;\r\n          config.disabled = config.disabled || !!option.disabled;\r\n\r\n          mainData.push(config);\r\n        }\r\n      }\r\n\r\n      function addOptgroup (index, selectOptions) {\r\n        var optgroup = selectOptions[index],\r\n            // skip placeholder option\r\n            previous = index - 1 < startIndex ? false : selectOptions[index - 1],\r\n            next = selectOptions[index + 1],\r\n            options = optgroup.querySelectorAll('option' + optionSelector);\r\n\r\n        if (!options.length) return;\r\n\r\n        var config = {\r\n              display: htmlEscape(optgroup.label),\r\n              subtext: optgroup.getAttribute('data-subtext'),\r\n              icon: optgroup.getAttribute('data-icon'),\r\n              type: 'optgroup-label',\r\n              optgroupClass: ' ' + (optgroup.className || '')\r\n            },\r\n            headerIndex,\r\n            lastIndex;\r\n\r\n        optID++;\r\n\r\n        if (previous) {\r\n          addDivider({ optID: optID });\r\n        }\r\n\r\n        config.optID = optID;\r\n\r\n        mainData.push(config);\r\n\r\n        for (var j = 0, len = options.length; j < len; j++) {\r\n          var option = options[j];\r\n\r\n          if (j === 0) {\r\n            headerIndex = mainData.length - 1;\r\n            lastIndex = headerIndex + len;\r\n          }\r\n\r\n          addOption(option, {\r\n            headerIndex: headerIndex,\r\n            lastIndex: lastIndex,\r\n            optID: config.optID,\r\n            optgroupClass: config.optgroupClass,\r\n            disabled: optgroup.disabled\r\n          });\r\n        }\r\n\r\n        if (next) {\r\n          addDivider({ optID: optID });\r\n        }\r\n      }\r\n\r\n      for (var len = selectOptions.length, i = startIndex; i < len; i++) {\r\n        var item = selectOptions[i];\r\n\r\n        if (item.tagName !== 'OPTGROUP') {\r\n          addOption(item, {});\r\n        } else {\r\n          addOptgroup(i, selectOptions);\r\n        }\r\n      }\r\n\r\n      this.selectpicker.main.data = this.selectpicker.current.data = mainData;\r\n    },\r\n\r\n    buildList: function () {\r\n      var that = this,\r\n          selectData = this.selectpicker.main.data,\r\n          mainElements = [],\r\n          widestOptionLength = 0;\r\n\r\n      if ((that.options.showTick || that.multiple) && !elementTemplates.checkMark.parentNode) {\r\n        elementTemplates.checkMark.className = this.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';\r\n        elementTemplates.a.appendChild(elementTemplates.checkMark);\r\n      }\r\n\r\n      function buildElement (item) {\r\n        var liElement,\r\n            combinedLength = 0;\r\n\r\n        switch (item.type) {\r\n          case 'divider':\r\n            liElement = generateOption.li(\r\n              false,\r\n              classNames.DIVIDER,\r\n              (item.optID ? item.optID + 'div' : undefined)\r\n            );\r\n\r\n            break;\r\n\r\n          case 'option':\r\n            liElement = generateOption.li(\r\n              generateOption.a(\r\n                generateOption.text.call(that, item),\r\n                item.optionClass,\r\n                item.inlineStyle\r\n              ),\r\n              '',\r\n              item.optID\r\n            );\r\n\r\n            if (liElement.firstChild) {\r\n              liElement.firstChild.id = that.selectId + '-' + item.index;\r\n            }\r\n\r\n            break;\r\n\r\n          case 'optgroup-label':\r\n            liElement = generateOption.li(\r\n              generateOption.label.call(that, item),\r\n              'dropdown-header' + item.optgroupClass,\r\n              item.optID\r\n            );\r\n\r\n            break;\r\n        }\r\n\r\n        item.element = liElement;\r\n        mainElements.push(liElement);\r\n\r\n        // count the number of characters in the option - not perfect, but should work in most cases\r\n        if (item.display) combinedLength += item.display.length;\r\n        if (item.subtext) combinedLength += item.subtext.length;\r\n        // if there is an icon, ensure this option's width is checked\r\n        if (item.icon) combinedLength += 1;\r\n\r\n        if (combinedLength > widestOptionLength) {\r\n          widestOptionLength = combinedLength;\r\n\r\n          // guess which option is the widest\r\n          // use this when calculating menu width\r\n          // not perfect, but it's fast, and the width will be updating accordingly when scrolling\r\n          that.selectpicker.view.widestOption = mainElements[mainElements.length - 1];\r\n        }\r\n      }\r\n\r\n      for (var len = selectData.length, i = 0; i < len; i++) {\r\n        var item = selectData[i];\r\n\r\n        buildElement(item);\r\n      }\r\n\r\n      this.selectpicker.main.elements = this.selectpicker.current.elements = mainElements;\r\n    },\r\n\r\n    findLis: function () {\r\n      return this.$menuInner.find('.inner > li');\r\n    },\r\n\r\n    render: function () {\r\n      var that = this,\r\n          element = this.$element[0],\r\n          // ensure titleOption is appended and selected (if necessary) before getting selectedOptions\r\n          placeholderSelected = this.setPlaceholder() && element.selectedIndex === 0,\r\n          selectedOptions = getSelectedOptions(element, this.options.hideDisabled),\r\n          selectedCount = selectedOptions.length,\r\n          button = this.$button[0],\r\n          buttonInner = button.querySelector('.filter-option-inner-inner'),\r\n          multipleSeparator = document.createTextNode(this.options.multipleSeparator),\r\n          titleFragment = elementTemplates.fragment.cloneNode(false),\r\n          showCount,\r\n          countMax,\r\n          hasContent = false;\r\n\r\n      button.classList.toggle('bs-placeholder', that.multiple ? !selectedCount : !getSelectValues(element, selectedOptions));\r\n\r\n      if (!that.multiple && selectedOptions.length === 1) {\r\n        that.selectpicker.view.displayedValue = getSelectValues(element, selectedOptions);\r\n      }\r\n\r\n      if (this.options.selectedTextFormat === 'static') {\r\n        titleFragment = generateOption.text.call(this, { text: this.options.title }, true);\r\n      } else {\r\n        showCount = this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1 && selectedCount > 1;\r\n\r\n        // determine if the number of selected options will be shown (showCount === true)\r\n        if (showCount) {\r\n          countMax = this.options.selectedTextFormat.split('>');\r\n          showCount = (countMax.length > 1 && selectedCount > countMax[1]) || (countMax.length === 1 && selectedCount >= 2);\r\n        }\r\n\r\n        // only loop through all selected options if the count won't be shown\r\n        if (showCount === false) {\r\n          if (!placeholderSelected) {\r\n            for (var selectedIndex = 0; selectedIndex < selectedCount; selectedIndex++) {\r\n              if (selectedIndex < 50) {\r\n                var option = selectedOptions[selectedIndex],\r\n                    thisData = this.selectpicker.main.data[option.liIndex],\r\n                    titleOptions = {};\r\n\r\n                if (this.multiple && selectedIndex > 0) {\r\n                  titleFragment.appendChild(multipleSeparator.cloneNode(false));\r\n                }\r\n\r\n                if (option.title) {\r\n                  titleOptions.text = option.title;\r\n                } else if (thisData) {\r\n                  if (thisData.content && that.options.showContent) {\r\n                    titleOptions.content = thisData.content.toString();\r\n                    hasContent = true;\r\n                  } else {\r\n                    if (that.options.showIcon) {\r\n                      titleOptions.icon = thisData.icon;\r\n                    }\r\n                    if (that.options.showSubtext && !that.multiple && thisData.subtext) titleOptions.subtext = ' ' + thisData.subtext;\r\n                    titleOptions.text = option.textContent.trim();\r\n                  }\r\n                }\r\n\r\n                titleFragment.appendChild(generateOption.text.call(this, titleOptions, true));\r\n              } else {\r\n                break;\r\n              }\r\n            }\r\n\r\n            // add ellipsis\r\n            if (selectedCount > 49) {\r\n              titleFragment.appendChild(document.createTextNode('...'));\r\n            }\r\n          }\r\n        } else {\r\n          var optionSelector = ':not([hidden]):not([data-hidden=\"true\"]):not([data-divider=\"true\"])';\r\n          if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\r\n\r\n          // If this is a multiselect, and selectedTextFormat is count, then show 1 of 2 selected, etc.\r\n          var totalCount = this.$element[0].querySelectorAll('select > option' + optionSelector + ', optgroup' + optionSelector + ' option' + optionSelector).length,\r\n              tr8nText = (typeof this.options.countSelectedText === 'function') ? this.options.countSelectedText(selectedCount, totalCount) : this.options.countSelectedText;\r\n\r\n          titleFragment = generateOption.text.call(this, {\r\n            text: tr8nText.replace('{0}', selectedCount.toString()).replace('{1}', totalCount.toString())\r\n          }, true);\r\n        }\r\n      }\r\n\r\n      if (this.options.title == undefined) {\r\n        // use .attr to ensure undefined is returned if title attribute is not set\r\n        this.options.title = this.$element.attr('title');\r\n      }\r\n\r\n      // If the select doesn't have a title, then use the default, or if nothing is set at all, use noneSelectedText\r\n      if (!titleFragment.childNodes.length) {\r\n        titleFragment = generateOption.text.call(this, {\r\n          text: typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText\r\n        }, true);\r\n      }\r\n\r\n      // strip all HTML tags and trim the result, then unescape any escaped tags\r\n      button.title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();\r\n\r\n      if (this.options.sanitize && hasContent) {\r\n        sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);\r\n      }\r\n\r\n      buttonInner.innerHTML = '';\r\n      buttonInner.appendChild(titleFragment);\r\n\r\n      if (version.major < 4 && this.$newElement[0].classList.contains('bs3-has-addon')) {\r\n        var filterExpand = button.querySelector('.filter-expand'),\r\n            clone = buttonInner.cloneNode(true);\r\n\r\n        clone.className = 'filter-expand';\r\n\r\n        if (filterExpand) {\r\n          button.replaceChild(clone, filterExpand);\r\n        } else {\r\n          button.appendChild(clone);\r\n        }\r\n      }\r\n\r\n      this.$element.trigger('rendered' + EVENT_KEY);\r\n    },\r\n\r\n    /**\r\n     * @param [style]\r\n     * @param [status]\r\n     */\r\n    setStyle: function (newStyle, status) {\r\n      var button = this.$button[0],\r\n          newElement = this.$newElement[0],\r\n          style = this.options.style.trim(),\r\n          buttonClass;\r\n\r\n      if (this.$element.attr('class')) {\r\n        this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\\[.*\\]/gi, ''));\r\n      }\r\n\r\n      if (version.major < 4) {\r\n        newElement.classList.add('bs3');\r\n\r\n        if (newElement.parentNode.classList && newElement.parentNode.classList.contains('input-group') &&\r\n            (newElement.previousElementSibling || newElement.nextElementSibling) &&\r\n            (newElement.previousElementSibling || newElement.nextElementSibling).classList.contains('input-group-addon')\r\n        ) {\r\n          newElement.classList.add('bs3-has-addon');\r\n        }\r\n      }\r\n\r\n      if (newStyle) {\r\n        buttonClass = newStyle.trim();\r\n      } else {\r\n        buttonClass = style;\r\n      }\r\n\r\n      if (status == 'add') {\r\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\r\n      } else if (status == 'remove') {\r\n        if (buttonClass) button.classList.remove.apply(button.classList, buttonClass.split(' '));\r\n      } else {\r\n        if (style) button.classList.remove.apply(button.classList, style.split(' '));\r\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\r\n      }\r\n    },\r\n\r\n    liHeight: function (refresh) {\r\n      if (!refresh && (this.options.size === false || Object.keys(this.sizeInfo).length)) return;\r\n\r\n      var newElement = elementTemplates.div.cloneNode(false),\r\n          menu = elementTemplates.div.cloneNode(false),\r\n          menuInner = elementTemplates.div.cloneNode(false),\r\n          menuInnerInner = document.createElement('ul'),\r\n          divider = elementTemplates.li.cloneNode(false),\r\n          dropdownHeader = elementTemplates.li.cloneNode(false),\r\n          li,\r\n          a = elementTemplates.a.cloneNode(false),\r\n          text = elementTemplates.span.cloneNode(false),\r\n          header = this.options.header && this.$menu.find('.' + classNames.POPOVERHEADER).length > 0 ? this.$menu.find('.' + classNames.POPOVERHEADER)[0].cloneNode(true) : null,\r\n          search = this.options.liveSearch ? elementTemplates.div.cloneNode(false) : null,\r\n          actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,\r\n          doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null,\r\n          firstOption = this.$element.find('option')[0];\r\n\r\n      this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;\r\n\r\n      text.className = 'text';\r\n      a.className = 'dropdown-item ' + (firstOption ? firstOption.className : '');\r\n      newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;\r\n      newElement.style.width = 0; // ensure button width doesn't affect natural width of menu when calculating\r\n      if (this.options.width === 'auto') menu.style.minWidth = 0;\r\n      menu.className = classNames.MENU + ' ' + classNames.SHOW;\r\n      menuInner.className = 'inner ' + classNames.SHOW;\r\n      menuInnerInner.className = classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '');\r\n      divider.className = classNames.DIVIDER;\r\n      dropdownHeader.className = 'dropdown-header';\r\n\r\n      text.appendChild(document.createTextNode('\\u200b'));\r\n\r\n      if (this.selectpicker.current.data.length) {\r\n        for (var i = 0; i < this.selectpicker.current.data.length; i++) {\r\n          var data = this.selectpicker.current.data[i];\r\n          if (data.type === 'option') {\r\n            li = data.element;\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        li = elementTemplates.li.cloneNode(false);\r\n        a.appendChild(text);\r\n        li.appendChild(a);\r\n      }\r\n\r\n      dropdownHeader.appendChild(text.cloneNode(true));\r\n\r\n      if (this.selectpicker.view.widestOption) {\r\n        menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));\r\n      }\r\n\r\n      menuInnerInner.appendChild(li);\r\n      menuInnerInner.appendChild(divider);\r\n      menuInnerInner.appendChild(dropdownHeader);\r\n      if (header) menu.appendChild(header);\r\n      if (search) {\r\n        var input = document.createElement('input');\r\n        search.className = 'bs-searchbox';\r\n        input.className = 'form-control';\r\n        search.appendChild(input);\r\n        menu.appendChild(search);\r\n      }\r\n      if (actions) menu.appendChild(actions);\r\n      menuInner.appendChild(menuInnerInner);\r\n      menu.appendChild(menuInner);\r\n      if (doneButton) menu.appendChild(doneButton);\r\n      newElement.appendChild(menu);\r\n\r\n      document.body.appendChild(newElement);\r\n\r\n      var liHeight = li.offsetHeight,\r\n          dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,\r\n          headerHeight = header ? header.offsetHeight : 0,\r\n          searchHeight = search ? search.offsetHeight : 0,\r\n          actionsHeight = actions ? actions.offsetHeight : 0,\r\n          doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,\r\n          dividerHeight = $(divider).outerHeight(true),\r\n          // fall back to jQuery if getComputedStyle is not supported\r\n          menuStyle = window.getComputedStyle ? window.getComputedStyle(menu) : false,\r\n          menuWidth = menu.offsetWidth,\r\n          $menu = menuStyle ? null : $(menu),\r\n          menuPadding = {\r\n            vert: toInteger(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) +\r\n                  toInteger(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) +\r\n                  toInteger(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) +\r\n                  toInteger(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),\r\n            horiz: toInteger(menuStyle ? menuStyle.paddingLeft : $menu.css('paddingLeft')) +\r\n                  toInteger(menuStyle ? menuStyle.paddingRight : $menu.css('paddingRight')) +\r\n                  toInteger(menuStyle ? menuStyle.borderLeftWidth : $menu.css('borderLeftWidth')) +\r\n                  toInteger(menuStyle ? menuStyle.borderRightWidth : $menu.css('borderRightWidth'))\r\n          },\r\n          menuExtras = {\r\n            vert: menuPadding.vert +\r\n                  toInteger(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) +\r\n                  toInteger(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2,\r\n            horiz: menuPadding.horiz +\r\n                  toInteger(menuStyle ? menuStyle.marginLeft : $menu.css('marginLeft')) +\r\n                  toInteger(menuStyle ? menuStyle.marginRight : $menu.css('marginRight')) + 2\r\n          },\r\n          scrollBarWidth;\r\n\r\n      menuInner.style.overflowY = 'scroll';\r\n\r\n      scrollBarWidth = menu.offsetWidth - menuWidth;\r\n\r\n      document.body.removeChild(newElement);\r\n\r\n      this.sizeInfo.liHeight = liHeight;\r\n      this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;\r\n      this.sizeInfo.headerHeight = headerHeight;\r\n      this.sizeInfo.searchHeight = searchHeight;\r\n      this.sizeInfo.actionsHeight = actionsHeight;\r\n      this.sizeInfo.doneButtonHeight = doneButtonHeight;\r\n      this.sizeInfo.dividerHeight = dividerHeight;\r\n      this.sizeInfo.menuPadding = menuPadding;\r\n      this.sizeInfo.menuExtras = menuExtras;\r\n      this.sizeInfo.menuWidth = menuWidth;\r\n      this.sizeInfo.menuInnerInnerWidth = menuWidth - menuPadding.horiz;\r\n      this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;\r\n      this.sizeInfo.scrollBarWidth = scrollBarWidth;\r\n      this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;\r\n\r\n      this.setPositionData();\r\n    },\r\n\r\n    getSelectPosition: function () {\r\n      var that = this,\r\n          $window = $(window),\r\n          pos = that.$newElement.offset(),\r\n          $container = $(that.options.container),\r\n          containerPos;\r\n\r\n      if (that.options.container && $container.length && !$container.is('body')) {\r\n        containerPos = $container.offset();\r\n        containerPos.top += parseInt($container.css('borderTopWidth'));\r\n        containerPos.left += parseInt($container.css('borderLeftWidth'));\r\n      } else {\r\n        containerPos = { top: 0, left: 0 };\r\n      }\r\n\r\n      var winPad = that.options.windowPadding;\r\n\r\n      this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();\r\n      this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - containerPos.top - winPad[2];\r\n      this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();\r\n      this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - containerPos.left - winPad[1];\r\n      this.sizeInfo.selectOffsetTop -= winPad[0];\r\n      this.sizeInfo.selectOffsetLeft -= winPad[3];\r\n    },\r\n\r\n    setMenuSize: function (isAuto) {\r\n      this.getSelectPosition();\r\n\r\n      var selectWidth = this.sizeInfo.selectWidth,\r\n          liHeight = this.sizeInfo.liHeight,\r\n          headerHeight = this.sizeInfo.headerHeight,\r\n          searchHeight = this.sizeInfo.searchHeight,\r\n          actionsHeight = this.sizeInfo.actionsHeight,\r\n          doneButtonHeight = this.sizeInfo.doneButtonHeight,\r\n          divHeight = this.sizeInfo.dividerHeight,\r\n          menuPadding = this.sizeInfo.menuPadding,\r\n          menuInnerHeight,\r\n          menuHeight,\r\n          divLength = 0,\r\n          minHeight,\r\n          _minHeight,\r\n          maxHeight,\r\n          menuInnerMinHeight,\r\n          estimate,\r\n          isDropup;\r\n\r\n      if (this.options.dropupAuto) {\r\n        // Get the estimated height of the menu without scrollbars.\r\n        // This is useful for smaller menus, where there might be plenty of room\r\n        // below the button without setting dropup, but we can't know\r\n        // the exact height of the menu until createView is called later\r\n        estimate = liHeight * this.selectpicker.current.elements.length + menuPadding.vert;\r\n\r\n        isDropup = this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot;\r\n\r\n        // ensure dropup doesn't change while searching (so menu doesn't bounce back and forth)\r\n        if (this.selectpicker.isSearching === true) {\r\n          isDropup = this.selectpicker.dropup;\r\n        }\r\n\r\n        this.$newElement.toggleClass(classNames.DROPUP, isDropup);\r\n        this.selectpicker.dropup = isDropup;\r\n      }\r\n\r\n      if (this.options.size === 'auto') {\r\n        _minHeight = this.selectpicker.current.elements.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;\r\n        menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;\r\n        minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\r\n        menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);\r\n\r\n        if (this.$newElement.hasClass(classNames.DROPUP)) {\r\n          menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;\r\n        }\r\n\r\n        maxHeight = menuHeight;\r\n        menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;\r\n      } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\r\n        for (var i = 0; i < this.options.size; i++) {\r\n          if (this.selectpicker.current.data[i].type === 'divider') divLength++;\r\n        }\r\n\r\n        menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;\r\n        menuInnerHeight = menuHeight - menuPadding.vert;\r\n        maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\r\n        minHeight = menuInnerMinHeight = '';\r\n      }\r\n\r\n      this.$menu.css({\r\n        'max-height': maxHeight + 'px',\r\n        'overflow': 'hidden',\r\n        'min-height': minHeight + 'px'\r\n      });\r\n\r\n      this.$menuInner.css({\r\n        'max-height': menuInnerHeight + 'px',\r\n        'overflow-y': 'auto',\r\n        'min-height': menuInnerMinHeight + 'px'\r\n      });\r\n\r\n      // ensure menuInnerHeight is always a positive number to prevent issues calculating chunkSize in createView\r\n      this.sizeInfo.menuInnerHeight = Math.max(menuInnerHeight, 1);\r\n\r\n      if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {\r\n        this.sizeInfo.hasScrollBar = true;\r\n        this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;\r\n      }\r\n\r\n      if (this.options.dropdownAlignRight === 'auto') {\r\n        this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < (this.sizeInfo.totalMenuWidth - selectWidth));\r\n      }\r\n\r\n      if (this.dropdown && this.dropdown._popper) this.dropdown._popper.update();\r\n    },\r\n\r\n    setSize: function (refresh) {\r\n      this.liHeight(refresh);\r\n\r\n      if (this.options.header) this.$menu.css('padding-top', 0);\r\n\r\n      if (this.options.size !== false) {\r\n        var that = this,\r\n            $window = $(window);\r\n\r\n        this.setMenuSize();\r\n\r\n        if (this.options.liveSearch) {\r\n          this.$searchbox\r\n            .off('input.setMenuSize propertychange.setMenuSize')\r\n            .on('input.setMenuSize propertychange.setMenuSize', function () {\r\n              return that.setMenuSize();\r\n            });\r\n        }\r\n\r\n        if (this.options.size === 'auto') {\r\n          $window\r\n            .off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize')\r\n            .on('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize', function () {\r\n              return that.setMenuSize();\r\n            });\r\n        } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\r\n          $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize');\r\n        }\r\n      }\r\n\r\n      this.createView(false, true, refresh);\r\n    },\r\n\r\n    setWidth: function () {\r\n      var that = this;\r\n\r\n      if (this.options.width === 'auto') {\r\n        requestAnimationFrame(function () {\r\n          that.$menu.css('min-width', '0');\r\n\r\n          that.$element.on('loaded' + EVENT_KEY, function () {\r\n            that.liHeight();\r\n            that.setMenuSize();\r\n\r\n            // Get correct width if element is hidden\r\n            var $selectClone = that.$newElement.clone().appendTo('body'),\r\n                btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();\r\n\r\n            $selectClone.remove();\r\n\r\n            // Set width to whatever's larger, button title or longest option\r\n            that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);\r\n            that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');\r\n          });\r\n        });\r\n      } else if (this.options.width === 'fit') {\r\n        // Remove inline min-width so width can be changed from 'auto'\r\n        this.$menu.css('min-width', '');\r\n        this.$newElement.css('width', '').addClass('fit-width');\r\n      } else if (this.options.width) {\r\n        // Remove inline min-width so width can be changed from 'auto'\r\n        this.$menu.css('min-width', '');\r\n        this.$newElement.css('width', this.options.width);\r\n      } else {\r\n        // Remove inline min-width/width so width can be changed\r\n        this.$menu.css('min-width', '');\r\n        this.$newElement.css('width', '');\r\n      }\r\n      // Remove fit-width class if width is changed programmatically\r\n      if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {\r\n        this.$newElement[0].classList.remove('fit-width');\r\n      }\r\n    },\r\n\r\n    selectPosition: function () {\r\n      this.$bsContainer = $('<div class=\"bs-container\" />');\r\n\r\n      var that = this,\r\n          $container = $(this.options.container),\r\n          pos,\r\n          containerPos,\r\n          actualHeight,\r\n          getPlacement = function ($element) {\r\n            var containerPosition = {},\r\n                // fall back to dropdown's default display setting if display is not manually set\r\n                display = that.options.display || (\r\n                  // Bootstrap 3 doesn't have $.fn.dropdown.Constructor.Default\r\n                  $.fn.dropdown.Constructor.Default ? $.fn.dropdown.Constructor.Default.display\r\n                  : false\r\n                );\r\n\r\n            that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));\r\n            pos = $element.offset();\r\n\r\n            if (!$container.is('body')) {\r\n              containerPos = $container.offset();\r\n              containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();\r\n              containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();\r\n            } else {\r\n              containerPos = { top: 0, left: 0 };\r\n            }\r\n\r\n            actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight;\r\n\r\n            // Bootstrap 4+ uses Popper for menu positioning\r\n            if (version.major < 4 || display === 'static') {\r\n              containerPosition.top = pos.top - containerPos.top + actualHeight;\r\n              containerPosition.left = pos.left - containerPos.left;\r\n            }\r\n\r\n            containerPosition.width = $element[0].offsetWidth;\r\n\r\n            that.$bsContainer.css(containerPosition);\r\n          };\r\n\r\n      this.$button.on('click.bs.dropdown.data-api', function () {\r\n        if (that.isDisabled()) {\r\n          return;\r\n        }\r\n\r\n        getPlacement(that.$newElement);\r\n\r\n        that.$bsContainer\r\n          .appendTo(that.options.container)\r\n          .toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW))\r\n          .append(that.$menu);\r\n      });\r\n\r\n      $(window)\r\n        .off('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId)\r\n        .on('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId, function () {\r\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\r\n\r\n          if (isActive) getPlacement(that.$newElement);\r\n        });\r\n\r\n      this.$element.on('hide' + EVENT_KEY, function () {\r\n        that.$menu.data('height', that.$menu.height());\r\n        that.$bsContainer.detach();\r\n      });\r\n    },\r\n\r\n    setOptionStatus: function (selectedOnly) {\r\n      var that = this;\r\n\r\n      that.noScroll = false;\r\n\r\n      if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {\r\n        for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {\r\n          var liData = that.selectpicker.current.data[i + that.selectpicker.view.position0],\r\n              option = liData.option;\r\n\r\n          if (option) {\r\n            if (selectedOnly !== true) {\r\n              that.setDisabled(\r\n                liData.index,\r\n                liData.disabled\r\n              );\r\n            }\r\n\r\n            that.setSelected(\r\n              liData.index,\r\n              option.selected\r\n            );\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {number} index - the index of the option that is being changed\r\n     * @param {boolean} selected - true if the option is being selected, false if being deselected\r\n     */\r\n    setSelected: function (index, selected) {\r\n      var li = this.selectpicker.main.elements[index],\r\n          liData = this.selectpicker.main.data[index],\r\n          activeIndexIsSet = this.activeIndex !== undefined,\r\n          thisIsActive = this.activeIndex === index,\r\n          prevActive,\r\n          a,\r\n          // if current option is already active\r\n          // OR\r\n          // if the current option is being selected, it's NOT multiple, and\r\n          // activeIndex is undefined:\r\n          //  - when the menu is first being opened, OR\r\n          //  - after a search has been performed, OR\r\n          //  - when retainActive is false when selecting a new option (i.e. index of the newly selected option is not the same as the current activeIndex)\r\n          keepActive = thisIsActive || (selected && !this.multiple && !activeIndexIsSet);\r\n\r\n      liData.selected = selected;\r\n\r\n      a = li.firstChild;\r\n\r\n      if (selected) {\r\n        this.selectedIndex = index;\r\n      }\r\n\r\n      li.classList.toggle('selected', selected);\r\n\r\n      if (keepActive) {\r\n        this.focusItem(li, liData);\r\n        this.selectpicker.view.currentActive = li;\r\n        this.activeIndex = index;\r\n      } else {\r\n        this.defocusItem(li);\r\n      }\r\n\r\n      if (a) {\r\n        a.classList.toggle('selected', selected);\r\n\r\n        if (selected) {\r\n          a.setAttribute('aria-selected', true);\r\n        } else {\r\n          if (this.multiple) {\r\n            a.setAttribute('aria-selected', false);\r\n          } else {\r\n            a.removeAttribute('aria-selected');\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!keepActive && !activeIndexIsSet && selected && this.prevActiveIndex !== undefined) {\r\n        prevActive = this.selectpicker.main.elements[this.prevActiveIndex];\r\n\r\n        this.defocusItem(prevActive);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {number} index - the index of the option that is being disabled\r\n     * @param {boolean} disabled - true if the option is being disabled, false if being enabled\r\n     */\r\n    setDisabled: function (index, disabled) {\r\n      var li = this.selectpicker.main.elements[index],\r\n          a;\r\n\r\n      this.selectpicker.main.data[index].disabled = disabled;\r\n\r\n      a = li.firstChild;\r\n\r\n      li.classList.toggle(classNames.DISABLED, disabled);\r\n\r\n      if (a) {\r\n        if (version.major === '4') a.classList.toggle(classNames.DISABLED, disabled);\r\n\r\n        if (disabled) {\r\n          a.setAttribute('aria-disabled', disabled);\r\n          a.setAttribute('tabindex', -1);\r\n        } else {\r\n          a.removeAttribute('aria-disabled');\r\n          a.setAttribute('tabindex', 0);\r\n        }\r\n      }\r\n    },\r\n\r\n    isDisabled: function () {\r\n      return this.$element[0].disabled;\r\n    },\r\n\r\n    checkDisabled: function () {\r\n      if (this.isDisabled()) {\r\n        this.$newElement[0].classList.add(classNames.DISABLED);\r\n        this.$button.addClass(classNames.DISABLED).attr('aria-disabled', true);\r\n      } else {\r\n        if (this.$button[0].classList.contains(classNames.DISABLED)) {\r\n          this.$newElement[0].classList.remove(classNames.DISABLED);\r\n          this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);\r\n        }\r\n      }\r\n    },\r\n\r\n    clickListener: function () {\r\n      var that = this,\r\n          $document = $(document);\r\n\r\n      $document.data('spaceSelect', false);\r\n\r\n      this.$button.on('keyup', function (e) {\r\n        if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {\r\n          e.preventDefault();\r\n          $document.data('spaceSelect', false);\r\n        }\r\n      });\r\n\r\n      this.$newElement.on('show.bs.dropdown', function () {\r\n        if (version.major > 3 && !that.dropdown) {\r\n          that.dropdown = that.$button.data('bs.dropdown');\r\n          that.dropdown._menu = that.$menu[0];\r\n        }\r\n      });\r\n\r\n      this.$button.on('click.bs.dropdown.data-api', function () {\r\n        if (!that.$newElement.hasClass(classNames.SHOW)) {\r\n          that.setSize();\r\n        }\r\n      });\r\n\r\n      function setFocus () {\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          that.$menuInner.trigger('focus');\r\n        }\r\n      }\r\n\r\n      function checkPopperExists () {\r\n        if (that.dropdown && that.dropdown._popper && that.dropdown._popper.state.isCreated) {\r\n          setFocus();\r\n        } else {\r\n          requestAnimationFrame(checkPopperExists);\r\n        }\r\n      }\r\n\r\n      this.$element.on('shown' + EVENT_KEY, function () {\r\n        if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {\r\n          that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;\r\n        }\r\n\r\n        if (version.major > 3) {\r\n          requestAnimationFrame(checkPopperExists);\r\n        } else {\r\n          setFocus();\r\n        }\r\n      });\r\n\r\n      // ensure posinset and setsize are correct before selecting an option via a click\r\n      this.$menuInner.on('mouseenter', 'li a', function (e) {\r\n        var hoverLi = this.parentElement,\r\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\r\n            index = Array.prototype.indexOf.call(hoverLi.parentElement.children, hoverLi),\r\n            hoverData = that.selectpicker.current.data[index + position0];\r\n\r\n        that.focusItem(hoverLi, hoverData, true);\r\n      });\r\n\r\n      this.$menuInner.on('click', 'li a', function (e, retainActive) {\r\n        var $this = $(this),\r\n            element = that.$element[0],\r\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\r\n            clickedData = that.selectpicker.current.data[$this.parent().index() + position0],\r\n            clickedIndex = clickedData.index,\r\n            prevValue = getSelectValues(element),\r\n            prevIndex = element.selectedIndex,\r\n            prevOption = element.options[prevIndex],\r\n            triggerChange = true;\r\n\r\n        // Don't close on multi choice menu\r\n        if (that.multiple && that.options.maxOptions !== 1) {\r\n          e.stopPropagation();\r\n        }\r\n\r\n        e.preventDefault();\r\n\r\n        // Don't run if the select is disabled\r\n        if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {\r\n          var option = clickedData.option,\r\n              $option = $(option),\r\n              state = option.selected,\r\n              $optgroup = $option.parent('optgroup'),\r\n              $optgroupOptions = $optgroup.find('option'),\r\n              maxOptions = that.options.maxOptions,\r\n              maxOptionsGrp = $optgroup.data('maxOptions') || false;\r\n\r\n          if (clickedIndex === that.activeIndex) retainActive = true;\r\n\r\n          if (!retainActive) {\r\n            that.prevActiveIndex = that.activeIndex;\r\n            that.activeIndex = undefined;\r\n          }\r\n\r\n          if (!that.multiple) { // Deselect all others if not multi select box\r\n            if (prevOption) prevOption.selected = false;\r\n            option.selected = true;\r\n            that.setSelected(clickedIndex, true);\r\n          } else { // Toggle the one we have chosen if we are multi select.\r\n            option.selected = !state;\r\n\r\n            that.setSelected(clickedIndex, !state);\r\n            that.focusedParent.focus();\r\n\r\n            if (maxOptions !== false || maxOptionsGrp !== false) {\r\n              var maxReached = maxOptions < getSelectedOptions(element).length,\r\n                  maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;\r\n\r\n              if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {\r\n                if (maxOptions && maxOptions == 1) {\r\n                  element.selectedIndex = -1;\r\n                  option.selected = true;\r\n                  that.setOptionStatus(true);\r\n                } else if (maxOptionsGrp && maxOptionsGrp == 1) {\r\n                  for (var i = 0; i < $optgroupOptions.length; i++) {\r\n                    var _option = $optgroupOptions[i];\r\n                    _option.selected = false;\r\n                    that.setSelected(_option.liIndex, false);\r\n                  }\r\n\r\n                  option.selected = true;\r\n                  that.setSelected(clickedIndex, true);\r\n                } else {\r\n                  var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,\r\n                      maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,\r\n                      maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),\r\n                      maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),\r\n                      $notify = $('<div class=\"notify\"></div>');\r\n                  // If {var} is set in array, replace it\r\n                  /** @deprecated */\r\n                  if (maxOptionsArr[2]) {\r\n                    maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);\r\n                    maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);\r\n                  }\r\n\r\n                  option.selected = false;\r\n\r\n                  that.$menu.append($notify);\r\n\r\n                  if (maxOptions && maxReached) {\r\n                    $notify.append($('<div>' + maxTxt + '</div>'));\r\n                    triggerChange = false;\r\n                    that.$element.trigger('maxReached' + EVENT_KEY);\r\n                  }\r\n\r\n                  if (maxOptionsGrp && maxReachedGrp) {\r\n                    $notify.append($('<div>' + maxTxtGrp + '</div>'));\r\n                    triggerChange = false;\r\n                    that.$element.trigger('maxReachedGrp' + EVENT_KEY);\r\n                  }\r\n\r\n                  setTimeout(function () {\r\n                    that.setSelected(clickedIndex, false);\r\n                  }, 10);\r\n\r\n                  $notify[0].classList.add('fadeOut');\r\n\r\n                  setTimeout(function () {\r\n                    $notify.remove();\r\n                  }, 1050);\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (!that.multiple || (that.multiple && that.options.maxOptions === 1)) {\r\n            that.$button.trigger('focus');\r\n          } else if (that.options.liveSearch) {\r\n            that.$searchbox.trigger('focus');\r\n          }\r\n\r\n          // Trigger select 'change'\r\n          if (triggerChange) {\r\n            if (that.multiple || prevIndex !== element.selectedIndex) {\r\n              // $option.prop('selected') is current option state (selected/unselected). prevValue is the value of the select prior to being changed.\r\n              changedArguments = [option.index, $option.prop('selected'), prevValue];\r\n              that.$element\r\n                .triggerNative('change');\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .' + classNames.POPOVERHEADER + ', .' + classNames.POPOVERHEADER + ' :not(.close)', function (e) {\r\n        if (e.currentTarget == this) {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          if (that.options.liveSearch && !$(e.target).hasClass('close')) {\r\n            that.$searchbox.trigger('focus');\r\n          } else {\r\n            that.$button.trigger('focus');\r\n          }\r\n        }\r\n      });\r\n\r\n      this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          that.$button.trigger('focus');\r\n        }\r\n      });\r\n\r\n      this.$menu.on('click', '.' + classNames.POPOVERHEADER + ' .close', function () {\r\n        that.$button.trigger('click');\r\n      });\r\n\r\n      this.$searchbox.on('click', function (e) {\r\n        e.stopPropagation();\r\n      });\r\n\r\n      this.$menu.on('click', '.actions-btn', function (e) {\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          that.$button.trigger('focus');\r\n        }\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        if ($(this).hasClass('bs-select-all')) {\r\n          that.selectAll();\r\n        } else {\r\n          that.deselectAll();\r\n        }\r\n      });\r\n\r\n      this.$button\r\n        .on('focus' + EVENT_KEY, function (e) {\r\n          var tabindex = that.$element[0].getAttribute('tabindex');\r\n\r\n          // only change when button is actually focused\r\n          if (tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\r\n            // apply select element's tabindex to ensure correct order is followed when tabbing to the next element\r\n            this.setAttribute('tabindex', tabindex);\r\n            // set element's tabindex to -1 to allow for reverse tabbing\r\n            that.$element[0].setAttribute('tabindex', -1);\r\n            that.selectpicker.view.tabindex = tabindex;\r\n          }\r\n        })\r\n        .on('blur' + EVENT_KEY, function (e) {\r\n          // revert everything to original tabindex\r\n          if (that.selectpicker.view.tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\r\n            that.$element[0].setAttribute('tabindex', that.selectpicker.view.tabindex);\r\n            this.setAttribute('tabindex', -1);\r\n            that.selectpicker.view.tabindex = undefined;\r\n          }\r\n        });\r\n\r\n      this.$element\r\n        .on('change' + EVENT_KEY, function () {\r\n          that.render();\r\n          that.$element.trigger('changed' + EVENT_KEY, changedArguments);\r\n          changedArguments = null;\r\n        })\r\n        .on('focus' + EVENT_KEY, function () {\r\n          if (!that.options.mobile) that.$button[0].focus();\r\n        });\r\n    },\r\n\r\n    liveSearchListener: function () {\r\n      var that = this;\r\n\r\n      this.$button.on('click.bs.dropdown.data-api', function () {\r\n        if (!!that.$searchbox.val()) {\r\n          that.$searchbox.val('');\r\n          that.selectpicker.search.previousValue = undefined;\r\n        }\r\n      });\r\n\r\n      this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {\r\n        e.stopPropagation();\r\n      });\r\n\r\n      this.$searchbox.on('input propertychange', function () {\r\n        var searchValue = that.$searchbox[0].value;\r\n\r\n        that.selectpicker.search.elements = [];\r\n        that.selectpicker.search.data = [];\r\n\r\n        if (searchValue) {\r\n          var i,\r\n              searchMatch = [],\r\n              q = searchValue.toUpperCase(),\r\n              cache = {},\r\n              cacheArr = [],\r\n              searchStyle = that._searchStyle(),\r\n              normalizeSearch = that.options.liveSearchNormalize;\r\n\r\n          if (normalizeSearch) q = normalizeToBase(q);\r\n\r\n          for (var i = 0; i < that.selectpicker.main.data.length; i++) {\r\n            var li = that.selectpicker.main.data[i];\r\n\r\n            if (!cache[i]) {\r\n              cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);\r\n            }\r\n\r\n            if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {\r\n              if (li.headerIndex > 0) {\r\n                cache[li.headerIndex - 1] = true;\r\n                cacheArr.push(li.headerIndex - 1);\r\n              }\r\n\r\n              cache[li.headerIndex] = true;\r\n              cacheArr.push(li.headerIndex);\r\n\r\n              cache[li.lastIndex + 1] = true;\r\n            }\r\n\r\n            if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);\r\n          }\r\n\r\n          for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {\r\n            var index = cacheArr[i],\r\n                prevIndex = cacheArr[i - 1],\r\n                li = that.selectpicker.main.data[index],\r\n                liPrev = that.selectpicker.main.data[prevIndex];\r\n\r\n            if (li.type !== 'divider' || (li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i)) {\r\n              that.selectpicker.search.data.push(li);\r\n              searchMatch.push(that.selectpicker.main.elements[index]);\r\n            }\r\n          }\r\n\r\n          that.activeIndex = undefined;\r\n          that.noScroll = true;\r\n          that.$menuInner.scrollTop(0);\r\n          that.selectpicker.search.elements = searchMatch;\r\n          that.createView(true);\r\n          showNoResults.call(that, searchMatch, searchValue);\r\n        } else if (that.selectpicker.search.previousValue) { // for IE11 (#2402)\r\n          that.$menuInner.scrollTop(0);\r\n          that.createView(false);\r\n        }\r\n\r\n        that.selectpicker.search.previousValue =  searchValue;\r\n      });\r\n    },\r\n\r\n    _searchStyle: function () {\r\n      return this.options.liveSearchStyle || 'contains';\r\n    },\r\n\r\n    val: function (value) {\r\n      var element = this.$element[0];\r\n\r\n      if (typeof value !== 'undefined') {\r\n        var prevValue = getSelectValues(element);\r\n\r\n        changedArguments = [null, null, prevValue];\r\n\r\n        this.$element\r\n          .val(value)\r\n          .trigger('changed' + EVENT_KEY, changedArguments);\r\n\r\n        if (this.$newElement.hasClass(classNames.SHOW)) {\r\n          if (this.multiple) {\r\n            this.setOptionStatus(true);\r\n          } else {\r\n            var liSelectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\r\n\r\n            if (typeof liSelectedIndex === 'number') {\r\n              this.setSelected(this.selectedIndex, false);\r\n              this.setSelected(liSelectedIndex, true);\r\n            }\r\n          }\r\n        }\r\n\r\n        this.render();\r\n\r\n        changedArguments = null;\r\n\r\n        return this.$element;\r\n      } else {\r\n        return this.$element.val();\r\n      }\r\n    },\r\n\r\n    changeAll: function (status) {\r\n      if (!this.multiple) return;\r\n      if (typeof status === 'undefined') status = true;\r\n\r\n      var element = this.$element[0],\r\n          previousSelected = 0,\r\n          currentSelected = 0,\r\n          prevValue = getSelectValues(element);\r\n\r\n      element.classList.add('bs-select-hidden');\r\n\r\n      for (var i = 0, data = this.selectpicker.current.data, len = data.length; i < len; i++) {\r\n        var liData = data[i],\r\n            option = liData.option;\r\n\r\n        if (option && !liData.disabled && liData.type !== 'divider') {\r\n          if (liData.selected) previousSelected++;\r\n          option.selected = status;\r\n          if (status === true) currentSelected++;\r\n        }\r\n      }\r\n\r\n      element.classList.remove('bs-select-hidden');\r\n\r\n      if (previousSelected === currentSelected) return;\r\n\r\n      this.setOptionStatus();\r\n\r\n      changedArguments = [null, null, prevValue];\r\n\r\n      this.$element\r\n        .triggerNative('change');\r\n    },\r\n\r\n    selectAll: function () {\r\n      return this.changeAll(true);\r\n    },\r\n\r\n    deselectAll: function () {\r\n      return this.changeAll(false);\r\n    },\r\n\r\n    toggle: function (e) {\r\n      e = e || window.event;\r\n\r\n      if (e) e.stopPropagation();\r\n\r\n      this.$button.trigger('click.bs.dropdown.data-api');\r\n    },\r\n\r\n    keydown: function (e) {\r\n      var $this = $(this),\r\n          isToggle = $this.hasClass('dropdown-toggle'),\r\n          $parent = isToggle ? $this.closest('.dropdown') : $this.closest(Selector.MENU),\r\n          that = $parent.data('this'),\r\n          $items = that.findLis(),\r\n          index,\r\n          isActive,\r\n          liActive,\r\n          activeLi,\r\n          offset,\r\n          updateScroll = false,\r\n          downOnTab = e.which === keyCodes.TAB && !isToggle && !that.options.selectOnTab,\r\n          isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,\r\n          scrollTop = that.$menuInner[0].scrollTop,\r\n          isVirtual = that.isVirtual(),\r\n          position0 = isVirtual === true ? that.selectpicker.view.position0 : 0;\r\n\r\n      // do nothing if a function key is pressed\r\n      if (e.which >= 112 && e.which <= 123) return;\r\n\r\n      isActive = that.$newElement.hasClass(classNames.SHOW);\r\n\r\n      if (\r\n        !isActive &&\r\n        (\r\n          isArrowKey ||\r\n          (e.which >= 48 && e.which <= 57) ||\r\n          (e.which >= 96 && e.which <= 105) ||\r\n          (e.which >= 65 && e.which <= 90)\r\n        )\r\n      ) {\r\n        that.$button.trigger('click.bs.dropdown.data-api');\r\n\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (e.which === keyCodes.ESCAPE && isActive) {\r\n        e.preventDefault();\r\n        that.$button.trigger('click.bs.dropdown.data-api').trigger('focus');\r\n      }\r\n\r\n      if (isArrowKey) { // if up or down\r\n        if (!$items.length) return;\r\n\r\n        liActive = that.selectpicker.main.elements[that.activeIndex];\r\n        index = liActive ? Array.prototype.indexOf.call(liActive.parentElement.children, liActive) : -1;\r\n\r\n        if (index !== -1) {\r\n          that.defocusItem(liActive);\r\n        }\r\n\r\n        if (e.which === keyCodes.ARROW_UP) { // up\r\n          if (index !== -1) index--;\r\n          if (index + position0 < 0) index += $items.length;\r\n\r\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\r\n            index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;\r\n            if (index === -1) index = $items.length - 1;\r\n          }\r\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\r\n          index++;\r\n          if (index + position0 >= that.selectpicker.view.canHighlight.length) index = that.selectpicker.view.firstHighlightIndex;\r\n\r\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\r\n            index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);\r\n          }\r\n        }\r\n\r\n        e.preventDefault();\r\n\r\n        var liActiveIndex = position0 + index;\r\n\r\n        if (e.which === keyCodes.ARROW_UP) { // up\r\n          // scroll to bottom and highlight last option\r\n          if (position0 === 0 && index === $items.length - 1) {\r\n            that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;\r\n\r\n            liActiveIndex = that.selectpicker.current.elements.length - 1;\r\n          } else {\r\n            activeLi = that.selectpicker.current.data[liActiveIndex];\r\n            offset = activeLi.position - activeLi.height;\r\n\r\n            updateScroll = offset < scrollTop;\r\n          }\r\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\r\n          // scroll to top and highlight first option\r\n          if (index === that.selectpicker.view.firstHighlightIndex) {\r\n            that.$menuInner[0].scrollTop = 0;\r\n\r\n            liActiveIndex = that.selectpicker.view.firstHighlightIndex;\r\n          } else {\r\n            activeLi = that.selectpicker.current.data[liActiveIndex];\r\n            offset = activeLi.position - that.sizeInfo.menuInnerHeight;\r\n\r\n            updateScroll = offset > scrollTop;\r\n          }\r\n        }\r\n\r\n        liActive = that.selectpicker.current.elements[liActiveIndex];\r\n\r\n        that.activeIndex = that.selectpicker.current.data[liActiveIndex].index;\r\n\r\n        that.focusItem(liActive);\r\n\r\n        that.selectpicker.view.currentActive = liActive;\r\n\r\n        if (updateScroll) that.$menuInner[0].scrollTop = offset;\r\n\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          $this.trigger('focus');\r\n        }\r\n      } else if (\r\n        (!$this.is('input') && !REGEXP_TAB_OR_ESCAPE.test(e.which)) ||\r\n        (e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory)\r\n      ) {\r\n        var searchMatch,\r\n            matches = [],\r\n            keyHistory;\r\n\r\n        e.preventDefault();\r\n\r\n        that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];\r\n\r\n        if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);\r\n        that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();\r\n\r\n        keyHistory = that.selectpicker.keydown.keyHistory;\r\n\r\n        // if all letters are the same, set keyHistory to just the first character when searching\r\n        if (/^(.)\\1+$/.test(keyHistory)) {\r\n          keyHistory = keyHistory.charAt(0);\r\n        }\r\n\r\n        // find matches\r\n        for (var i = 0; i < that.selectpicker.current.data.length; i++) {\r\n          var li = that.selectpicker.current.data[i],\r\n              hasMatch;\r\n\r\n          hasMatch = stringSearch(li, keyHistory, 'startsWith', true);\r\n\r\n          if (hasMatch && that.selectpicker.view.canHighlight[i]) {\r\n            matches.push(li.index);\r\n          }\r\n        }\r\n\r\n        if (matches.length) {\r\n          var matchIndex = 0;\r\n\r\n          $items.removeClass('active').find('a').removeClass('active');\r\n\r\n          // either only one key has been pressed or they are all the same key\r\n          if (keyHistory.length === 1) {\r\n            matchIndex = matches.indexOf(that.activeIndex);\r\n\r\n            if (matchIndex === -1 || matchIndex === matches.length - 1) {\r\n              matchIndex = 0;\r\n            } else {\r\n              matchIndex++;\r\n            }\r\n          }\r\n\r\n          searchMatch = matches[matchIndex];\r\n\r\n          activeLi = that.selectpicker.main.data[searchMatch];\r\n\r\n          if (scrollTop - activeLi.position > 0) {\r\n            offset = activeLi.position - activeLi.height;\r\n            updateScroll = true;\r\n          } else {\r\n            offset = activeLi.position - that.sizeInfo.menuInnerHeight;\r\n            // if the option is already visible at the current scroll position, just keep it the same\r\n            updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;\r\n          }\r\n\r\n          liActive = that.selectpicker.main.elements[searchMatch];\r\n\r\n          that.activeIndex = matches[matchIndex];\r\n\r\n          that.focusItem(liActive);\r\n\r\n          if (liActive) liActive.firstChild.focus();\r\n\r\n          if (updateScroll) that.$menuInner[0].scrollTop = offset;\r\n\r\n          $this.trigger('focus');\r\n        }\r\n      }\r\n\r\n      // Select focused option if \"Enter\", \"Spacebar\" or \"Tab\" (when selectOnTab is true) are pressed inside the menu.\r\n      if (\r\n        isActive &&\r\n        (\r\n          (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory) ||\r\n          e.which === keyCodes.ENTER ||\r\n          (e.which === keyCodes.TAB && that.options.selectOnTab)\r\n        )\r\n      ) {\r\n        if (e.which !== keyCodes.SPACE) e.preventDefault();\r\n\r\n        if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {\r\n          that.$menuInner.find('.active a').trigger('click', true); // retain active class\r\n          $this.trigger('focus');\r\n\r\n          if (!that.options.liveSearch) {\r\n            // Prevent screen from scrolling if the user hits the spacebar\r\n            e.preventDefault();\r\n            // Fixes spacebar selection of dropdown items in FF & IE\r\n            $(document).data('spaceSelect', true);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    mobile: function () {\r\n      // ensure mobile is set to true if mobile function is called after init\r\n      this.options.mobile = true;\r\n      this.$element[0].classList.add('mobile-device');\r\n    },\r\n\r\n    refresh: function () {\r\n      // update options if data attributes have been changed\r\n      var config = $.extend({}, this.options, this.$element.data());\r\n      this.options = config;\r\n\r\n      this.checkDisabled();\r\n      this.buildData();\r\n      this.setStyle();\r\n      this.render();\r\n      this.buildList();\r\n      this.setWidth();\r\n\r\n      this.setSize(true);\r\n\r\n      this.$element.trigger('refreshed' + EVENT_KEY);\r\n    },\r\n\r\n    hide: function () {\r\n      this.$newElement.hide();\r\n    },\r\n\r\n    show: function () {\r\n      this.$newElement.show();\r\n    },\r\n\r\n    remove: function () {\r\n      this.$newElement.remove();\r\n      this.$element.remove();\r\n    },\r\n\r\n    destroy: function () {\r\n      this.$newElement.before(this.$element).remove();\r\n\r\n      if (this.$bsContainer) {\r\n        this.$bsContainer.remove();\r\n      } else {\r\n        this.$menu.remove();\r\n      }\r\n\r\n      if (this.selectpicker.view.titleOption && this.selectpicker.view.titleOption.parentNode) {\r\n        this.selectpicker.view.titleOption.parentNode.removeChild(this.selectpicker.view.titleOption);\r\n      }\r\n\r\n      this.$element\r\n        .off(EVENT_KEY)\r\n        .removeData('selectpicker')\r\n        .removeClass('bs-select-hidden selectpicker');\r\n\r\n      $(window).off(EVENT_KEY + '.' + this.selectId);\r\n    }\r\n  };\r\n\r\n  // SELECTPICKER PLUGIN DEFINITION\r\n  // ==============================\r\n  function Plugin (option) {\r\n    // get the args of the outer function..\r\n    var args = arguments;\r\n    // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them\r\n    // to get lost/corrupted in android 2.3 and IE9 #715 #775\r\n    var _option = option;\r\n\r\n    [].shift.apply(args);\r\n\r\n    // if the version was not set successfully\r\n    if (!version.success) {\r\n      // try to retreive it again\r\n      try {\r\n        version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');\r\n      } catch (err) {\r\n        // fall back to use BootstrapVersion if set\r\n        if (Selectpicker.BootstrapVersion) {\r\n          version.full = Selectpicker.BootstrapVersion.split(' ')[0].split('.');\r\n        } else {\r\n          version.full = [version.major, '0', '0'];\r\n\r\n          console.warn(\r\n            'There was an issue retrieving Bootstrap\\'s version. ' +\r\n            'Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. ' +\r\n            'If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.',\r\n            err\r\n          );\r\n        }\r\n      }\r\n\r\n      version.major = version.full[0];\r\n      version.success = true;\r\n    }\r\n\r\n    if (version.major === '4') {\r\n      // some defaults need to be changed if using Bootstrap 4\r\n      // check to see if they have already been manually changed before forcing them to update\r\n      var toUpdate = [];\r\n\r\n      if (Selectpicker.DEFAULTS.style === classNames.BUTTONCLASS) toUpdate.push({ name: 'style', className: 'BUTTONCLASS' });\r\n      if (Selectpicker.DEFAULTS.iconBase === classNames.ICONBASE) toUpdate.push({ name: 'iconBase', className: 'ICONBASE' });\r\n      if (Selectpicker.DEFAULTS.tickIcon === classNames.TICKICON) toUpdate.push({ name: 'tickIcon', className: 'TICKICON' });\r\n\r\n      classNames.DIVIDER = 'dropdown-divider';\r\n      classNames.SHOW = 'show';\r\n      classNames.BUTTONCLASS = 'btn-light';\r\n      classNames.POPOVERHEADER = 'popover-header';\r\n      classNames.ICONBASE = '';\r\n      classNames.TICKICON = 'bs-ok-default';\r\n\r\n      for (var i = 0; i < toUpdate.length; i++) {\r\n        var option = toUpdate[i];\r\n        Selectpicker.DEFAULTS[option.name] = classNames[option.className];\r\n      }\r\n    }\r\n\r\n    var value;\r\n    var chain = this.each(function () {\r\n      var $this = $(this);\r\n      if ($this.is('select')) {\r\n        var data = $this.data('selectpicker'),\r\n            options = typeof _option == 'object' && _option;\r\n\r\n        if (!data) {\r\n          var dataAttributes = $this.data();\r\n\r\n          for (var dataAttr in dataAttributes) {\r\n            if (Object.prototype.hasOwnProperty.call(dataAttributes, dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {\r\n              delete dataAttributes[dataAttr];\r\n            }\r\n          }\r\n\r\n          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, dataAttributes, options);\r\n          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), dataAttributes.template, options.template);\r\n          $this.data('selectpicker', (data = new Selectpicker(this, config)));\r\n        } else if (options) {\r\n          for (var i in options) {\r\n            if (Object.prototype.hasOwnProperty.call(options, i)) {\r\n              data.options[i] = options[i];\r\n            }\r\n          }\r\n        }\r\n\r\n        if (typeof _option == 'string') {\r\n          if (data[_option] instanceof Function) {\r\n            value = data[_option].apply(data, args);\r\n          } else {\r\n            value = data.options[_option];\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (typeof value !== 'undefined') {\r\n      // noinspection JSUnusedAssignment\r\n      return value;\r\n    } else {\r\n      return chain;\r\n    }\r\n  }\r\n\r\n  var old = $.fn.selectpicker;\r\n  $.fn.selectpicker = Plugin;\r\n  $.fn.selectpicker.Constructor = Selectpicker;\r\n\r\n  // SELECTPICKER NO CONFLICT\r\n  // ========================\r\n  $.fn.selectpicker.noConflict = function () {\r\n    $.fn.selectpicker = old;\r\n    return this;\r\n  };\r\n\r\n  // get Bootstrap's keydown event handler for either Bootstrap 4 or Bootstrap 3\r\n  function keydownHandler () {\r\n    if ($.fn.dropdown) {\r\n      // wait to define until function is called in case Bootstrap isn't loaded yet\r\n      var bootstrapKeydown = $.fn.dropdown.Constructor._dataApiKeydownHandler || $.fn.dropdown.Constructor.prototype.keydown;\r\n      return bootstrapKeydown.apply(this, arguments);\r\n    }\r\n  }\r\n\r\n  $(document)\r\n    .off('keydown.bs.dropdown.data-api')\r\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > [data-toggle=\"dropdown\"]', keydownHandler)\r\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > .dropdown-menu', keydownHandler)\r\n    .on('keydown' + EVENT_KEY, '.bootstrap-select [data-toggle=\"dropdown\"], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', Selectpicker.prototype.keydown)\r\n    .on('focusin.modal', '.bootstrap-select [data-toggle=\"dropdown\"], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', function (e) {\r\n      e.stopPropagation();\r\n    });\r\n\r\n  // SELECTPICKER DATA-API\r\n  // =====================\r\n  $(window).on('load' + EVENT_KEY + '.data-api', function () {\r\n    $('.selectpicker').each(function () {\r\n      var $selectpicker = $(this);\r\n      Plugin.call($selectpicker, $selectpicker.data());\r\n    })\r\n  });\r\n})(jQuery);\r\n\r\n\r\n}));\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \**********************************************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n  * Bootstrap v5.2.0 (https://getbootstrap.com/)\n  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core')) :\n  typeof define === 'function' && define.amd ? define(['@popperjs/core'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bootstrap = factory(global.Popper));\n})(this, (function (Popper) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });\n    if (e) {\n      for (const k in e) {\n        if (k !== 'default') {\n          const d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: () => e[k]\n          });\n        }\n      }\n    }\n    n.default = e;\n    return Object.freeze(n);\n  }\n\n  const Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  const MAX_UID = 1000000;\n  const MILLISECONDS_MULTIPLIER = 1000;\n  const TRANSITION_END = 'transitionend'; // Shout-out Angus Croll (https://goo.gl/pxwQGp)\n\n  const toType = object => {\n    if (object === null || object === undefined) {\n      return `${object}`;\n    }\n\n    return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  };\n  /**\n   * Public Util API\n   */\n\n\n  const getUID = prefix => {\n    do {\n      prefix += Math.floor(Math.random() * MAX_UID);\n    } while (document.getElementById(prefix));\n\n    return prefix;\n  };\n\n  const getSelector = element => {\n    let selector = element.getAttribute('data-bs-target');\n\n    if (!selector || selector === '#') {\n      let hrefAttribute = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n\n      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\n        return null;\n      } // Just in case some CMS puts out a full URL with the anchor appended\n\n\n      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n        hrefAttribute = `#${hrefAttribute.split('#')[1]}`;\n      }\n\n      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\n    }\n\n    return selector;\n  };\n\n  const getSelectorFromElement = element => {\n    const selector = getSelector(element);\n\n    if (selector) {\n      return document.querySelector(selector) ? selector : null;\n    }\n\n    return null;\n  };\n\n  const getElementFromSelector = element => {\n    const selector = getSelector(element);\n    return selector ? document.querySelector(selector) : null;\n  };\n\n  const getTransitionDurationFromElement = element => {\n    if (!element) {\n      return 0;\n    } // Get transition-duration of the element\n\n\n    let {\n      transitionDuration,\n      transitionDelay\n    } = window.getComputedStyle(element);\n    const floatTransitionDuration = Number.parseFloat(transitionDuration);\n    const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n    if (!floatTransitionDuration && !floatTransitionDelay) {\n      return 0;\n    } // If multiple durations are defined, take the first\n\n\n    transitionDuration = transitionDuration.split(',')[0];\n    transitionDelay = transitionDelay.split(',')[0];\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n  };\n\n  const triggerTransitionEnd = element => {\n    element.dispatchEvent(new Event(TRANSITION_END));\n  };\n\n  const isElement = object => {\n    if (!object || typeof object !== 'object') {\n      return false;\n    }\n\n    if (typeof object.jquery !== 'undefined') {\n      object = object[0];\n    }\n\n    return typeof object.nodeType !== 'undefined';\n  };\n\n  const getElement = object => {\n    // it's a jQuery object or a node element\n    if (isElement(object)) {\n      return object.jquery ? object[0] : object;\n    }\n\n    if (typeof object === 'string' && object.length > 0) {\n      return document.querySelector(object);\n    }\n\n    return null;\n  };\n\n  const isVisible = element => {\n    if (!isElement(element) || element.getClientRects().length === 0) {\n      return false;\n    }\n\n    const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible'; // Handle `details` element as its content may falsie appear visible when it is closed\n\n    const closedDetails = element.closest('details:not([open])');\n\n    if (!closedDetails) {\n      return elementIsVisible;\n    }\n\n    if (closedDetails !== element) {\n      const summary = element.closest('summary');\n\n      if (summary && summary.parentNode !== closedDetails) {\n        return false;\n      }\n\n      if (summary === null) {\n        return false;\n      }\n    }\n\n    return elementIsVisible;\n  };\n\n  const isDisabled = element => {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n\n    if (element.classList.contains('disabled')) {\n      return true;\n    }\n\n    if (typeof element.disabled !== 'undefined') {\n      return element.disabled;\n    }\n\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n  };\n\n  const findShadowRoot = element => {\n    if (!document.documentElement.attachShadow) {\n      return null;\n    } // Can find the shadow root otherwise it'll return the document\n\n\n    if (typeof element.getRootNode === 'function') {\n      const root = element.getRootNode();\n      return root instanceof ShadowRoot ? root : null;\n    }\n\n    if (element instanceof ShadowRoot) {\n      return element;\n    } // when we don't find a shadow root\n\n\n    if (!element.parentNode) {\n      return null;\n    }\n\n    return findShadowRoot(element.parentNode);\n  };\n\n  const noop = () => {};\n  /**\n   * Trick to restart an element's animation\n   *\n   * @param {HTMLElement} element\n   * @return void\n   *\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n   */\n\n\n  const reflow = element => {\n    element.offsetHeight; // eslint-disable-line no-unused-expressions\n  };\n\n  const getjQuery = () => {\n    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n      return window.jQuery;\n    }\n\n    return null;\n  };\n\n  const DOMContentLoadedCallbacks = [];\n\n  const onDOMContentLoaded = callback => {\n    if (document.readyState === 'loading') {\n      // add listener on the first call when the document is in loading state\n      if (!DOMContentLoadedCallbacks.length) {\n        document.addEventListener('DOMContentLoaded', () => {\n          for (const callback of DOMContentLoadedCallbacks) {\n            callback();\n          }\n        });\n      }\n\n      DOMContentLoadedCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n\n  const isRTL = () => document.documentElement.dir === 'rtl';\n\n  const defineJQueryPlugin = plugin => {\n    onDOMContentLoaded(() => {\n      const $ = getjQuery();\n      /* istanbul ignore if */\n\n      if ($) {\n        const name = plugin.NAME;\n        const JQUERY_NO_CONFLICT = $.fn[name];\n        $.fn[name] = plugin.jQueryInterface;\n        $.fn[name].Constructor = plugin;\n\n        $.fn[name].noConflict = () => {\n          $.fn[name] = JQUERY_NO_CONFLICT;\n          return plugin.jQueryInterface;\n        };\n      }\n    });\n  };\n\n  const execute = callback => {\n    if (typeof callback === 'function') {\n      callback();\n    }\n  };\n\n  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {\n    if (!waitForTransition) {\n      execute(callback);\n      return;\n    }\n\n    const durationPadding = 5;\n    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n    let called = false;\n\n    const handler = ({\n      target\n    }) => {\n      if (target !== transitionElement) {\n        return;\n      }\n\n      called = true;\n      transitionElement.removeEventListener(TRANSITION_END, handler);\n      execute(callback);\n    };\n\n    transitionElement.addEventListener(TRANSITION_END, handler);\n    setTimeout(() => {\n      if (!called) {\n        triggerTransitionEnd(transitionElement);\n      }\n    }, emulatedDuration);\n  };\n  /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */\n\n\n  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {\n    const listLength = list.length;\n    let index = list.indexOf(activeElement); // if the element does not exist in the list return an element\n    // depending on the direction and if cycle is allowed\n\n    if (index === -1) {\n      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n    }\n\n    index += shouldGetNext ? 1 : -1;\n\n    if (isCycleAllowed) {\n      index = (index + listLength) % listLength;\n    }\n\n    return list[Math.max(0, Math.min(index, listLength - 1))];\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/event-handler.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n  const stripNameRegex = /\\..*/;\n  const stripUidRegex = /::\\d+$/;\n  const eventRegistry = {}; // Events storage\n\n  let uidEvent = 1;\n  const customEvents = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout'\n  };\n  const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n  /**\n   * Private methods\n   */\n\n  function makeEventUid(element, uid) {\n    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n  }\n\n  function getElementEvents(element) {\n    const uid = makeEventUid(element);\n    element.uidEvent = uid;\n    eventRegistry[uid] = eventRegistry[uid] || {};\n    return eventRegistry[uid];\n  }\n\n  function bootstrapHandler(element, fn) {\n    return function handler(event) {\n      hydrateObj(event, {\n        delegateTarget: element\n      });\n\n      if (handler.oneOff) {\n        EventHandler.off(element, event.type, fn);\n      }\n\n      return fn.apply(element, [event]);\n    };\n  }\n\n  function bootstrapDelegationHandler(element, selector, fn) {\n    return function handler(event) {\n      const domElements = element.querySelectorAll(selector);\n\n      for (let {\n        target\n      } = event; target && target !== this; target = target.parentNode) {\n        for (const domElement of domElements) {\n          if (domElement !== target) {\n            continue;\n          }\n\n          hydrateObj(event, {\n            delegateTarget: target\n          });\n\n          if (handler.oneOff) {\n            EventHandler.off(element, event.type, selector, fn);\n          }\n\n          return fn.apply(target, [event]);\n        }\n      }\n    };\n  }\n\n  function findHandler(events, callable, delegationSelector = null) {\n    return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);\n  }\n\n  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n    const isDelegated = typeof handler === 'string'; // todo: tooltip passes `false` instead of selector, so we need to check\n\n    const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n    let typeEvent = getTypeEvent(originalTypeEvent);\n\n    if (!nativeEvents.has(typeEvent)) {\n      typeEvent = originalTypeEvent;\n    }\n\n    return [isDelegated, callable, typeEvent];\n  }\n\n  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n\n    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction); // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n\n    if (originalTypeEvent in customEvents) {\n      const wrapFunction = fn => {\n        return function (event) {\n          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n            return fn.call(this, event);\n          }\n        };\n      };\n\n      callable = wrapFunction(callable);\n    }\n\n    const events = getElementEvents(element);\n    const handlers = events[typeEvent] || (events[typeEvent] = {});\n    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n\n    if (previousFunction) {\n      previousFunction.oneOff = previousFunction.oneOff && oneOff;\n      return;\n    }\n\n    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\n    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n    fn.delegationSelector = isDelegated ? handler : null;\n    fn.callable = callable;\n    fn.oneOff = oneOff;\n    fn.uidEvent = uid;\n    handlers[uid] = fn;\n    element.addEventListener(typeEvent, fn, isDelegated);\n  }\n\n  function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n    const fn = findHandler(events[typeEvent], handler, delegationSelector);\n\n    if (!fn) {\n      return;\n    }\n\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n    delete events[typeEvent][fn.uidEvent];\n  }\n\n  function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n    const storeElementEvent = events[typeEvent] || {};\n\n    for (const handlerKey of Object.keys(storeElementEvent)) {\n      if (handlerKey.includes(namespace)) {\n        const event = storeElementEvent[handlerKey];\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n      }\n    }\n  }\n\n  function getTypeEvent(event) {\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n    event = event.replace(stripNameRegex, '');\n    return customEvents[event] || event;\n  }\n\n  const EventHandler = {\n    on(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, false);\n    },\n\n    one(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, true);\n    },\n\n    off(element, originalTypeEvent, handler, delegationFunction) {\n      if (typeof originalTypeEvent !== 'string' || !element) {\n        return;\n      }\n\n      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n      const inNamespace = typeEvent !== originalTypeEvent;\n      const events = getElementEvents(element);\n      const storeElementEvent = events[typeEvent] || {};\n      const isNamespace = originalTypeEvent.startsWith('.');\n\n      if (typeof callable !== 'undefined') {\n        // Simplest case: handler is passed, remove that listener ONLY.\n        if (!Object.keys(storeElementEvent).length) {\n          return;\n        }\n\n        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n        return;\n      }\n\n      if (isNamespace) {\n        for (const elementEvent of Object.keys(events)) {\n          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n        }\n      }\n\n      for (const keyHandlers of Object.keys(storeElementEvent)) {\n        const handlerKey = keyHandlers.replace(stripUidRegex, '');\n\n        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n          const event = storeElementEvent[keyHandlers];\n          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n        }\n      }\n    },\n\n    trigger(element, event, args) {\n      if (typeof event !== 'string' || !element) {\n        return null;\n      }\n\n      const $ = getjQuery();\n      const typeEvent = getTypeEvent(event);\n      const inNamespace = event !== typeEvent;\n      let jQueryEvent = null;\n      let bubbles = true;\n      let nativeDispatch = true;\n      let defaultPrevented = false;\n\n      if (inNamespace && $) {\n        jQueryEvent = $.Event(event, args);\n        $(element).trigger(jQueryEvent);\n        bubbles = !jQueryEvent.isPropagationStopped();\n        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n        defaultPrevented = jQueryEvent.isDefaultPrevented();\n      }\n\n      let evt = new Event(event, {\n        bubbles,\n        cancelable: true\n      });\n      evt = hydrateObj(evt, args);\n\n      if (defaultPrevented) {\n        evt.preventDefault();\n      }\n\n      if (nativeDispatch) {\n        element.dispatchEvent(evt);\n      }\n\n      if (evt.defaultPrevented && jQueryEvent) {\n        jQueryEvent.preventDefault();\n      }\n\n      return evt;\n    }\n\n  };\n\n  function hydrateObj(obj, meta) {\n    for (const [key, value] of Object.entries(meta || {})) {\n      try {\n        obj[key] = value;\n      } catch (_unused) {\n        Object.defineProperty(obj, key, {\n          configurable: true,\n\n          get() {\n            return value;\n          }\n\n        });\n      }\n    }\n\n    return obj;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/data.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * Constants\n   */\n  const elementMap = new Map();\n  const Data = {\n    set(element, key, instance) {\n      if (!elementMap.has(element)) {\n        elementMap.set(element, new Map());\n      }\n\n      const instanceMap = elementMap.get(element); // make it clear we only want one instance per element\n      // can be removed later when multiple key/instances are fine to be used\n\n      if (!instanceMap.has(key) && instanceMap.size !== 0) {\n        // eslint-disable-next-line no-console\n        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n        return;\n      }\n\n      instanceMap.set(key, instance);\n    },\n\n    get(element, key) {\n      if (elementMap.has(element)) {\n        return elementMap.get(element).get(key) || null;\n      }\n\n      return null;\n    },\n\n    remove(element, key) {\n      if (!elementMap.has(element)) {\n        return;\n      }\n\n      const instanceMap = elementMap.get(element);\n      instanceMap.delete(key); // free up element references if there are no instances left for an element\n\n      if (instanceMap.size === 0) {\n        elementMap.delete(element);\n      }\n    }\n\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/manipulator.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  function normalizeData(value) {\n    if (value === 'true') {\n      return true;\n    }\n\n    if (value === 'false') {\n      return false;\n    }\n\n    if (value === Number(value).toString()) {\n      return Number(value);\n    }\n\n    if (value === '' || value === 'null') {\n      return null;\n    }\n\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    try {\n      return JSON.parse(decodeURIComponent(value));\n    } catch (_unused) {\n      return value;\n    }\n  }\n\n  function normalizeDataKey(key) {\n    return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\n  }\n\n  const Manipulator = {\n    setDataAttribute(element, key, value) {\n      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n    },\n\n    removeDataAttribute(element, key) {\n      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n    },\n\n    getDataAttributes(element) {\n      if (!element) {\n        return {};\n      }\n\n      const attributes = {};\n      const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));\n\n      for (const key of bsKeys) {\n        let pureKey = key.replace(/^bs/, '');\n        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n        attributes[pureKey] = normalizeData(element.dataset[key]);\n      }\n\n      return attributes;\n    },\n\n    getDataAttribute(element, key) {\n      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n    }\n\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Class definition\n   */\n\n  class Config {\n    // Getters\n    static get Default() {\n      return {};\n    }\n\n    static get DefaultType() {\n      return {};\n    }\n\n    static get NAME() {\n      throw new Error('You have to implement the static method \"NAME\", for each component!');\n    }\n\n    _getConfig(config) {\n      config = this._mergeConfigObj(config);\n      config = this._configAfterMerge(config);\n\n      this._typeCheckConfig(config);\n\n      return config;\n    }\n\n    _configAfterMerge(config) {\n      return config;\n    }\n\n    _mergeConfigObj(config, element) {\n      const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n      return { ...this.constructor.Default,\n        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n        ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n        ...(typeof config === 'object' ? config : {})\n      };\n    }\n\n    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n      for (const property of Object.keys(configTypes)) {\n        const expectedTypes = configTypes[property];\n        const value = config[property];\n        const valueType = isElement(value) ? 'element' : toType(value);\n\n        if (!new RegExp(expectedTypes).test(valueType)) {\n          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n        }\n      }\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): base-component.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const VERSION = '5.2.0';\n  /**\n   * Class definition\n   */\n\n  class BaseComponent extends Config {\n    constructor(element, config) {\n      super();\n      element = getElement(element);\n\n      if (!element) {\n        return;\n      }\n\n      this._element = element;\n      this._config = this._getConfig(config);\n      Data.set(this._element, this.constructor.DATA_KEY, this);\n    } // Public\n\n\n    dispose() {\n      Data.remove(this._element, this.constructor.DATA_KEY);\n      EventHandler.off(this._element, this.constructor.EVENT_KEY);\n\n      for (const propertyName of Object.getOwnPropertyNames(this)) {\n        this[propertyName] = null;\n      }\n    }\n\n    _queueCallback(callback, element, isAnimated = true) {\n      executeAfterTransition(callback, element, isAnimated);\n    }\n\n    _getConfig(config) {\n      config = this._mergeConfigObj(config, this._element);\n      config = this._configAfterMerge(config);\n\n      this._typeCheckConfig(config);\n\n      return config;\n    } // Static\n\n\n    static getInstance(element) {\n      return Data.get(getElement(element), this.DATA_KEY);\n    }\n\n    static getOrCreateInstance(element, config = {}) {\n      return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);\n    }\n\n    static get VERSION() {\n      return VERSION;\n    }\n\n    static get DATA_KEY() {\n      return `bs.${this.NAME}`;\n    }\n\n    static get EVENT_KEY() {\n      return `.${this.DATA_KEY}`;\n    }\n\n    static eventName(name) {\n      return `${name}${this.EVENT_KEY}`;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/component-functions.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  const enableDismissTrigger = (component, method = 'hide') => {\n    const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n    const name = component.NAME;\n    EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function (event) {\n      if (['A', 'AREA'].includes(this.tagName)) {\n        event.preventDefault();\n      }\n\n      if (isDisabled(this)) {\n        return;\n      }\n\n      const target = getElementFromSelector(this) || this.closest(`.${name}`);\n      const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n\n      instance[method]();\n    });\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): alert.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$f = 'alert';\n  const DATA_KEY$a = 'bs.alert';\n  const EVENT_KEY$b = `.${DATA_KEY$a}`;\n  const EVENT_CLOSE = `close${EVENT_KEY$b}`;\n  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;\n  const CLASS_NAME_FADE$5 = 'fade';\n  const CLASS_NAME_SHOW$8 = 'show';\n  /**\n   * Class definition\n   */\n\n  class Alert extends BaseComponent {\n    // Getters\n    static get NAME() {\n      return NAME$f;\n    } // Public\n\n\n    close() {\n      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n\n      if (closeEvent.defaultPrevented) {\n        return;\n      }\n\n      this._element.classList.remove(CLASS_NAME_SHOW$8);\n\n      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n\n      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);\n    } // Private\n\n\n    _destroyElement() {\n      this._element.remove();\n\n      EventHandler.trigger(this._element, EVENT_CLOSED);\n      this.dispose();\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Alert.getOrCreateInstance(this);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](this);\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  enableDismissTrigger(Alert, 'close');\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Alert);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): button.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$e = 'button';\n  const DATA_KEY$9 = 'bs.button';\n  const EVENT_KEY$a = `.${DATA_KEY$9}`;\n  const DATA_API_KEY$6 = '.data-api';\n  const CLASS_NAME_ACTIVE$3 = 'active';\n  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\n  /**\n   * Class definition\n   */\n\n  class Button extends BaseComponent {\n    // Getters\n    static get NAME() {\n      return NAME$e;\n    } // Public\n\n\n    toggle() {\n      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Button.getOrCreateInstance(this);\n\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\n    event.preventDefault();\n    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n    const data = Button.getOrCreateInstance(button);\n    data.toggle();\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Button);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/selector-engine.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const SelectorEngine = {\n    find(selector, element = document.documentElement) {\n      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n    },\n\n    findOne(selector, element = document.documentElement) {\n      return Element.prototype.querySelector.call(element, selector);\n    },\n\n    children(element, selector) {\n      return [].concat(...element.children).filter(child => child.matches(selector));\n    },\n\n    parents(element, selector) {\n      const parents = [];\n      let ancestor = element.parentNode.closest(selector);\n\n      while (ancestor) {\n        parents.push(ancestor);\n        ancestor = ancestor.parentNode.closest(selector);\n      }\n\n      return parents;\n    },\n\n    prev(element, selector) {\n      let previous = element.previousElementSibling;\n\n      while (previous) {\n        if (previous.matches(selector)) {\n          return [previous];\n        }\n\n        previous = previous.previousElementSibling;\n      }\n\n      return [];\n    },\n\n    // TODO: this is now unused; remove later along with prev()\n    next(element, selector) {\n      let next = element.nextElementSibling;\n\n      while (next) {\n        if (next.matches(selector)) {\n          return [next];\n        }\n\n        next = next.nextElementSibling;\n      }\n\n      return [];\n    },\n\n    focusableChildren(element) {\n      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',');\n      return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));\n    }\n\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/swipe.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$d = 'swipe';\n  const EVENT_KEY$9 = '.bs.swipe';\n  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\n  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\n  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\n  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\n  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\n  const POINTER_TYPE_TOUCH = 'touch';\n  const POINTER_TYPE_PEN = 'pen';\n  const CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  const SWIPE_THRESHOLD = 40;\n  const Default$c = {\n    endCallback: null,\n    leftCallback: null,\n    rightCallback: null\n  };\n  const DefaultType$c = {\n    endCallback: '(function|null)',\n    leftCallback: '(function|null)',\n    rightCallback: '(function|null)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Swipe extends Config {\n    constructor(element, config) {\n      super();\n      this._element = element;\n\n      if (!element || !Swipe.isSupported()) {\n        return;\n      }\n\n      this._config = this._getConfig(config);\n      this._deltaX = 0;\n      this._supportPointerEvents = Boolean(window.PointerEvent);\n\n      this._initEvents();\n    } // Getters\n\n\n    static get Default() {\n      return Default$c;\n    }\n\n    static get DefaultType() {\n      return DefaultType$c;\n    }\n\n    static get NAME() {\n      return NAME$d;\n    } // Public\n\n\n    dispose() {\n      EventHandler.off(this._element, EVENT_KEY$9);\n    } // Private\n\n\n    _start(event) {\n      if (!this._supportPointerEvents) {\n        this._deltaX = event.touches[0].clientX;\n        return;\n      }\n\n      if (this._eventIsPointerPenTouch(event)) {\n        this._deltaX = event.clientX;\n      }\n    }\n\n    _end(event) {\n      if (this._eventIsPointerPenTouch(event)) {\n        this._deltaX = event.clientX - this._deltaX;\n      }\n\n      this._handleSwipe();\n\n      execute(this._config.endCallback);\n    }\n\n    _move(event) {\n      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n    }\n\n    _handleSwipe() {\n      const absDeltaX = Math.abs(this._deltaX);\n\n      if (absDeltaX <= SWIPE_THRESHOLD) {\n        return;\n      }\n\n      const direction = absDeltaX / this._deltaX;\n      this._deltaX = 0;\n\n      if (!direction) {\n        return;\n      }\n\n      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n    }\n\n    _initEvents() {\n      if (this._supportPointerEvents) {\n        EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));\n        EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));\n\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n      } else {\n        EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));\n        EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));\n        EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));\n      }\n    }\n\n    _eventIsPointerPenTouch(event) {\n      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n    } // Static\n\n\n    static isSupported() {\n      return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): carousel.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$c = 'carousel';\n  const DATA_KEY$8 = 'bs.carousel';\n  const EVENT_KEY$8 = `.${DATA_KEY$8}`;\n  const DATA_API_KEY$5 = '.data-api';\n  const ARROW_LEFT_KEY$1 = 'ArrowLeft';\n  const ARROW_RIGHT_KEY$1 = 'ArrowRight';\n  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  const ORDER_NEXT = 'next';\n  const ORDER_PREV = 'prev';\n  const DIRECTION_LEFT = 'left';\n  const DIRECTION_RIGHT = 'right';\n  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;\n  const EVENT_SLID = `slid${EVENT_KEY$8}`;\n  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\n  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\n  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\n  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\n  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\n  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\n  const CLASS_NAME_CAROUSEL = 'carousel';\n  const CLASS_NAME_ACTIVE$2 = 'active';\n  const CLASS_NAME_SLIDE = 'slide';\n  const CLASS_NAME_END = 'carousel-item-end';\n  const CLASS_NAME_START = 'carousel-item-start';\n  const CLASS_NAME_NEXT = 'carousel-item-next';\n  const CLASS_NAME_PREV = 'carousel-item-prev';\n  const SELECTOR_ACTIVE = '.active';\n  const SELECTOR_ITEM = '.carousel-item';\n  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\n  const SELECTOR_ITEM_IMG = '.carousel-item img';\n  const SELECTOR_INDICATORS = '.carousel-indicators';\n  const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\n  const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n  const KEY_TO_DIRECTION = {\n    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n  };\n  const Default$b = {\n    interval: 5000,\n    keyboard: true,\n    pause: 'hover',\n    ride: false,\n    touch: true,\n    wrap: true\n  };\n  const DefaultType$b = {\n    interval: '(number|boolean)',\n    // TODO:v6 remove boolean support\n    keyboard: 'boolean',\n    pause: '(string|boolean)',\n    ride: '(boolean|string)',\n    touch: 'boolean',\n    wrap: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Carousel extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._interval = null;\n      this._activeElement = null;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this._swipeHelper = null;\n      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n\n      this._addEventListeners();\n\n      if (this._config.ride === CLASS_NAME_CAROUSEL) {\n        this.cycle();\n      }\n    } // Getters\n\n\n    static get Default() {\n      return Default$b;\n    }\n\n    static get DefaultType() {\n      return DefaultType$b;\n    }\n\n    static get NAME() {\n      return NAME$c;\n    } // Public\n\n\n    next() {\n      this._slide(ORDER_NEXT);\n    }\n\n    nextWhenVisible() {\n      // FIXME TODO use `document.visibilityState`\n      // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n      if (!document.hidden && isVisible(this._element)) {\n        this.next();\n      }\n    }\n\n    prev() {\n      this._slide(ORDER_PREV);\n    }\n\n    pause() {\n      if (this._isSliding) {\n        triggerTransitionEnd(this._element);\n      }\n\n      this._clearInterval();\n    }\n\n    cycle() {\n      this._clearInterval();\n\n      this._updateInterval();\n\n      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);\n    }\n\n    _maybeEnableCycle() {\n      if (!this._config.ride) {\n        return;\n      }\n\n      if (this._isSliding) {\n        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());\n        return;\n      }\n\n      this.cycle();\n    }\n\n    to(index) {\n      const items = this._getItems();\n\n      if (index > items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n        return;\n      }\n\n      const activeIndex = this._getItemIndex(this._getActive());\n\n      if (activeIndex === index) {\n        return;\n      }\n\n      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n\n      this._slide(order, items[index]);\n    }\n\n    dispose() {\n      if (this._swipeHelper) {\n        this._swipeHelper.dispose();\n      }\n\n      super.dispose();\n    } // Private\n\n\n    _configAfterMerge(config) {\n      config.defaultInterval = config.interval;\n      return config;\n    }\n\n    _addEventListeners() {\n      if (this._config.keyboard) {\n        EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));\n      }\n\n      if (this._config.pause === 'hover') {\n        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());\n        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());\n      }\n\n      if (this._config.touch && Swipe.isSupported()) {\n        this._addTouchEventListeners();\n      }\n    }\n\n    _addTouchEventListeners() {\n      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {\n        EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());\n      }\n\n      const endCallBack = () => {\n        if (this._config.pause !== 'hover') {\n          return;\n        } // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n\n\n        this.pause();\n\n        if (this.touchTimeout) {\n          clearTimeout(this.touchTimeout);\n        }\n\n        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n      };\n\n      const swipeConfig = {\n        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),\n        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n        endCallback: endCallBack\n      };\n      this._swipeHelper = new Swipe(this._element, swipeConfig);\n    }\n\n    _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      const direction = KEY_TO_DIRECTION[event.key];\n\n      if (direction) {\n        event.preventDefault();\n\n        this._slide(this._directionToOrder(direction));\n      }\n    }\n\n    _getItemIndex(element) {\n      return this._getItems().indexOf(element);\n    }\n\n    _setActiveIndicatorElement(index) {\n      if (!this._indicatorsElement) {\n        return;\n      }\n\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n      activeIndicator.removeAttribute('aria-current');\n      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\n\n      if (newActiveIndicator) {\n        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n        newActiveIndicator.setAttribute('aria-current', 'true');\n      }\n    }\n\n    _updateInterval() {\n      const element = this._activeElement || this._getActive();\n\n      if (!element) {\n        return;\n      }\n\n      const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n      this._config.interval = elementInterval || this._config.defaultInterval;\n    }\n\n    _slide(order, element = null) {\n      if (this._isSliding) {\n        return;\n      }\n\n      const activeElement = this._getActive();\n\n      const isNext = order === ORDER_NEXT;\n      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n\n      if (nextElement === activeElement) {\n        return;\n      }\n\n      const nextElementIndex = this._getItemIndex(nextElement);\n\n      const triggerEvent = eventName => {\n        return EventHandler.trigger(this._element, eventName, {\n          relatedTarget: nextElement,\n          direction: this._orderToDirection(order),\n          from: this._getItemIndex(activeElement),\n          to: nextElementIndex\n        });\n      };\n\n      const slideEvent = triggerEvent(EVENT_SLIDE);\n\n      if (slideEvent.defaultPrevented) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        // todo: change tests that use empty divs to avoid this check\n        return;\n      }\n\n      const isCycling = Boolean(this._interval);\n      this.pause();\n      this._isSliding = true;\n\n      this._setActiveIndicatorElement(nextElementIndex);\n\n      this._activeElement = nextElement;\n      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n      nextElement.classList.add(orderClassName);\n      reflow(nextElement);\n      activeElement.classList.add(directionalClassName);\n      nextElement.classList.add(directionalClassName);\n\n      const completeCallBack = () => {\n        nextElement.classList.remove(directionalClassName, orderClassName);\n        nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n        this._isSliding = false;\n        triggerEvent(EVENT_SLID);\n      };\n\n      this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n\n      if (isCycling) {\n        this.cycle();\n      }\n    }\n\n    _isAnimated() {\n      return this._element.classList.contains(CLASS_NAME_SLIDE);\n    }\n\n    _getActive() {\n      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n    }\n\n    _getItems() {\n      return SelectorEngine.find(SELECTOR_ITEM, this._element);\n    }\n\n    _clearInterval() {\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n    }\n\n    _directionToOrder(direction) {\n      if (isRTL()) {\n        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n      }\n\n      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n    }\n\n    _orderToDirection(order) {\n      if (isRTL()) {\n        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n      }\n\n      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Carousel.getOrCreateInstance(this, config);\n\n        if (typeof config === 'number') {\n          data.to(config);\n          return;\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(`No method named \"${config}\"`);\n          }\n\n          data[config]();\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\n    const target = getElementFromSelector(this);\n\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return;\n    }\n\n    event.preventDefault();\n    const carousel = Carousel.getOrCreateInstance(target);\n    const slideIndex = this.getAttribute('data-bs-slide-to');\n\n    if (slideIndex) {\n      carousel.to(slideIndex);\n\n      carousel._maybeEnableCycle();\n\n      return;\n    }\n\n    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\n      carousel.next();\n\n      carousel._maybeEnableCycle();\n\n      return;\n    }\n\n    carousel.prev();\n\n    carousel._maybeEnableCycle();\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {\n    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n\n    for (const carousel of carousels) {\n      Carousel.getOrCreateInstance(carousel);\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Carousel);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): collapse.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$b = 'collapse';\n  const DATA_KEY$7 = 'bs.collapse';\n  const EVENT_KEY$7 = `.${DATA_KEY$7}`;\n  const DATA_API_KEY$4 = '.data-api';\n  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\n  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\n  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\n  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\n  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\n  const CLASS_NAME_SHOW$7 = 'show';\n  const CLASS_NAME_COLLAPSE = 'collapse';\n  const CLASS_NAME_COLLAPSING = 'collapsing';\n  const CLASS_NAME_COLLAPSED = 'collapsed';\n  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\n  const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\n  const WIDTH = 'width';\n  const HEIGHT = 'height';\n  const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\n  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n  const Default$a = {\n    parent: null,\n    toggle: true\n  };\n  const DefaultType$a = {\n    parent: '(null|element)',\n    toggle: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Collapse extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._isTransitioning = false;\n      this._triggerArray = [];\n      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n\n      for (const elem of toggleList) {\n        const selector = getSelectorFromElement(elem);\n        const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);\n\n        if (selector !== null && filterElement.length) {\n          this._triggerArray.push(elem);\n        }\n      }\n\n      this._initializeChildren();\n\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n      }\n\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n\n    static get Default() {\n      return Default$a;\n    }\n\n    static get DefaultType() {\n      return DefaultType$a;\n    }\n\n    static get NAME() {\n      return NAME$b;\n    } // Public\n\n\n    toggle() {\n      if (this._isShown()) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    show() {\n      if (this._isTransitioning || this._isShown()) {\n        return;\n      }\n\n      let activeChildren = []; // find active children\n\n      if (this._config.parent) {\n        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {\n          toggle: false\n        }));\n      }\n\n      if (activeChildren.length && activeChildren[0]._isTransitioning) {\n        return;\n      }\n\n      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n\n      if (startEvent.defaultPrevented) {\n        return;\n      }\n\n      for (const activeInstance of activeChildren) {\n        activeInstance.hide();\n      }\n\n      const dimension = this._getDimension();\n\n      this._element.classList.remove(CLASS_NAME_COLLAPSE);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n      this._element.style[dimension] = 0;\n\n      this._addAriaAndCollapsedClass(this._triggerArray, true);\n\n      this._isTransitioning = true;\n\n      const complete = () => {\n        this._isTransitioning = false;\n\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n\n        this._element.style[dimension] = '';\n        EventHandler.trigger(this._element, EVENT_SHOWN$6);\n      };\n\n      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      const scrollSize = `scroll${capitalizedDimension}`;\n\n      this._queueCallback(complete, this._element, true);\n\n      this._element.style[dimension] = `${this._element[scrollSize]}px`;\n    }\n\n    hide() {\n      if (this._isTransitioning || !this._isShown()) {\n        return;\n      }\n\n      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n\n      if (startEvent.defaultPrevented) {\n        return;\n      }\n\n      const dimension = this._getDimension();\n\n      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n      reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n\n      for (const trigger of this._triggerArray) {\n        const element = getElementFromSelector(trigger);\n\n        if (element && !this._isShown(element)) {\n          this._addAriaAndCollapsedClass([trigger], false);\n        }\n      }\n\n      this._isTransitioning = true;\n\n      const complete = () => {\n        this._isTransitioning = false;\n\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n        this._element.classList.add(CLASS_NAME_COLLAPSE);\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n      };\n\n      this._element.style[dimension] = '';\n\n      this._queueCallback(complete, this._element, true);\n    }\n\n    _isShown(element = this._element) {\n      return element.classList.contains(CLASS_NAME_SHOW$7);\n    } // Private\n\n\n    _configAfterMerge(config) {\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      config.parent = getElement(config.parent);\n      return config;\n    }\n\n    _getDimension() {\n      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n    }\n\n    _initializeChildren() {\n      if (!this._config.parent) {\n        return;\n      }\n\n      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n\n      for (const element of children) {\n        const selected = getElementFromSelector(element);\n\n        if (selected) {\n          this._addAriaAndCollapsedClass([element], this._isShown(selected));\n        }\n      }\n    }\n\n    _getFirstLevelChildren(selector) {\n      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent); // remove children if greater depth\n\n      return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));\n    }\n\n    _addAriaAndCollapsedClass(triggerArray, isOpen) {\n      if (!triggerArray.length) {\n        return;\n      }\n\n      for (const element of triggerArray) {\n        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n        element.setAttribute('aria-expanded', isOpen);\n      }\n    } // Static\n\n\n    static jQueryInterface(config) {\n      const _config = {};\n\n      if (typeof config === 'string' && /show|hide/.test(config)) {\n        _config.toggle = false;\n      }\n\n      return this.each(function () {\n        const data = Collapse.getOrCreateInstance(this, _config);\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(`No method named \"${config}\"`);\n          }\n\n          data[config]();\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n\n    const selector = getSelectorFromElement(this);\n    const selectorElements = SelectorEngine.find(selector);\n\n    for (const element of selectorElements) {\n      Collapse.getOrCreateInstance(element, {\n        toggle: false\n      }).toggle();\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Collapse);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$a = 'dropdown';\n  const DATA_KEY$6 = 'bs.dropdown';\n  const EVENT_KEY$6 = `.${DATA_KEY$6}`;\n  const DATA_API_KEY$3 = '.data-api';\n  const ESCAPE_KEY$2 = 'Escape';\n  const TAB_KEY$1 = 'Tab';\n  const ARROW_UP_KEY$1 = 'ArrowUp';\n  const ARROW_DOWN_KEY$1 = 'ArrowDown';\n  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\n  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\n  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\n  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\n  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\n  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\n  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\n  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\n  const CLASS_NAME_SHOW$6 = 'show';\n  const CLASS_NAME_DROPUP = 'dropup';\n  const CLASS_NAME_DROPEND = 'dropend';\n  const CLASS_NAME_DROPSTART = 'dropstart';\n  const CLASS_NAME_DROPUP_CENTER = 'dropup-center';\n  const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\n  const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\n  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\n  const SELECTOR_MENU = '.dropdown-menu';\n  const SELECTOR_NAVBAR = '.navbar';\n  const SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\n  const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\n  const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\n  const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\n  const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\n  const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\n  const PLACEMENT_TOPCENTER = 'top';\n  const PLACEMENT_BOTTOMCENTER = 'bottom';\n  const Default$9 = {\n    autoClose: true,\n    boundary: 'clippingParents',\n    display: 'dynamic',\n    offset: [0, 2],\n    popperConfig: null,\n    reference: 'toggle'\n  };\n  const DefaultType$9 = {\n    autoClose: '(boolean|string)',\n    boundary: '(string|element)',\n    display: 'string',\n    offset: '(array|string|function)',\n    popperConfig: '(null|object|function)',\n    reference: '(string|element|object)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Dropdown extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._popper = null;\n      this._parent = this._element.parentNode; // dropdown wrapper\n\n      this._menu = SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n      this._inNavbar = this._detectNavbar();\n    } // Getters\n\n\n    static get Default() {\n      return Default$9;\n    }\n\n    static get DefaultType() {\n      return DefaultType$9;\n    }\n\n    static get NAME() {\n      return NAME$a;\n    } // Public\n\n\n    toggle() {\n      return this._isShown() ? this.hide() : this.show();\n    }\n\n    show() {\n      if (isDisabled(this._element) || this._isShown()) {\n        return;\n      }\n\n      const relatedTarget = {\n        relatedTarget: this._element\n      };\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._createPopper(); // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n      if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.on(element, 'mouseover', noop);\n        }\n      }\n\n      this._element.focus();\n\n      this._element.setAttribute('aria-expanded', true);\n\n      this._menu.classList.add(CLASS_NAME_SHOW$6);\n\n      this._element.classList.add(CLASS_NAME_SHOW$6);\n\n      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n    }\n\n    hide() {\n      if (isDisabled(this._element) || !this._isShown()) {\n        return;\n      }\n\n      const relatedTarget = {\n        relatedTarget: this._element\n      };\n\n      this._completeHide(relatedTarget);\n    }\n\n    dispose() {\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      super.dispose();\n    }\n\n    update() {\n      this._inNavbar = this._detectNavbar();\n\n      if (this._popper) {\n        this._popper.update();\n      }\n    } // Private\n\n\n    _completeHide(relatedTarget) {\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      } // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n\n      if ('ontouchstart' in document.documentElement) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.off(element, 'mouseover', noop);\n        }\n      }\n\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      this._menu.classList.remove(CLASS_NAME_SHOW$6);\n\n      this._element.classList.remove(CLASS_NAME_SHOW$6);\n\n      this._element.setAttribute('aria-expanded', 'false');\n\n      Manipulator.removeDataAttribute(this._menu, 'popper');\n      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n    }\n\n    _getConfig(config) {\n      config = super._getConfig(config);\n\n      if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n        // Popper virtual elements require a getBoundingClientRect method\n        throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n      }\n\n      return config;\n    }\n\n    _createPopper() {\n      if (typeof Popper__namespace === 'undefined') {\n        throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n      }\n\n      let referenceElement = this._element;\n\n      if (this._config.reference === 'parent') {\n        referenceElement = this._parent;\n      } else if (isElement(this._config.reference)) {\n        referenceElement = getElement(this._config.reference);\n      } else if (typeof this._config.reference === 'object') {\n        referenceElement = this._config.reference;\n      }\n\n      const popperConfig = this._getPopperConfig();\n\n      this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);\n    }\n\n    _isShown() {\n      return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n    }\n\n    _getPlacement() {\n      const parentDropdown = this._parent;\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n        return PLACEMENT_RIGHT;\n      }\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n        return PLACEMENT_LEFT;\n      }\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n        return PLACEMENT_TOPCENTER;\n      }\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n        return PLACEMENT_BOTTOMCENTER;\n      } // We need to trim the value because custom properties can also include spaces\n\n\n      const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n      }\n\n      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n    }\n\n    _detectNavbar() {\n      return this._element.closest(SELECTOR_NAVBAR) !== null;\n    }\n\n    _getOffset() {\n      const {\n        offset\n      } = this._config;\n\n      if (typeof offset === 'string') {\n        return offset.split(',').map(value => Number.parseInt(value, 10));\n      }\n\n      if (typeof offset === 'function') {\n        return popperData => offset(popperData, this._element);\n      }\n\n      return offset;\n    }\n\n    _getPopperConfig() {\n      const defaultBsPopperConfig = {\n        placement: this._getPlacement(),\n        modifiers: [{\n          name: 'preventOverflow',\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: 'offset',\n          options: {\n            offset: this._getOffset()\n          }\n        }]\n      }; // Disable Popper if we have a static display or Dropdown is in Navbar\n\n      if (this._inNavbar || this._config.display === 'static') {\n        Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // todo:v6 remove\n\n        defaultBsPopperConfig.modifiers = [{\n          name: 'applyStyles',\n          enabled: false\n        }];\n      }\n\n      return { ...defaultBsPopperConfig,\n        ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n      };\n    }\n\n    _selectMenuItem({\n      key,\n      target\n    }) {\n      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));\n\n      if (!items.length) {\n        return;\n      } // if target isn't included in items (e.g. when expanding the dropdown)\n      // allow cycling to get the last item in case key equals ARROW_UP_KEY\n\n\n      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Dropdown.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n    static clearMenus(event) {\n      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\n        return;\n      }\n\n      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n\n      for (const toggle of openToggles) {\n        const context = Dropdown.getInstance(toggle);\n\n        if (!context || context._config.autoClose === false) {\n          continue;\n        }\n\n        const composedPath = event.composedPath();\n        const isMenuTarget = composedPath.includes(context._menu);\n\n        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n          continue;\n        } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n\n        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n          continue;\n        }\n\n        const relatedTarget = {\n          relatedTarget: context._element\n        };\n\n        if (event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n\n        context._completeHide(relatedTarget);\n      }\n    }\n\n    static dataApiKeydownHandler(event) {\n      // If not an UP | DOWN | ESCAPE key => not a dropdown command\n      // If input/textarea && if key is other than ESCAPE => not a dropdown command\n      const isInput = /input|textarea/i.test(event.target.tagName);\n      const isEscapeEvent = event.key === ESCAPE_KEY$2;\n      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\n\n      if (!isUpOrDownEvent && !isEscapeEvent) {\n        return;\n      }\n\n      if (isInput && !isEscapeEvent) {\n        return;\n      }\n\n      event.preventDefault();\n      const getToggleButton = SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n      const instance = Dropdown.getOrCreateInstance(getToggleButton);\n\n      if (isUpOrDownEvent) {\n        event.stopPropagation();\n        instance.show();\n\n        instance._selectMenuItem(event);\n\n        return;\n      }\n\n      if (instance._isShown()) {\n        // else is escape and we check if it is shown\n        event.stopPropagation();\n        instance.hide();\n        getToggleButton.focus();\n      }\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n    event.preventDefault();\n    Dropdown.getOrCreateInstance(this).toggle();\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Dropdown);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/scrollBar.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  const SELECTOR_STICKY_CONTENT = '.sticky-top';\n  const PROPERTY_PADDING = 'padding-right';\n  const PROPERTY_MARGIN = 'margin-right';\n  /**\n   * Class definition\n   */\n\n  class ScrollBarHelper {\n    constructor() {\n      this._element = document.body;\n    } // Public\n\n\n    getWidth() {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n      const documentWidth = document.documentElement.clientWidth;\n      return Math.abs(window.innerWidth - documentWidth);\n    }\n\n    hide() {\n      const width = this.getWidth();\n\n      this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width\n\n\n      this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n\n\n      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\n\n      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);\n    }\n\n    reset() {\n      this._resetElementAttributes(this._element, 'overflow');\n\n      this._resetElementAttributes(this._element, PROPERTY_PADDING);\n\n      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n\n      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n    }\n\n    isOverflowing() {\n      return this.getWidth() > 0;\n    } // Private\n\n\n    _disableOverFlow() {\n      this._saveInitialAttribute(this._element, 'overflow');\n\n      this._element.style.overflow = 'hidden';\n    }\n\n    _setElementAttributes(selector, styleProperty, callback) {\n      const scrollbarWidth = this.getWidth();\n\n      const manipulationCallBack = element => {\n        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n          return;\n        }\n\n        this._saveInitialAttribute(element, styleProperty);\n\n        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n      };\n\n      this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n\n    _saveInitialAttribute(element, styleProperty) {\n      const actualValue = element.style.getPropertyValue(styleProperty);\n\n      if (actualValue) {\n        Manipulator.setDataAttribute(element, styleProperty, actualValue);\n      }\n    }\n\n    _resetElementAttributes(selector, styleProperty) {\n      const manipulationCallBack = element => {\n        const value = Manipulator.getDataAttribute(element, styleProperty); // We only want to remove the property if the value is `null`; the value can also be zero\n\n        if (value === null) {\n          element.style.removeProperty(styleProperty);\n          return;\n        }\n\n        Manipulator.removeDataAttribute(element, styleProperty);\n        element.style.setProperty(styleProperty, value);\n      };\n\n      this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n\n    _applyManipulationCallback(selector, callBack) {\n      if (isElement(selector)) {\n        callBack(selector);\n        return;\n      }\n\n      for (const sel of SelectorEngine.find(selector, this._element)) {\n        callBack(sel);\n      }\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/backdrop.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$9 = 'backdrop';\n  const CLASS_NAME_FADE$4 = 'fade';\n  const CLASS_NAME_SHOW$5 = 'show';\n  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\n  const Default$8 = {\n    className: 'modal-backdrop',\n    clickCallback: null,\n    isAnimated: false,\n    isVisible: true,\n    // if false, we use the backdrop helper without adding any element to the dom\n    rootElement: 'body' // give the choice to place backdrop under different elements\n\n  };\n  const DefaultType$8 = {\n    className: 'string',\n    clickCallback: '(function|null)',\n    isAnimated: 'boolean',\n    isVisible: 'boolean',\n    rootElement: '(element|string)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Backdrop extends Config {\n    constructor(config) {\n      super();\n      this._config = this._getConfig(config);\n      this._isAppended = false;\n      this._element = null;\n    } // Getters\n\n\n    static get Default() {\n      return Default$8;\n    }\n\n    static get DefaultType() {\n      return DefaultType$8;\n    }\n\n    static get NAME() {\n      return NAME$9;\n    } // Public\n\n\n    show(callback) {\n      if (!this._config.isVisible) {\n        execute(callback);\n        return;\n      }\n\n      this._append();\n\n      const element = this._getElement();\n\n      if (this._config.isAnimated) {\n        reflow(element);\n      }\n\n      element.classList.add(CLASS_NAME_SHOW$5);\n\n      this._emulateAnimation(() => {\n        execute(callback);\n      });\n    }\n\n    hide(callback) {\n      if (!this._config.isVisible) {\n        execute(callback);\n        return;\n      }\n\n      this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n\n      this._emulateAnimation(() => {\n        this.dispose();\n        execute(callback);\n      });\n    }\n\n    dispose() {\n      if (!this._isAppended) {\n        return;\n      }\n\n      EventHandler.off(this._element, EVENT_MOUSEDOWN);\n\n      this._element.remove();\n\n      this._isAppended = false;\n    } // Private\n\n\n    _getElement() {\n      if (!this._element) {\n        const backdrop = document.createElement('div');\n        backdrop.className = this._config.className;\n\n        if (this._config.isAnimated) {\n          backdrop.classList.add(CLASS_NAME_FADE$4);\n        }\n\n        this._element = backdrop;\n      }\n\n      return this._element;\n    }\n\n    _configAfterMerge(config) {\n      // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n      config.rootElement = getElement(config.rootElement);\n      return config;\n    }\n\n    _append() {\n      if (this._isAppended) {\n        return;\n      }\n\n      const element = this._getElement();\n\n      this._config.rootElement.append(element);\n\n      EventHandler.on(element, EVENT_MOUSEDOWN, () => {\n        execute(this._config.clickCallback);\n      });\n      this._isAppended = true;\n    }\n\n    _emulateAnimation(callback) {\n      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/focustrap.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$8 = 'focustrap';\n  const DATA_KEY$5 = 'bs.focustrap';\n  const EVENT_KEY$5 = `.${DATA_KEY$5}`;\n  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\n  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\n  const TAB_KEY = 'Tab';\n  const TAB_NAV_FORWARD = 'forward';\n  const TAB_NAV_BACKWARD = 'backward';\n  const Default$7 = {\n    autofocus: true,\n    trapElement: null // The element to trap focus inside of\n\n  };\n  const DefaultType$7 = {\n    autofocus: 'boolean',\n    trapElement: 'element'\n  };\n  /**\n   * Class definition\n   */\n\n  class FocusTrap extends Config {\n    constructor(config) {\n      super();\n      this._config = this._getConfig(config);\n      this._isActive = false;\n      this._lastTabNavDirection = null;\n    } // Getters\n\n\n    static get Default() {\n      return Default$7;\n    }\n\n    static get DefaultType() {\n      return DefaultType$7;\n    }\n\n    static get NAME() {\n      return NAME$8;\n    } // Public\n\n\n    activate() {\n      if (this._isActive) {\n        return;\n      }\n\n      if (this._config.autofocus) {\n        this._config.trapElement.focus();\n      }\n\n      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n\n      EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));\n      EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));\n      this._isActive = true;\n    }\n\n    deactivate() {\n      if (!this._isActive) {\n        return;\n      }\n\n      this._isActive = false;\n      EventHandler.off(document, EVENT_KEY$5);\n    } // Private\n\n\n    _handleFocusin(event) {\n      const {\n        trapElement\n      } = this._config;\n\n      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n        return;\n      }\n\n      const elements = SelectorEngine.focusableChildren(trapElement);\n\n      if (elements.length === 0) {\n        trapElement.focus();\n      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n        elements[elements.length - 1].focus();\n      } else {\n        elements[0].focus();\n      }\n    }\n\n    _handleKeydown(event) {\n      if (event.key !== TAB_KEY) {\n        return;\n      }\n\n      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): modal.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$7 = 'modal';\n  const DATA_KEY$4 = 'bs.modal';\n  const EVENT_KEY$4 = `.${DATA_KEY$4}`;\n  const DATA_API_KEY$2 = '.data-api';\n  const ESCAPE_KEY$1 = 'Escape';\n  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\n  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\n  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\n  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\n  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\n  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\n  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\n  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\n  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\n  const CLASS_NAME_OPEN = 'modal-open';\n  const CLASS_NAME_FADE$3 = 'fade';\n  const CLASS_NAME_SHOW$4 = 'show';\n  const CLASS_NAME_STATIC = 'modal-static';\n  const OPEN_SELECTOR$1 = '.modal.show';\n  const SELECTOR_DIALOG = '.modal-dialog';\n  const SELECTOR_MODAL_BODY = '.modal-body';\n  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n  const Default$6 = {\n    backdrop: true,\n    focus: true,\n    keyboard: true\n  };\n  const DefaultType$6 = {\n    backdrop: '(boolean|string)',\n    focus: 'boolean',\n    keyboard: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Modal extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n      this._backdrop = this._initializeBackDrop();\n      this._focustrap = this._initializeFocusTrap();\n      this._isShown = false;\n      this._isTransitioning = false;\n      this._scrollBar = new ScrollBarHelper();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default$6;\n    }\n\n    static get DefaultType() {\n      return DefaultType$6;\n    }\n\n    static get NAME() {\n      return NAME$7;\n    } // Public\n\n\n    toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    }\n\n    show(relatedTarget) {\n      if (this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n        relatedTarget\n      });\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._isShown = true;\n      this._isTransitioning = true;\n\n      this._scrollBar.hide();\n\n      document.body.classList.add(CLASS_NAME_OPEN);\n\n      this._adjustDialog();\n\n      this._backdrop.show(() => this._showElement(relatedTarget));\n    }\n\n    hide() {\n      if (!this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      this._isShown = false;\n      this._isTransitioning = true;\n\n      this._focustrap.deactivate();\n\n      this._element.classList.remove(CLASS_NAME_SHOW$4);\n\n      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());\n    }\n\n    dispose() {\n      for (const htmlElement of [window, this._dialog]) {\n        EventHandler.off(htmlElement, EVENT_KEY$4);\n      }\n\n      this._backdrop.dispose();\n\n      this._focustrap.deactivate();\n\n      super.dispose();\n    }\n\n    handleUpdate() {\n      this._adjustDialog();\n    } // Private\n\n\n    _initializeBackDrop() {\n      return new Backdrop({\n        isVisible: Boolean(this._config.backdrop),\n        // 'static' option will be translated to true, and booleans will keep their value,\n        isAnimated: this._isAnimated()\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new FocusTrap({\n        trapElement: this._element\n      });\n    }\n\n    _showElement(relatedTarget) {\n      // try to append dynamic modal\n      if (!document.body.contains(this._element)) {\n        document.body.append(this._element);\n      }\n\n      this._element.style.display = 'block';\n\n      this._element.removeAttribute('aria-hidden');\n\n      this._element.setAttribute('aria-modal', true);\n\n      this._element.setAttribute('role', 'dialog');\n\n      this._element.scrollTop = 0;\n      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n\n      if (modalBody) {\n        modalBody.scrollTop = 0;\n      }\n\n      reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_SHOW$4);\n\n      const transitionComplete = () => {\n        if (this._config.focus) {\n          this._focustrap.activate();\n        }\n\n        this._isTransitioning = false;\n        EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n          relatedTarget\n        });\n      };\n\n      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n    }\n\n    _addEventListeners() {\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\n        if (event.key !== ESCAPE_KEY$1) {\n          return;\n        }\n\n        if (this._config.keyboard) {\n          event.preventDefault();\n          this.hide();\n          return;\n        }\n\n        this._triggerBackdropTransition();\n      });\n      EventHandler.on(window, EVENT_RESIZE$1, () => {\n        if (this._isShown && !this._isTransitioning) {\n          this._adjustDialog();\n        }\n      });\n      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {\n        if (event.target !== event.currentTarget) {\n          // click is inside modal-dialog\n          return;\n        }\n\n        if (this._config.backdrop === 'static') {\n          this._triggerBackdropTransition();\n\n          return;\n        }\n\n        if (this._config.backdrop) {\n          this.hide();\n        }\n      });\n    }\n\n    _hideModal() {\n      this._element.style.display = 'none';\n\n      this._element.setAttribute('aria-hidden', true);\n\n      this._element.removeAttribute('aria-modal');\n\n      this._element.removeAttribute('role');\n\n      this._isTransitioning = false;\n\n      this._backdrop.hide(() => {\n        document.body.classList.remove(CLASS_NAME_OPEN);\n\n        this._resetAdjustments();\n\n        this._scrollBar.reset();\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n      });\n    }\n\n    _isAnimated() {\n      return this._element.classList.contains(CLASS_NAME_FADE$3);\n    }\n\n    _triggerBackdropTransition() {\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      const initialOverflowY = this._element.style.overflowY; // return if the following background transition hasn't yet completed\n\n      if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\n        return;\n      }\n\n      if (!isModalOverflowing) {\n        this._element.style.overflowY = 'hidden';\n      }\n\n      this._element.classList.add(CLASS_NAME_STATIC);\n\n      this._queueCallback(() => {\n        this._element.classList.remove(CLASS_NAME_STATIC);\n\n        this._queueCallback(() => {\n          this._element.style.overflowY = initialOverflowY;\n        }, this._dialog);\n      }, this._dialog);\n\n      this._element.focus();\n    }\n    /**\n     * The following methods are used to handle overflowing modals\n     */\n\n\n    _adjustDialog() {\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      const scrollbarWidth = this._scrollBar.getWidth();\n\n      const isBodyOverflowing = scrollbarWidth > 0;\n\n      if (isBodyOverflowing && !isModalOverflowing) {\n        const property = isRTL() ? 'paddingLeft' : 'paddingRight';\n        this._element.style[property] = `${scrollbarWidth}px`;\n      }\n\n      if (!isBodyOverflowing && isModalOverflowing) {\n        const property = isRTL() ? 'paddingRight' : 'paddingLeft';\n        this._element.style[property] = `${scrollbarWidth}px`;\n      }\n    }\n\n    _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    } // Static\n\n\n    static jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        const data = Modal.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](relatedTarget);\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n    const target = getElementFromSelector(this);\n\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n\n    EventHandler.one(target, EVENT_SHOW$4, showEvent => {\n      if (showEvent.defaultPrevented) {\n        // only register focus restorer if modal will actually get shown\n        return;\n      }\n\n      EventHandler.one(target, EVENT_HIDDEN$4, () => {\n        if (isVisible(this)) {\n          this.focus();\n        }\n      });\n    }); // avoid conflict when clicking modal toggler while another one is open\n\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n\n    if (alreadyOpen) {\n      Modal.getInstance(alreadyOpen).hide();\n    }\n\n    const data = Modal.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  enableDismissTrigger(Modal);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Modal);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): offcanvas.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$6 = 'offcanvas';\n  const DATA_KEY$3 = 'bs.offcanvas';\n  const EVENT_KEY$3 = `.${DATA_KEY$3}`;\n  const DATA_API_KEY$1 = '.data-api';\n  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\n  const ESCAPE_KEY = 'Escape';\n  const CLASS_NAME_SHOW$3 = 'show';\n  const CLASS_NAME_SHOWING$1 = 'showing';\n  const CLASS_NAME_HIDING = 'hiding';\n  const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\n  const OPEN_SELECTOR = '.offcanvas.show';\n  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\n  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\n  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\n  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\n  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\n  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;\n  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\n  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\n  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n  const Default$5 = {\n    backdrop: true,\n    keyboard: true,\n    scroll: false\n  };\n  const DefaultType$5 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    scroll: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Offcanvas extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._isShown = false;\n      this._backdrop = this._initializeBackDrop();\n      this._focustrap = this._initializeFocusTrap();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default$5;\n    }\n\n    static get DefaultType() {\n      return DefaultType$5;\n    }\n\n    static get NAME() {\n      return NAME$6;\n    } // Public\n\n\n    toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    }\n\n    show(relatedTarget) {\n      if (this._isShown) {\n        return;\n      }\n\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n        relatedTarget\n      });\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._isShown = true;\n\n      this._backdrop.show();\n\n      if (!this._config.scroll) {\n        new ScrollBarHelper().hide();\n      }\n\n      this._element.setAttribute('aria-modal', true);\n\n      this._element.setAttribute('role', 'dialog');\n\n      this._element.classList.add(CLASS_NAME_SHOWING$1);\n\n      const completeCallBack = () => {\n        if (!this._config.scroll || this._config.backdrop) {\n          this._focustrap.activate();\n        }\n\n        this._element.classList.add(CLASS_NAME_SHOW$3);\n\n        this._element.classList.remove(CLASS_NAME_SHOWING$1);\n\n        EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n          relatedTarget\n        });\n      };\n\n      this._queueCallback(completeCallBack, this._element, true);\n    }\n\n    hide() {\n      if (!this._isShown) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      this._focustrap.deactivate();\n\n      this._element.blur();\n\n      this._isShown = false;\n\n      this._element.classList.add(CLASS_NAME_HIDING);\n\n      this._backdrop.hide();\n\n      const completeCallback = () => {\n        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n\n        this._element.removeAttribute('aria-modal');\n\n        this._element.removeAttribute('role');\n\n        if (!this._config.scroll) {\n          new ScrollBarHelper().reset();\n        }\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n      };\n\n      this._queueCallback(completeCallback, this._element, true);\n    }\n\n    dispose() {\n      this._backdrop.dispose();\n\n      this._focustrap.deactivate();\n\n      super.dispose();\n    } // Private\n\n\n    _initializeBackDrop() {\n      const clickCallback = () => {\n        if (this._config.backdrop === 'static') {\n          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n          return;\n        }\n\n        this.hide();\n      }; // 'static' option will be translated to true, and booleans will keep their value\n\n\n      const isVisible = Boolean(this._config.backdrop);\n      return new Backdrop({\n        className: CLASS_NAME_BACKDROP,\n        isVisible,\n        isAnimated: true,\n        rootElement: this._element.parentNode,\n        clickCallback: isVisible ? clickCallback : null\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new FocusTrap({\n        trapElement: this._element\n      });\n    }\n\n    _addEventListeners() {\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\n        if (event.key !== ESCAPE_KEY) {\n          return;\n        }\n\n        if (!this._config.keyboard) {\n          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n          return;\n        }\n\n        this.hide();\n      });\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Offcanvas.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](this);\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n    const target = getElementFromSelector(this);\n\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n\n    if (isDisabled(this)) {\n      return;\n    }\n\n    EventHandler.one(target, EVENT_HIDDEN$3, () => {\n      // focus on trigger when it is closed\n      if (isVisible(this)) {\n        this.focus();\n      }\n    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\n\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n\n    if (alreadyOpen && alreadyOpen !== target) {\n      Offcanvas.getInstance(alreadyOpen).hide();\n    }\n\n    const data = Offcanvas.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\n    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {\n      Offcanvas.getOrCreateInstance(selector).show();\n    }\n  });\n  EventHandler.on(window, EVENT_RESIZE, () => {\n    for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {\n      if (getComputedStyle(element).position !== 'fixed') {\n        Offcanvas.getOrCreateInstance(element).hide();\n      }\n    }\n  });\n  enableDismissTrigger(Offcanvas);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Offcanvas);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\n  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  const DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n\n  const allowedAttribute = (attribute, allowedAttributeList) => {\n    const attributeName = attribute.nodeName.toLowerCase();\n\n    if (allowedAttributeList.includes(attributeName)) {\n      if (uriAttributes.has(attributeName)) {\n        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));\n      }\n\n      return true;\n    } // Check if a regular expression validates the attribute.\n\n\n    return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));\n  };\n\n  const DefaultAllowlist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n    if (!unsafeHtml.length) {\n      return unsafeHtml;\n    }\n\n    if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n      return sanitizeFunction(unsafeHtml);\n    }\n\n    const domParser = new window.DOMParser();\n    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\n\n    for (const element of elements) {\n      const elementName = element.nodeName.toLowerCase();\n\n      if (!Object.keys(allowList).includes(elementName)) {\n        element.remove();\n        continue;\n      }\n\n      const attributeList = [].concat(...element.attributes);\n      const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\n\n      for (const attribute of attributeList) {\n        if (!allowedAttribute(attribute, allowedAttributes)) {\n          element.removeAttribute(attribute.nodeName);\n        }\n      }\n    }\n\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/template-factory.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$5 = 'TemplateFactory';\n  const Default$4 = {\n    allowList: DefaultAllowlist,\n    content: {},\n    // { selector : text ,  selector2 : text2 , }\n    extraClass: '',\n    html: false,\n    sanitize: true,\n    sanitizeFn: null,\n    template: '<div></div>'\n  };\n  const DefaultType$4 = {\n    allowList: 'object',\n    content: 'object',\n    extraClass: '(string|function)',\n    html: 'boolean',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    template: 'string'\n  };\n  const DefaultContentType = {\n    entry: '(string|element|function|null)',\n    selector: '(string|element)'\n  };\n  /**\n   * Class definition\n   */\n\n  class TemplateFactory extends Config {\n    constructor(config) {\n      super();\n      this._config = this._getConfig(config);\n    } // Getters\n\n\n    static get Default() {\n      return Default$4;\n    }\n\n    static get DefaultType() {\n      return DefaultType$4;\n    }\n\n    static get NAME() {\n      return NAME$5;\n    } // Public\n\n\n    getContent() {\n      return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);\n    }\n\n    hasContent() {\n      return this.getContent().length > 0;\n    }\n\n    changeContent(content) {\n      this._checkContent(content);\n\n      this._config.content = { ...this._config.content,\n        ...content\n      };\n      return this;\n    }\n\n    toHtml() {\n      const templateWrapper = document.createElement('div');\n      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n\n      for (const [selector, text] of Object.entries(this._config.content)) {\n        this._setContent(templateWrapper, text, selector);\n      }\n\n      const template = templateWrapper.children[0];\n\n      const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n\n      if (extraClass) {\n        template.classList.add(...extraClass.split(' '));\n      }\n\n      return template;\n    } // Private\n\n\n    _typeCheckConfig(config) {\n      super._typeCheckConfig(config);\n\n      this._checkContent(config.content);\n    }\n\n    _checkContent(arg) {\n      for (const [selector, content] of Object.entries(arg)) {\n        super._typeCheckConfig({\n          selector,\n          entry: content\n        }, DefaultContentType);\n      }\n    }\n\n    _setContent(template, content, selector) {\n      const templateElement = SelectorEngine.findOne(selector, template);\n\n      if (!templateElement) {\n        return;\n      }\n\n      content = this._resolvePossibleFunction(content);\n\n      if (!content) {\n        templateElement.remove();\n        return;\n      }\n\n      if (isElement(content)) {\n        this._putElementInTemplate(getElement(content), templateElement);\n\n        return;\n      }\n\n      if (this._config.html) {\n        templateElement.innerHTML = this._maybeSanitize(content);\n        return;\n      }\n\n      templateElement.textContent = content;\n    }\n\n    _maybeSanitize(arg) {\n      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n    }\n\n    _resolvePossibleFunction(arg) {\n      return typeof arg === 'function' ? arg(this) : arg;\n    }\n\n    _putElementInTemplate(element, templateElement) {\n      if (this._config.html) {\n        templateElement.innerHTML = '';\n        templateElement.append(element);\n        return;\n      }\n\n      templateElement.textContent = element.textContent;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$4 = 'tooltip';\n  const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\n  const CLASS_NAME_FADE$2 = 'fade';\n  const CLASS_NAME_MODAL = 'modal';\n  const CLASS_NAME_SHOW$2 = 'show';\n  const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\n  const EVENT_MODAL_HIDE = 'hide.bs.modal';\n  const TRIGGER_HOVER = 'hover';\n  const TRIGGER_FOCUS = 'focus';\n  const TRIGGER_CLICK = 'click';\n  const TRIGGER_MANUAL = 'manual';\n  const EVENT_HIDE$2 = 'hide';\n  const EVENT_HIDDEN$2 = 'hidden';\n  const EVENT_SHOW$2 = 'show';\n  const EVENT_SHOWN$2 = 'shown';\n  const EVENT_INSERTED = 'inserted';\n  const EVENT_CLICK$1 = 'click';\n  const EVENT_FOCUSIN$1 = 'focusin';\n  const EVENT_FOCUSOUT$1 = 'focusout';\n  const EVENT_MOUSEENTER = 'mouseenter';\n  const EVENT_MOUSELEAVE = 'mouseleave';\n  const AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: isRTL() ? 'left' : 'right',\n    BOTTOM: 'bottom',\n    LEFT: isRTL() ? 'right' : 'left'\n  };\n  const Default$3 = {\n    allowList: DefaultAllowlist,\n    animation: true,\n    boundary: 'clippingParents',\n    container: false,\n    customClass: '',\n    delay: 0,\n    fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n    html: false,\n    offset: [0, 0],\n    placement: 'top',\n    popperConfig: null,\n    sanitize: true,\n    sanitizeFn: null,\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n    title: '',\n    trigger: 'hover focus'\n  };\n  const DefaultType$3 = {\n    allowList: 'object',\n    animation: 'boolean',\n    boundary: '(string|element)',\n    container: '(string|element|boolean)',\n    customClass: '(string|function)',\n    delay: '(number|object)',\n    fallbackPlacements: 'array',\n    html: 'boolean',\n    offset: '(array|string|function)',\n    placement: '(string|function)',\n    popperConfig: '(null|object|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    selector: '(string|boolean)',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string'\n  };\n  /**\n   * Class definition\n   */\n\n  class Tooltip extends BaseComponent {\n    constructor(element, config) {\n      if (typeof Popper__namespace === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      }\n\n      super(element, config); // Private\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._isHovered = false;\n      this._activeTrigger = {};\n      this._popper = null;\n      this._templateFactory = null;\n      this._newContent = null; // Protected\n\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default$3;\n    }\n\n    static get DefaultType() {\n      return DefaultType$3;\n    }\n\n    static get NAME() {\n      return NAME$4;\n    } // Public\n\n\n    enable() {\n      this._isEnabled = true;\n    }\n\n    disable() {\n      this._isEnabled = false;\n    }\n\n    toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    }\n\n    toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        const context = this._initializeOnDelegatedTarget(event);\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter();\n        } else {\n          context._leave();\n        }\n\n        return;\n      }\n\n      if (this._isShown()) {\n        this._leave();\n\n        return;\n      }\n\n      this._enter();\n    }\n\n    dispose() {\n      clearTimeout(this._timeout);\n      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n\n      if (this.tip) {\n        this.tip.remove();\n      }\n\n      this._disposePopper();\n\n      super.dispose();\n    }\n\n    show() {\n      if (this._element.style.display === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      if (!(this._isWithContent() && this._isEnabled)) {\n        return;\n      }\n\n      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n      const shadowRoot = findShadowRoot(this._element);\n\n      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n\n      if (showEvent.defaultPrevented || !isInTheDom) {\n        return;\n      } // todo v6 remove this OR make it optional\n\n\n      if (this.tip) {\n        this.tip.remove();\n        this.tip = null;\n      }\n\n      const tip = this._getTipElement();\n\n      this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\n\n      const {\n        container\n      } = this._config;\n\n      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n        container.append(tip);\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n      }\n\n      if (this._popper) {\n        this._popper.update();\n      } else {\n        this._popper = this._createPopper(tip);\n      }\n\n      tip.classList.add(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n      if ('ontouchstart' in document.documentElement) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.on(element, 'mouseover', noop);\n        }\n      }\n\n      const complete = () => {\n        const previousHoverState = this._isHovered;\n        this._isHovered = false;\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n\n        if (previousHoverState) {\n          this._leave();\n        }\n      };\n\n      this._queueCallback(complete, this.tip, this._isAnimated());\n    }\n\n    hide() {\n      if (!this._isShown()) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      const tip = this._getTipElement();\n\n      tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.off(element, 'mouseover', noop);\n        }\n      }\n\n      this._activeTrigger[TRIGGER_CLICK] = false;\n      this._activeTrigger[TRIGGER_FOCUS] = false;\n      this._activeTrigger[TRIGGER_HOVER] = false;\n      this._isHovered = false;\n\n      const complete = () => {\n        if (this._isWithActiveTrigger()) {\n          return;\n        }\n\n        if (!this._isHovered) {\n          tip.remove();\n        }\n\n        this._element.removeAttribute('aria-describedby');\n\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n\n        this._disposePopper();\n      };\n\n      this._queueCallback(complete, this.tip, this._isAnimated());\n    }\n\n    update() {\n      if (this._popper) {\n        this._popper.update();\n      }\n    } // Protected\n\n\n    _isWithContent() {\n      return Boolean(this._getTitle());\n    }\n\n    _getTipElement() {\n      if (!this.tip) {\n        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n      }\n\n      return this.tip;\n    }\n\n    _createTipElement(content) {\n      const tip = this._getTemplateFactory(content).toHtml(); // todo: remove this check on v6\n\n\n      if (!tip) {\n        return null;\n      }\n\n      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2); // todo: on v6 the following can be achieved with CSS only\n\n      tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n      const tipId = getUID(this.constructor.NAME).toString();\n      tip.setAttribute('id', tipId);\n\n      if (this._isAnimated()) {\n        tip.classList.add(CLASS_NAME_FADE$2);\n      }\n\n      return tip;\n    }\n\n    setContent(content) {\n      this._newContent = content;\n\n      if (this._isShown()) {\n        this._disposePopper();\n\n        this.show();\n      }\n    }\n\n    _getTemplateFactory(content) {\n      if (this._templateFactory) {\n        this._templateFactory.changeContent(content);\n      } else {\n        this._templateFactory = new TemplateFactory({ ...this._config,\n          // the `content` var has to be after `this._config`\n          // to override config.content in case of popover\n          content,\n          extraClass: this._resolvePossibleFunction(this._config.customClass)\n        });\n      }\n\n      return this._templateFactory;\n    }\n\n    _getContentForTemplate() {\n      return {\n        [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n      };\n    }\n\n    _getTitle() {\n      return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle;\n    } // Private\n\n\n    _initializeOnDelegatedTarget(event) {\n      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n    }\n\n    _isAnimated() {\n      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n    }\n\n    _isShown() {\n      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n    }\n\n    _createPopper(tip) {\n      const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;\n      const attachment = AttachmentMap[placement.toUpperCase()];\n      return Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));\n    }\n\n    _getOffset() {\n      const {\n        offset\n      } = this._config;\n\n      if (typeof offset === 'string') {\n        return offset.split(',').map(value => Number.parseInt(value, 10));\n      }\n\n      if (typeof offset === 'function') {\n        return popperData => offset(popperData, this._element);\n      }\n\n      return offset;\n    }\n\n    _resolvePossibleFunction(arg) {\n      return typeof arg === 'function' ? arg.call(this._element) : arg;\n    }\n\n    _getPopperConfig(attachment) {\n      const defaultBsPopperConfig = {\n        placement: attachment,\n        modifiers: [{\n          name: 'flip',\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        }, {\n          name: 'offset',\n          options: {\n            offset: this._getOffset()\n          }\n        }, {\n          name: 'preventOverflow',\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: 'arrow',\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        }, {\n          name: 'preSetPlacement',\n          enabled: true,\n          phase: 'beforeMain',\n          fn: data => {\n            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n            this._getTipElement().setAttribute('data-popper-placement', data.state.placement);\n          }\n        }]\n      };\n      return { ...defaultBsPopperConfig,\n        ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n      };\n    }\n\n    _setListeners() {\n      const triggers = this._config.trigger.split(' ');\n\n      for (const trigger of triggers) {\n        if (trigger === 'click') {\n          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => this.toggle(event));\n        } else if (trigger !== TRIGGER_MANUAL) {\n          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n          EventHandler.on(this._element, eventIn, this._config.selector, event => {\n            const context = this._initializeOnDelegatedTarget(event);\n\n            context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n\n            context._enter();\n          });\n          EventHandler.on(this._element, eventOut, this._config.selector, event => {\n            const context = this._initializeOnDelegatedTarget(event);\n\n            context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n\n            context._leave();\n          });\n        }\n      }\n\n      this._hideModalHandler = () => {\n        if (this._element) {\n          this.hide();\n        }\n      };\n\n      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n\n      if (this._config.selector) {\n        this._config = { ...this._config,\n          trigger: 'manual',\n          selector: ''\n        };\n      } else {\n        this._fixTitle();\n      }\n    }\n\n    _fixTitle() {\n      const title = this._config.originalTitle;\n\n      if (!title) {\n        return;\n      }\n\n      if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\n        this._element.setAttribute('aria-label', title);\n      }\n\n      this._element.removeAttribute('title');\n    }\n\n    _enter() {\n      if (this._isShown() || this._isHovered) {\n        this._isHovered = true;\n        return;\n      }\n\n      this._isHovered = true;\n\n      this._setTimeout(() => {\n        if (this._isHovered) {\n          this.show();\n        }\n      }, this._config.delay.show);\n    }\n\n    _leave() {\n      if (this._isWithActiveTrigger()) {\n        return;\n      }\n\n      this._isHovered = false;\n\n      this._setTimeout(() => {\n        if (!this._isHovered) {\n          this.hide();\n        }\n      }, this._config.delay.hide);\n    }\n\n    _setTimeout(handler, timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(handler, timeout);\n    }\n\n    _isWithActiveTrigger() {\n      return Object.values(this._activeTrigger).includes(true);\n    }\n\n    _getConfig(config) {\n      const dataAttributes = Manipulator.getDataAttributes(this._element);\n\n      for (const dataAttribute of Object.keys(dataAttributes)) {\n        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n          delete dataAttributes[dataAttribute];\n        }\n      }\n\n      config = { ...dataAttributes,\n        ...(typeof config === 'object' && config ? config : {})\n      };\n      config = this._mergeConfigObj(config);\n      config = this._configAfterMerge(config);\n\n      this._typeCheckConfig(config);\n\n      return config;\n    }\n\n    _configAfterMerge(config) {\n      config.container = config.container === false ? document.body : getElement(config.container);\n\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      config.originalTitle = this._element.getAttribute('title') || '';\n\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n\n      return config;\n    }\n\n    _getDelegateConfig() {\n      const config = {};\n\n      for (const key in this._config) {\n        if (this.constructor.Default[key] !== this._config[key]) {\n          config[key] = this._config[key];\n        }\n      } // In the future can be replaced with:\n      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n      // `Object.fromEntries(keysWithDifferentValues)`\n\n\n      return config;\n    }\n\n    _disposePopper() {\n      if (this._popper) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Tooltip.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * jQuery\n   */\n\n\n  defineJQueryPlugin(Tooltip);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): popover.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$3 = 'popover';\n  const SELECTOR_TITLE = '.popover-header';\n  const SELECTOR_CONTENT = '.popover-body';\n  const Default$2 = { ...Tooltip.Default,\n    content: '',\n    offset: [0, 8],\n    placement: 'right',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\n    trigger: 'click'\n  };\n  const DefaultType$2 = { ...Tooltip.DefaultType,\n    content: '(null|string|element|function)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Popover extends Tooltip {\n    // Getters\n    static get Default() {\n      return Default$2;\n    }\n\n    static get DefaultType() {\n      return DefaultType$2;\n    }\n\n    static get NAME() {\n      return NAME$3;\n    } // Overrides\n\n\n    _isWithContent() {\n      return this._getTitle() || this._getContent();\n    } // Private\n\n\n    _getContentForTemplate() {\n      return {\n        [SELECTOR_TITLE]: this._getTitle(),\n        [SELECTOR_CONTENT]: this._getContent()\n      };\n    }\n\n    _getContent() {\n      return this._resolvePossibleFunction(this._config.content);\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Popover.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * jQuery\n   */\n\n\n  defineJQueryPlugin(Popover);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): scrollspy.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$2 = 'scrollspy';\n  const DATA_KEY$2 = 'bs.scrollspy';\n  const EVENT_KEY$2 = `.${DATA_KEY$2}`;\n  const DATA_API_KEY = '.data-api';\n  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\n  const EVENT_CLICK = `click${EVENT_KEY$2}`;\n  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\n  const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  const CLASS_NAME_ACTIVE$1 = 'active';\n  const SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n  const SELECTOR_TARGET_LINKS = '[href]';\n  const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  const SELECTOR_NAV_LINKS = '.nav-link';\n  const SELECTOR_NAV_ITEMS = '.nav-item';\n  const SELECTOR_LIST_ITEMS = '.list-group-item';\n  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\n  const SELECTOR_DROPDOWN = '.dropdown';\n  const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  const Default$1 = {\n    offset: null,\n    // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: '0px 0px -25%',\n    smoothScroll: false,\n    target: null\n  };\n  const DefaultType$1 = {\n    offset: '(number|null)',\n    // TODO v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: 'string',\n    smoothScroll: 'boolean',\n    target: 'element'\n  };\n  /**\n   * Class definition\n   */\n\n  class ScrollSpy extends BaseComponent {\n    constructor(element, config) {\n      super(element, config); // this._element is the observablesContainer and config.target the menu links wrapper\n\n      this._targetLinks = new Map();\n      this._observableSections = new Map();\n      this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;\n      this._activeTarget = null;\n      this._observer = null;\n      this._previousScrollData = {\n        visibleEntryTop: 0,\n        parentScrollTop: 0\n      };\n      this.refresh(); // initialize\n    } // Getters\n\n\n    static get Default() {\n      return Default$1;\n    }\n\n    static get DefaultType() {\n      return DefaultType$1;\n    }\n\n    static get NAME() {\n      return NAME$2;\n    } // Public\n\n\n    refresh() {\n      this._initializeTargetsAndObservables();\n\n      this._maybeEnableSmoothScroll();\n\n      if (this._observer) {\n        this._observer.disconnect();\n      } else {\n        this._observer = this._getNewObserver();\n      }\n\n      for (const section of this._observableSections.values()) {\n        this._observer.observe(section);\n      }\n    }\n\n    dispose() {\n      this._observer.disconnect();\n\n      super.dispose();\n    } // Private\n\n\n    _configAfterMerge(config) {\n      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n      config.target = getElement(config.target) || document.body;\n      return config;\n    }\n\n    _maybeEnableSmoothScroll() {\n      if (!this._config.smoothScroll) {\n        return;\n      } // unregister any previous listeners\n\n\n      EventHandler.off(this._config.target, EVENT_CLICK);\n      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {\n        const observableSection = this._observableSections.get(event.target.hash);\n\n        if (observableSection) {\n          event.preventDefault();\n          const root = this._rootElement || window;\n          const height = observableSection.offsetTop - this._element.offsetTop;\n\n          if (root.scrollTo) {\n            root.scrollTo({\n              top: height,\n              behavior: 'smooth'\n            });\n            return;\n          } // Chrome 60 doesn't support `scrollTo`\n\n\n          root.scrollTop = height;\n        }\n      });\n    }\n\n    _getNewObserver() {\n      const options = {\n        root: this._rootElement,\n        threshold: [0.1, 0.5, 1],\n        rootMargin: this._getRootMargin()\n      };\n      return new IntersectionObserver(entries => this._observerCallback(entries), options);\n    } // The logic of selection\n\n\n    _observerCallback(entries) {\n      const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);\n\n      const activate = entry => {\n        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n\n        this._process(targetElement(entry));\n      };\n\n      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n      this._previousScrollData.parentScrollTop = parentScrollTop;\n\n      for (const entry of entries) {\n        if (!entry.isIntersecting) {\n          this._activeTarget = null;\n\n          this._clearActiveClass(targetElement(entry));\n\n          continue;\n        }\n\n        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop; // if we are scrolling down, pick the bigger offsetTop\n\n        if (userScrollsDown && entryIsLowerThanPrevious) {\n          activate(entry); // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n\n          if (!parentScrollTop) {\n            return;\n          }\n\n          continue;\n        } // if we are scrolling up, pick the smallest offsetTop\n\n\n        if (!userScrollsDown && !entryIsLowerThanPrevious) {\n          activate(entry);\n        }\n      }\n    } // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n\n\n    _getRootMargin() {\n      return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin;\n    }\n\n    _initializeTargetsAndObservables() {\n      this._targetLinks = new Map();\n      this._observableSections = new Map();\n      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n\n      for (const anchor of targetLinks) {\n        // ensure that the anchor has an id and is not disabled\n        if (!anchor.hash || isDisabled(anchor)) {\n          continue;\n        }\n\n        const observableSection = SelectorEngine.findOne(anchor.hash, this._element); // ensure that the observableSection exists & is visible\n\n        if (isVisible(observableSection)) {\n          this._targetLinks.set(anchor.hash, anchor);\n\n          this._observableSections.set(anchor.hash, observableSection);\n        }\n      }\n    }\n\n    _process(target) {\n      if (this._activeTarget === target) {\n        return;\n      }\n\n      this._clearActiveClass(this._config.target);\n\n      this._activeTarget = target;\n      target.classList.add(CLASS_NAME_ACTIVE$1);\n\n      this._activateParents(target);\n\n      EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n        relatedTarget: target\n      });\n    }\n\n    _activateParents(target) {\n      // Activate dropdown parents\n      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n        return;\n      }\n\n      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {\n        // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {\n          item.classList.add(CLASS_NAME_ACTIVE$1);\n        }\n      }\n    }\n\n    _clearActiveClass(parent) {\n      parent.classList.remove(CLASS_NAME_ACTIVE$1);\n      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\n\n      for (const node of activeNodes) {\n        node.classList.remove(CLASS_NAME_ACTIVE$1);\n      }\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = ScrollSpy.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\n    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {\n      ScrollSpy.getOrCreateInstance(spy);\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(ScrollSpy);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): tab.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$1 = 'tab';\n  const DATA_KEY$1 = 'bs.tab';\n  const EVENT_KEY$1 = `.${DATA_KEY$1}`;\n  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\n  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\n  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\n  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\n  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\n  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\n  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\n  const ARROW_LEFT_KEY = 'ArrowLeft';\n  const ARROW_RIGHT_KEY = 'ArrowRight';\n  const ARROW_UP_KEY = 'ArrowUp';\n  const ARROW_DOWN_KEY = 'ArrowDown';\n  const CLASS_NAME_ACTIVE = 'active';\n  const CLASS_NAME_FADE$1 = 'fade';\n  const CLASS_NAME_SHOW$1 = 'show';\n  const CLASS_DROPDOWN = 'dropdown';\n  const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\n  const SELECTOR_DROPDOWN_ITEM = '.dropdown-item';\n  const NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';\n  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\n  const SELECTOR_OUTER = '.nav-item, .list-group-item';\n  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\n  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // todo:v6: could be only `tab`\n\n  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\n  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\n  /**\n   * Class definition\n   */\n\n  class Tab extends BaseComponent {\n    constructor(element) {\n      super(element);\n      this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n\n      if (!this._parent) {\n        return; // todo: should Throw exception on v6\n        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n      } // Set up initial aria attributes\n\n\n      this._setInitialAttributes(this._parent, this._getChildren());\n\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n    } // Getters\n\n\n    static get NAME() {\n      return NAME$1;\n    } // Public\n\n\n    show() {\n      // Shows this elem and deactivate the active sibling if exists\n      const innerElem = this._element;\n\n      if (this._elemIsActive(innerElem)) {\n        return;\n      } // Search for active tab on same parent to deactivate it\n\n\n      const active = this._getActiveElem();\n\n      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n        relatedTarget: innerElem\n      }) : null;\n      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n        relatedTarget: active\n      });\n\n      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n        return;\n      }\n\n      this._deactivate(active, innerElem);\n\n      this._activate(innerElem, active);\n    } // Private\n\n\n    _activate(element, relatedElem) {\n      if (!element) {\n        return;\n      }\n\n      element.classList.add(CLASS_NAME_ACTIVE);\n\n      this._activate(getElementFromSelector(element)); // Search and activate/show the proper section\n\n\n      const complete = () => {\n        if (element.getAttribute('role') !== 'tab') {\n          element.classList.add(CLASS_NAME_SHOW$1);\n          return;\n        }\n\n        element.focus();\n        element.removeAttribute('tabindex');\n        element.setAttribute('aria-selected', true);\n\n        this._toggleDropDown(element, true);\n\n        EventHandler.trigger(element, EVENT_SHOWN$1, {\n          relatedTarget: relatedElem\n        });\n      };\n\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n    }\n\n    _deactivate(element, relatedElem) {\n      if (!element) {\n        return;\n      }\n\n      element.classList.remove(CLASS_NAME_ACTIVE);\n      element.blur();\n\n      this._deactivate(getElementFromSelector(element)); // Search and deactivate the shown section too\n\n\n      const complete = () => {\n        if (element.getAttribute('role') !== 'tab') {\n          element.classList.remove(CLASS_NAME_SHOW$1);\n          return;\n        }\n\n        element.setAttribute('aria-selected', false);\n        element.setAttribute('tabindex', '-1');\n\n        this._toggleDropDown(element, false);\n\n        EventHandler.trigger(element, EVENT_HIDDEN$1, {\n          relatedTarget: relatedElem\n        });\n      };\n\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n    }\n\n    _keydown(event) {\n      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {\n        return;\n      }\n\n      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n\n      event.preventDefault();\n      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\n      const nextActiveElement = getNextActiveElement(this._getChildren().filter(element => !isDisabled(element)), event.target, isNext, true);\n\n      if (nextActiveElement) {\n        Tab.getOrCreateInstance(nextActiveElement).show();\n      }\n    }\n\n    _getChildren() {\n      // collection of inner elements\n      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n    }\n\n    _getActiveElem() {\n      return this._getChildren().find(child => this._elemIsActive(child)) || null;\n    }\n\n    _setInitialAttributes(parent, children) {\n      this._setAttributeIfNotExists(parent, 'role', 'tablist');\n\n      for (const child of children) {\n        this._setInitialAttributesOnChild(child);\n      }\n    }\n\n    _setInitialAttributesOnChild(child) {\n      child = this._getInnerElement(child);\n\n      const isActive = this._elemIsActive(child);\n\n      const outerElem = this._getOuterElement(child);\n\n      child.setAttribute('aria-selected', isActive);\n\n      if (outerElem !== child) {\n        this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\n      }\n\n      if (!isActive) {\n        child.setAttribute('tabindex', '-1');\n      }\n\n      this._setAttributeIfNotExists(child, 'role', 'tab'); // set attributes to the related panel too\n\n\n      this._setInitialAttributesOnTargetPanel(child);\n    }\n\n    _setInitialAttributesOnTargetPanel(child) {\n      const target = getElementFromSelector(child);\n\n      if (!target) {\n        return;\n      }\n\n      this._setAttributeIfNotExists(target, 'role', 'tabpanel');\n\n      if (child.id) {\n        this._setAttributeIfNotExists(target, 'aria-labelledby', `#${child.id}`);\n      }\n    }\n\n    _toggleDropDown(element, open) {\n      const outerElem = this._getOuterElement(element);\n\n      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n        return;\n      }\n\n      const toggle = (selector, className) => {\n        const element = SelectorEngine.findOne(selector, outerElem);\n\n        if (element) {\n          element.classList.toggle(className, open);\n        }\n      };\n\n      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n      toggle(SELECTOR_DROPDOWN_ITEM, CLASS_NAME_ACTIVE);\n      outerElem.setAttribute('aria-expanded', open);\n    }\n\n    _setAttributeIfNotExists(element, attribute, value) {\n      if (!element.hasAttribute(attribute)) {\n        element.setAttribute(attribute, value);\n      }\n    }\n\n    _elemIsActive(elem) {\n      return elem.classList.contains(CLASS_NAME_ACTIVE);\n    } // Try to get the inner element (usually the .nav-link)\n\n\n    _getInnerElement(elem) {\n      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n    } // Try to get the outer element (usually the .nav-item)\n\n\n    _getOuterElement(elem) {\n      return elem.closest(SELECTOR_OUTER) || elem;\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Tab.getOrCreateInstance(this);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n\n    if (isDisabled(this)) {\n      return;\n    }\n\n    Tab.getOrCreateInstance(this).show();\n  });\n  /**\n   * Initialize on focus\n   */\n\n  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {\n      Tab.getOrCreateInstance(element);\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Tab);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): toast.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME = 'toast';\n  const DATA_KEY = 'bs.toast';\n  const EVENT_KEY = `.${DATA_KEY}`;\n  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\n  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\n  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\n  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\n  const EVENT_HIDE = `hide${EVENT_KEY}`;\n  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;\n  const EVENT_SHOW = `show${EVENT_KEY}`;\n  const EVENT_SHOWN = `shown${EVENT_KEY}`;\n  const CLASS_NAME_FADE = 'fade';\n  const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\n\n  const CLASS_NAME_SHOW = 'show';\n  const CLASS_NAME_SHOWING = 'showing';\n  const DefaultType = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  const Default = {\n    animation: true,\n    autohide: true,\n    delay: 5000\n  };\n  /**\n   * Class definition\n   */\n\n  class Toast extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._timeout = null;\n      this._hasMouseInteraction = false;\n      this._hasKeyboardInteraction = false;\n\n      this._setListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default;\n    }\n\n    static get DefaultType() {\n      return DefaultType;\n    }\n\n    static get NAME() {\n      return NAME;\n    } // Public\n\n\n    show() {\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._clearTimeout();\n\n      if (this._config.animation) {\n        this._element.classList.add(CLASS_NAME_FADE);\n      }\n\n      const complete = () => {\n        this._element.classList.remove(CLASS_NAME_SHOWING);\n\n        EventHandler.trigger(this._element, EVENT_SHOWN);\n\n        this._maybeScheduleHide();\n      };\n\n      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n\n\n      reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n\n      this._queueCallback(complete, this._element, this._config.animation);\n    }\n\n    hide() {\n      if (!this.isShown()) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      const complete = () => {\n        this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n\n\n        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN);\n      };\n\n      this._element.classList.add(CLASS_NAME_SHOWING);\n\n      this._queueCallback(complete, this._element, this._config.animation);\n    }\n\n    dispose() {\n      this._clearTimeout();\n\n      if (this.isShown()) {\n        this._element.classList.remove(CLASS_NAME_SHOW);\n      }\n\n      super.dispose();\n    }\n\n    isShown() {\n      return this._element.classList.contains(CLASS_NAME_SHOW);\n    } // Private\n\n\n    _maybeScheduleHide() {\n      if (!this._config.autohide) {\n        return;\n      }\n\n      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n        return;\n      }\n\n      this._timeout = setTimeout(() => {\n        this.hide();\n      }, this._config.delay);\n    }\n\n    _onInteraction(event, isInteracting) {\n      switch (event.type) {\n        case 'mouseover':\n        case 'mouseout':\n          this._hasMouseInteraction = isInteracting;\n          break;\n\n        case 'focusin':\n        case 'focusout':\n          this._hasKeyboardInteraction = isInteracting;\n          break;\n      }\n\n      if (isInteracting) {\n        this._clearTimeout();\n\n        return;\n      }\n\n      const nextElement = event.relatedTarget;\n\n      if (this._element === nextElement || this._element.contains(nextElement)) {\n        return;\n      }\n\n      this._maybeScheduleHide();\n    }\n\n    _setListeners() {\n      EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\n      EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\n      EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\n      EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\n    }\n\n    _clearTimeout() {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Toast.getOrCreateInstance(this, config);\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(`No method named \"${config}\"`);\n          }\n\n          data[config](this);\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  enableDismissTrigger(Toast);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Toast);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): index.umd.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  const index_umd = {\n    Alert,\n    Button,\n    Carousel,\n    Collapse,\n    Dropdown,\n    Modal,\n    Offcanvas,\n    Popover,\n    ScrollSpy,\n    Tab,\n    Toast,\n    Tooltip\n  };\n\n  return index_umd;\n\n}));\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js ***!
  \******************************************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n * Select2 4.0.13\n * https://select2.github.io\n *\n * Released under the MIT license\n * https://github.com/select2/select2/blob/master/LICENSE.md\n */\n;(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = function (root, jQuery) {\n      if (jQuery === undefined) {\n        // require('jQuery') returns a factory that requires window to\n        // build a jQuery instance, we normalize how we use modules\n        // that require this pattern but the window provided is a noop\n        // if it's defined (how jquery works)\n        if (typeof window !== 'undefined') {\n          jQuery = require('jquery');\n        }\n        else {\n          jQuery = require('jquery')(root);\n        }\n      }\n      factory(jQuery);\n      return jQuery;\n    };\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n} (function (jQuery) {\n  // This is needed so we can catch the AMD loader configuration and use it\n  // The inner file should be wrapped (by `banner.start.js`) in a function that\n  // returns the AMD loader references.\n  var S2 =(function () {\n  // Restore the Select2 AMD loader so it can be used\n  // Needed mostly in the language files, where the loader is not inserted\n  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {\n    var S2 = jQuery.fn.select2.amd;\n  }\nvar S2;(function () { if (!S2 || !S2.requirejs) {\nif (!S2) { S2 = {}; } else { require = S2; }\n/**\n * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\n * Released under MIT license, http://github.com/requirejs/almond/LICENSE\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name) {\n            name = name.split('/');\n            lastIndex = name.length - 1;\n\n            // If wanting node ID compatibility, strip .js from end\n            // of IDs. Have to do this here, and not in nameToUrl\n            // because node allows either .js or non .js to map\n            // to same file.\n            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n            }\n\n            // Starts with a '.' so need the baseName\n            if (name[0].charAt(0) === '.' && baseParts) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that 'directory' and not name of the baseName's\n                //module. For instance, baseName of 'one/two/three', maps to\n                //'one/two/three.js', but we want the directory, 'one/two' for\n                //this normalization.\n                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                name = normalizedBaseParts.concat(name);\n            }\n\n            //start trimDots\n            for (i = 0; i < name.length; i++) {\n                part = name[i];\n                if (part === '.') {\n                    name.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    // If at the start, or previous value is still ..,\n                    // keep them so that when converted to a path it may\n                    // still work when converted to a path, even though\n                    // as an ID it is less than ideal. In larger point\n                    // releases, may be better to just kick out an error.\n                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {\n                        continue;\n                    } else if (i > 0) {\n                        name.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n            //end trimDots\n\n            name = name.join('/');\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not require('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    //Creates a parts array for a relName where first part is plugin ID,\n    //second part is resource ID. Assumes relName has already been normalized.\n    function makeRelParts(relName) {\n        return relName ? splitPrefix(relName) : [];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relParts) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0],\n            relResourceName = relParts[1];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relResourceName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relResourceName));\n            } else {\n                name = normalize(name, relResourceName);\n            }\n        } else {\n            name = normalize(name, relResourceName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i, relParts,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n        relParts = makeRelParts(relName);\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relParts);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, makeRelParts(callback)).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\nS2.requirejs = requirejs;S2.require = require;S2.define = define;\n}\n}());\nS2.define(\"almond\", function(){});\n\n/* global jQuery:false, $:false */\nS2.define('jquery',[],function () {\n  var _$ = jQuery || $;\n\n  if (_$ == null && console && console.error) {\n    console.error(\n      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +\n      'found. Make sure that you are including jQuery before Select2 on your ' +\n      'web page.'\n    );\n  }\n\n  return _$;\n});\n\nS2.define('select2/utils',[\n  'jquery'\n], function ($) {\n  var Utils = {};\n\n  Utils.Extend = function (ChildClass, SuperClass) {\n    var __hasProp = {}.hasOwnProperty;\n\n    function BaseConstructor () {\n      this.constructor = ChildClass;\n    }\n\n    for (var key in SuperClass) {\n      if (__hasProp.call(SuperClass, key)) {\n        ChildClass[key] = SuperClass[key];\n      }\n    }\n\n    BaseConstructor.prototype = SuperClass.prototype;\n    ChildClass.prototype = new BaseConstructor();\n    ChildClass.__super__ = SuperClass.prototype;\n\n    return ChildClass;\n  };\n\n  function getMethods (theClass) {\n    var proto = theClass.prototype;\n\n    var methods = [];\n\n    for (var methodName in proto) {\n      var m = proto[methodName];\n\n      if (typeof m !== 'function') {\n        continue;\n      }\n\n      if (methodName === 'constructor') {\n        continue;\n      }\n\n      methods.push(methodName);\n    }\n\n    return methods;\n  }\n\n  Utils.Decorate = function (SuperClass, DecoratorClass) {\n    var decoratedMethods = getMethods(DecoratorClass);\n    var superMethods = getMethods(SuperClass);\n\n    function DecoratedClass () {\n      var unshift = Array.prototype.unshift;\n\n      var argCount = DecoratorClass.prototype.constructor.length;\n\n      var calledConstructor = SuperClass.prototype.constructor;\n\n      if (argCount > 0) {\n        unshift.call(arguments, SuperClass.prototype.constructor);\n\n        calledConstructor = DecoratorClass.prototype.constructor;\n      }\n\n      calledConstructor.apply(this, arguments);\n    }\n\n    DecoratorClass.displayName = SuperClass.displayName;\n\n    function ctr () {\n      this.constructor = DecoratedClass;\n    }\n\n    DecoratedClass.prototype = new ctr();\n\n    for (var m = 0; m < superMethods.length; m++) {\n      var superMethod = superMethods[m];\n\n      DecoratedClass.prototype[superMethod] =\n        SuperClass.prototype[superMethod];\n    }\n\n    var calledMethod = function (methodName) {\n      // Stub out the original method if it's not decorating an actual method\n      var originalMethod = function () {};\n\n      if (methodName in DecoratedClass.prototype) {\n        originalMethod = DecoratedClass.prototype[methodName];\n      }\n\n      var decoratedMethod = DecoratorClass.prototype[methodName];\n\n      return function () {\n        var unshift = Array.prototype.unshift;\n\n        unshift.call(arguments, originalMethod);\n\n        return decoratedMethod.apply(this, arguments);\n      };\n    };\n\n    for (var d = 0; d < decoratedMethods.length; d++) {\n      var decoratedMethod = decoratedMethods[d];\n\n      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);\n    }\n\n    return DecoratedClass;\n  };\n\n  var Observable = function () {\n    this.listeners = {};\n  };\n\n  Observable.prototype.on = function (event, callback) {\n    this.listeners = this.listeners || {};\n\n    if (event in this.listeners) {\n      this.listeners[event].push(callback);\n    } else {\n      this.listeners[event] = [callback];\n    }\n  };\n\n  Observable.prototype.trigger = function (event) {\n    var slice = Array.prototype.slice;\n    var params = slice.call(arguments, 1);\n\n    this.listeners = this.listeners || {};\n\n    // Params should always come in as an array\n    if (params == null) {\n      params = [];\n    }\n\n    // If there are no arguments to the event, use a temporary object\n    if (params.length === 0) {\n      params.push({});\n    }\n\n    // Set the `_type` of the first object to the event\n    params[0]._type = event;\n\n    if (event in this.listeners) {\n      this.invoke(this.listeners[event], slice.call(arguments, 1));\n    }\n\n    if ('*' in this.listeners) {\n      this.invoke(this.listeners['*'], arguments);\n    }\n  };\n\n  Observable.prototype.invoke = function (listeners, params) {\n    for (var i = 0, len = listeners.length; i < len; i++) {\n      listeners[i].apply(this, params);\n    }\n  };\n\n  Utils.Observable = Observable;\n\n  Utils.generateChars = function (length) {\n    var chars = '';\n\n    for (var i = 0; i < length; i++) {\n      var randomChar = Math.floor(Math.random() * 36);\n      chars += randomChar.toString(36);\n    }\n\n    return chars;\n  };\n\n  Utils.bind = function (func, context) {\n    return function () {\n      func.apply(context, arguments);\n    };\n  };\n\n  Utils._convertData = function (data) {\n    for (var originalKey in data) {\n      var keys = originalKey.split('-');\n\n      var dataLevel = data;\n\n      if (keys.length === 1) {\n        continue;\n      }\n\n      for (var k = 0; k < keys.length; k++) {\n        var key = keys[k];\n\n        // Lowercase the first letter\n        // By default, dash-separated becomes camelCase\n        key = key.substring(0, 1).toLowerCase() + key.substring(1);\n\n        if (!(key in dataLevel)) {\n          dataLevel[key] = {};\n        }\n\n        if (k == keys.length - 1) {\n          dataLevel[key] = data[originalKey];\n        }\n\n        dataLevel = dataLevel[key];\n      }\n\n      delete data[originalKey];\n    }\n\n    return data;\n  };\n\n  Utils.hasScroll = function (index, el) {\n    // Adapted from the function created by @ShadowScripter\n    // and adapted by @BillBarry on the Stack Exchange Code Review website.\n    // The original code can be found at\n    // http://codereview.stackexchange.com/q/13338\n    // and was designed to be used with the Sizzle selector engine.\n\n    var $el = $(el);\n    var overflowX = el.style.overflowX;\n    var overflowY = el.style.overflowY;\n\n    //Check both x and y declarations\n    if (overflowX === overflowY &&\n        (overflowY === 'hidden' || overflowY === 'visible')) {\n      return false;\n    }\n\n    if (overflowX === 'scroll' || overflowY === 'scroll') {\n      return true;\n    }\n\n    return ($el.innerHeight() < el.scrollHeight ||\n      $el.innerWidth() < el.scrollWidth);\n  };\n\n  Utils.escapeMarkup = function (markup) {\n    var replaceMap = {\n      '\\\\': '&#92;',\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '/': '&#47;'\n    };\n\n    // Do not try to escape the markup if it's not a string\n    if (typeof markup !== 'string') {\n      return markup;\n    }\n\n    return String(markup).replace(/[&<>\"'\\/\\\\]/g, function (match) {\n      return replaceMap[match];\n    });\n  };\n\n  // Append an array of jQuery nodes to a given element.\n  Utils.appendMany = function ($element, $nodes) {\n    // jQuery 1.7.x does not support $.fn.append() with an array\n    // Fall back to a jQuery object collection using $.fn.add()\n    if ($.fn.jquery.substr(0, 3) === '1.7') {\n      var $jqNodes = $();\n\n      $.map($nodes, function (node) {\n        $jqNodes = $jqNodes.add(node);\n      });\n\n      $nodes = $jqNodes;\n    }\n\n    $element.append($nodes);\n  };\n\n  // Cache objects in Utils.__cache instead of $.data (see #4346)\n  Utils.__cache = {};\n\n  var id = 0;\n  Utils.GetUniqueElementId = function (element) {\n    // Get a unique element Id. If element has no id,\n    // creates a new unique number, stores it in the id\n    // attribute and returns the new id.\n    // If an id already exists, it simply returns it.\n\n    var select2Id = element.getAttribute('data-select2-id');\n    if (select2Id == null) {\n      // If element has id, use it.\n      if (element.id) {\n        select2Id = element.id;\n        element.setAttribute('data-select2-id', select2Id);\n      } else {\n        element.setAttribute('data-select2-id', ++id);\n        select2Id = id.toString();\n      }\n    }\n    return select2Id;\n  };\n\n  Utils.StoreData = function (element, name, value) {\n    // Stores an item in the cache for a specified element.\n    // name is the cache key.\n    var id = Utils.GetUniqueElementId(element);\n    if (!Utils.__cache[id]) {\n      Utils.__cache[id] = {};\n    }\n\n    Utils.__cache[id][name] = value;\n  };\n\n  Utils.GetData = function (element, name) {\n    // Retrieves a value from the cache by its key (name)\n    // name is optional. If no name specified, return\n    // all cache items for the specified element.\n    // and for a specified element.\n    var id = Utils.GetUniqueElementId(element);\n    if (name) {\n      if (Utils.__cache[id]) {\n        if (Utils.__cache[id][name] != null) {\n          return Utils.__cache[id][name];\n        }\n        return $(element).data(name); // Fallback to HTML5 data attribs.\n      }\n      return $(element).data(name); // Fallback to HTML5 data attribs.\n    } else {\n      return Utils.__cache[id];\n    }\n  };\n\n  Utils.RemoveData = function (element) {\n    // Removes all cached items for a specified element.\n    var id = Utils.GetUniqueElementId(element);\n    if (Utils.__cache[id] != null) {\n      delete Utils.__cache[id];\n    }\n\n    element.removeAttribute('data-select2-id');\n  };\n\n  return Utils;\n});\n\nS2.define('select2/results',[\n  'jquery',\n  './utils'\n], function ($, Utils) {\n  function Results ($element, options, dataAdapter) {\n    this.$element = $element;\n    this.data = dataAdapter;\n    this.options = options;\n\n    Results.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(Results, Utils.Observable);\n\n  Results.prototype.render = function () {\n    var $results = $(\n      '<ul class=\"select2-results__options\" role=\"listbox\"></ul>'\n    );\n\n    if (this.options.get('multiple')) {\n      $results.attr('aria-multiselectable', 'true');\n    }\n\n    this.$results = $results;\n\n    return $results;\n  };\n\n  Results.prototype.clear = function () {\n    this.$results.empty();\n  };\n\n  Results.prototype.displayMessage = function (params) {\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    this.clear();\n    this.hideLoading();\n\n    var $message = $(\n      '<li role=\"alert\" aria-live=\"assertive\"' +\n      ' class=\"select2-results__option\"></li>'\n    );\n\n    var message = this.options.get('translations').get(params.message);\n\n    $message.append(\n      escapeMarkup(\n        message(params.args)\n      )\n    );\n\n    $message[0].className += ' select2-results__message';\n\n    this.$results.append($message);\n  };\n\n  Results.prototype.hideMessages = function () {\n    this.$results.find('.select2-results__message').remove();\n  };\n\n  Results.prototype.append = function (data) {\n    this.hideLoading();\n\n    var $options = [];\n\n    if (data.results == null || data.results.length === 0) {\n      if (this.$results.children().length === 0) {\n        this.trigger('results:message', {\n          message: 'noResults'\n        });\n      }\n\n      return;\n    }\n\n    data.results = this.sort(data.results);\n\n    for (var d = 0; d < data.results.length; d++) {\n      var item = data.results[d];\n\n      var $option = this.option(item);\n\n      $options.push($option);\n    }\n\n    this.$results.append($options);\n  };\n\n  Results.prototype.position = function ($results, $dropdown) {\n    var $resultsContainer = $dropdown.find('.select2-results');\n    $resultsContainer.append($results);\n  };\n\n  Results.prototype.sort = function (data) {\n    var sorter = this.options.get('sorter');\n\n    return sorter(data);\n  };\n\n  Results.prototype.highlightFirstItem = function () {\n    var $options = this.$results\n      .find('.select2-results__option[aria-selected]');\n\n    var $selected = $options.filter('[aria-selected=true]');\n\n    // Check if there are any selected options\n    if ($selected.length > 0) {\n      // If there are selected options, highlight the first\n      $selected.first().trigger('mouseenter');\n    } else {\n      // If there are no selected options, highlight the first option\n      // in the dropdown\n      $options.first().trigger('mouseenter');\n    }\n\n    this.ensureHighlightVisible();\n  };\n\n  Results.prototype.setClasses = function () {\n    var self = this;\n\n    this.data.current(function (selected) {\n      var selectedIds = $.map(selected, function (s) {\n        return s.id.toString();\n      });\n\n      var $options = self.$results\n        .find('.select2-results__option[aria-selected]');\n\n      $options.each(function () {\n        var $option = $(this);\n\n        var item = Utils.GetData(this, 'data');\n\n        // id needs to be converted to a string when comparing\n        var id = '' + item.id;\n\n        if ((item.element != null && item.element.selected) ||\n            (item.element == null && $.inArray(id, selectedIds) > -1)) {\n          $option.attr('aria-selected', 'true');\n        } else {\n          $option.attr('aria-selected', 'false');\n        }\n      });\n\n    });\n  };\n\n  Results.prototype.showLoading = function (params) {\n    this.hideLoading();\n\n    var loadingMore = this.options.get('translations').get('searching');\n\n    var loading = {\n      disabled: true,\n      loading: true,\n      text: loadingMore(params)\n    };\n    var $loading = this.option(loading);\n    $loading.className += ' loading-results';\n\n    this.$results.prepend($loading);\n  };\n\n  Results.prototype.hideLoading = function () {\n    this.$results.find('.loading-results').remove();\n  };\n\n  Results.prototype.option = function (data) {\n    var option = document.createElement('li');\n    option.className = 'select2-results__option';\n\n    var attrs = {\n      'role': 'option',\n      'aria-selected': 'false'\n    };\n\n    var matches = window.Element.prototype.matches ||\n      window.Element.prototype.msMatchesSelector ||\n      window.Element.prototype.webkitMatchesSelector;\n\n    if ((data.element != null && matches.call(data.element, ':disabled')) ||\n        (data.element == null && data.disabled)) {\n      delete attrs['aria-selected'];\n      attrs['aria-disabled'] = 'true';\n    }\n\n    if (data.id == null) {\n      delete attrs['aria-selected'];\n    }\n\n    if (data._resultId != null) {\n      option.id = data._resultId;\n    }\n\n    if (data.title) {\n      option.title = data.title;\n    }\n\n    if (data.children) {\n      attrs.role = 'group';\n      attrs['aria-label'] = data.text;\n      delete attrs['aria-selected'];\n    }\n\n    for (var attr in attrs) {\n      var val = attrs[attr];\n\n      option.setAttribute(attr, val);\n    }\n\n    if (data.children) {\n      var $option = $(option);\n\n      var label = document.createElement('strong');\n      label.className = 'select2-results__group';\n\n      var $label = $(label);\n      this.template(data, label);\n\n      var $children = [];\n\n      for (var c = 0; c < data.children.length; c++) {\n        var child = data.children[c];\n\n        var $child = this.option(child);\n\n        $children.push($child);\n      }\n\n      var $childrenContainer = $('<ul></ul>', {\n        'class': 'select2-results__options select2-results__options--nested'\n      });\n\n      $childrenContainer.append($children);\n\n      $option.append(label);\n      $option.append($childrenContainer);\n    } else {\n      this.template(data, option);\n    }\n\n    Utils.StoreData(option, 'data', data);\n\n    return option;\n  };\n\n  Results.prototype.bind = function (container, $container) {\n    var self = this;\n\n    var id = container.id + '-results';\n\n    this.$results.attr('id', id);\n\n    container.on('results:all', function (params) {\n      self.clear();\n      self.append(params.data);\n\n      if (container.isOpen()) {\n        self.setClasses();\n        self.highlightFirstItem();\n      }\n    });\n\n    container.on('results:append', function (params) {\n      self.append(params.data);\n\n      if (container.isOpen()) {\n        self.setClasses();\n      }\n    });\n\n    container.on('query', function (params) {\n      self.hideMessages();\n      self.showLoading(params);\n    });\n\n    container.on('select', function () {\n      if (!container.isOpen()) {\n        return;\n      }\n\n      self.setClasses();\n\n      if (self.options.get('scrollAfterSelect')) {\n        self.highlightFirstItem();\n      }\n    });\n\n    container.on('unselect', function () {\n      if (!container.isOpen()) {\n        return;\n      }\n\n      self.setClasses();\n\n      if (self.options.get('scrollAfterSelect')) {\n        self.highlightFirstItem();\n      }\n    });\n\n    container.on('open', function () {\n      // When the dropdown is open, aria-expended=\"true\"\n      self.$results.attr('aria-expanded', 'true');\n      self.$results.attr('aria-hidden', 'false');\n\n      self.setClasses();\n      self.ensureHighlightVisible();\n    });\n\n    container.on('close', function () {\n      // When the dropdown is closed, aria-expended=\"false\"\n      self.$results.attr('aria-expanded', 'false');\n      self.$results.attr('aria-hidden', 'true');\n      self.$results.removeAttr('aria-activedescendant');\n    });\n\n    container.on('results:toggle', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      if ($highlighted.length === 0) {\n        return;\n      }\n\n      $highlighted.trigger('mouseup');\n    });\n\n    container.on('results:select', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      if ($highlighted.length === 0) {\n        return;\n      }\n\n      var data = Utils.GetData($highlighted[0], 'data');\n\n      if ($highlighted.attr('aria-selected') == 'true') {\n        self.trigger('close', {});\n      } else {\n        self.trigger('select', {\n          data: data\n        });\n      }\n    });\n\n    container.on('results:previous', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      var $options = self.$results.find('[aria-selected]');\n\n      var currentIndex = $options.index($highlighted);\n\n      // If we are already at the top, don't move further\n      // If no options, currentIndex will be -1\n      if (currentIndex <= 0) {\n        return;\n      }\n\n      var nextIndex = currentIndex - 1;\n\n      // If none are highlighted, highlight the first\n      if ($highlighted.length === 0) {\n        nextIndex = 0;\n      }\n\n      var $next = $options.eq(nextIndex);\n\n      $next.trigger('mouseenter');\n\n      var currentOffset = self.$results.offset().top;\n      var nextTop = $next.offset().top;\n      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);\n\n      if (nextIndex === 0) {\n        self.$results.scrollTop(0);\n      } else if (nextTop - currentOffset < 0) {\n        self.$results.scrollTop(nextOffset);\n      }\n    });\n\n    container.on('results:next', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      var $options = self.$results.find('[aria-selected]');\n\n      var currentIndex = $options.index($highlighted);\n\n      var nextIndex = currentIndex + 1;\n\n      // If we are at the last option, stay there\n      if (nextIndex >= $options.length) {\n        return;\n      }\n\n      var $next = $options.eq(nextIndex);\n\n      $next.trigger('mouseenter');\n\n      var currentOffset = self.$results.offset().top +\n        self.$results.outerHeight(false);\n      var nextBottom = $next.offset().top + $next.outerHeight(false);\n      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;\n\n      if (nextIndex === 0) {\n        self.$results.scrollTop(0);\n      } else if (nextBottom > currentOffset) {\n        self.$results.scrollTop(nextOffset);\n      }\n    });\n\n    container.on('results:focus', function (params) {\n      params.element.addClass('select2-results__option--highlighted');\n    });\n\n    container.on('results:message', function (params) {\n      self.displayMessage(params);\n    });\n\n    if ($.fn.mousewheel) {\n      this.$results.on('mousewheel', function (e) {\n        var top = self.$results.scrollTop();\n\n        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;\n\n        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;\n        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();\n\n        if (isAtTop) {\n          self.$results.scrollTop(0);\n\n          e.preventDefault();\n          e.stopPropagation();\n        } else if (isAtBottom) {\n          self.$results.scrollTop(\n            self.$results.get(0).scrollHeight - self.$results.height()\n          );\n\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      });\n    }\n\n    this.$results.on('mouseup', '.select2-results__option[aria-selected]',\n      function (evt) {\n      var $this = $(this);\n\n      var data = Utils.GetData(this, 'data');\n\n      if ($this.attr('aria-selected') === 'true') {\n        if (self.options.get('multiple')) {\n          self.trigger('unselect', {\n            originalEvent: evt,\n            data: data\n          });\n        } else {\n          self.trigger('close', {});\n        }\n\n        return;\n      }\n\n      self.trigger('select', {\n        originalEvent: evt,\n        data: data\n      });\n    });\n\n    this.$results.on('mouseenter', '.select2-results__option[aria-selected]',\n      function (evt) {\n      var data = Utils.GetData(this, 'data');\n\n      self.getHighlightedResults()\n          .removeClass('select2-results__option--highlighted');\n\n      self.trigger('results:focus', {\n        data: data,\n        element: $(this)\n      });\n    });\n  };\n\n  Results.prototype.getHighlightedResults = function () {\n    var $highlighted = this.$results\n    .find('.select2-results__option--highlighted');\n\n    return $highlighted;\n  };\n\n  Results.prototype.destroy = function () {\n    this.$results.remove();\n  };\n\n  Results.prototype.ensureHighlightVisible = function () {\n    var $highlighted = this.getHighlightedResults();\n\n    if ($highlighted.length === 0) {\n      return;\n    }\n\n    var $options = this.$results.find('[aria-selected]');\n\n    var currentIndex = $options.index($highlighted);\n\n    var currentOffset = this.$results.offset().top;\n    var nextTop = $highlighted.offset().top;\n    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);\n\n    var offsetDelta = nextTop - currentOffset;\n    nextOffset -= $highlighted.outerHeight(false) * 2;\n\n    if (currentIndex <= 2) {\n      this.$results.scrollTop(0);\n    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {\n      this.$results.scrollTop(nextOffset);\n    }\n  };\n\n  Results.prototype.template = function (result, container) {\n    var template = this.options.get('templateResult');\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    var content = template(result, container);\n\n    if (content == null) {\n      container.style.display = 'none';\n    } else if (typeof content === 'string') {\n      container.innerHTML = escapeMarkup(content);\n    } else {\n      $(container).append(content);\n    }\n  };\n\n  return Results;\n});\n\nS2.define('select2/keys',[\n\n], function () {\n  var KEYS = {\n    BACKSPACE: 8,\n    TAB: 9,\n    ENTER: 13,\n    SHIFT: 16,\n    CTRL: 17,\n    ALT: 18,\n    ESC: 27,\n    SPACE: 32,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    END: 35,\n    HOME: 36,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    DELETE: 46\n  };\n\n  return KEYS;\n});\n\nS2.define('select2/selection/base',[\n  'jquery',\n  '../utils',\n  '../keys'\n], function ($, Utils, KEYS) {\n  function BaseSelection ($element, options) {\n    this.$element = $element;\n    this.options = options;\n\n    BaseSelection.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(BaseSelection, Utils.Observable);\n\n  BaseSelection.prototype.render = function () {\n    var $selection = $(\n      '<span class=\"select2-selection\" role=\"combobox\" ' +\n      ' aria-haspopup=\"true\" aria-expanded=\"false\">' +\n      '</span>'\n    );\n\n    this._tabindex = 0;\n\n    if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {\n      this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');\n    } else if (this.$element.attr('tabindex') != null) {\n      this._tabindex = this.$element.attr('tabindex');\n    }\n\n    $selection.attr('title', this.$element.attr('title'));\n    $selection.attr('tabindex', this._tabindex);\n    $selection.attr('aria-disabled', 'false');\n\n    this.$selection = $selection;\n\n    return $selection;\n  };\n\n  BaseSelection.prototype.bind = function (container, $container) {\n    var self = this;\n\n    var resultsId = container.id + '-results';\n\n    this.container = container;\n\n    this.$selection.on('focus', function (evt) {\n      self.trigger('focus', evt);\n    });\n\n    this.$selection.on('blur', function (evt) {\n      self._handleBlur(evt);\n    });\n\n    this.$selection.on('keydown', function (evt) {\n      self.trigger('keypress', evt);\n\n      if (evt.which === KEYS.SPACE) {\n        evt.preventDefault();\n      }\n    });\n\n    container.on('results:focus', function (params) {\n      self.$selection.attr('aria-activedescendant', params.data._resultId);\n    });\n\n    container.on('selection:update', function (params) {\n      self.update(params.data);\n    });\n\n    container.on('open', function () {\n      // When the dropdown is open, aria-expanded=\"true\"\n      self.$selection.attr('aria-expanded', 'true');\n      self.$selection.attr('aria-owns', resultsId);\n\n      self._attachCloseHandler(container);\n    });\n\n    container.on('close', function () {\n      // When the dropdown is closed, aria-expanded=\"false\"\n      self.$selection.attr('aria-expanded', 'false');\n      self.$selection.removeAttr('aria-activedescendant');\n      self.$selection.removeAttr('aria-owns');\n\n      self.$selection.trigger('focus');\n\n      self._detachCloseHandler(container);\n    });\n\n    container.on('enable', function () {\n      self.$selection.attr('tabindex', self._tabindex);\n      self.$selection.attr('aria-disabled', 'false');\n    });\n\n    container.on('disable', function () {\n      self.$selection.attr('tabindex', '-1');\n      self.$selection.attr('aria-disabled', 'true');\n    });\n  };\n\n  BaseSelection.prototype._handleBlur = function (evt) {\n    var self = this;\n\n    // This needs to be delayed as the active element is the body when the tab\n    // key is pressed, possibly along with others.\n    window.setTimeout(function () {\n      // Don't trigger `blur` if the focus is still in the selection\n      if (\n        (document.activeElement == self.$selection[0]) ||\n        ($.contains(self.$selection[0], document.activeElement))\n      ) {\n        return;\n      }\n\n      self.trigger('blur', evt);\n    }, 1);\n  };\n\n  BaseSelection.prototype._attachCloseHandler = function (container) {\n\n    $(document.body).on('mousedown.select2.' + container.id, function (e) {\n      var $target = $(e.target);\n\n      var $select = $target.closest('.select2');\n\n      var $all = $('.select2.select2-container--open');\n\n      $all.each(function () {\n        if (this == $select[0]) {\n          return;\n        }\n\n        var $element = Utils.GetData(this, 'element');\n\n        $element.select2('close');\n      });\n    });\n  };\n\n  BaseSelection.prototype._detachCloseHandler = function (container) {\n    $(document.body).off('mousedown.select2.' + container.id);\n  };\n\n  BaseSelection.prototype.position = function ($selection, $container) {\n    var $selectionContainer = $container.find('.selection');\n    $selectionContainer.append($selection);\n  };\n\n  BaseSelection.prototype.destroy = function () {\n    this._detachCloseHandler(this.container);\n  };\n\n  BaseSelection.prototype.update = function (data) {\n    throw new Error('The `update` method must be defined in child classes.');\n  };\n\n  /**\n   * Helper method to abstract the \"enabled\" (not \"disabled\") state of this\n   * object.\n   *\n   * @return {true} if the instance is not disabled.\n   * @return {false} if the instance is disabled.\n   */\n  BaseSelection.prototype.isEnabled = function () {\n    return !this.isDisabled();\n  };\n\n  /**\n   * Helper method to abstract the \"disabled\" state of this object.\n   *\n   * @return {true} if the disabled option is true.\n   * @return {false} if the disabled option is false.\n   */\n  BaseSelection.prototype.isDisabled = function () {\n    return this.options.get('disabled');\n  };\n\n  return BaseSelection;\n});\n\nS2.define('select2/selection/single',[\n  'jquery',\n  './base',\n  '../utils',\n  '../keys'\n], function ($, BaseSelection, Utils, KEYS) {\n  function SingleSelection () {\n    SingleSelection.__super__.constructor.apply(this, arguments);\n  }\n\n  Utils.Extend(SingleSelection, BaseSelection);\n\n  SingleSelection.prototype.render = function () {\n    var $selection = SingleSelection.__super__.render.call(this);\n\n    $selection.addClass('select2-selection--single');\n\n    $selection.html(\n      '<span class=\"select2-selection__rendered\"></span>' +\n      '<span class=\"select2-selection__arrow\" role=\"presentation\">' +\n        '<b role=\"presentation\"></b>' +\n      '</span>'\n    );\n\n    return $selection;\n  };\n\n  SingleSelection.prototype.bind = function (container, $container) {\n    var self = this;\n\n    SingleSelection.__super__.bind.apply(this, arguments);\n\n    var id = container.id + '-container';\n\n    this.$selection.find('.select2-selection__rendered')\n      .attr('id', id)\n      .attr('role', 'textbox')\n      .attr('aria-readonly', 'true');\n    this.$selection.attr('aria-labelledby', id);\n\n    this.$selection.on('mousedown', function (evt) {\n      // Only respond to left clicks\n      if (evt.which !== 1) {\n        return;\n      }\n\n      self.trigger('toggle', {\n        originalEvent: evt\n      });\n    });\n\n    this.$selection.on('focus', function (evt) {\n      // User focuses on the container\n    });\n\n    this.$selection.on('blur', function (evt) {\n      // User exits the container\n    });\n\n    container.on('focus', function (evt) {\n      if (!container.isOpen()) {\n        self.$selection.trigger('focus');\n      }\n    });\n  };\n\n  SingleSelection.prototype.clear = function () {\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n    $rendered.empty();\n    $rendered.removeAttr('title'); // clear tooltip on empty\n  };\n\n  SingleSelection.prototype.display = function (data, container) {\n    var template = this.options.get('templateSelection');\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    return escapeMarkup(template(data, container));\n  };\n\n  SingleSelection.prototype.selectionContainer = function () {\n    return $('<span></span>');\n  };\n\n  SingleSelection.prototype.update = function (data) {\n    if (data.length === 0) {\n      this.clear();\n      return;\n    }\n\n    var selection = data[0];\n\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n    var formatted = this.display(selection, $rendered);\n\n    $rendered.empty().append(formatted);\n\n    var title = selection.title || selection.text;\n\n    if (title) {\n      $rendered.attr('title', title);\n    } else {\n      $rendered.removeAttr('title');\n    }\n  };\n\n  return SingleSelection;\n});\n\nS2.define('select2/selection/multiple',[\n  'jquery',\n  './base',\n  '../utils'\n], function ($, BaseSelection, Utils) {\n  function MultipleSelection ($element, options) {\n    MultipleSelection.__super__.constructor.apply(this, arguments);\n  }\n\n  Utils.Extend(MultipleSelection, BaseSelection);\n\n  MultipleSelection.prototype.render = function () {\n    var $selection = MultipleSelection.__super__.render.call(this);\n\n    $selection.addClass('select2-selection--multiple');\n\n    $selection.html(\n      '<ul class=\"select2-selection__rendered\"></ul>'\n    );\n\n    return $selection;\n  };\n\n  MultipleSelection.prototype.bind = function (container, $container) {\n    var self = this;\n\n    MultipleSelection.__super__.bind.apply(this, arguments);\n\n    this.$selection.on('click', function (evt) {\n      self.trigger('toggle', {\n        originalEvent: evt\n      });\n    });\n\n    this.$selection.on(\n      'click',\n      '.select2-selection__choice__remove',\n      function (evt) {\n        // Ignore the event if it is disabled\n        if (self.isDisabled()) {\n          return;\n        }\n\n        var $remove = $(this);\n        var $selection = $remove.parent();\n\n        var data = Utils.GetData($selection[0], 'data');\n\n        self.trigger('unselect', {\n          originalEvent: evt,\n          data: data\n        });\n      }\n    );\n  };\n\n  MultipleSelection.prototype.clear = function () {\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n    $rendered.empty();\n    $rendered.removeAttr('title');\n  };\n\n  MultipleSelection.prototype.display = function (data, container) {\n    var template = this.options.get('templateSelection');\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    return escapeMarkup(template(data, container));\n  };\n\n  MultipleSelection.prototype.selectionContainer = function () {\n    var $container = $(\n      '<li class=\"select2-selection__choice\">' +\n        '<span class=\"select2-selection__choice__remove\" role=\"presentation\">' +\n          '&times;' +\n        '</span>' +\n      '</li>'\n    );\n\n    return $container;\n  };\n\n  MultipleSelection.prototype.update = function (data) {\n    this.clear();\n\n    if (data.length === 0) {\n      return;\n    }\n\n    var $selections = [];\n\n    for (var d = 0; d < data.length; d++) {\n      var selection = data[d];\n\n      var $selection = this.selectionContainer();\n      var formatted = this.display(selection, $selection);\n\n      $selection.append(formatted);\n\n      var title = selection.title || selection.text;\n\n      if (title) {\n        $selection.attr('title', title);\n      }\n\n      Utils.StoreData($selection[0], 'data', selection);\n\n      $selections.push($selection);\n    }\n\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n\n    Utils.appendMany($rendered, $selections);\n  };\n\n  return MultipleSelection;\n});\n\nS2.define('select2/selection/placeholder',[\n  '../utils'\n], function (Utils) {\n  function Placeholder (decorated, $element, options) {\n    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));\n\n    decorated.call(this, $element, options);\n  }\n\n  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {\n    if (typeof placeholder === 'string') {\n      placeholder = {\n        id: '',\n        text: placeholder\n      };\n    }\n\n    return placeholder;\n  };\n\n  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {\n    var $placeholder = this.selectionContainer();\n\n    $placeholder.html(this.display(placeholder));\n    $placeholder.addClass('select2-selection__placeholder')\n                .removeClass('select2-selection__choice');\n\n    return $placeholder;\n  };\n\n  Placeholder.prototype.update = function (decorated, data) {\n    var singlePlaceholder = (\n      data.length == 1 && data[0].id != this.placeholder.id\n    );\n    var multipleSelections = data.length > 1;\n\n    if (multipleSelections || singlePlaceholder) {\n      return decorated.call(this, data);\n    }\n\n    this.clear();\n\n    var $placeholder = this.createPlaceholder(this.placeholder);\n\n    this.$selection.find('.select2-selection__rendered').append($placeholder);\n  };\n\n  return Placeholder;\n});\n\nS2.define('select2/selection/allowClear',[\n  'jquery',\n  '../keys',\n  '../utils'\n], function ($, KEYS, Utils) {\n  function AllowClear () { }\n\n  AllowClear.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    if (this.placeholder == null) {\n      if (this.options.get('debug') && window.console && console.error) {\n        console.error(\n          'Select2: The `allowClear` option should be used in combination ' +\n          'with the `placeholder` option.'\n        );\n      }\n    }\n\n    this.$selection.on('mousedown', '.select2-selection__clear',\n      function (evt) {\n        self._handleClear(evt);\n    });\n\n    container.on('keypress', function (evt) {\n      self._handleKeyboardClear(evt, container);\n    });\n  };\n\n  AllowClear.prototype._handleClear = function (_, evt) {\n    // Ignore the event if it is disabled\n    if (this.isDisabled()) {\n      return;\n    }\n\n    var $clear = this.$selection.find('.select2-selection__clear');\n\n    // Ignore the event if nothing has been selected\n    if ($clear.length === 0) {\n      return;\n    }\n\n    evt.stopPropagation();\n\n    var data = Utils.GetData($clear[0], 'data');\n\n    var previousVal = this.$element.val();\n    this.$element.val(this.placeholder.id);\n\n    var unselectData = {\n      data: data\n    };\n    this.trigger('clear', unselectData);\n    if (unselectData.prevented) {\n      this.$element.val(previousVal);\n      return;\n    }\n\n    for (var d = 0; d < data.length; d++) {\n      unselectData = {\n        data: data[d]\n      };\n\n      // Trigger the `unselect` event, so people can prevent it from being\n      // cleared.\n      this.trigger('unselect', unselectData);\n\n      // If the event was prevented, don't clear it out.\n      if (unselectData.prevented) {\n        this.$element.val(previousVal);\n        return;\n      }\n    }\n\n    this.$element.trigger('input').trigger('change');\n\n    this.trigger('toggle', {});\n  };\n\n  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {\n    if (container.isOpen()) {\n      return;\n    }\n\n    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {\n      this._handleClear(evt);\n    }\n  };\n\n  AllowClear.prototype.update = function (decorated, data) {\n    decorated.call(this, data);\n\n    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||\n        data.length === 0) {\n      return;\n    }\n\n    var removeAll = this.options.get('translations').get('removeAllItems');\n\n    var $remove = $(\n      '<span class=\"select2-selection__clear\" title=\"' + removeAll() +'\">' +\n        '&times;' +\n      '</span>'\n    );\n    Utils.StoreData($remove[0], 'data', data);\n\n    this.$selection.find('.select2-selection__rendered').prepend($remove);\n  };\n\n  return AllowClear;\n});\n\nS2.define('select2/selection/search',[\n  'jquery',\n  '../utils',\n  '../keys'\n], function ($, Utils, KEYS) {\n  function Search (decorated, $element, options) {\n    decorated.call(this, $element, options);\n  }\n\n  Search.prototype.render = function (decorated) {\n    var $search = $(\n      '<li class=\"select2-search select2-search--inline\">' +\n        '<input class=\"select2-search__field\" type=\"search\" tabindex=\"-1\"' +\n        ' autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"none\"' +\n        ' spellcheck=\"false\" role=\"searchbox\" aria-autocomplete=\"list\" />' +\n      '</li>'\n    );\n\n    this.$searchContainer = $search;\n    this.$search = $search.find('input');\n\n    var $rendered = decorated.call(this);\n\n    this._transferTabIndex();\n\n    return $rendered;\n  };\n\n  Search.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    var resultsId = container.id + '-results';\n\n    decorated.call(this, container, $container);\n\n    container.on('open', function () {\n      self.$search.attr('aria-controls', resultsId);\n      self.$search.trigger('focus');\n    });\n\n    container.on('close', function () {\n      self.$search.val('');\n      self.$search.removeAttr('aria-controls');\n      self.$search.removeAttr('aria-activedescendant');\n      self.$search.trigger('focus');\n    });\n\n    container.on('enable', function () {\n      self.$search.prop('disabled', false);\n\n      self._transferTabIndex();\n    });\n\n    container.on('disable', function () {\n      self.$search.prop('disabled', true);\n    });\n\n    container.on('focus', function (evt) {\n      self.$search.trigger('focus');\n    });\n\n    container.on('results:focus', function (params) {\n      if (params.data._resultId) {\n        self.$search.attr('aria-activedescendant', params.data._resultId);\n      } else {\n        self.$search.removeAttr('aria-activedescendant');\n      }\n    });\n\n    this.$selection.on('focusin', '.select2-search--inline', function (evt) {\n      self.trigger('focus', evt);\n    });\n\n    this.$selection.on('focusout', '.select2-search--inline', function (evt) {\n      self._handleBlur(evt);\n    });\n\n    this.$selection.on('keydown', '.select2-search--inline', function (evt) {\n      evt.stopPropagation();\n\n      self.trigger('keypress', evt);\n\n      self._keyUpPrevented = evt.isDefaultPrevented();\n\n      var key = evt.which;\n\n      if (key === KEYS.BACKSPACE && self.$search.val() === '') {\n        var $previousChoice = self.$searchContainer\n          .prev('.select2-selection__choice');\n\n        if ($previousChoice.length > 0) {\n          var item = Utils.GetData($previousChoice[0], 'data');\n\n          self.searchRemoveChoice(item);\n\n          evt.preventDefault();\n        }\n      }\n    });\n\n    this.$selection.on('click', '.select2-search--inline', function (evt) {\n      if (self.$search.val()) {\n        evt.stopPropagation();\n      }\n    });\n\n    // Try to detect the IE version should the `documentMode` property that\n    // is stored on the document. This is only implemented in IE and is\n    // slightly cleaner than doing a user agent check.\n    // This property is not available in Edge, but Edge also doesn't have\n    // this bug.\n    var msie = document.documentMode;\n    var disableInputEvents = msie && msie <= 11;\n\n    // Workaround for browsers which do not support the `input` event\n    // This will prevent double-triggering of events for browsers which support\n    // both the `keyup` and `input` events.\n    this.$selection.on(\n      'input.searchcheck',\n      '.select2-search--inline',\n      function (evt) {\n        // IE will trigger the `input` event when a placeholder is used on a\n        // search box. To get around this issue, we are forced to ignore all\n        // `input` events in IE and keep using `keyup`.\n        if (disableInputEvents) {\n          self.$selection.off('input.search input.searchcheck');\n          return;\n        }\n\n        // Unbind the duplicated `keyup` event\n        self.$selection.off('keyup.search');\n      }\n    );\n\n    this.$selection.on(\n      'keyup.search input.search',\n      '.select2-search--inline',\n      function (evt) {\n        // IE will trigger the `input` event when a placeholder is used on a\n        // search box. To get around this issue, we are forced to ignore all\n        // `input` events in IE and keep using `keyup`.\n        if (disableInputEvents && evt.type === 'input') {\n          self.$selection.off('input.search input.searchcheck');\n          return;\n        }\n\n        var key = evt.which;\n\n        // We can freely ignore events from modifier keys\n        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {\n          return;\n        }\n\n        // Tabbing will be handled during the `keydown` phase\n        if (key == KEYS.TAB) {\n          return;\n        }\n\n        self.handleSearch(evt);\n      }\n    );\n  };\n\n  /**\n   * This method will transfer the tabindex attribute from the rendered\n   * selection to the search box. This allows for the search box to be used as\n   * the primary focus instead of the selection container.\n   *\n   * @private\n   */\n  Search.prototype._transferTabIndex = function (decorated) {\n    this.$search.attr('tabindex', this.$selection.attr('tabindex'));\n    this.$selection.attr('tabindex', '-1');\n  };\n\n  Search.prototype.createPlaceholder = function (decorated, placeholder) {\n    this.$search.attr('placeholder', placeholder.text);\n  };\n\n  Search.prototype.update = function (decorated, data) {\n    var searchHadFocus = this.$search[0] == document.activeElement;\n\n    this.$search.attr('placeholder', '');\n\n    decorated.call(this, data);\n\n    this.$selection.find('.select2-selection__rendered')\n                   .append(this.$searchContainer);\n\n    this.resizeSearch();\n    if (searchHadFocus) {\n      this.$search.trigger('focus');\n    }\n  };\n\n  Search.prototype.handleSearch = function () {\n    this.resizeSearch();\n\n    if (!this._keyUpPrevented) {\n      var input = this.$search.val();\n\n      this.trigger('query', {\n        term: input\n      });\n    }\n\n    this._keyUpPrevented = false;\n  };\n\n  Search.prototype.searchRemoveChoice = function (decorated, item) {\n    this.trigger('unselect', {\n      data: item\n    });\n\n    this.$search.val(item.text);\n    this.handleSearch();\n  };\n\n  Search.prototype.resizeSearch = function () {\n    this.$search.css('width', '25px');\n\n    var width = '';\n\n    if (this.$search.attr('placeholder') !== '') {\n      width = this.$selection.find('.select2-selection__rendered').width();\n    } else {\n      var minimumWidth = this.$search.val().length + 1;\n\n      width = (minimumWidth * 0.75) + 'em';\n    }\n\n    this.$search.css('width', width);\n  };\n\n  return Search;\n});\n\nS2.define('select2/selection/eventRelay',[\n  'jquery'\n], function ($) {\n  function EventRelay () { }\n\n  EventRelay.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n    var relayEvents = [\n      'open', 'opening',\n      'close', 'closing',\n      'select', 'selecting',\n      'unselect', 'unselecting',\n      'clear', 'clearing'\n    ];\n\n    var preventableEvents = [\n      'opening', 'closing', 'selecting', 'unselecting', 'clearing'\n    ];\n\n    decorated.call(this, container, $container);\n\n    container.on('*', function (name, params) {\n      // Ignore events that should not be relayed\n      if ($.inArray(name, relayEvents) === -1) {\n        return;\n      }\n\n      // The parameters should always be an object\n      params = params || {};\n\n      // Generate the jQuery event for the Select2 event\n      var evt = $.Event('select2:' + name, {\n        params: params\n      });\n\n      self.$element.trigger(evt);\n\n      // Only handle preventable events if it was one\n      if ($.inArray(name, preventableEvents) === -1) {\n        return;\n      }\n\n      params.prevented = evt.isDefaultPrevented();\n    });\n  };\n\n  return EventRelay;\n});\n\nS2.define('select2/translation',[\n  'jquery',\n  'require'\n], function ($, require) {\n  function Translation (dict) {\n    this.dict = dict || {};\n  }\n\n  Translation.prototype.all = function () {\n    return this.dict;\n  };\n\n  Translation.prototype.get = function (key) {\n    return this.dict[key];\n  };\n\n  Translation.prototype.extend = function (translation) {\n    this.dict = $.extend({}, translation.all(), this.dict);\n  };\n\n  // Static functions\n\n  Translation._cache = {};\n\n  Translation.loadPath = function (path) {\n    if (!(path in Translation._cache)) {\n      var translations = require(path);\n\n      Translation._cache[path] = translations;\n    }\n\n    return new Translation(Translation._cache[path]);\n  };\n\n  return Translation;\n});\n\nS2.define('select2/diacritics',[\n\n], function () {\n  var diacritics = {\n    '\\u24B6': 'A',\n    '\\uFF21': 'A',\n    '\\u00C0': 'A',\n    '\\u00C1': 'A',\n    '\\u00C2': 'A',\n    '\\u1EA6': 'A',\n    '\\u1EA4': 'A',\n    '\\u1EAA': 'A',\n    '\\u1EA8': 'A',\n    '\\u00C3': 'A',\n    '\\u0100': 'A',\n    '\\u0102': 'A',\n    '\\u1EB0': 'A',\n    '\\u1EAE': 'A',\n    '\\u1EB4': 'A',\n    '\\u1EB2': 'A',\n    '\\u0226': 'A',\n    '\\u01E0': 'A',\n    '\\u00C4': 'A',\n    '\\u01DE': 'A',\n    '\\u1EA2': 'A',\n    '\\u00C5': 'A',\n    '\\u01FA': 'A',\n    '\\u01CD': 'A',\n    '\\u0200': 'A',\n    '\\u0202': 'A',\n    '\\u1EA0': 'A',\n    '\\u1EAC': 'A',\n    '\\u1EB6': 'A',\n    '\\u1E00': 'A',\n    '\\u0104': 'A',\n    '\\u023A': 'A',\n    '\\u2C6F': 'A',\n    '\\uA732': 'AA',\n    '\\u00C6': 'AE',\n    '\\u01FC': 'AE',\n    '\\u01E2': 'AE',\n    '\\uA734': 'AO',\n    '\\uA736': 'AU',\n    '\\uA738': 'AV',\n    '\\uA73A': 'AV',\n    '\\uA73C': 'AY',\n    '\\u24B7': 'B',\n    '\\uFF22': 'B',\n    '\\u1E02': 'B',\n    '\\u1E04': 'B',\n    '\\u1E06': 'B',\n    '\\u0243': 'B',\n    '\\u0182': 'B',\n    '\\u0181': 'B',\n    '\\u24B8': 'C',\n    '\\uFF23': 'C',\n    '\\u0106': 'C',\n    '\\u0108': 'C',\n    '\\u010A': 'C',\n    '\\u010C': 'C',\n    '\\u00C7': 'C',\n    '\\u1E08': 'C',\n    '\\u0187': 'C',\n    '\\u023B': 'C',\n    '\\uA73E': 'C',\n    '\\u24B9': 'D',\n    '\\uFF24': 'D',\n    '\\u1E0A': 'D',\n    '\\u010E': 'D',\n    '\\u1E0C': 'D',\n    '\\u1E10': 'D',\n    '\\u1E12': 'D',\n    '\\u1E0E': 'D',\n    '\\u0110': 'D',\n    '\\u018B': 'D',\n    '\\u018A': 'D',\n    '\\u0189': 'D',\n    '\\uA779': 'D',\n    '\\u01F1': 'DZ',\n    '\\u01C4': 'DZ',\n    '\\u01F2': 'Dz',\n    '\\u01C5': 'Dz',\n    '\\u24BA': 'E',\n    '\\uFF25': 'E',\n    '\\u00C8': 'E',\n    '\\u00C9': 'E',\n    '\\u00CA': 'E',\n    '\\u1EC0': 'E',\n    '\\u1EBE': 'E',\n    '\\u1EC4': 'E',\n    '\\u1EC2': 'E',\n    '\\u1EBC': 'E',\n    '\\u0112': 'E',\n    '\\u1E14': 'E',\n    '\\u1E16': 'E',\n    '\\u0114': 'E',\n    '\\u0116': 'E',\n    '\\u00CB': 'E',\n    '\\u1EBA': 'E',\n    '\\u011A': 'E',\n    '\\u0204': 'E',\n    '\\u0206': 'E',\n    '\\u1EB8': 'E',\n    '\\u1EC6': 'E',\n    '\\u0228': 'E',\n    '\\u1E1C': 'E',\n    '\\u0118': 'E',\n    '\\u1E18': 'E',\n    '\\u1E1A': 'E',\n    '\\u0190': 'E',\n    '\\u018E': 'E',\n    '\\u24BB': 'F',\n    '\\uFF26': 'F',\n    '\\u1E1E': 'F',\n    '\\u0191': 'F',\n    '\\uA77B': 'F',\n    '\\u24BC': 'G',\n    '\\uFF27': 'G',\n    '\\u01F4': 'G',\n    '\\u011C': 'G',\n    '\\u1E20': 'G',\n    '\\u011E': 'G',\n    '\\u0120': 'G',\n    '\\u01E6': 'G',\n    '\\u0122': 'G',\n    '\\u01E4': 'G',\n    '\\u0193': 'G',\n    '\\uA7A0': 'G',\n    '\\uA77D': 'G',\n    '\\uA77E': 'G',\n    '\\u24BD': 'H',\n    '\\uFF28': 'H',\n    '\\u0124': 'H',\n    '\\u1E22': 'H',\n    '\\u1E26': 'H',\n    '\\u021E': 'H',\n    '\\u1E24': 'H',\n    '\\u1E28': 'H',\n    '\\u1E2A': 'H',\n    '\\u0126': 'H',\n    '\\u2C67': 'H',\n    '\\u2C75': 'H',\n    '\\uA78D': 'H',\n    '\\u24BE': 'I',\n    '\\uFF29': 'I',\n    '\\u00CC': 'I',\n    '\\u00CD': 'I',\n    '\\u00CE': 'I',\n    '\\u0128': 'I',\n    '\\u012A': 'I',\n    '\\u012C': 'I',\n    '\\u0130': 'I',\n    '\\u00CF': 'I',\n    '\\u1E2E': 'I',\n    '\\u1EC8': 'I',\n    '\\u01CF': 'I',\n    '\\u0208': 'I',\n    '\\u020A': 'I',\n    '\\u1ECA': 'I',\n    '\\u012E': 'I',\n    '\\u1E2C': 'I',\n    '\\u0197': 'I',\n    '\\u24BF': 'J',\n    '\\uFF2A': 'J',\n    '\\u0134': 'J',\n    '\\u0248': 'J',\n    '\\u24C0': 'K',\n    '\\uFF2B': 'K',\n    '\\u1E30': 'K',\n    '\\u01E8': 'K',\n    '\\u1E32': 'K',\n    '\\u0136': 'K',\n    '\\u1E34': 'K',\n    '\\u0198': 'K',\n    '\\u2C69': 'K',\n    '\\uA740': 'K',\n    '\\uA742': 'K',\n    '\\uA744': 'K',\n    '\\uA7A2': 'K',\n    '\\u24C1': 'L',\n    '\\uFF2C': 'L',\n    '\\u013F': 'L',\n    '\\u0139': 'L',\n    '\\u013D': 'L',\n    '\\u1E36': 'L',\n    '\\u1E38': 'L',\n    '\\u013B': 'L',\n    '\\u1E3C': 'L',\n    '\\u1E3A': 'L',\n    '\\u0141': 'L',\n    '\\u023D': 'L',\n    '\\u2C62': 'L',\n    '\\u2C60': 'L',\n    '\\uA748': 'L',\n    '\\uA746': 'L',\n    '\\uA780': 'L',\n    '\\u01C7': 'LJ',\n    '\\u01C8': 'Lj',\n    '\\u24C2': 'M',\n    '\\uFF2D': 'M',\n    '\\u1E3E': 'M',\n    '\\u1E40': 'M',\n    '\\u1E42': 'M',\n    '\\u2C6E': 'M',\n    '\\u019C': 'M',\n    '\\u24C3': 'N',\n    '\\uFF2E': 'N',\n    '\\u01F8': 'N',\n    '\\u0143': 'N',\n    '\\u00D1': 'N',\n    '\\u1E44': 'N',\n    '\\u0147': 'N',\n    '\\u1E46': 'N',\n    '\\u0145': 'N',\n    '\\u1E4A': 'N',\n    '\\u1E48': 'N',\n    '\\u0220': 'N',\n    '\\u019D': 'N',\n    '\\uA790': 'N',\n    '\\uA7A4': 'N',\n    '\\u01CA': 'NJ',\n    '\\u01CB': 'Nj',\n    '\\u24C4': 'O',\n    '\\uFF2F': 'O',\n    '\\u00D2': 'O',\n    '\\u00D3': 'O',\n    '\\u00D4': 'O',\n    '\\u1ED2': 'O',\n    '\\u1ED0': 'O',\n    '\\u1ED6': 'O',\n    '\\u1ED4': 'O',\n    '\\u00D5': 'O',\n    '\\u1E4C': 'O',\n    '\\u022C': 'O',\n    '\\u1E4E': 'O',\n    '\\u014C': 'O',\n    '\\u1E50': 'O',\n    '\\u1E52': 'O',\n    '\\u014E': 'O',\n    '\\u022E': 'O',\n    '\\u0230': 'O',\n    '\\u00D6': 'O',\n    '\\u022A': 'O',\n    '\\u1ECE': 'O',\n    '\\u0150': 'O',\n    '\\u01D1': 'O',\n    '\\u020C': 'O',\n    '\\u020E': 'O',\n    '\\u01A0': 'O',\n    '\\u1EDC': 'O',\n    '\\u1EDA': 'O',\n    '\\u1EE0': 'O',\n    '\\u1EDE': 'O',\n    '\\u1EE2': 'O',\n    '\\u1ECC': 'O',\n    '\\u1ED8': 'O',\n    '\\u01EA': 'O',\n    '\\u01EC': 'O',\n    '\\u00D8': 'O',\n    '\\u01FE': 'O',\n    '\\u0186': 'O',\n    '\\u019F': 'O',\n    '\\uA74A': 'O',\n    '\\uA74C': 'O',\n    '\\u0152': 'OE',\n    '\\u01A2': 'OI',\n    '\\uA74E': 'OO',\n    '\\u0222': 'OU',\n    '\\u24C5': 'P',\n    '\\uFF30': 'P',\n    '\\u1E54': 'P',\n    '\\u1E56': 'P',\n    '\\u01A4': 'P',\n    '\\u2C63': 'P',\n    '\\uA750': 'P',\n    '\\uA752': 'P',\n    '\\uA754': 'P',\n    '\\u24C6': 'Q',\n    '\\uFF31': 'Q',\n    '\\uA756': 'Q',\n    '\\uA758': 'Q',\n    '\\u024A': 'Q',\n    '\\u24C7': 'R',\n    '\\uFF32': 'R',\n    '\\u0154': 'R',\n    '\\u1E58': 'R',\n    '\\u0158': 'R',\n    '\\u0210': 'R',\n    '\\u0212': 'R',\n    '\\u1E5A': 'R',\n    '\\u1E5C': 'R',\n    '\\u0156': 'R',\n    '\\u1E5E': 'R',\n    '\\u024C': 'R',\n    '\\u2C64': 'R',\n    '\\uA75A': 'R',\n    '\\uA7A6': 'R',\n    '\\uA782': 'R',\n    '\\u24C8': 'S',\n    '\\uFF33': 'S',\n    '\\u1E9E': 'S',\n    '\\u015A': 'S',\n    '\\u1E64': 'S',\n    '\\u015C': 'S',\n    '\\u1E60': 'S',\n    '\\u0160': 'S',\n    '\\u1E66': 'S',\n    '\\u1E62': 'S',\n    '\\u1E68': 'S',\n    '\\u0218': 'S',\n    '\\u015E': 'S',\n    '\\u2C7E': 'S',\n    '\\uA7A8': 'S',\n    '\\uA784': 'S',\n    '\\u24C9': 'T',\n    '\\uFF34': 'T',\n    '\\u1E6A': 'T',\n    '\\u0164': 'T',\n    '\\u1E6C': 'T',\n    '\\u021A': 'T',\n    '\\u0162': 'T',\n    '\\u1E70': 'T',\n    '\\u1E6E': 'T',\n    '\\u0166': 'T',\n    '\\u01AC': 'T',\n    '\\u01AE': 'T',\n    '\\u023E': 'T',\n    '\\uA786': 'T',\n    '\\uA728': 'TZ',\n    '\\u24CA': 'U',\n    '\\uFF35': 'U',\n    '\\u00D9': 'U',\n    '\\u00DA': 'U',\n    '\\u00DB': 'U',\n    '\\u0168': 'U',\n    '\\u1E78': 'U',\n    '\\u016A': 'U',\n    '\\u1E7A': 'U',\n    '\\u016C': 'U',\n    '\\u00DC': 'U',\n    '\\u01DB': 'U',\n    '\\u01D7': 'U',\n    '\\u01D5': 'U',\n    '\\u01D9': 'U',\n    '\\u1EE6': 'U',\n    '\\u016E': 'U',\n    '\\u0170': 'U',\n    '\\u01D3': 'U',\n    '\\u0214': 'U',\n    '\\u0216': 'U',\n    '\\u01AF': 'U',\n    '\\u1EEA': 'U',\n    '\\u1EE8': 'U',\n    '\\u1EEE': 'U',\n    '\\u1EEC': 'U',\n    '\\u1EF0': 'U',\n    '\\u1EE4': 'U',\n    '\\u1E72': 'U',\n    '\\u0172': 'U',\n    '\\u1E76': 'U',\n    '\\u1E74': 'U',\n    '\\u0244': 'U',\n    '\\u24CB': 'V',\n    '\\uFF36': 'V',\n    '\\u1E7C': 'V',\n    '\\u1E7E': 'V',\n    '\\u01B2': 'V',\n    '\\uA75E': 'V',\n    '\\u0245': 'V',\n    '\\uA760': 'VY',\n    '\\u24CC': 'W',\n    '\\uFF37': 'W',\n    '\\u1E80': 'W',\n    '\\u1E82': 'W',\n    '\\u0174': 'W',\n    '\\u1E86': 'W',\n    '\\u1E84': 'W',\n    '\\u1E88': 'W',\n    '\\u2C72': 'W',\n    '\\u24CD': 'X',\n    '\\uFF38': 'X',\n    '\\u1E8A': 'X',\n    '\\u1E8C': 'X',\n    '\\u24CE': 'Y',\n    '\\uFF39': 'Y',\n    '\\u1EF2': 'Y',\n    '\\u00DD': 'Y',\n    '\\u0176': 'Y',\n    '\\u1EF8': 'Y',\n    '\\u0232': 'Y',\n    '\\u1E8E': 'Y',\n    '\\u0178': 'Y',\n    '\\u1EF6': 'Y',\n    '\\u1EF4': 'Y',\n    '\\u01B3': 'Y',\n    '\\u024E': 'Y',\n    '\\u1EFE': 'Y',\n    '\\u24CF': 'Z',\n    '\\uFF3A': 'Z',\n    '\\u0179': 'Z',\n    '\\u1E90': 'Z',\n    '\\u017B': 'Z',\n    '\\u017D': 'Z',\n    '\\u1E92': 'Z',\n    '\\u1E94': 'Z',\n    '\\u01B5': 'Z',\n    '\\u0224': 'Z',\n    '\\u2C7F': 'Z',\n    '\\u2C6B': 'Z',\n    '\\uA762': 'Z',\n    '\\u24D0': 'a',\n    '\\uFF41': 'a',\n    '\\u1E9A': 'a',\n    '\\u00E0': 'a',\n    '\\u00E1': 'a',\n    '\\u00E2': 'a',\n    '\\u1EA7': 'a',\n    '\\u1EA5': 'a',\n    '\\u1EAB': 'a',\n    '\\u1EA9': 'a',\n    '\\u00E3': 'a',\n    '\\u0101': 'a',\n    '\\u0103': 'a',\n    '\\u1EB1': 'a',\n    '\\u1EAF': 'a',\n    '\\u1EB5': 'a',\n    '\\u1EB3': 'a',\n    '\\u0227': 'a',\n    '\\u01E1': 'a',\n    '\\u00E4': 'a',\n    '\\u01DF': 'a',\n    '\\u1EA3': 'a',\n    '\\u00E5': 'a',\n    '\\u01FB': 'a',\n    '\\u01CE': 'a',\n    '\\u0201': 'a',\n    '\\u0203': 'a',\n    '\\u1EA1': 'a',\n    '\\u1EAD': 'a',\n    '\\u1EB7': 'a',\n    '\\u1E01': 'a',\n    '\\u0105': 'a',\n    '\\u2C65': 'a',\n    '\\u0250': 'a',\n    '\\uA733': 'aa',\n    '\\u00E6': 'ae',\n    '\\u01FD': 'ae',\n    '\\u01E3': 'ae',\n    '\\uA735': 'ao',\n    '\\uA737': 'au',\n    '\\uA739': 'av',\n    '\\uA73B': 'av',\n    '\\uA73D': 'ay',\n    '\\u24D1': 'b',\n    '\\uFF42': 'b',\n    '\\u1E03': 'b',\n    '\\u1E05': 'b',\n    '\\u1E07': 'b',\n    '\\u0180': 'b',\n    '\\u0183': 'b',\n    '\\u0253': 'b',\n    '\\u24D2': 'c',\n    '\\uFF43': 'c',\n    '\\u0107': 'c',\n    '\\u0109': 'c',\n    '\\u010B': 'c',\n    '\\u010D': 'c',\n    '\\u00E7': 'c',\n    '\\u1E09': 'c',\n    '\\u0188': 'c',\n    '\\u023C': 'c',\n    '\\uA73F': 'c',\n    '\\u2184': 'c',\n    '\\u24D3': 'd',\n    '\\uFF44': 'd',\n    '\\u1E0B': 'd',\n    '\\u010F': 'd',\n    '\\u1E0D': 'd',\n    '\\u1E11': 'd',\n    '\\u1E13': 'd',\n    '\\u1E0F': 'd',\n    '\\u0111': 'd',\n    '\\u018C': 'd',\n    '\\u0256': 'd',\n    '\\u0257': 'd',\n    '\\uA77A': 'd',\n    '\\u01F3': 'dz',\n    '\\u01C6': 'dz',\n    '\\u24D4': 'e',\n    '\\uFF45': 'e',\n    '\\u00E8': 'e',\n    '\\u00E9': 'e',\n    '\\u00EA': 'e',\n    '\\u1EC1': 'e',\n    '\\u1EBF': 'e',\n    '\\u1EC5': 'e',\n    '\\u1EC3': 'e',\n    '\\u1EBD': 'e',\n    '\\u0113': 'e',\n    '\\u1E15': 'e',\n    '\\u1E17': 'e',\n    '\\u0115': 'e',\n    '\\u0117': 'e',\n    '\\u00EB': 'e',\n    '\\u1EBB': 'e',\n    '\\u011B': 'e',\n    '\\u0205': 'e',\n    '\\u0207': 'e',\n    '\\u1EB9': 'e',\n    '\\u1EC7': 'e',\n    '\\u0229': 'e',\n    '\\u1E1D': 'e',\n    '\\u0119': 'e',\n    '\\u1E19': 'e',\n    '\\u1E1B': 'e',\n    '\\u0247': 'e',\n    '\\u025B': 'e',\n    '\\u01DD': 'e',\n    '\\u24D5': 'f',\n    '\\uFF46': 'f',\n    '\\u1E1F': 'f',\n    '\\u0192': 'f',\n    '\\uA77C': 'f',\n    '\\u24D6': 'g',\n    '\\uFF47': 'g',\n    '\\u01F5': 'g',\n    '\\u011D': 'g',\n    '\\u1E21': 'g',\n    '\\u011F': 'g',\n    '\\u0121': 'g',\n    '\\u01E7': 'g',\n    '\\u0123': 'g',\n    '\\u01E5': 'g',\n    '\\u0260': 'g',\n    '\\uA7A1': 'g',\n    '\\u1D79': 'g',\n    '\\uA77F': 'g',\n    '\\u24D7': 'h',\n    '\\uFF48': 'h',\n    '\\u0125': 'h',\n    '\\u1E23': 'h',\n    '\\u1E27': 'h',\n    '\\u021F': 'h',\n    '\\u1E25': 'h',\n    '\\u1E29': 'h',\n    '\\u1E2B': 'h',\n    '\\u1E96': 'h',\n    '\\u0127': 'h',\n    '\\u2C68': 'h',\n    '\\u2C76': 'h',\n    '\\u0265': 'h',\n    '\\u0195': 'hv',\n    '\\u24D8': 'i',\n    '\\uFF49': 'i',\n    '\\u00EC': 'i',\n    '\\u00ED': 'i',\n    '\\u00EE': 'i',\n    '\\u0129': 'i',\n    '\\u012B': 'i',\n    '\\u012D': 'i',\n    '\\u00EF': 'i',\n    '\\u1E2F': 'i',\n    '\\u1EC9': 'i',\n    '\\u01D0': 'i',\n    '\\u0209': 'i',\n    '\\u020B': 'i',\n    '\\u1ECB': 'i',\n    '\\u012F': 'i',\n    '\\u1E2D': 'i',\n    '\\u0268': 'i',\n    '\\u0131': 'i',\n    '\\u24D9': 'j',\n    '\\uFF4A': 'j',\n    '\\u0135': 'j',\n    '\\u01F0': 'j',\n    '\\u0249': 'j',\n    '\\u24DA': 'k',\n    '\\uFF4B': 'k',\n    '\\u1E31': 'k',\n    '\\u01E9': 'k',\n    '\\u1E33': 'k',\n    '\\u0137': 'k',\n    '\\u1E35': 'k',\n    '\\u0199': 'k',\n    '\\u2C6A': 'k',\n    '\\uA741': 'k',\n    '\\uA743': 'k',\n    '\\uA745': 'k',\n    '\\uA7A3': 'k',\n    '\\u24DB': 'l',\n    '\\uFF4C': 'l',\n    '\\u0140': 'l',\n    '\\u013A': 'l',\n    '\\u013E': 'l',\n    '\\u1E37': 'l',\n    '\\u1E39': 'l',\n    '\\u013C': 'l',\n    '\\u1E3D': 'l',\n    '\\u1E3B': 'l',\n    '\\u017F': 'l',\n    '\\u0142': 'l',\n    '\\u019A': 'l',\n    '\\u026B': 'l',\n    '\\u2C61': 'l',\n    '\\uA749': 'l',\n    '\\uA781': 'l',\n    '\\uA747': 'l',\n    '\\u01C9': 'lj',\n    '\\u24DC': 'm',\n    '\\uFF4D': 'm',\n    '\\u1E3F': 'm',\n    '\\u1E41': 'm',\n    '\\u1E43': 'm',\n    '\\u0271': 'm',\n    '\\u026F': 'm',\n    '\\u24DD': 'n',\n    '\\uFF4E': 'n',\n    '\\u01F9': 'n',\n    '\\u0144': 'n',\n    '\\u00F1': 'n',\n    '\\u1E45': 'n',\n    '\\u0148': 'n',\n    '\\u1E47': 'n',\n    '\\u0146': 'n',\n    '\\u1E4B': 'n',\n    '\\u1E49': 'n',\n    '\\u019E': 'n',\n    '\\u0272': 'n',\n    '\\u0149': 'n',\n    '\\uA791': 'n',\n    '\\uA7A5': 'n',\n    '\\u01CC': 'nj',\n    '\\u24DE': 'o',\n    '\\uFF4F': 'o',\n    '\\u00F2': 'o',\n    '\\u00F3': 'o',\n    '\\u00F4': 'o',\n    '\\u1ED3': 'o',\n    '\\u1ED1': 'o',\n    '\\u1ED7': 'o',\n    '\\u1ED5': 'o',\n    '\\u00F5': 'o',\n    '\\u1E4D': 'o',\n    '\\u022D': 'o',\n    '\\u1E4F': 'o',\n    '\\u014D': 'o',\n    '\\u1E51': 'o',\n    '\\u1E53': 'o',\n    '\\u014F': 'o',\n    '\\u022F': 'o',\n    '\\u0231': 'o',\n    '\\u00F6': 'o',\n    '\\u022B': 'o',\n    '\\u1ECF': 'o',\n    '\\u0151': 'o',\n    '\\u01D2': 'o',\n    '\\u020D': 'o',\n    '\\u020F': 'o',\n    '\\u01A1': 'o',\n    '\\u1EDD': 'o',\n    '\\u1EDB': 'o',\n    '\\u1EE1': 'o',\n    '\\u1EDF': 'o',\n    '\\u1EE3': 'o',\n    '\\u1ECD': 'o',\n    '\\u1ED9': 'o',\n    '\\u01EB': 'o',\n    '\\u01ED': 'o',\n    '\\u00F8': 'o',\n    '\\u01FF': 'o',\n    '\\u0254': 'o',\n    '\\uA74B': 'o',\n    '\\uA74D': 'o',\n    '\\u0275': 'o',\n    '\\u0153': 'oe',\n    '\\u01A3': 'oi',\n    '\\u0223': 'ou',\n    '\\uA74F': 'oo',\n    '\\u24DF': 'p',\n    '\\uFF50': 'p',\n    '\\u1E55': 'p',\n    '\\u1E57': 'p',\n    '\\u01A5': 'p',\n    '\\u1D7D': 'p',\n    '\\uA751': 'p',\n    '\\uA753': 'p',\n    '\\uA755': 'p',\n    '\\u24E0': 'q',\n    '\\uFF51': 'q',\n    '\\u024B': 'q',\n    '\\uA757': 'q',\n    '\\uA759': 'q',\n    '\\u24E1': 'r',\n    '\\uFF52': 'r',\n    '\\u0155': 'r',\n    '\\u1E59': 'r',\n    '\\u0159': 'r',\n    '\\u0211': 'r',\n    '\\u0213': 'r',\n    '\\u1E5B': 'r',\n    '\\u1E5D': 'r',\n    '\\u0157': 'r',\n    '\\u1E5F': 'r',\n    '\\u024D': 'r',\n    '\\u027D': 'r',\n    '\\uA75B': 'r',\n    '\\uA7A7': 'r',\n    '\\uA783': 'r',\n    '\\u24E2': 's',\n    '\\uFF53': 's',\n    '\\u00DF': 's',\n    '\\u015B': 's',\n    '\\u1E65': 's',\n    '\\u015D': 's',\n    '\\u1E61': 's',\n    '\\u0161': 's',\n    '\\u1E67': 's',\n    '\\u1E63': 's',\n    '\\u1E69': 's',\n    '\\u0219': 's',\n    '\\u015F': 's',\n    '\\u023F': 's',\n    '\\uA7A9': 's',\n    '\\uA785': 's',\n    '\\u1E9B': 's',\n    '\\u24E3': 't',\n    '\\uFF54': 't',\n    '\\u1E6B': 't',\n    '\\u1E97': 't',\n    '\\u0165': 't',\n    '\\u1E6D': 't',\n    '\\u021B': 't',\n    '\\u0163': 't',\n    '\\u1E71': 't',\n    '\\u1E6F': 't',\n    '\\u0167': 't',\n    '\\u01AD': 't',\n    '\\u0288': 't',\n    '\\u2C66': 't',\n    '\\uA787': 't',\n    '\\uA729': 'tz',\n    '\\u24E4': 'u',\n    '\\uFF55': 'u',\n    '\\u00F9': 'u',\n    '\\u00FA': 'u',\n    '\\u00FB': 'u',\n    '\\u0169': 'u',\n    '\\u1E79': 'u',\n    '\\u016B': 'u',\n    '\\u1E7B': 'u',\n    '\\u016D': 'u',\n    '\\u00FC': 'u',\n    '\\u01DC': 'u',\n    '\\u01D8': 'u',\n    '\\u01D6': 'u',\n    '\\u01DA': 'u',\n    '\\u1EE7': 'u',\n    '\\u016F': 'u',\n    '\\u0171': 'u',\n    '\\u01D4': 'u',\n    '\\u0215': 'u',\n    '\\u0217': 'u',\n    '\\u01B0': 'u',\n    '\\u1EEB': 'u',\n    '\\u1EE9': 'u',\n    '\\u1EEF': 'u',\n    '\\u1EED': 'u',\n    '\\u1EF1': 'u',\n    '\\u1EE5': 'u',\n    '\\u1E73': 'u',\n    '\\u0173': 'u',\n    '\\u1E77': 'u',\n    '\\u1E75': 'u',\n    '\\u0289': 'u',\n    '\\u24E5': 'v',\n    '\\uFF56': 'v',\n    '\\u1E7D': 'v',\n    '\\u1E7F': 'v',\n    '\\u028B': 'v',\n    '\\uA75F': 'v',\n    '\\u028C': 'v',\n    '\\uA761': 'vy',\n    '\\u24E6': 'w',\n    '\\uFF57': 'w',\n    '\\u1E81': 'w',\n    '\\u1E83': 'w',\n    '\\u0175': 'w',\n    '\\u1E87': 'w',\n    '\\u1E85': 'w',\n    '\\u1E98': 'w',\n    '\\u1E89': 'w',\n    '\\u2C73': 'w',\n    '\\u24E7': 'x',\n    '\\uFF58': 'x',\n    '\\u1E8B': 'x',\n    '\\u1E8D': 'x',\n    '\\u24E8': 'y',\n    '\\uFF59': 'y',\n    '\\u1EF3': 'y',\n    '\\u00FD': 'y',\n    '\\u0177': 'y',\n    '\\u1EF9': 'y',\n    '\\u0233': 'y',\n    '\\u1E8F': 'y',\n    '\\u00FF': 'y',\n    '\\u1EF7': 'y',\n    '\\u1E99': 'y',\n    '\\u1EF5': 'y',\n    '\\u01B4': 'y',\n    '\\u024F': 'y',\n    '\\u1EFF': 'y',\n    '\\u24E9': 'z',\n    '\\uFF5A': 'z',\n    '\\u017A': 'z',\n    '\\u1E91': 'z',\n    '\\u017C': 'z',\n    '\\u017E': 'z',\n    '\\u1E93': 'z',\n    '\\u1E95': 'z',\n    '\\u01B6': 'z',\n    '\\u0225': 'z',\n    '\\u0240': 'z',\n    '\\u2C6C': 'z',\n    '\\uA763': 'z',\n    '\\u0386': '\\u0391',\n    '\\u0388': '\\u0395',\n    '\\u0389': '\\u0397',\n    '\\u038A': '\\u0399',\n    '\\u03AA': '\\u0399',\n    '\\u038C': '\\u039F',\n    '\\u038E': '\\u03A5',\n    '\\u03AB': '\\u03A5',\n    '\\u038F': '\\u03A9',\n    '\\u03AC': '\\u03B1',\n    '\\u03AD': '\\u03B5',\n    '\\u03AE': '\\u03B7',\n    '\\u03AF': '\\u03B9',\n    '\\u03CA': '\\u03B9',\n    '\\u0390': '\\u03B9',\n    '\\u03CC': '\\u03BF',\n    '\\u03CD': '\\u03C5',\n    '\\u03CB': '\\u03C5',\n    '\\u03B0': '\\u03C5',\n    '\\u03CE': '\\u03C9',\n    '\\u03C2': '\\u03C3',\n    '\\u2019': '\\''\n  };\n\n  return diacritics;\n});\n\nS2.define('select2/data/base',[\n  '../utils'\n], function (Utils) {\n  function BaseAdapter ($element, options) {\n    BaseAdapter.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(BaseAdapter, Utils.Observable);\n\n  BaseAdapter.prototype.current = function (callback) {\n    throw new Error('The `current` method must be defined in child classes.');\n  };\n\n  BaseAdapter.prototype.query = function (params, callback) {\n    throw new Error('The `query` method must be defined in child classes.');\n  };\n\n  BaseAdapter.prototype.bind = function (container, $container) {\n    // Can be implemented in subclasses\n  };\n\n  BaseAdapter.prototype.destroy = function () {\n    // Can be implemented in subclasses\n  };\n\n  BaseAdapter.prototype.generateResultId = function (container, data) {\n    var id = container.id + '-result-';\n\n    id += Utils.generateChars(4);\n\n    if (data.id != null) {\n      id += '-' + data.id.toString();\n    } else {\n      id += '-' + Utils.generateChars(4);\n    }\n    return id;\n  };\n\n  return BaseAdapter;\n});\n\nS2.define('select2/data/select',[\n  './base',\n  '../utils',\n  'jquery'\n], function (BaseAdapter, Utils, $) {\n  function SelectAdapter ($element, options) {\n    this.$element = $element;\n    this.options = options;\n\n    SelectAdapter.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(SelectAdapter, BaseAdapter);\n\n  SelectAdapter.prototype.current = function (callback) {\n    var data = [];\n    var self = this;\n\n    this.$element.find(':selected').each(function () {\n      var $option = $(this);\n\n      var option = self.item($option);\n\n      data.push(option);\n    });\n\n    callback(data);\n  };\n\n  SelectAdapter.prototype.select = function (data) {\n    var self = this;\n\n    data.selected = true;\n\n    // If data.element is a DOM node, use it instead\n    if ($(data.element).is('option')) {\n      data.element.selected = true;\n\n      this.$element.trigger('input').trigger('change');\n\n      return;\n    }\n\n    if (this.$element.prop('multiple')) {\n      this.current(function (currentData) {\n        var val = [];\n\n        data = [data];\n        data.push.apply(data, currentData);\n\n        for (var d = 0; d < data.length; d++) {\n          var id = data[d].id;\n\n          if ($.inArray(id, val) === -1) {\n            val.push(id);\n          }\n        }\n\n        self.$element.val(val);\n        self.$element.trigger('input').trigger('change');\n      });\n    } else {\n      var val = data.id;\n\n      this.$element.val(val);\n      this.$element.trigger('input').trigger('change');\n    }\n  };\n\n  SelectAdapter.prototype.unselect = function (data) {\n    var self = this;\n\n    if (!this.$element.prop('multiple')) {\n      return;\n    }\n\n    data.selected = false;\n\n    if ($(data.element).is('option')) {\n      data.element.selected = false;\n\n      this.$element.trigger('input').trigger('change');\n\n      return;\n    }\n\n    this.current(function (currentData) {\n      var val = [];\n\n      for (var d = 0; d < currentData.length; d++) {\n        var id = currentData[d].id;\n\n        if (id !== data.id && $.inArray(id, val) === -1) {\n          val.push(id);\n        }\n      }\n\n      self.$element.val(val);\n\n      self.$element.trigger('input').trigger('change');\n    });\n  };\n\n  SelectAdapter.prototype.bind = function (container, $container) {\n    var self = this;\n\n    this.container = container;\n\n    container.on('select', function (params) {\n      self.select(params.data);\n    });\n\n    container.on('unselect', function (params) {\n      self.unselect(params.data);\n    });\n  };\n\n  SelectAdapter.prototype.destroy = function () {\n    // Remove anything added to child elements\n    this.$element.find('*').each(function () {\n      // Remove any custom data set by Select2\n      Utils.RemoveData(this);\n    });\n  };\n\n  SelectAdapter.prototype.query = function (params, callback) {\n    var data = [];\n    var self = this;\n\n    var $options = this.$element.children();\n\n    $options.each(function () {\n      var $option = $(this);\n\n      if (!$option.is('option') && !$option.is('optgroup')) {\n        return;\n      }\n\n      var option = self.item($option);\n\n      var matches = self.matches(params, option);\n\n      if (matches !== null) {\n        data.push(matches);\n      }\n    });\n\n    callback({\n      results: data\n    });\n  };\n\n  SelectAdapter.prototype.addOptions = function ($options) {\n    Utils.appendMany(this.$element, $options);\n  };\n\n  SelectAdapter.prototype.option = function (data) {\n    var option;\n\n    if (data.children) {\n      option = document.createElement('optgroup');\n      option.label = data.text;\n    } else {\n      option = document.createElement('option');\n\n      if (option.textContent !== undefined) {\n        option.textContent = data.text;\n      } else {\n        option.innerText = data.text;\n      }\n    }\n\n    if (data.id !== undefined) {\n      option.value = data.id;\n    }\n\n    if (data.disabled) {\n      option.disabled = true;\n    }\n\n    if (data.selected) {\n      option.selected = true;\n    }\n\n    if (data.title) {\n      option.title = data.title;\n    }\n\n    var $option = $(option);\n\n    var normalizedData = this._normalizeItem(data);\n    normalizedData.element = option;\n\n    // Override the option's data with the combined data\n    Utils.StoreData(option, 'data', normalizedData);\n\n    return $option;\n  };\n\n  SelectAdapter.prototype.item = function ($option) {\n    var data = {};\n\n    data = Utils.GetData($option[0], 'data');\n\n    if (data != null) {\n      return data;\n    }\n\n    if ($option.is('option')) {\n      data = {\n        id: $option.val(),\n        text: $option.text(),\n        disabled: $option.prop('disabled'),\n        selected: $option.prop('selected'),\n        title: $option.prop('title')\n      };\n    } else if ($option.is('optgroup')) {\n      data = {\n        text: $option.prop('label'),\n        children: [],\n        title: $option.prop('title')\n      };\n\n      var $children = $option.children('option');\n      var children = [];\n\n      for (var c = 0; c < $children.length; c++) {\n        var $child = $($children[c]);\n\n        var child = this.item($child);\n\n        children.push(child);\n      }\n\n      data.children = children;\n    }\n\n    data = this._normalizeItem(data);\n    data.element = $option[0];\n\n    Utils.StoreData($option[0], 'data', data);\n\n    return data;\n  };\n\n  SelectAdapter.prototype._normalizeItem = function (item) {\n    if (item !== Object(item)) {\n      item = {\n        id: item,\n        text: item\n      };\n    }\n\n    item = $.extend({}, {\n      text: ''\n    }, item);\n\n    var defaults = {\n      selected: false,\n      disabled: false\n    };\n\n    if (item.id != null) {\n      item.id = item.id.toString();\n    }\n\n    if (item.text != null) {\n      item.text = item.text.toString();\n    }\n\n    if (item._resultId == null && item.id && this.container != null) {\n      item._resultId = this.generateResultId(this.container, item);\n    }\n\n    return $.extend({}, defaults, item);\n  };\n\n  SelectAdapter.prototype.matches = function (params, data) {\n    var matcher = this.options.get('matcher');\n\n    return matcher(params, data);\n  };\n\n  return SelectAdapter;\n});\n\nS2.define('select2/data/array',[\n  './select',\n  '../utils',\n  'jquery'\n], function (SelectAdapter, Utils, $) {\n  function ArrayAdapter ($element, options) {\n    this._dataToConvert = options.get('data') || [];\n\n    ArrayAdapter.__super__.constructor.call(this, $element, options);\n  }\n\n  Utils.Extend(ArrayAdapter, SelectAdapter);\n\n  ArrayAdapter.prototype.bind = function (container, $container) {\n    ArrayAdapter.__super__.bind.call(this, container, $container);\n\n    this.addOptions(this.convertToOptions(this._dataToConvert));\n  };\n\n  ArrayAdapter.prototype.select = function (data) {\n    var $option = this.$element.find('option').filter(function (i, elm) {\n      return elm.value == data.id.toString();\n    });\n\n    if ($option.length === 0) {\n      $option = this.option(data);\n\n      this.addOptions($option);\n    }\n\n    ArrayAdapter.__super__.select.call(this, data);\n  };\n\n  ArrayAdapter.prototype.convertToOptions = function (data) {\n    var self = this;\n\n    var $existing = this.$element.find('option');\n    var existingIds = $existing.map(function () {\n      return self.item($(this)).id;\n    }).get();\n\n    var $options = [];\n\n    // Filter out all items except for the one passed in the argument\n    function onlyItem (item) {\n      return function () {\n        return $(this).val() == item.id;\n      };\n    }\n\n    for (var d = 0; d < data.length; d++) {\n      var item = this._normalizeItem(data[d]);\n\n      // Skip items which were pre-loaded, only merge the data\n      if ($.inArray(item.id, existingIds) >= 0) {\n        var $existingOption = $existing.filter(onlyItem(item));\n\n        var existingData = this.item($existingOption);\n        var newData = $.extend(true, {}, item, existingData);\n\n        var $newOption = this.option(newData);\n\n        $existingOption.replaceWith($newOption);\n\n        continue;\n      }\n\n      var $option = this.option(item);\n\n      if (item.children) {\n        var $children = this.convertToOptions(item.children);\n\n        Utils.appendMany($option, $children);\n      }\n\n      $options.push($option);\n    }\n\n    return $options;\n  };\n\n  return ArrayAdapter;\n});\n\nS2.define('select2/data/ajax',[\n  './array',\n  '../utils',\n  'jquery'\n], function (ArrayAdapter, Utils, $) {\n  function AjaxAdapter ($element, options) {\n    this.ajaxOptions = this._applyDefaults(options.get('ajax'));\n\n    if (this.ajaxOptions.processResults != null) {\n      this.processResults = this.ajaxOptions.processResults;\n    }\n\n    AjaxAdapter.__super__.constructor.call(this, $element, options);\n  }\n\n  Utils.Extend(AjaxAdapter, ArrayAdapter);\n\n  AjaxAdapter.prototype._applyDefaults = function (options) {\n    var defaults = {\n      data: function (params) {\n        return $.extend({}, params, {\n          q: params.term\n        });\n      },\n      transport: function (params, success, failure) {\n        var $request = $.ajax(params);\n\n        $request.then(success);\n        $request.fail(failure);\n\n        return $request;\n      }\n    };\n\n    return $.extend({}, defaults, options, true);\n  };\n\n  AjaxAdapter.prototype.processResults = function (results) {\n    return results;\n  };\n\n  AjaxAdapter.prototype.query = function (params, callback) {\n    var matches = [];\n    var self = this;\n\n    if (this._request != null) {\n      // JSONP requests cannot always be aborted\n      if ($.isFunction(this._request.abort)) {\n        this._request.abort();\n      }\n\n      this._request = null;\n    }\n\n    var options = $.extend({\n      type: 'GET'\n    }, this.ajaxOptions);\n\n    if (typeof options.url === 'function') {\n      options.url = options.url.call(this.$element, params);\n    }\n\n    if (typeof options.data === 'function') {\n      options.data = options.data.call(this.$element, params);\n    }\n\n    function request () {\n      var $request = options.transport(options, function (data) {\n        var results = self.processResults(data, params);\n\n        if (self.options.get('debug') && window.console && console.error) {\n          // Check to make sure that the response included a `results` key.\n          if (!results || !results.results || !$.isArray(results.results)) {\n            console.error(\n              'Select2: The AJAX results did not return an array in the ' +\n              '`results` key of the response.'\n            );\n          }\n        }\n\n        callback(results);\n      }, function () {\n        // Attempt to detect if a request was aborted\n        // Only works if the transport exposes a status property\n        if ('status' in $request &&\n            ($request.status === 0 || $request.status === '0')) {\n          return;\n        }\n\n        self.trigger('results:message', {\n          message: 'errorLoading'\n        });\n      });\n\n      self._request = $request;\n    }\n\n    if (this.ajaxOptions.delay && params.term != null) {\n      if (this._queryTimeout) {\n        window.clearTimeout(this._queryTimeout);\n      }\n\n      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);\n    } else {\n      request();\n    }\n  };\n\n  return AjaxAdapter;\n});\n\nS2.define('select2/data/tags',[\n  'jquery'\n], function ($) {\n  function Tags (decorated, $element, options) {\n    var tags = options.get('tags');\n\n    var createTag = options.get('createTag');\n\n    if (createTag !== undefined) {\n      this.createTag = createTag;\n    }\n\n    var insertTag = options.get('insertTag');\n\n    if (insertTag !== undefined) {\n        this.insertTag = insertTag;\n    }\n\n    decorated.call(this, $element, options);\n\n    if ($.isArray(tags)) {\n      for (var t = 0; t < tags.length; t++) {\n        var tag = tags[t];\n        var item = this._normalizeItem(tag);\n\n        var $option = this.option(item);\n\n        this.$element.append($option);\n      }\n    }\n  }\n\n  Tags.prototype.query = function (decorated, params, callback) {\n    var self = this;\n\n    this._removeOldTags();\n\n    if (params.term == null || params.page != null) {\n      decorated.call(this, params, callback);\n      return;\n    }\n\n    function wrapper (obj, child) {\n      var data = obj.results;\n\n      for (var i = 0; i < data.length; i++) {\n        var option = data[i];\n\n        var checkChildren = (\n          option.children != null &&\n          !wrapper({\n            results: option.children\n          }, true)\n        );\n\n        var optionText = (option.text || '').toUpperCase();\n        var paramsTerm = (params.term || '').toUpperCase();\n\n        var checkText = optionText === paramsTerm;\n\n        if (checkText || checkChildren) {\n          if (child) {\n            return false;\n          }\n\n          obj.data = data;\n          callback(obj);\n\n          return;\n        }\n      }\n\n      if (child) {\n        return true;\n      }\n\n      var tag = self.createTag(params);\n\n      if (tag != null) {\n        var $option = self.option(tag);\n        $option.attr('data-select2-tag', true);\n\n        self.addOptions([$option]);\n\n        self.insertTag(data, tag);\n      }\n\n      obj.results = data;\n\n      callback(obj);\n    }\n\n    decorated.call(this, params, wrapper);\n  };\n\n  Tags.prototype.createTag = function (decorated, params) {\n    var term = $.trim(params.term);\n\n    if (term === '') {\n      return null;\n    }\n\n    return {\n      id: term,\n      text: term\n    };\n  };\n\n  Tags.prototype.insertTag = function (_, data, tag) {\n    data.unshift(tag);\n  };\n\n  Tags.prototype._removeOldTags = function (_) {\n    var $options = this.$element.find('option[data-select2-tag]');\n\n    $options.each(function () {\n      if (this.selected) {\n        return;\n      }\n\n      $(this).remove();\n    });\n  };\n\n  return Tags;\n});\n\nS2.define('select2/data/tokenizer',[\n  'jquery'\n], function ($) {\n  function Tokenizer (decorated, $element, options) {\n    var tokenizer = options.get('tokenizer');\n\n    if (tokenizer !== undefined) {\n      this.tokenizer = tokenizer;\n    }\n\n    decorated.call(this, $element, options);\n  }\n\n  Tokenizer.prototype.bind = function (decorated, container, $container) {\n    decorated.call(this, container, $container);\n\n    this.$search =  container.dropdown.$search || container.selection.$search ||\n      $container.find('.select2-search__field');\n  };\n\n  Tokenizer.prototype.query = function (decorated, params, callback) {\n    var self = this;\n\n    function createAndSelect (data) {\n      // Normalize the data object so we can use it for checks\n      var item = self._normalizeItem(data);\n\n      // Check if the data object already exists as a tag\n      // Select it if it doesn't\n      var $existingOptions = self.$element.find('option').filter(function () {\n        return $(this).val() === item.id;\n      });\n\n      // If an existing option wasn't found for it, create the option\n      if (!$existingOptions.length) {\n        var $option = self.option(item);\n        $option.attr('data-select2-tag', true);\n\n        self._removeOldTags();\n        self.addOptions([$option]);\n      }\n\n      // Select the item, now that we know there is an option for it\n      select(item);\n    }\n\n    function select (data) {\n      self.trigger('select', {\n        data: data\n      });\n    }\n\n    params.term = params.term || '';\n\n    var tokenData = this.tokenizer(params, this.options, createAndSelect);\n\n    if (tokenData.term !== params.term) {\n      // Replace the search term if we have the search box\n      if (this.$search.length) {\n        this.$search.val(tokenData.term);\n        this.$search.trigger('focus');\n      }\n\n      params.term = tokenData.term;\n    }\n\n    decorated.call(this, params, callback);\n  };\n\n  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {\n    var separators = options.get('tokenSeparators') || [];\n    var term = params.term;\n    var i = 0;\n\n    var createTag = this.createTag || function (params) {\n      return {\n        id: params.term,\n        text: params.term\n      };\n    };\n\n    while (i < term.length) {\n      var termChar = term[i];\n\n      if ($.inArray(termChar, separators) === -1) {\n        i++;\n\n        continue;\n      }\n\n      var part = term.substr(0, i);\n      var partParams = $.extend({}, params, {\n        term: part\n      });\n\n      var data = createTag(partParams);\n\n      if (data == null) {\n        i++;\n        continue;\n      }\n\n      callback(data);\n\n      // Reset the term to not include the tokenized portion\n      term = term.substr(i + 1) || '';\n      i = 0;\n    }\n\n    return {\n      term: term\n    };\n  };\n\n  return Tokenizer;\n});\n\nS2.define('select2/data/minimumInputLength',[\n\n], function () {\n  function MinimumInputLength (decorated, $e, options) {\n    this.minimumInputLength = options.get('minimumInputLength');\n\n    decorated.call(this, $e, options);\n  }\n\n  MinimumInputLength.prototype.query = function (decorated, params, callback) {\n    params.term = params.term || '';\n\n    if (params.term.length < this.minimumInputLength) {\n      this.trigger('results:message', {\n        message: 'inputTooShort',\n        args: {\n          minimum: this.minimumInputLength,\n          input: params.term,\n          params: params\n        }\n      });\n\n      return;\n    }\n\n    decorated.call(this, params, callback);\n  };\n\n  return MinimumInputLength;\n});\n\nS2.define('select2/data/maximumInputLength',[\n\n], function () {\n  function MaximumInputLength (decorated, $e, options) {\n    this.maximumInputLength = options.get('maximumInputLength');\n\n    decorated.call(this, $e, options);\n  }\n\n  MaximumInputLength.prototype.query = function (decorated, params, callback) {\n    params.term = params.term || '';\n\n    if (this.maximumInputLength > 0 &&\n        params.term.length > this.maximumInputLength) {\n      this.trigger('results:message', {\n        message: 'inputTooLong',\n        args: {\n          maximum: this.maximumInputLength,\n          input: params.term,\n          params: params\n        }\n      });\n\n      return;\n    }\n\n    decorated.call(this, params, callback);\n  };\n\n  return MaximumInputLength;\n});\n\nS2.define('select2/data/maximumSelectionLength',[\n\n], function (){\n  function MaximumSelectionLength (decorated, $e, options) {\n    this.maximumSelectionLength = options.get('maximumSelectionLength');\n\n    decorated.call(this, $e, options);\n  }\n\n  MaximumSelectionLength.prototype.bind =\n    function (decorated, container, $container) {\n      var self = this;\n\n      decorated.call(this, container, $container);\n\n      container.on('select', function () {\n        self._checkIfMaximumSelected();\n      });\n  };\n\n  MaximumSelectionLength.prototype.query =\n    function (decorated, params, callback) {\n      var self = this;\n\n      this._checkIfMaximumSelected(function () {\n        decorated.call(self, params, callback);\n      });\n  };\n\n  MaximumSelectionLength.prototype._checkIfMaximumSelected =\n    function (_, successCallback) {\n      var self = this;\n\n      this.current(function (currentData) {\n        var count = currentData != null ? currentData.length : 0;\n        if (self.maximumSelectionLength > 0 &&\n          count >= self.maximumSelectionLength) {\n          self.trigger('results:message', {\n            message: 'maximumSelected',\n            args: {\n              maximum: self.maximumSelectionLength\n            }\n          });\n          return;\n        }\n\n        if (successCallback) {\n          successCallback();\n        }\n      });\n  };\n\n  return MaximumSelectionLength;\n});\n\nS2.define('select2/dropdown',[\n  'jquery',\n  './utils'\n], function ($, Utils) {\n  function Dropdown ($element, options) {\n    this.$element = $element;\n    this.options = options;\n\n    Dropdown.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(Dropdown, Utils.Observable);\n\n  Dropdown.prototype.render = function () {\n    var $dropdown = $(\n      '<span class=\"select2-dropdown\">' +\n        '<span class=\"select2-results\"></span>' +\n      '</span>'\n    );\n\n    $dropdown.attr('dir', this.options.get('dir'));\n\n    this.$dropdown = $dropdown;\n\n    return $dropdown;\n  };\n\n  Dropdown.prototype.bind = function () {\n    // Should be implemented in subclasses\n  };\n\n  Dropdown.prototype.position = function ($dropdown, $container) {\n    // Should be implemented in subclasses\n  };\n\n  Dropdown.prototype.destroy = function () {\n    // Remove the dropdown from the DOM\n    this.$dropdown.remove();\n  };\n\n  return Dropdown;\n});\n\nS2.define('select2/dropdown/search',[\n  'jquery',\n  '../utils'\n], function ($, Utils) {\n  function Search () { }\n\n  Search.prototype.render = function (decorated) {\n    var $rendered = decorated.call(this);\n\n    var $search = $(\n      '<span class=\"select2-search select2-search--dropdown\">' +\n        '<input class=\"select2-search__field\" type=\"search\" tabindex=\"-1\"' +\n        ' autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"none\"' +\n        ' spellcheck=\"false\" role=\"searchbox\" aria-autocomplete=\"list\" />' +\n      '</span>'\n    );\n\n    this.$searchContainer = $search;\n    this.$search = $search.find('input');\n\n    $rendered.prepend($search);\n\n    return $rendered;\n  };\n\n  Search.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    var resultsId = container.id + '-results';\n\n    decorated.call(this, container, $container);\n\n    this.$search.on('keydown', function (evt) {\n      self.trigger('keypress', evt);\n\n      self._keyUpPrevented = evt.isDefaultPrevented();\n    });\n\n    // Workaround for browsers which do not support the `input` event\n    // This will prevent double-triggering of events for browsers which support\n    // both the `keyup` and `input` events.\n    this.$search.on('input', function (evt) {\n      // Unbind the duplicated `keyup` event\n      $(this).off('keyup');\n    });\n\n    this.$search.on('keyup input', function (evt) {\n      self.handleSearch(evt);\n    });\n\n    container.on('open', function () {\n      self.$search.attr('tabindex', 0);\n      self.$search.attr('aria-controls', resultsId);\n\n      self.$search.trigger('focus');\n\n      window.setTimeout(function () {\n        self.$search.trigger('focus');\n      }, 0);\n    });\n\n    container.on('close', function () {\n      self.$search.attr('tabindex', -1);\n      self.$search.removeAttr('aria-controls');\n      self.$search.removeAttr('aria-activedescendant');\n\n      self.$search.val('');\n      self.$search.trigger('blur');\n    });\n\n    container.on('focus', function () {\n      if (!container.isOpen()) {\n        self.$search.trigger('focus');\n      }\n    });\n\n    container.on('results:all', function (params) {\n      if (params.query.term == null || params.query.term === '') {\n        var showSearch = self.showSearch(params);\n\n        if (showSearch) {\n          self.$searchContainer.removeClass('select2-search--hide');\n        } else {\n          self.$searchContainer.addClass('select2-search--hide');\n        }\n      }\n    });\n\n    container.on('results:focus', function (params) {\n      if (params.data._resultId) {\n        self.$search.attr('aria-activedescendant', params.data._resultId);\n      } else {\n        self.$search.removeAttr('aria-activedescendant');\n      }\n    });\n  };\n\n  Search.prototype.handleSearch = function (evt) {\n    if (!this._keyUpPrevented) {\n      var input = this.$search.val();\n\n      this.trigger('query', {\n        term: input\n      });\n    }\n\n    this._keyUpPrevented = false;\n  };\n\n  Search.prototype.showSearch = function (_, params) {\n    return true;\n  };\n\n  return Search;\n});\n\nS2.define('select2/dropdown/hidePlaceholder',[\n\n], function () {\n  function HidePlaceholder (decorated, $element, options, dataAdapter) {\n    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));\n\n    decorated.call(this, $element, options, dataAdapter);\n  }\n\n  HidePlaceholder.prototype.append = function (decorated, data) {\n    data.results = this.removePlaceholder(data.results);\n\n    decorated.call(this, data);\n  };\n\n  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {\n    if (typeof placeholder === 'string') {\n      placeholder = {\n        id: '',\n        text: placeholder\n      };\n    }\n\n    return placeholder;\n  };\n\n  HidePlaceholder.prototype.removePlaceholder = function (_, data) {\n    var modifiedData = data.slice(0);\n\n    for (var d = data.length - 1; d >= 0; d--) {\n      var item = data[d];\n\n      if (this.placeholder.id === item.id) {\n        modifiedData.splice(d, 1);\n      }\n    }\n\n    return modifiedData;\n  };\n\n  return HidePlaceholder;\n});\n\nS2.define('select2/dropdown/infiniteScroll',[\n  'jquery'\n], function ($) {\n  function InfiniteScroll (decorated, $element, options, dataAdapter) {\n    this.lastParams = {};\n\n    decorated.call(this, $element, options, dataAdapter);\n\n    this.$loadingMore = this.createLoadingMore();\n    this.loading = false;\n  }\n\n  InfiniteScroll.prototype.append = function (decorated, data) {\n    this.$loadingMore.remove();\n    this.loading = false;\n\n    decorated.call(this, data);\n\n    if (this.showLoadingMore(data)) {\n      this.$results.append(this.$loadingMore);\n      this.loadMoreIfNeeded();\n    }\n  };\n\n  InfiniteScroll.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('query', function (params) {\n      self.lastParams = params;\n      self.loading = true;\n    });\n\n    container.on('query:append', function (params) {\n      self.lastParams = params;\n      self.loading = true;\n    });\n\n    this.$results.on('scroll', this.loadMoreIfNeeded.bind(this));\n  };\n\n  InfiniteScroll.prototype.loadMoreIfNeeded = function () {\n    var isLoadMoreVisible = $.contains(\n      document.documentElement,\n      this.$loadingMore[0]\n    );\n\n    if (this.loading || !isLoadMoreVisible) {\n      return;\n    }\n\n    var currentOffset = this.$results.offset().top +\n      this.$results.outerHeight(false);\n    var loadingMoreOffset = this.$loadingMore.offset().top +\n      this.$loadingMore.outerHeight(false);\n\n    if (currentOffset + 50 >= loadingMoreOffset) {\n      this.loadMore();\n    }\n  };\n\n  InfiniteScroll.prototype.loadMore = function () {\n    this.loading = true;\n\n    var params = $.extend({}, {page: 1}, this.lastParams);\n\n    params.page++;\n\n    this.trigger('query:append', params);\n  };\n\n  InfiniteScroll.prototype.showLoadingMore = function (_, data) {\n    return data.pagination && data.pagination.more;\n  };\n\n  InfiniteScroll.prototype.createLoadingMore = function () {\n    var $option = $(\n      '<li ' +\n      'class=\"select2-results__option select2-results__option--load-more\"' +\n      'role=\"option\" aria-disabled=\"true\"></li>'\n    );\n\n    var message = this.options.get('translations').get('loadingMore');\n\n    $option.html(message(this.lastParams));\n\n    return $option;\n  };\n\n  return InfiniteScroll;\n});\n\nS2.define('select2/dropdown/attachBody',[\n  'jquery',\n  '../utils'\n], function ($, Utils) {\n  function AttachBody (decorated, $element, options) {\n    this.$dropdownParent = $(options.get('dropdownParent') || document.body);\n\n    decorated.call(this, $element, options);\n  }\n\n  AttachBody.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('open', function () {\n      self._showDropdown();\n      self._attachPositioningHandler(container);\n\n      // Must bind after the results handlers to ensure correct sizing\n      self._bindContainerResultHandlers(container);\n    });\n\n    container.on('close', function () {\n      self._hideDropdown();\n      self._detachPositioningHandler(container);\n    });\n\n    this.$dropdownContainer.on('mousedown', function (evt) {\n      evt.stopPropagation();\n    });\n  };\n\n  AttachBody.prototype.destroy = function (decorated) {\n    decorated.call(this);\n\n    this.$dropdownContainer.remove();\n  };\n\n  AttachBody.prototype.position = function (decorated, $dropdown, $container) {\n    // Clone all of the container classes\n    $dropdown.attr('class', $container.attr('class'));\n\n    $dropdown.removeClass('select2');\n    $dropdown.addClass('select2-container--open');\n\n    $dropdown.css({\n      position: 'absolute',\n      top: -999999\n    });\n\n    this.$container = $container;\n  };\n\n  AttachBody.prototype.render = function (decorated) {\n    var $container = $('<span></span>');\n\n    var $dropdown = decorated.call(this);\n    $container.append($dropdown);\n\n    this.$dropdownContainer = $container;\n\n    return $container;\n  };\n\n  AttachBody.prototype._hideDropdown = function (decorated) {\n    this.$dropdownContainer.detach();\n  };\n\n  AttachBody.prototype._bindContainerResultHandlers =\n      function (decorated, container) {\n\n    // These should only be bound once\n    if (this._containerResultsHandlersBound) {\n      return;\n    }\n\n    var self = this;\n\n    container.on('results:all', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('results:append', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('results:message', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('select', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('unselect', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    this._containerResultsHandlersBound = true;\n  };\n\n  AttachBody.prototype._attachPositioningHandler =\n      function (decorated, container) {\n    var self = this;\n\n    var scrollEvent = 'scroll.select2.' + container.id;\n    var resizeEvent = 'resize.select2.' + container.id;\n    var orientationEvent = 'orientationchange.select2.' + container.id;\n\n    var $watchers = this.$container.parents().filter(Utils.hasScroll);\n    $watchers.each(function () {\n      Utils.StoreData(this, 'select2-scroll-position', {\n        x: $(this).scrollLeft(),\n        y: $(this).scrollTop()\n      });\n    });\n\n    $watchers.on(scrollEvent, function (ev) {\n      var position = Utils.GetData(this, 'select2-scroll-position');\n      $(this).scrollTop(position.y);\n    });\n\n    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,\n      function (e) {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n  };\n\n  AttachBody.prototype._detachPositioningHandler =\n      function (decorated, container) {\n    var scrollEvent = 'scroll.select2.' + container.id;\n    var resizeEvent = 'resize.select2.' + container.id;\n    var orientationEvent = 'orientationchange.select2.' + container.id;\n\n    var $watchers = this.$container.parents().filter(Utils.hasScroll);\n    $watchers.off(scrollEvent);\n\n    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);\n  };\n\n  AttachBody.prototype._positionDropdown = function () {\n    var $window = $(window);\n\n    var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');\n    var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');\n\n    var newDirection = null;\n\n    var offset = this.$container.offset();\n\n    offset.bottom = offset.top + this.$container.outerHeight(false);\n\n    var container = {\n      height: this.$container.outerHeight(false)\n    };\n\n    container.top = offset.top;\n    container.bottom = offset.top + container.height;\n\n    var dropdown = {\n      height: this.$dropdown.outerHeight(false)\n    };\n\n    var viewport = {\n      top: $window.scrollTop(),\n      bottom: $window.scrollTop() + $window.height()\n    };\n\n    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);\n    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);\n\n    var css = {\n      left: offset.left,\n      top: container.bottom\n    };\n\n    // Determine what the parent element is to use for calculating the offset\n    var $offsetParent = this.$dropdownParent;\n\n    // For statically positioned elements, we need to get the element\n    // that is determining the offset\n    if ($offsetParent.css('position') === 'static') {\n      $offsetParent = $offsetParent.offsetParent();\n    }\n\n    var parentOffset = {\n      top: 0,\n      left: 0\n    };\n\n    if (\n      $.contains(document.body, $offsetParent[0]) ||\n      $offsetParent[0].isConnected\n      ) {\n      parentOffset = $offsetParent.offset();\n    }\n\n    css.top -= parentOffset.top;\n    css.left -= parentOffset.left;\n\n    if (!isCurrentlyAbove && !isCurrentlyBelow) {\n      newDirection = 'below';\n    }\n\n    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {\n      newDirection = 'above';\n    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {\n      newDirection = 'below';\n    }\n\n    if (newDirection == 'above' ||\n      (isCurrentlyAbove && newDirection !== 'below')) {\n      css.top = container.top - parentOffset.top - dropdown.height;\n    }\n\n    if (newDirection != null) {\n      this.$dropdown\n        .removeClass('select2-dropdown--below select2-dropdown--above')\n        .addClass('select2-dropdown--' + newDirection);\n      this.$container\n        .removeClass('select2-container--below select2-container--above')\n        .addClass('select2-container--' + newDirection);\n    }\n\n    this.$dropdownContainer.css(css);\n  };\n\n  AttachBody.prototype._resizeDropdown = function () {\n    var css = {\n      width: this.$container.outerWidth(false) + 'px'\n    };\n\n    if (this.options.get('dropdownAutoWidth')) {\n      css.minWidth = css.width;\n      css.position = 'relative';\n      css.width = 'auto';\n    }\n\n    this.$dropdown.css(css);\n  };\n\n  AttachBody.prototype._showDropdown = function (decorated) {\n    this.$dropdownContainer.appendTo(this.$dropdownParent);\n\n    this._positionDropdown();\n    this._resizeDropdown();\n  };\n\n  return AttachBody;\n});\n\nS2.define('select2/dropdown/minimumResultsForSearch',[\n\n], function () {\n  function countResults (data) {\n    var count = 0;\n\n    for (var d = 0; d < data.length; d++) {\n      var item = data[d];\n\n      if (item.children) {\n        count += countResults(item.children);\n      } else {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {\n    this.minimumResultsForSearch = options.get('minimumResultsForSearch');\n\n    if (this.minimumResultsForSearch < 0) {\n      this.minimumResultsForSearch = Infinity;\n    }\n\n    decorated.call(this, $element, options, dataAdapter);\n  }\n\n  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {\n    if (countResults(params.data.results) < this.minimumResultsForSearch) {\n      return false;\n    }\n\n    return decorated.call(this, params);\n  };\n\n  return MinimumResultsForSearch;\n});\n\nS2.define('select2/dropdown/selectOnClose',[\n  '../utils'\n], function (Utils) {\n  function SelectOnClose () { }\n\n  SelectOnClose.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('close', function (params) {\n      self._handleSelectOnClose(params);\n    });\n  };\n\n  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {\n    if (params && params.originalSelect2Event != null) {\n      var event = params.originalSelect2Event;\n\n      // Don't select an item if the close event was triggered from a select or\n      // unselect event\n      if (event._type === 'select' || event._type === 'unselect') {\n        return;\n      }\n    }\n\n    var $highlightedResults = this.getHighlightedResults();\n\n    // Only select highlighted results\n    if ($highlightedResults.length < 1) {\n      return;\n    }\n\n    var data = Utils.GetData($highlightedResults[0], 'data');\n\n    // Don't re-select already selected resulte\n    if (\n      (data.element != null && data.element.selected) ||\n      (data.element == null && data.selected)\n    ) {\n      return;\n    }\n\n    this.trigger('select', {\n        data: data\n    });\n  };\n\n  return SelectOnClose;\n});\n\nS2.define('select2/dropdown/closeOnSelect',[\n\n], function () {\n  function CloseOnSelect () { }\n\n  CloseOnSelect.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('select', function (evt) {\n      self._selectTriggered(evt);\n    });\n\n    container.on('unselect', function (evt) {\n      self._selectTriggered(evt);\n    });\n  };\n\n  CloseOnSelect.prototype._selectTriggered = function (_, evt) {\n    var originalEvent = evt.originalEvent;\n\n    // Don't close if the control key is being held\n    if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {\n      return;\n    }\n\n    this.trigger('close', {\n      originalEvent: originalEvent,\n      originalSelect2Event: evt\n    });\n  };\n\n  return CloseOnSelect;\n});\n\nS2.define('select2/i18n/en',[],function () {\n  // English\n  return {\n    errorLoading: function () {\n      return 'The results could not be loaded.';\n    },\n    inputTooLong: function (args) {\n      var overChars = args.input.length - args.maximum;\n\n      var message = 'Please delete ' + overChars + ' character';\n\n      if (overChars != 1) {\n        message += 's';\n      }\n\n      return message;\n    },\n    inputTooShort: function (args) {\n      var remainingChars = args.minimum - args.input.length;\n\n      var message = 'Please enter ' + remainingChars + ' or more characters';\n\n      return message;\n    },\n    loadingMore: function () {\n      return 'Loading more results…';\n    },\n    maximumSelected: function (args) {\n      var message = 'You can only select ' + args.maximum + ' item';\n\n      if (args.maximum != 1) {\n        message += 's';\n      }\n\n      return message;\n    },\n    noResults: function () {\n      return 'No results found';\n    },\n    searching: function () {\n      return 'Searching…';\n    },\n    removeAllItems: function () {\n      return 'Remove all items';\n    }\n  };\n});\n\nS2.define('select2/defaults',[\n  'jquery',\n  'require',\n\n  './results',\n\n  './selection/single',\n  './selection/multiple',\n  './selection/placeholder',\n  './selection/allowClear',\n  './selection/search',\n  './selection/eventRelay',\n\n  './utils',\n  './translation',\n  './diacritics',\n\n  './data/select',\n  './data/array',\n  './data/ajax',\n  './data/tags',\n  './data/tokenizer',\n  './data/minimumInputLength',\n  './data/maximumInputLength',\n  './data/maximumSelectionLength',\n\n  './dropdown',\n  './dropdown/search',\n  './dropdown/hidePlaceholder',\n  './dropdown/infiniteScroll',\n  './dropdown/attachBody',\n  './dropdown/minimumResultsForSearch',\n  './dropdown/selectOnClose',\n  './dropdown/closeOnSelect',\n\n  './i18n/en'\n], function ($, require,\n\n             ResultsList,\n\n             SingleSelection, MultipleSelection, Placeholder, AllowClear,\n             SelectionSearch, EventRelay,\n\n             Utils, Translation, DIACRITICS,\n\n             SelectData, ArrayData, AjaxData, Tags, Tokenizer,\n             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,\n\n             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,\n             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,\n\n             EnglishTranslation) {\n  function Defaults () {\n    this.reset();\n  }\n\n  Defaults.prototype.apply = function (options) {\n    options = $.extend(true, {}, this.defaults, options);\n\n    if (options.dataAdapter == null) {\n      if (options.ajax != null) {\n        options.dataAdapter = AjaxData;\n      } else if (options.data != null) {\n        options.dataAdapter = ArrayData;\n      } else {\n        options.dataAdapter = SelectData;\n      }\n\n      if (options.minimumInputLength > 0) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          MinimumInputLength\n        );\n      }\n\n      if (options.maximumInputLength > 0) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          MaximumInputLength\n        );\n      }\n\n      if (options.maximumSelectionLength > 0) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          MaximumSelectionLength\n        );\n      }\n\n      if (options.tags) {\n        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);\n      }\n\n      if (options.tokenSeparators != null || options.tokenizer != null) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          Tokenizer\n        );\n      }\n\n      if (options.query != null) {\n        var Query = require(options.amdBase + 'compat/query');\n\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          Query\n        );\n      }\n\n      if (options.initSelection != null) {\n        var InitSelection = require(options.amdBase + 'compat/initSelection');\n\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          InitSelection\n        );\n      }\n    }\n\n    if (options.resultsAdapter == null) {\n      options.resultsAdapter = ResultsList;\n\n      if (options.ajax != null) {\n        options.resultsAdapter = Utils.Decorate(\n          options.resultsAdapter,\n          InfiniteScroll\n        );\n      }\n\n      if (options.placeholder != null) {\n        options.resultsAdapter = Utils.Decorate(\n          options.resultsAdapter,\n          HidePlaceholder\n        );\n      }\n\n      if (options.selectOnClose) {\n        options.resultsAdapter = Utils.Decorate(\n          options.resultsAdapter,\n          SelectOnClose\n        );\n      }\n    }\n\n    if (options.dropdownAdapter == null) {\n      if (options.multiple) {\n        options.dropdownAdapter = Dropdown;\n      } else {\n        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);\n\n        options.dropdownAdapter = SearchableDropdown;\n      }\n\n      if (options.minimumResultsForSearch !== 0) {\n        options.dropdownAdapter = Utils.Decorate(\n          options.dropdownAdapter,\n          MinimumResultsForSearch\n        );\n      }\n\n      if (options.closeOnSelect) {\n        options.dropdownAdapter = Utils.Decorate(\n          options.dropdownAdapter,\n          CloseOnSelect\n        );\n      }\n\n      if (\n        options.dropdownCssClass != null ||\n        options.dropdownCss != null ||\n        options.adaptDropdownCssClass != null\n      ) {\n        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');\n\n        options.dropdownAdapter = Utils.Decorate(\n          options.dropdownAdapter,\n          DropdownCSS\n        );\n      }\n\n      options.dropdownAdapter = Utils.Decorate(\n        options.dropdownAdapter,\n        AttachBody\n      );\n    }\n\n    if (options.selectionAdapter == null) {\n      if (options.multiple) {\n        options.selectionAdapter = MultipleSelection;\n      } else {\n        options.selectionAdapter = SingleSelection;\n      }\n\n      // Add the placeholder mixin if a placeholder was specified\n      if (options.placeholder != null) {\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          Placeholder\n        );\n      }\n\n      if (options.allowClear) {\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          AllowClear\n        );\n      }\n\n      if (options.multiple) {\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          SelectionSearch\n        );\n      }\n\n      if (\n        options.containerCssClass != null ||\n        options.containerCss != null ||\n        options.adaptContainerCssClass != null\n      ) {\n        var ContainerCSS = require(options.amdBase + 'compat/containerCss');\n\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          ContainerCSS\n        );\n      }\n\n      options.selectionAdapter = Utils.Decorate(\n        options.selectionAdapter,\n        EventRelay\n      );\n    }\n\n    // If the defaults were not previously applied from an element, it is\n    // possible for the language option to have not been resolved\n    options.language = this._resolveLanguage(options.language);\n\n    // Always fall back to English since it will always be complete\n    options.language.push('en');\n\n    var uniqueLanguages = [];\n\n    for (var l = 0; l < options.language.length; l++) {\n      var language = options.language[l];\n\n      if (uniqueLanguages.indexOf(language) === -1) {\n        uniqueLanguages.push(language);\n      }\n    }\n\n    options.language = uniqueLanguages;\n\n    options.translations = this._processTranslations(\n      options.language,\n      options.debug\n    );\n\n    return options;\n  };\n\n  Defaults.prototype.reset = function () {\n    function stripDiacritics (text) {\n      // Used 'uni range + named function' from http://jsperf.com/diacritics/18\n      function match(a) {\n        return DIACRITICS[a] || a;\n      }\n\n      return text.replace(/[^\\u0000-\\u007E]/g, match);\n    }\n\n    function matcher (params, data) {\n      // Always return the object if there is nothing to compare\n      if ($.trim(params.term) === '') {\n        return data;\n      }\n\n      // Do a recursive check for options with children\n      if (data.children && data.children.length > 0) {\n        // Clone the data object if there are children\n        // This is required as we modify the object to remove any non-matches\n        var match = $.extend(true, {}, data);\n\n        // Check each child of the option\n        for (var c = data.children.length - 1; c >= 0; c--) {\n          var child = data.children[c];\n\n          var matches = matcher(params, child);\n\n          // If there wasn't a match, remove the object in the array\n          if (matches == null) {\n            match.children.splice(c, 1);\n          }\n        }\n\n        // If any children matched, return the new object\n        if (match.children.length > 0) {\n          return match;\n        }\n\n        // If there were no matching children, check just the plain object\n        return matcher(params, match);\n      }\n\n      var original = stripDiacritics(data.text).toUpperCase();\n      var term = stripDiacritics(params.term).toUpperCase();\n\n      // Check if the text contains the term\n      if (original.indexOf(term) > -1) {\n        return data;\n      }\n\n      // If it doesn't contain the term, don't return anything\n      return null;\n    }\n\n    this.defaults = {\n      amdBase: './',\n      amdLanguageBase: './i18n/',\n      closeOnSelect: true,\n      debug: false,\n      dropdownAutoWidth: false,\n      escapeMarkup: Utils.escapeMarkup,\n      language: {},\n      matcher: matcher,\n      minimumInputLength: 0,\n      maximumInputLength: 0,\n      maximumSelectionLength: 0,\n      minimumResultsForSearch: 0,\n      selectOnClose: false,\n      scrollAfterSelect: false,\n      sorter: function (data) {\n        return data;\n      },\n      templateResult: function (result) {\n        return result.text;\n      },\n      templateSelection: function (selection) {\n        return selection.text;\n      },\n      theme: 'default',\n      width: 'resolve'\n    };\n  };\n\n  Defaults.prototype.applyFromElement = function (options, $element) {\n    var optionLanguage = options.language;\n    var defaultLanguage = this.defaults.language;\n    var elementLanguage = $element.prop('lang');\n    var parentLanguage = $element.closest('[lang]').prop('lang');\n\n    var languages = Array.prototype.concat.call(\n      this._resolveLanguage(elementLanguage),\n      this._resolveLanguage(optionLanguage),\n      this._resolveLanguage(defaultLanguage),\n      this._resolveLanguage(parentLanguage)\n    );\n\n    options.language = languages;\n\n    return options;\n  };\n\n  Defaults.prototype._resolveLanguage = function (language) {\n    if (!language) {\n      return [];\n    }\n\n    if ($.isEmptyObject(language)) {\n      return [];\n    }\n\n    if ($.isPlainObject(language)) {\n      return [language];\n    }\n\n    var languages;\n\n    if (!$.isArray(language)) {\n      languages = [language];\n    } else {\n      languages = language;\n    }\n\n    var resolvedLanguages = [];\n\n    for (var l = 0; l < languages.length; l++) {\n      resolvedLanguages.push(languages[l]);\n\n      if (typeof languages[l] === 'string' && languages[l].indexOf('-') > 0) {\n        // Extract the region information if it is included\n        var languageParts = languages[l].split('-');\n        var baseLanguage = languageParts[0];\n\n        resolvedLanguages.push(baseLanguage);\n      }\n    }\n\n    return resolvedLanguages;\n  };\n\n  Defaults.prototype._processTranslations = function (languages, debug) {\n    var translations = new Translation();\n\n    for (var l = 0; l < languages.length; l++) {\n      var languageData = new Translation();\n\n      var language = languages[l];\n\n      if (typeof language === 'string') {\n        try {\n          // Try to load it with the original name\n          languageData = Translation.loadPath(language);\n        } catch (e) {\n          try {\n            // If we couldn't load it, check if it wasn't the full path\n            language = this.defaults.amdLanguageBase + language;\n            languageData = Translation.loadPath(language);\n          } catch (ex) {\n            // The translation could not be loaded at all. Sometimes this is\n            // because of a configuration problem, other times this can be\n            // because of how Select2 helps load all possible translation files\n            if (debug && window.console && console.warn) {\n              console.warn(\n                'Select2: The language file for \"' + language + '\" could ' +\n                'not be automatically loaded. A fallback will be used instead.'\n              );\n            }\n          }\n        }\n      } else if ($.isPlainObject(language)) {\n        languageData = new Translation(language);\n      } else {\n        languageData = language;\n      }\n\n      translations.extend(languageData);\n    }\n\n    return translations;\n  };\n\n  Defaults.prototype.set = function (key, value) {\n    var camelKey = $.camelCase(key);\n\n    var data = {};\n    data[camelKey] = value;\n\n    var convertedData = Utils._convertData(data);\n\n    $.extend(true, this.defaults, convertedData);\n  };\n\n  var defaults = new Defaults();\n\n  return defaults;\n});\n\nS2.define('select2/options',[\n  'require',\n  'jquery',\n  './defaults',\n  './utils'\n], function (require, $, Defaults, Utils) {\n  function Options (options, $element) {\n    this.options = options;\n\n    if ($element != null) {\n      this.fromElement($element);\n    }\n\n    if ($element != null) {\n      this.options = Defaults.applyFromElement(this.options, $element);\n    }\n\n    this.options = Defaults.apply(this.options);\n\n    if ($element && $element.is('input')) {\n      var InputCompat = require(this.get('amdBase') + 'compat/inputData');\n\n      this.options.dataAdapter = Utils.Decorate(\n        this.options.dataAdapter,\n        InputCompat\n      );\n    }\n  }\n\n  Options.prototype.fromElement = function ($e) {\n    var excludedData = ['select2'];\n\n    if (this.options.multiple == null) {\n      this.options.multiple = $e.prop('multiple');\n    }\n\n    if (this.options.disabled == null) {\n      this.options.disabled = $e.prop('disabled');\n    }\n\n    if (this.options.dir == null) {\n      if ($e.prop('dir')) {\n        this.options.dir = $e.prop('dir');\n      } else if ($e.closest('[dir]').prop('dir')) {\n        this.options.dir = $e.closest('[dir]').prop('dir');\n      } else {\n        this.options.dir = 'ltr';\n      }\n    }\n\n    $e.prop('disabled', this.options.disabled);\n    $e.prop('multiple', this.options.multiple);\n\n    if (Utils.GetData($e[0], 'select2Tags')) {\n      if (this.options.debug && window.console && console.warn) {\n        console.warn(\n          'Select2: The `data-select2-tags` attribute has been changed to ' +\n          'use the `data-data` and `data-tags=\"true\"` attributes and will be ' +\n          'removed in future versions of Select2.'\n        );\n      }\n\n      Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));\n      Utils.StoreData($e[0], 'tags', true);\n    }\n\n    if (Utils.GetData($e[0], 'ajaxUrl')) {\n      if (this.options.debug && window.console && console.warn) {\n        console.warn(\n          'Select2: The `data-ajax-url` attribute has been changed to ' +\n          '`data-ajax--url` and support for the old attribute will be removed' +\n          ' in future versions of Select2.'\n        );\n      }\n\n      $e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));\n      Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));\n    }\n\n    var dataset = {};\n\n    function upperCaseLetter(_, letter) {\n      return letter.toUpperCase();\n    }\n\n    // Pre-load all of the attributes which are prefixed with `data-`\n    for (var attr = 0; attr < $e[0].attributes.length; attr++) {\n      var attributeName = $e[0].attributes[attr].name;\n      var prefix = 'data-';\n\n      if (attributeName.substr(0, prefix.length) == prefix) {\n        // Get the contents of the attribute after `data-`\n        var dataName = attributeName.substring(prefix.length);\n\n        // Get the data contents from the consistent source\n        // This is more than likely the jQuery data helper\n        var dataValue = Utils.GetData($e[0], dataName);\n\n        // camelCase the attribute name to match the spec\n        var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);\n\n        // Store the data attribute contents into the dataset since\n        dataset[camelDataName] = dataValue;\n      }\n    }\n\n    // Prefer the element's `dataset` attribute if it exists\n    // jQuery 1.x does not correctly handle data attributes with multiple dashes\n    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {\n      dataset = $.extend(true, {}, $e[0].dataset, dataset);\n    }\n\n    // Prefer our internal data cache if it exists\n    var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);\n\n    data = Utils._convertData(data);\n\n    for (var key in data) {\n      if ($.inArray(key, excludedData) > -1) {\n        continue;\n      }\n\n      if ($.isPlainObject(this.options[key])) {\n        $.extend(this.options[key], data[key]);\n      } else {\n        this.options[key] = data[key];\n      }\n    }\n\n    return this;\n  };\n\n  Options.prototype.get = function (key) {\n    return this.options[key];\n  };\n\n  Options.prototype.set = function (key, val) {\n    this.options[key] = val;\n  };\n\n  return Options;\n});\n\nS2.define('select2/core',[\n  'jquery',\n  './options',\n  './utils',\n  './keys'\n], function ($, Options, Utils, KEYS) {\n  var Select2 = function ($element, options) {\n    if (Utils.GetData($element[0], 'select2') != null) {\n      Utils.GetData($element[0], 'select2').destroy();\n    }\n\n    this.$element = $element;\n\n    this.id = this._generateId($element);\n\n    options = options || {};\n\n    this.options = new Options(options, $element);\n\n    Select2.__super__.constructor.call(this);\n\n    // Set up the tabindex\n\n    var tabindex = $element.attr('tabindex') || 0;\n    Utils.StoreData($element[0], 'old-tabindex', tabindex);\n    $element.attr('tabindex', '-1');\n\n    // Set up containers and adapters\n\n    var DataAdapter = this.options.get('dataAdapter');\n    this.dataAdapter = new DataAdapter($element, this.options);\n\n    var $container = this.render();\n\n    this._placeContainer($container);\n\n    var SelectionAdapter = this.options.get('selectionAdapter');\n    this.selection = new SelectionAdapter($element, this.options);\n    this.$selection = this.selection.render();\n\n    this.selection.position(this.$selection, $container);\n\n    var DropdownAdapter = this.options.get('dropdownAdapter');\n    this.dropdown = new DropdownAdapter($element, this.options);\n    this.$dropdown = this.dropdown.render();\n\n    this.dropdown.position(this.$dropdown, $container);\n\n    var ResultsAdapter = this.options.get('resultsAdapter');\n    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);\n    this.$results = this.results.render();\n\n    this.results.position(this.$results, this.$dropdown);\n\n    // Bind events\n\n    var self = this;\n\n    // Bind the container to all of the adapters\n    this._bindAdapters();\n\n    // Register any DOM event handlers\n    this._registerDomEvents();\n\n    // Register any internal event handlers\n    this._registerDataEvents();\n    this._registerSelectionEvents();\n    this._registerDropdownEvents();\n    this._registerResultsEvents();\n    this._registerEvents();\n\n    // Set the initial state\n    this.dataAdapter.current(function (initialData) {\n      self.trigger('selection:update', {\n        data: initialData\n      });\n    });\n\n    // Hide the original select\n    $element.addClass('select2-hidden-accessible');\n    $element.attr('aria-hidden', 'true');\n\n    // Synchronize any monitored attributes\n    this._syncAttributes();\n\n    Utils.StoreData($element[0], 'select2', this);\n\n    // Ensure backwards compatibility with $element.data('select2').\n    $element.data('select2', this);\n  };\n\n  Utils.Extend(Select2, Utils.Observable);\n\n  Select2.prototype._generateId = function ($element) {\n    var id = '';\n\n    if ($element.attr('id') != null) {\n      id = $element.attr('id');\n    } else if ($element.attr('name') != null) {\n      id = $element.attr('name') + '-' + Utils.generateChars(2);\n    } else {\n      id = Utils.generateChars(4);\n    }\n\n    id = id.replace(/(:|\\.|\\[|\\]|,)/g, '');\n    id = 'select2-' + id;\n\n    return id;\n  };\n\n  Select2.prototype._placeContainer = function ($container) {\n    $container.insertAfter(this.$element);\n\n    var width = this._resolveWidth(this.$element, this.options.get('width'));\n\n    if (width != null) {\n      $container.css('width', width);\n    }\n  };\n\n  Select2.prototype._resolveWidth = function ($element, method) {\n    var WIDTH = /^width:(([-+]?([0-9]*\\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;\n\n    if (method == 'resolve') {\n      var styleWidth = this._resolveWidth($element, 'style');\n\n      if (styleWidth != null) {\n        return styleWidth;\n      }\n\n      return this._resolveWidth($element, 'element');\n    }\n\n    if (method == 'element') {\n      var elementWidth = $element.outerWidth(false);\n\n      if (elementWidth <= 0) {\n        return 'auto';\n      }\n\n      return elementWidth + 'px';\n    }\n\n    if (method == 'style') {\n      var style = $element.attr('style');\n\n      if (typeof(style) !== 'string') {\n        return null;\n      }\n\n      var attrs = style.split(';');\n\n      for (var i = 0, l = attrs.length; i < l; i = i + 1) {\n        var attr = attrs[i].replace(/\\s/g, '');\n        var matches = attr.match(WIDTH);\n\n        if (matches !== null && matches.length >= 1) {\n          return matches[1];\n        }\n      }\n\n      return null;\n    }\n\n    if (method == 'computedstyle') {\n      var computedStyle = window.getComputedStyle($element[0]);\n\n      return computedStyle.width;\n    }\n\n    return method;\n  };\n\n  Select2.prototype._bindAdapters = function () {\n    this.dataAdapter.bind(this, this.$container);\n    this.selection.bind(this, this.$container);\n\n    this.dropdown.bind(this, this.$container);\n    this.results.bind(this, this.$container);\n  };\n\n  Select2.prototype._registerDomEvents = function () {\n    var self = this;\n\n    this.$element.on('change.select2', function () {\n      self.dataAdapter.current(function (data) {\n        self.trigger('selection:update', {\n          data: data\n        });\n      });\n    });\n\n    this.$element.on('focus.select2', function (evt) {\n      self.trigger('focus', evt);\n    });\n\n    this._syncA = Utils.bind(this._syncAttributes, this);\n    this._syncS = Utils.bind(this._syncSubtree, this);\n\n    if (this.$element[0].attachEvent) {\n      this.$element[0].attachEvent('onpropertychange', this._syncA);\n    }\n\n    var observer = window.MutationObserver ||\n      window.WebKitMutationObserver ||\n      window.MozMutationObserver\n    ;\n\n    if (observer != null) {\n      this._observer = new observer(function (mutations) {\n        self._syncA();\n        self._syncS(null, mutations);\n      });\n      this._observer.observe(this.$element[0], {\n        attributes: true,\n        childList: true,\n        subtree: false\n      });\n    } else if (this.$element[0].addEventListener) {\n      this.$element[0].addEventListener(\n        'DOMAttrModified',\n        self._syncA,\n        false\n      );\n      this.$element[0].addEventListener(\n        'DOMNodeInserted',\n        self._syncS,\n        false\n      );\n      this.$element[0].addEventListener(\n        'DOMNodeRemoved',\n        self._syncS,\n        false\n      );\n    }\n  };\n\n  Select2.prototype._registerDataEvents = function () {\n    var self = this;\n\n    this.dataAdapter.on('*', function (name, params) {\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerSelectionEvents = function () {\n    var self = this;\n    var nonRelayEvents = ['toggle', 'focus'];\n\n    this.selection.on('toggle', function () {\n      self.toggleDropdown();\n    });\n\n    this.selection.on('focus', function (params) {\n      self.focus(params);\n    });\n\n    this.selection.on('*', function (name, params) {\n      if ($.inArray(name, nonRelayEvents) !== -1) {\n        return;\n      }\n\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerDropdownEvents = function () {\n    var self = this;\n\n    this.dropdown.on('*', function (name, params) {\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerResultsEvents = function () {\n    var self = this;\n\n    this.results.on('*', function (name, params) {\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerEvents = function () {\n    var self = this;\n\n    this.on('open', function () {\n      self.$container.addClass('select2-container--open');\n    });\n\n    this.on('close', function () {\n      self.$container.removeClass('select2-container--open');\n    });\n\n    this.on('enable', function () {\n      self.$container.removeClass('select2-container--disabled');\n    });\n\n    this.on('disable', function () {\n      self.$container.addClass('select2-container--disabled');\n    });\n\n    this.on('blur', function () {\n      self.$container.removeClass('select2-container--focus');\n    });\n\n    this.on('query', function (params) {\n      if (!self.isOpen()) {\n        self.trigger('open', {});\n      }\n\n      this.dataAdapter.query(params, function (data) {\n        self.trigger('results:all', {\n          data: data,\n          query: params\n        });\n      });\n    });\n\n    this.on('query:append', function (params) {\n      this.dataAdapter.query(params, function (data) {\n        self.trigger('results:append', {\n          data: data,\n          query: params\n        });\n      });\n    });\n\n    this.on('keypress', function (evt) {\n      var key = evt.which;\n\n      if (self.isOpen()) {\n        if (key === KEYS.ESC || key === KEYS.TAB ||\n            (key === KEYS.UP && evt.altKey)) {\n          self.close(evt);\n\n          evt.preventDefault();\n        } else if (key === KEYS.ENTER) {\n          self.trigger('results:select', {});\n\n          evt.preventDefault();\n        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {\n          self.trigger('results:toggle', {});\n\n          evt.preventDefault();\n        } else if (key === KEYS.UP) {\n          self.trigger('results:previous', {});\n\n          evt.preventDefault();\n        } else if (key === KEYS.DOWN) {\n          self.trigger('results:next', {});\n\n          evt.preventDefault();\n        }\n      } else {\n        if (key === KEYS.ENTER || key === KEYS.SPACE ||\n            (key === KEYS.DOWN && evt.altKey)) {\n          self.open();\n\n          evt.preventDefault();\n        }\n      }\n    });\n  };\n\n  Select2.prototype._syncAttributes = function () {\n    this.options.set('disabled', this.$element.prop('disabled'));\n\n    if (this.isDisabled()) {\n      if (this.isOpen()) {\n        this.close();\n      }\n\n      this.trigger('disable', {});\n    } else {\n      this.trigger('enable', {});\n    }\n  };\n\n  Select2.prototype._isChangeMutation = function (evt, mutations) {\n    var changed = false;\n    var self = this;\n\n    // Ignore any mutation events raised for elements that aren't options or\n    // optgroups. This handles the case when the select element is destroyed\n    if (\n      evt && evt.target && (\n        evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'\n      )\n    ) {\n      return;\n    }\n\n    if (!mutations) {\n      // If mutation events aren't supported, then we can only assume that the\n      // change affected the selections\n      changed = true;\n    } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {\n      for (var n = 0; n < mutations.addedNodes.length; n++) {\n        var node = mutations.addedNodes[n];\n\n        if (node.selected) {\n          changed = true;\n        }\n      }\n    } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {\n      changed = true;\n    } else if ($.isArray(mutations)) {\n      $.each(mutations, function(evt, mutation) {\n        if (self._isChangeMutation(evt, mutation)) {\n          // We've found a change mutation.\n          // Let's escape from the loop and continue\n          changed = true;\n          return false;\n        }\n      });\n    }\n    return changed;\n  };\n\n  Select2.prototype._syncSubtree = function (evt, mutations) {\n    var changed = this._isChangeMutation(evt, mutations);\n    var self = this;\n\n    // Only re-pull the data if we think there is a change\n    if (changed) {\n      this.dataAdapter.current(function (currentData) {\n        self.trigger('selection:update', {\n          data: currentData\n        });\n      });\n    }\n  };\n\n  /**\n   * Override the trigger method to automatically trigger pre-events when\n   * there are events that can be prevented.\n   */\n  Select2.prototype.trigger = function (name, args) {\n    var actualTrigger = Select2.__super__.trigger;\n    var preTriggerMap = {\n      'open': 'opening',\n      'close': 'closing',\n      'select': 'selecting',\n      'unselect': 'unselecting',\n      'clear': 'clearing'\n    };\n\n    if (args === undefined) {\n      args = {};\n    }\n\n    if (name in preTriggerMap) {\n      var preTriggerName = preTriggerMap[name];\n      var preTriggerArgs = {\n        prevented: false,\n        name: name,\n        args: args\n      };\n\n      actualTrigger.call(this, preTriggerName, preTriggerArgs);\n\n      if (preTriggerArgs.prevented) {\n        args.prevented = true;\n\n        return;\n      }\n    }\n\n    actualTrigger.call(this, name, args);\n  };\n\n  Select2.prototype.toggleDropdown = function () {\n    if (this.isDisabled()) {\n      return;\n    }\n\n    if (this.isOpen()) {\n      this.close();\n    } else {\n      this.open();\n    }\n  };\n\n  Select2.prototype.open = function () {\n    if (this.isOpen()) {\n      return;\n    }\n\n    if (this.isDisabled()) {\n      return;\n    }\n\n    this.trigger('query', {});\n  };\n\n  Select2.prototype.close = function (evt) {\n    if (!this.isOpen()) {\n      return;\n    }\n\n    this.trigger('close', { originalEvent : evt });\n  };\n\n  /**\n   * Helper method to abstract the \"enabled\" (not \"disabled\") state of this\n   * object.\n   *\n   * @return {true} if the instance is not disabled.\n   * @return {false} if the instance is disabled.\n   */\n  Select2.prototype.isEnabled = function () {\n    return !this.isDisabled();\n  };\n\n  /**\n   * Helper method to abstract the \"disabled\" state of this object.\n   *\n   * @return {true} if the disabled option is true.\n   * @return {false} if the disabled option is false.\n   */\n  Select2.prototype.isDisabled = function () {\n    return this.options.get('disabled');\n  };\n\n  Select2.prototype.isOpen = function () {\n    return this.$container.hasClass('select2-container--open');\n  };\n\n  Select2.prototype.hasFocus = function () {\n    return this.$container.hasClass('select2-container--focus');\n  };\n\n  Select2.prototype.focus = function (data) {\n    // No need to re-trigger focus events if we are already focused\n    if (this.hasFocus()) {\n      return;\n    }\n\n    this.$container.addClass('select2-container--focus');\n    this.trigger('focus', {});\n  };\n\n  Select2.prototype.enable = function (args) {\n    if (this.options.get('debug') && window.console && console.warn) {\n      console.warn(\n        'Select2: The `select2(\"enable\")` method has been deprecated and will' +\n        ' be removed in later Select2 versions. Use $element.prop(\"disabled\")' +\n        ' instead.'\n      );\n    }\n\n    if (args == null || args.length === 0) {\n      args = [true];\n    }\n\n    var disabled = !args[0];\n\n    this.$element.prop('disabled', disabled);\n  };\n\n  Select2.prototype.data = function () {\n    if (this.options.get('debug') &&\n        arguments.length > 0 && window.console && console.warn) {\n      console.warn(\n        'Select2: Data can no longer be set using `select2(\"data\")`. You ' +\n        'should consider setting the value instead using `$element.val()`.'\n      );\n    }\n\n    var data = [];\n\n    this.dataAdapter.current(function (currentData) {\n      data = currentData;\n    });\n\n    return data;\n  };\n\n  Select2.prototype.val = function (args) {\n    if (this.options.get('debug') && window.console && console.warn) {\n      console.warn(\n        'Select2: The `select2(\"val\")` method has been deprecated and will be' +\n        ' removed in later Select2 versions. Use $element.val() instead.'\n      );\n    }\n\n    if (args == null || args.length === 0) {\n      return this.$element.val();\n    }\n\n    var newVal = args[0];\n\n    if ($.isArray(newVal)) {\n      newVal = $.map(newVal, function (obj) {\n        return obj.toString();\n      });\n    }\n\n    this.$element.val(newVal).trigger('input').trigger('change');\n  };\n\n  Select2.prototype.destroy = function () {\n    this.$container.remove();\n\n    if (this.$element[0].detachEvent) {\n      this.$element[0].detachEvent('onpropertychange', this._syncA);\n    }\n\n    if (this._observer != null) {\n      this._observer.disconnect();\n      this._observer = null;\n    } else if (this.$element[0].removeEventListener) {\n      this.$element[0]\n        .removeEventListener('DOMAttrModified', this._syncA, false);\n      this.$element[0]\n        .removeEventListener('DOMNodeInserted', this._syncS, false);\n      this.$element[0]\n        .removeEventListener('DOMNodeRemoved', this._syncS, false);\n    }\n\n    this._syncA = null;\n    this._syncS = null;\n\n    this.$element.off('.select2');\n    this.$element.attr('tabindex',\n    Utils.GetData(this.$element[0], 'old-tabindex'));\n\n    this.$element.removeClass('select2-hidden-accessible');\n    this.$element.attr('aria-hidden', 'false');\n    Utils.RemoveData(this.$element[0]);\n    this.$element.removeData('select2');\n\n    this.dataAdapter.destroy();\n    this.selection.destroy();\n    this.dropdown.destroy();\n    this.results.destroy();\n\n    this.dataAdapter = null;\n    this.selection = null;\n    this.dropdown = null;\n    this.results = null;\n  };\n\n  Select2.prototype.render = function () {\n    var $container = $(\n      '<span class=\"select2 select2-container\">' +\n        '<span class=\"selection\"></span>' +\n        '<span class=\"dropdown-wrapper\" aria-hidden=\"true\"></span>' +\n      '</span>'\n    );\n\n    $container.attr('dir', this.options.get('dir'));\n\n    this.$container = $container;\n\n    this.$container.addClass('select2-container--' + this.options.get('theme'));\n\n    Utils.StoreData($container[0], 'element', this.$element);\n\n    return $container;\n  };\n\n  return Select2;\n});\n\nS2.define('jquery-mousewheel',[\n  'jquery'\n], function ($) {\n  // Used to shim jQuery.mousewheel for non-full builds.\n  return $;\n});\n\nS2.define('jquery.select2',[\n  'jquery',\n  'jquery-mousewheel',\n\n  './select2/core',\n  './select2/defaults',\n  './select2/utils'\n], function ($, _, Select2, Defaults, Utils) {\n  if ($.fn.select2 == null) {\n    // All methods that should return the element\n    var thisMethods = ['open', 'close', 'destroy'];\n\n    $.fn.select2 = function (options) {\n      options = options || {};\n\n      if (typeof options === 'object') {\n        this.each(function () {\n          var instanceOptions = $.extend(true, {}, options);\n\n          var instance = new Select2($(this), instanceOptions);\n        });\n\n        return this;\n      } else if (typeof options === 'string') {\n        var ret;\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        this.each(function () {\n          var instance = Utils.GetData(this, 'select2');\n\n          if (instance == null && window.console && console.error) {\n            console.error(\n              'The select2(\\'' + options + '\\') method was called on an ' +\n              'element that is not using Select2.'\n            );\n          }\n\n          ret = instance[options].apply(instance, args);\n        });\n\n        // Check if we should be returning `this`\n        if ($.inArray(options, thisMethods) > -1) {\n          return this;\n        }\n\n        return ret;\n      } else {\n        throw new Error('Invalid arguments for Select2: ' + options);\n      }\n    };\n  }\n\n  if ($.fn.select2.defaults == null) {\n    $.fn.select2.defaults = Defaults;\n  }\n\n  return Select2;\n});\n\n  // Return the AMD loader configuration so it can be used outside of this file\n  return {\n    define: S2.define,\n    require: S2.require\n  };\n}());\n\n  // Autoload the jQuery bindings\n  // We know that all of the modules exist above this, so we're safe\n  var select2 = S2.require('jquery.select2');\n\n  // Hold the AMD module references on the jQuery function that was just loaded\n  // This allows Select2 to use the internal loader outside of this file, such\n  // as in the language files.\n  jQuery.fn.select2.amd = S2;\n\n  // Return the Select2 instance for anyone who is importing it.\n  return select2;\n}));\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/***/ ((module) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js */ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///Users/johannes/Development/Libs/tutomvc/node_modules/source-map-loader/index.js!/Users/johannes/Development/Libs/tutomvc/node_modules/bootstrap-select/dist/js/bootstrap-select.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js */ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///Users/johannes/Development/Libs/tutomvc/node_modules/source-map-loader/index.js!/Users/johannes/Development/Libs/tutomvc/node_modules/bootstrap/dist/js/bootstrap.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/select2/dist/js/select2.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./node_modules/select2/dist/js/select2.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js */ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///Users/johannes/Development/Libs/tutomvc/node_modules/source-map-loader/index.js!/Users/johannes/Development/Libs/tutomvc/node_modules/select2/dist/js/select2.js")

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getTarget = function (target) {
  return document.querySelector(target);
};

var getElement = (function (fn) {
	var memo = {};

	return function(target) {
                // If passing function in options, then use it for resolve "head" element.
                // Useful for Shadow Root style i.e
                // {
                //   insertInto: function () { return document.querySelector("#foo").shadowRoot }
                // }
                if (typeof target === 'function') {
                        return target();
                }
                if (typeof memo[target] === "undefined") {
			var styleTarget = getTarget.call(this, target);
			// Special case to return head of iframe instead of iframe itself
			if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[target] = styleTarget;
		}
		return memo[target]
	};
})();

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
        if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	if(options.attrs.type === undefined) {
		options.attrs.type = "text/css";
	}
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/***/ ((module) => {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./src/scss/tutomvc.scss":
/*!*******************************!*\
  !*** ./src/scss/tutomvc.scss ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


var content = __webpack_require__(/*! !!../../node_modules/mini-css-extract-plugin/dist/loader.js!../../node_modules/css-loader/index.js??ruleSet[1].rules[2].use[2]!../../node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[2].use[3]!./tutomvc.scss */ "./node_modules/mini-css-extract-plugin/dist/loader.js!./node_modules/css-loader/index.js??ruleSet[1].rules[2].use[2]!./node_modules/sass-loader/dist/cjs.js??ruleSet[1].rules[2].use[3]!./src/scss/tutomvc.scss");

if(typeof content === 'string') content = [[module.id, content, '']];

var transform;
var insertInto;



var options = {"hmr":true}

options.transform = transform
options.insertInto = undefined;

var update = __webpack_require__(/*! !../../node_modules/style-loader/lib/addStyles.js */ "./node_modules/style-loader/lib/addStyles.js")(content, options);

if(content.locals) module.exports = content.locals;

if(false) {}

/***/ }),

/***/ "./src/tsc/plugins/jQueryWPAttachmentFormInput.ts":
/*!********************************************************!*\
  !*** ./src/tsc/plugins/jQueryWPAttachmentFormInput.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var WPAttachmentFormInput_1 = __webpack_require__(/*! ../wp/form/inputs/WPAttachmentFormInput */ "./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts");
jQuery(document).ready(function () {
    jQuery(".wpattachmentforminput").each(function () {
        new WPAttachmentFormInput_1.WPAttachmentFormInput(jQuery(this), jQuery(this).data());
    });
    //	jQuery( ".wpattachmentforminput .btn-remove" ).click( function ( e )
    //	{
    //		e.preventDefault();
    //		var $el = $( this );
    //		$el.closest( ".list-group-item" ).remove();
    //
    //		new WPAttachmentFormInput( $( $( this ).data( "target" ) ), "render" );
    //	} );
    //	jQuery( ".wpattachmentforminput .btn-add" ).click( function ( e )
    //	{
    //		new WPAttachmentFormInput( $( $( this ).data( "target" ) ), "open" );
    //	} );
});


/***/ }),

/***/ "./src/tsc/plugins/jQueryWPEditorFormInput.ts":
/*!****************************************************!*\
  !*** ./src/tsc/plugins/jQueryWPEditorFormInput.ts ***!
  \****************************************************/
/***/ (() => {

jQuery(function () {
    jQuery("body").on("click", ".wpeditor-placeholder-overlay", function (e) {
        var $currentTarget = e.currentTarget;
        var $el = jQuery($currentTarget.closest(".wpeditor-placeholder"));
        var content = $el.find("textarea").val();
        console.log(content);
        jQuery.ajax($el.data("ajax-url"), {
            data: {
                content: content,
                "id": $el.data("id"),
            },
            success: function (result) {
                console.log(result);
                $el.html(result.html);
                tinymce.init(result.settings);
                quicktags({ id: $el.data("id") });
                window.wpActiveEditor = $el.data("id");
            },
            error: function (error) { return console.error(error); }
        });
    });
});


/***/ }),

/***/ "./src/tsc/plugins/jQueryWPMetaBox.ts":
/*!********************************************!*\
  !*** ./src/tsc/plugins/jQueryWPMetaBox.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var MetaBox_1 = __webpack_require__(/*! ../wp/form/groups/MetaBox */ "./src/tsc/wp/form/groups/MetaBox.ts");
jQuery(function () {
    jQuery(".tutomvc-settings,.tutomvc-metabox,.tutomvc-user_metabox").each(function (i, el) {
        new MetaBox_1.MetaBox(jQuery(el));
    });
});


/***/ }),

/***/ "./src/tsc/wp/form/groups/MetaBox.ts":
/*!*******************************************!*\
  !*** ./src/tsc/wp/form/groups/MetaBox.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var WPAttachmentFormInput_1 = __webpack_require__(/*! ../inputs/WPAttachmentFormInput */ "./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts");
var MetaBox = /** @class */ (function () {
    function MetaBox($el) {
        var _this = this;
        this._$el = $el;
        this._$el.on("change", ".fissile-form-group-nuke", function (e) { return _this.parse(); });
        console.log("MetaBox");
        console.log(TutoMVC);
    }
    MetaBox.prototype.render = function (html) {
        this._$el.html(html);
        this._$el.find(".form-input-element.select2").each(function () {
            jQuery(this).select2(jQuery(this).data());
        });
        this._$el.find(".selectpicker").each(function () {
            jQuery(this).selectpicker(jQuery(this).data());
        });
        this._$el.find(".wpattachmentforminput").each(function () {
            new WPAttachmentFormInput_1.WPAttachmentFormInput(jQuery(this), jQuery(this).data());
        });
    };
    MetaBox.prototype.destroy = function () {
        this._$el.find("textarea.wp-editor-area").each(function (i, el) {
            console.log("DESOTRY:", jQuery(el).attr("id"));
            tinymce.remove("#" + jQuery(el).attr("id"));
            //			tinymce.execCommand( 'mceRemoveControl', true, jQuery( el ).attr( "id" ) );
        });
    };
    MetaBox.prototype.parse = function () {
        var _this = this;
        if (this.$form.length) {
            if (typeof tinymce !== 'undefined') {
                tinymce.triggerSave();
            }
            var data = new FormData(this.$form[0]);
            data.append("action", TutoMVC.parseAction);
            data.append("nonce", TutoMVC.parseNonce);
            var url = TutoMVC.parseURL + "&id=" + this.id + "&type=" + this.type;
            console.log(url);
            var ajaxRequest = jQuery.ajax(url, {
                data: data,
                method: "POST",
                contentType: false,
                processData: false,
                success: function (result) {
                    if (result) {
                        console.log(result);
                        var $metabox = jQuery(result);
                        _this.destroy();
                        _this.render($metabox.html());
                    }
                },
                error: function (result) { return console.error(result); }
            });
        }
    };
    Object.defineProperty(MetaBox.prototype, "id", {
        /* SET AND GET */
        get: function () {
            return this._$el.attr("id");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MetaBox.prototype, "$form", {
        get: function () {
            return jQuery(this._$el.closest("form"));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MetaBox.prototype, "type", {
        get: function () {
            if (this._$el.hasClass("tutomvc-metabox"))
                return "metabox";
            if (this._$el.hasClass("tutomvc-user_metabox"))
                return "user_metabox";
            if (this._$el.hasClass("tutomvc-settings"))
                return "settings";
        },
        enumerable: true,
        configurable: true
    });
    return MetaBox;
}());
exports.MetaBox = MetaBox;


/***/ }),

/***/ "./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts":
/*!*********************************************************!*\
  !*** ./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var WPAttachmentFormInput = /** @class */ (function () {
    function WPAttachmentFormInput($el, options) {
        var _this = this;
        this.options = {
            max: -1,
            title: "",
            buttonText: "",
            type: null,
            frame: "select"
        };
        this.$el = $el;
        // Model
        this.options = jQuery.extend({}, this.options, options);
        // View
        this.template = _.template(this.$el.find("textarea.underscore-template").val());
        this.wpMedia = wp.media({
            title: this.options.title,
            multiple: this.options.max < 0 || this.options.max > 1 ? true : false,
            library: this.options.type ? { type: this.options.type } : undefined,
            button: { text: this.options.buttonText },
            frame: this.options.frame
        });
        // Controller
        this.wpMedia.on("select", function () { return _this.onWPMediaSelect(); });
        this.$el.on("click", ".btn-add", function () { return _this.open(); });
        this.$el.on("click", ".btn-remove", function (e) { return _this.onRemoveClick(e); });
        this.render();
    }
    WPAttachmentFormInput.prototype.render = function () {
        if (this.count >= this.options.max && this.options.max >= 0)
            this.$el.find(".btn-add").prop("disabled", "disabled");
        else
            this.$el.find(".btn-add").prop("disabled", null);
    };
    WPAttachmentFormInput.prototype.open = function () {
        this.wpMedia.open();
    };
    ;
    WPAttachmentFormInput.prototype.add = function (attachmentModel) {
        attachmentModel.src = attachmentModel.icon;
        if (!attachmentModel.width)
            attachmentModel.width = "";
        if (!attachmentModel.height)
            attachmentModel.height = "";
        if (attachmentModel.sizes) {
            if (attachmentModel.sizes.thumbnail && attachmentModel.sizes.thumbnail.url) {
                attachmentModel.src = attachmentModel.sizes.thumbnail.url;
            }
            else if (attachmentModel.sizes.full && attachmentModel.sizes.full.url) {
                attachmentModel.src = attachmentModel.sizes.full.url;
            }
        }
        var $el = jQuery(this.template(attachmentModel));
        this.$el.find(".list-group").append($el);
    };
    ;
    Object.defineProperty(WPAttachmentFormInput.prototype, "count", {
        /* SET AND GET */
        get: function () {
            return this.$el.find(".list-group-item").length;
        },
        enumerable: true,
        configurable: true
    });
    /* EVENT HANDLERS */
    WPAttachmentFormInput.prototype.onWPMediaSelect = function () {
        var selection = this.wpMedia.state().get('selection');
        var __this = this;
        selection.each(function (attachment) {
            if (__this.options.max < 0 || __this.count < __this.options.max) {
                __this.add(attachment.toJSON());
            }
        });
        this.render();
    };
    ;
    WPAttachmentFormInput.prototype.onRemoveClick = function (e) {
        e.preventDefault();
        var $el = jQuery(e.currentTarget);
        $el.closest(".list-group-item").remove();
        this.render();
    };
    return WPAttachmentFormInput;
}());
exports.WPAttachmentFormInput = WPAttachmentFormInput;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!****************************!*\
  !*** ./src/tsc/tutomvc.ts ***!
  \****************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(/*! ../scss/tutomvc.scss */ "./src/scss/tutomvc.scss");
__webpack_require__(/*! script-loader!bootstrap/dist/js/bootstrap.js */ "./node_modules/script-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js");
__webpack_require__(/*! script-loader!select2/dist/js/select2.js */ "./node_modules/script-loader/index.js!./node_modules/select2/dist/js/select2.js");
__webpack_require__(/*! script-loader!bootstrap-select/dist/js/bootstrap-select.js */ "./node_modules/script-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js");
__webpack_require__(/*! ./plugins/jQueryWPAttachmentFormInput */ "./src/tsc/plugins/jQueryWPAttachmentFormInput.ts");
__webpack_require__(/*! ./plugins/jQueryWPEditorFormInput */ "./src/tsc/plugins/jQueryWPEditorFormInput.ts");
__webpack_require__(/*! ./plugins/jQueryWPMetaBox */ "./src/tsc/plugins/jQueryWPMetaBox.ts");
(function ($) {
    $(document).ready(function () {
        // Select2FormInput
        $(".form-input-element.select2").each(function () {
            $(this).select2($(this).data());
        });
    });
})(jQuery);
console.log("HELLO WORLD");

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDTCxDQUFDLENBQUMsQ0FBRSxNQUFNLENBQUUsQ0FBQztBQUViLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90dXRvbXZjLy4vc3JjL3Njc3MvdHV0b212Yy5zY3NzPzRhZTIiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAtc2VsZWN0L2Rpc3QvanMvYm9vdHN0cmFwLXNlbGVjdC5qcyIsIndlYnBhY2s6Ly90dXRvbXZjLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5qcyIsIndlYnBhY2s6Ly90dXRvbXZjLy4vbm9kZV9tb2R1bGVzL3NlbGVjdDIvZGlzdC9qcy9zZWxlY3QyLmpzIiwid2VicGFjazovL3R1dG9tdmMvLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAtc2VsZWN0L2Rpc3QvanMvYm9vdHN0cmFwLXNlbGVjdC5qcz9lOGY2Iiwid2VicGFjazovL3R1dG9tdmMvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzP2NjMTkiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL25vZGVfbW9kdWxlcy9zZWxlY3QyL2Rpc3QvanMvc2VsZWN0Mi5qcz82MmMzIiwid2VicGFjazovL3R1dG9tdmMvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXMuanMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL3NyYy9zY3NzL3R1dG9tdmMuc2Nzcz8xY2YyIiwid2VicGFjazovL3R1dG9tdmMvLi9zcmMvdHNjL3BsdWdpbnMvalF1ZXJ5V1BBdHRhY2htZW50Rm9ybUlucHV0LnRzIiwid2VicGFjazovL3R1dG9tdmMvLi9zcmMvdHNjL3BsdWdpbnMvalF1ZXJ5V1BFZGl0b3JGb3JtSW5wdXQudHMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL3NyYy90c2MvcGx1Z2lucy9qUXVlcnlXUE1ldGFCb3gudHMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL3NyYy90c2Mvd3AvZm9ybS9ncm91cHMvTWV0YUJveC50cyIsIndlYnBhY2s6Ly90dXRvbXZjLy4vc3JjL3RzYy93cC9mb3JtL2lucHV0cy9XUEF0dGFjaG1lbnRGb3JtSW5wdXQudHMiLCJ3ZWJwYWNrOi8vdHV0b212Yy93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90dXRvbXZjLy4vc3JjL3RzYy90dXRvbXZjLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiIsIm1vZHVsZS5leHBvcnRzID0gXCIvKiFcXHJcXG4gKiBCb290c3RyYXAtc2VsZWN0IHYxLjEzLjE4IChodHRwczovL2RldmVsb3Blci5zbmFwYXBwb2ludG1lbnRzLmNvbS9ib290c3RyYXAtc2VsZWN0KVxcclxcbiAqXFxyXFxuICogQ29weXJpZ2h0IDIwMTItMjAyMCBTbmFwQXBwb2ludG1lbnRzLCBMTENcXHJcXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS9zbmFwYXBwb2ludG1lbnRzL2Jvb3RzdHJhcC1zZWxlY3QvYmxvYi9tYXN0ZXIvTElDRU5TRSlcXHJcXG4gKi9cXHJcXG5cXHJcXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcXHJcXG4gIGlmIChyb290ID09PSB1bmRlZmluZWQgJiYgd2luZG93ICE9PSB1bmRlZmluZWQpIHJvb3QgPSB3aW5kb3c7XFxyXFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XFxyXFxuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZSB1bmxlc3MgYW1kTW9kdWxlSWQgaXMgc2V0XFxyXFxuICAgIGRlZmluZShbXFxcImpxdWVyeVxcXCJdLCBmdW5jdGlvbiAoYTApIHtcXHJcXG4gICAgICByZXR1cm4gKGZhY3RvcnkoYTApKTtcXHJcXG4gICAgfSk7XFxyXFxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XFxyXFxuICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxcclxcbiAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcXHJcXG4gICAgLy8gbGlrZSBOb2RlLlxcclxcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcXFwianF1ZXJ5XFxcIikpO1xcclxcbiAgfSBlbHNlIHtcXHJcXG4gICAgZmFjdG9yeShyb290W1xcXCJqUXVlcnlcXFwiXSk7XFxyXFxuICB9XFxyXFxufSh0aGlzLCBmdW5jdGlvbiAoalF1ZXJ5KSB7XFxyXFxuXFxyXFxuKGZ1bmN0aW9uICgkKSB7XFxyXFxuICAndXNlIHN0cmljdCc7XFxyXFxuXFxyXFxuICB2YXIgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gWydzYW5pdGl6ZScsICd3aGl0ZUxpc3QnLCAnc2FuaXRpemVGbiddO1xcclxcblxcclxcbiAgdmFyIHVyaUF0dHJzID0gW1xcclxcbiAgICAnYmFja2dyb3VuZCcsXFxyXFxuICAgICdjaXRlJyxcXHJcXG4gICAgJ2hyZWYnLFxcclxcbiAgICAnaXRlbXR5cGUnLFxcclxcbiAgICAnbG9uZ2Rlc2MnLFxcclxcbiAgICAncG9zdGVyJyxcXHJcXG4gICAgJ3NyYycsXFxyXFxuICAgICd4bGluazpocmVmJ1xcclxcbiAgXTtcXHJcXG5cXHJcXG4gIHZhciBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXFxcdy1dKiQvaTtcXHJcXG5cXHJcXG4gIHZhciBEZWZhdWx0V2hpdGVsaXN0ID0ge1xcclxcbiAgICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxcclxcbiAgICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsICd0YWJpbmRleCcsICdzdHlsZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxcclxcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxcclxcbiAgICBhcmVhOiBbXSxcXHJcXG4gICAgYjogW10sXFxyXFxuICAgIGJyOiBbXSxcXHJcXG4gICAgY29sOiBbXSxcXHJcXG4gICAgY29kZTogW10sXFxyXFxuICAgIGRpdjogW10sXFxyXFxuICAgIGVtOiBbXSxcXHJcXG4gICAgaHI6IFtdLFxcclxcbiAgICBoMTogW10sXFxyXFxuICAgIGgyOiBbXSxcXHJcXG4gICAgaDM6IFtdLFxcclxcbiAgICBoNDogW10sXFxyXFxuICAgIGg1OiBbXSxcXHJcXG4gICAgaDY6IFtdLFxcclxcbiAgICBpOiBbXSxcXHJcXG4gICAgaW1nOiBbJ3NyYycsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXFxyXFxuICAgIGxpOiBbXSxcXHJcXG4gICAgb2w6IFtdLFxcclxcbiAgICBwOiBbXSxcXHJcXG4gICAgcHJlOiBbXSxcXHJcXG4gICAgczogW10sXFxyXFxuICAgIHNtYWxsOiBbXSxcXHJcXG4gICAgc3BhbjogW10sXFxyXFxuICAgIHN1YjogW10sXFxyXFxuICAgIHN1cDogW10sXFxyXFxuICAgIHN0cm9uZzogW10sXFxyXFxuICAgIHU6IFtdLFxcclxcbiAgICB1bDogW11cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC8qKlxcclxcbiAgICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBhIGNvbW1vbmx5IHVzZWZ1bCBzdWJzZXQgb2YgVVJMcyB0aGF0IGFyZSBzYWZlLlxcclxcbiAgICpcXHJcXG4gICAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcXHJcXG4gICAqL1xcclxcbiAgdmFyIFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlKTp8W14mOi8/I10qKD86Wy8/I118JCkpL2dpO1xcclxcblxcclxcbiAgLyoqXFxyXFxuICAgKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cXHJcXG4gICAqXFxyXFxuICAgKiBTaG91dG91dCB0byBBbmd1bGFyIDcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzcuMi40L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXFxyXFxuICAgKi9cXHJcXG4gIHZhciBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFxcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFxcXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXFxcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW2EtejAtOSsvXSs9KiQvaTtcXHJcXG5cXHJcXG4gIGZ1bmN0aW9uIGFsbG93ZWRBdHRyaWJ1dGUgKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSB7XFxyXFxuICAgIHZhciBhdHRyTmFtZSA9IGF0dHIubm9kZU5hbWUudG9Mb3dlckNhc2UoKVxcclxcblxcclxcbiAgICBpZiAoJC5pbkFycmF5KGF0dHJOYW1lLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkgIT09IC0xKSB7XFxyXFxuICAgICAgaWYgKCQuaW5BcnJheShhdHRyTmFtZSwgdXJpQXR0cnMpICE9PSAtMSkge1xcclxcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oYXR0ci5ub2RlVmFsdWUubWF0Y2goU0FGRV9VUkxfUEFUVEVSTikgfHwgYXR0ci5ub2RlVmFsdWUubWF0Y2goREFUQV9VUkxfUEFUVEVSTikpXFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHJldHVybiB0cnVlXFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgdmFyIHJlZ0V4cCA9ICQoYWxsb3dlZEF0dHJpYnV0ZUxpc3QpLmZpbHRlcihmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XFxyXFxuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwXFxyXFxuICAgIH0pXFxyXFxuXFxyXFxuICAgIC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlZ0V4cC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXHJcXG4gICAgICBpZiAoYXR0ck5hbWUubWF0Y2gocmVnRXhwW2ldKSkge1xcclxcbiAgICAgICAgcmV0dXJuIHRydWVcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgcmV0dXJuIGZhbHNlXFxyXFxuICB9XFxyXFxuXFxyXFxuICBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwgKHVuc2FmZUVsZW1lbnRzLCB3aGl0ZUxpc3QsIHNhbml0aXplRm4pIHtcXHJcXG4gICAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcXHJcXG4gICAgICByZXR1cm4gc2FuaXRpemVGbih1bnNhZmVFbGVtZW50cyk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgdmFyIHdoaXRlbGlzdEtleXMgPSBPYmplY3Qua2V5cyh3aGl0ZUxpc3QpO1xcclxcblxcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdW5zYWZlRWxlbWVudHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICB2YXIgZWxlbWVudHMgPSB1bnNhZmVFbGVtZW50c1tpXS5xdWVyeVNlbGVjdG9yQWxsKCcqJyk7XFxyXFxuXFxyXFxuICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbjIgPSBlbGVtZW50cy5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcXHJcXG4gICAgICAgIHZhciBlbCA9IGVsZW1lbnRzW2pdO1xcclxcbiAgICAgICAgdmFyIGVsTmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAod2hpdGVsaXN0S2V5cy5pbmRleE9mKGVsTmFtZSkgPT09IC0xKSB7XFxyXFxuICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xcclxcblxcclxcbiAgICAgICAgICBjb250aW51ZTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHZhciBhdHRyaWJ1dGVMaXN0ID0gW10uc2xpY2UuY2FsbChlbC5hdHRyaWJ1dGVzKTtcXHJcXG4gICAgICAgIHZhciB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQod2hpdGVMaXN0WycqJ10gfHwgW10sIHdoaXRlTGlzdFtlbE5hbWVdIHx8IFtdKTtcXHJcXG5cXHJcXG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBsZW4zID0gYXR0cmlidXRlTGlzdC5sZW5ndGg7IGsgPCBsZW4zOyBrKyspIHtcXHJcXG4gICAgICAgICAgdmFyIGF0dHIgPSBhdHRyaWJ1dGVMaXN0W2tdO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGUoYXR0ciwgd2hpdGVsaXN0ZWRBdHRyaWJ1dGVzKSkge1xcclxcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcbiAgfVxcclxcblxcclxcbiAgLy8gUG9seWZpbGwgZm9yIGJyb3dzZXJzIHdpdGggbm8gY2xhc3NMaXN0IHN1cHBvcnRcXHJcXG4gIC8vIFJlbW92ZSBpbiB2MlxcclxcbiAgaWYgKCEoJ2NsYXNzTGlzdCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnXycpKSkge1xcclxcbiAgICAoZnVuY3Rpb24gKHZpZXcpIHtcXHJcXG4gICAgICBpZiAoISgnRWxlbWVudCcgaW4gdmlldykpIHJldHVybjtcXHJcXG5cXHJcXG4gICAgICB2YXIgY2xhc3NMaXN0UHJvcCA9ICdjbGFzc0xpc3QnLFxcclxcbiAgICAgICAgICBwcm90b1Byb3AgPSAncHJvdG90eXBlJyxcXHJcXG4gICAgICAgICAgZWxlbUN0clByb3RvID0gdmlldy5FbGVtZW50W3Byb3RvUHJvcF0sXFxyXFxuICAgICAgICAgIG9iakN0ciA9IE9iamVjdCxcXHJcXG4gICAgICAgICAgY2xhc3NMaXN0R2V0dGVyID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgcmV0dXJuIHtcXHJcXG4gICAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKGNsYXNzZXMpIHtcXHJcXG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0uYWRkQ2xhc3MoY2xhc3Nlcyk7XFxyXFxuICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoY2xhc3Nlcykge1xcclxcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5qb2luKCcgJyk7XFxyXFxuICAgICAgICAgICAgICAgIHJldHVybiAkZWxlbS5yZW1vdmVDbGFzcyhjbGFzc2VzKTtcXHJcXG4gICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uIChjbGFzc2VzLCBmb3JjZSkge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0udG9nZ2xlQ2xhc3MoY2xhc3NlcywgZm9yY2UpO1xcclxcbiAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbiAoY2xhc3Nlcykge1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0uaGFzQ2xhc3MoY2xhc3Nlcyk7XFxyXFxuICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICB9O1xcclxcblxcclxcbiAgICAgIGlmIChvYmpDdHIuZGVmaW5lUHJvcGVydHkpIHtcXHJcXG4gICAgICAgIHZhciBjbGFzc0xpc3RQcm9wRGVzYyA9IHtcXHJcXG4gICAgICAgICAgZ2V0OiBjbGFzc0xpc3RHZXR0ZXIsXFxyXFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXFxyXFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxcclxcbiAgICAgICAgfTtcXHJcXG4gICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcXHJcXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7IC8vIElFIDggZG9lc24ndCBzdXBwb3J0IGVudW1lcmFibGU6dHJ1ZVxcclxcbiAgICAgICAgICAvLyBhZGRpbmcgdW5kZWZpbmVkIHRvIGZpZ2h0IHRoaXMgaXNzdWUgaHR0cHM6Ly9naXRodWIuY29tL2VsaWdyZXkvY2xhc3NMaXN0LmpzL2lzc3Vlcy8zNlxcclxcbiAgICAgICAgICAvLyBtb2Rlcm5pZSBJRTgtTVNXNyBtYWNoaW5lIGhhcyBJRTggOC4wLjYwMDEuMTg3MDIgYW5kIGlzIGFmZmVjdGVkXFxyXFxuICAgICAgICAgIGlmIChleC5udW1iZXIgPT09IHVuZGVmaW5lZCB8fCBleC5udW1iZXIgPT09IC0weDdGRjVFQzU0KSB7XFxyXFxuICAgICAgICAgICAgY2xhc3NMaXN0UHJvcERlc2MuZW51bWVyYWJsZSA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgIG9iakN0ci5kZWZpbmVQcm9wZXJ0eShlbGVtQ3RyUHJvdG8sIGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdFByb3BEZXNjKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0gZWxzZSBpZiAob2JqQ3RyW3Byb3RvUHJvcF0uX19kZWZpbmVHZXR0ZXJfXykge1xcclxcbiAgICAgICAgZWxlbUN0clByb3RvLl9fZGVmaW5lR2V0dGVyX18oY2xhc3NMaXN0UHJvcCwgY2xhc3NMaXN0R2V0dGVyKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0od2luZG93KSk7XFxyXFxuICB9XFxyXFxuXFxyXFxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdfJyk7XFxyXFxuXFxyXFxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdjMScsICdjMicpO1xcclxcblxcclxcbiAgaWYgKCF0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2MyJykpIHtcXHJcXG4gICAgdmFyIF9hZGQgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLmFkZCxcXHJcXG4gICAgICAgIF9yZW1vdmUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnJlbW92ZTtcXHJcXG5cXHJcXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhcmd1bWVudHMsIF9hZGQuYmluZCh0aGlzKSk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChhcmd1bWVudHMsIF9yZW1vdmUuYmluZCh0aGlzKSk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHRlc3RFbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ2MzJywgZmFsc2UpO1xcclxcblxcclxcbiAgLy8gUG9seWZpbGwgZm9yIElFIDEwIGFuZCBGaXJlZm94IDwyNCwgd2hlcmUgY2xhc3NMaXN0LnRvZ2dsZSBkb2VzIG5vdFxcclxcbiAgLy8gc3VwcG9ydCB0aGUgc2Vjb25kIGFyZ3VtZW50LlxcclxcbiAgaWYgKHRlc3RFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnYzMnKSkge1xcclxcbiAgICB2YXIgX3RvZ2dsZSA9IERPTVRva2VuTGlzdC5wcm90b3R5cGUudG9nZ2xlO1xcclxcblxcclxcbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbiwgZm9yY2UpIHtcXHJcXG4gICAgICBpZiAoMSBpbiBhcmd1bWVudHMgJiYgIXRoaXMuY29udGFpbnModG9rZW4pID09PSAhZm9yY2UpIHtcXHJcXG4gICAgICAgIHJldHVybiBmb3JjZTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgcmV0dXJuIF90b2dnbGUuY2FsbCh0aGlzLCB0b2tlbik7XFxyXFxuICAgICAgfVxcclxcbiAgICB9O1xcclxcbiAgfVxcclxcblxcclxcbiAgdGVzdEVsZW1lbnQgPSBudWxsO1xcclxcblxcclxcbiAgLy8gc2hhbGxvdyBhcnJheSBjb21wYXJpc29uXFxyXFxuICBmdW5jdGlvbiBpc0VxdWFsIChhcnJheTEsIGFycmF5Mikge1xcclxcbiAgICByZXR1cm4gYXJyYXkxLmxlbmd0aCA9PT0gYXJyYXkyLmxlbmd0aCAmJiBhcnJheTEuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XFxyXFxuICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IGFycmF5MltpbmRleF07XFxyXFxuICAgIH0pO1xcclxcbiAgfTtcXHJcXG5cXHJcXG4gIC8vIDxlZGl0b3ItZm9sZCBkZXNjPVxcXCJTaGltc1xcXCI+XFxyXFxuICBpZiAoIVN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xcclxcbiAgICAoZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICd1c2Ugc3RyaWN0JzsgLy8gbmVlZGVkIHRvIHN1cHBvcnQgYGFwcGx5YC9gY2FsbGAgd2l0aCBgdW5kZWZpbmVkYC9gbnVsbGBcXHJcXG4gICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgLy8gSUUgOCBvbmx5IHN1cHBvcnRzIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG9uIERPTSBlbGVtZW50c1xcclxcbiAgICAgICAgdHJ5IHtcXHJcXG4gICAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xcclxcbiAgICAgICAgICB2YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xcclxcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJGRlZmluZVByb3BlcnR5KG9iamVjdCwgb2JqZWN0LCBvYmplY3QpICYmICRkZWZpbmVQcm9wZXJ0eTtcXHJcXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xcclxcbiAgICAgIH0oKSk7XFxyXFxuICAgICAgdmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxyXFxuICAgICAgdmFyIHN0YXJ0c1dpdGggPSBmdW5jdGlvbiAoc2VhcmNoKSB7XFxyXFxuICAgICAgICBpZiAodGhpcyA9PSBudWxsKSB7XFxyXFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XFxyXFxuICAgICAgICBpZiAoc2VhcmNoICYmIHRvU3RyaW5nLmNhbGwoc2VhcmNoKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xcclxcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB2YXIgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcXHJcXG4gICAgICAgIHZhciBzZWFyY2hTdHJpbmcgPSBTdHJpbmcoc2VhcmNoKTtcXHJcXG4gICAgICAgIHZhciBzZWFyY2hMZW5ndGggPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xcclxcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XFxyXFxuICAgICAgICAvLyBgVG9JbnRlZ2VyYFxcclxcbiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uID8gTnVtYmVyKHBvc2l0aW9uKSA6IDA7XFxyXFxuICAgICAgICBpZiAocG9zICE9IHBvcykgeyAvLyBiZXR0ZXIgYGlzTmFOYFxcclxcbiAgICAgICAgICBwb3MgPSAwO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdmFyIHN0YXJ0ID0gTWF0aC5taW4oTWF0aC5tYXgocG9zLCAwKSwgc3RyaW5nTGVuZ3RoKTtcXHJcXG4gICAgICAgIC8vIEF2b2lkIHRoZSBgaW5kZXhPZmAgY2FsbCBpZiBubyBtYXRjaCBpcyBwb3NzaWJsZVxcclxcbiAgICAgICAgaWYgKHNlYXJjaExlbmd0aCArIHN0YXJ0ID4gc3RyaW5nTGVuZ3RoKSB7XFxyXFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBpbmRleCA9IC0xO1xcclxcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzZWFyY2hMZW5ndGgpIHtcXHJcXG4gICAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KHN0YXJ0ICsgaW5kZXgpICE9IHNlYXJjaFN0cmluZy5jaGFyQ29kZUF0KGluZGV4KSkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgICAgfTtcXHJcXG4gICAgICBpZiAoZGVmaW5lUHJvcGVydHkpIHtcXHJcXG4gICAgICAgIGRlZmluZVByb3BlcnR5KFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJywge1xcclxcbiAgICAgICAgICAndmFsdWUnOiBzdGFydHNXaXRoLFxcclxcbiAgICAgICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcXHJcXG4gICAgICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XFxyXFxuICAgICAgfVxcclxcbiAgICB9KCkpO1xcclxcbiAgfVxcclxcblxcclxcbiAgaWYgKCFPYmplY3Qua2V5cykge1xcclxcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uIChcXHJcXG4gICAgICBvLCAvLyBvYmplY3RcXHJcXG4gICAgICBrLCAvLyBrZXlcXHJcXG4gICAgICByICAvLyByZXN1bHQgYXJyYXlcXHJcXG4gICAgKSB7XFxyXFxuICAgICAgLy8gaW5pdGlhbGl6ZSBvYmplY3QgYW5kIHJlc3VsdFxcclxcbiAgICAgIHIgPSBbXTtcXHJcXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcXHJcXG4gICAgICBmb3IgKGsgaW4gbykge1xcclxcbiAgICAgICAgLy8gZmlsbCByZXN1bHQgYXJyYXkgd2l0aCBub24tcHJvdG90eXBpY2FsIGtleXNcXHJcXG4gICAgICAgIHIuaGFzT3duUHJvcGVydHkuY2FsbChvLCBrKSAmJiByLnB1c2goayk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIC8vIHJldHVybiByZXN1bHRcXHJcXG4gICAgICByZXR1cm4gcjtcXHJcXG4gICAgfTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGlmIChIVE1MU2VsZWN0RWxlbWVudCAmJiAhSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdzZWxlY3RlZE9wdGlvbnMnKSkge1xcclxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTFNlbGVjdEVsZW1lbnQucHJvdG90eXBlLCAnc2VsZWN0ZWRPcHRpb25zJywge1xcclxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0pO1xcclxcbiAgfVxcclxcblxcclxcbiAgZnVuY3Rpb24gZ2V0U2VsZWN0ZWRPcHRpb25zIChzZWxlY3QsIGlnbm9yZURpc2FibGVkKSB7XFxyXFxuICAgIHZhciBzZWxlY3RlZE9wdGlvbnMgPSBzZWxlY3Quc2VsZWN0ZWRPcHRpb25zLFxcclxcbiAgICAgICAgb3B0aW9ucyA9IFtdLFxcclxcbiAgICAgICAgb3B0O1xcclxcblxcclxcbiAgICBpZiAoaWdub3JlRGlzYWJsZWQpIHtcXHJcXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VsZWN0ZWRPcHRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICBvcHQgPSBzZWxlY3RlZE9wdGlvbnNbaV07XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIShvcHQuZGlzYWJsZWQgfHwgb3B0LnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ09QVEdST1VQJyAmJiBvcHQucGFyZW50Tm9kZS5kaXNhYmxlZCkpIHtcXHJcXG4gICAgICAgICAgb3B0aW9ucy5wdXNoKG9wdCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHJldHVybiBvcHRpb25zO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHJldHVybiBzZWxlY3RlZE9wdGlvbnM7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAvLyBtdWNoIGZhc3RlciB0aGFuICQudmFsKClcXHJcXG4gIGZ1bmN0aW9uIGdldFNlbGVjdFZhbHVlcyAoc2VsZWN0LCBzZWxlY3RlZE9wdGlvbnMpIHtcXHJcXG4gICAgdmFyIHZhbHVlID0gW10sXFxyXFxuICAgICAgICBvcHRpb25zID0gc2VsZWN0ZWRPcHRpb25zIHx8IHNlbGVjdC5zZWxlY3RlZE9wdGlvbnMsXFxyXFxuICAgICAgICBvcHQ7XFxyXFxuXFxyXFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvcHRpb25zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgb3B0ID0gb3B0aW9uc1tpXTtcXHJcXG5cXHJcXG4gICAgICBpZiAoIShvcHQuZGlzYWJsZWQgfHwgb3B0LnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ09QVEdST1VQJyAmJiBvcHQucGFyZW50Tm9kZS5kaXNhYmxlZCkpIHtcXHJcXG4gICAgICAgIHZhbHVlLnB1c2gob3B0LnZhbHVlKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgaWYgKCFzZWxlY3QubXVsdGlwbGUpIHtcXHJcXG4gICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aCA/IG51bGwgOiB2YWx1ZVswXTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICByZXR1cm4gdmFsdWU7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAvLyBzZXQgZGF0YS1zZWxlY3RlZCBvbiBzZWxlY3QgZWxlbWVudCBpZiB0aGUgdmFsdWUgaGFzIGJlZW4gcHJvZ3JhbW1hdGljYWxseSBzZWxlY3RlZFxcclxcbiAgLy8gcHJpb3IgdG8gaW5pdGlhbGl6YXRpb24gb2YgYm9vdHN0cmFwLXNlbGVjdFxcclxcbiAgLy8gKiBjb25zaWRlciByZW1vdmluZyBvciByZXBsYWNpbmcgYW4gYWx0ZXJuYXRpdmUgbWV0aG9kICpcXHJcXG4gIHZhciB2YWxIb29rcyA9IHtcXHJcXG4gICAgdXNlRGVmYXVsdDogZmFsc2UsXFxyXFxuICAgIF9zZXQ6ICQudmFsSG9va3Muc2VsZWN0LnNldFxcclxcbiAgfTtcXHJcXG5cXHJcXG4gICQudmFsSG9va3Muc2VsZWN0LnNldCA9IGZ1bmN0aW9uIChlbGVtLCB2YWx1ZSkge1xcclxcbiAgICBpZiAodmFsdWUgJiYgIXZhbEhvb2tzLnVzZURlZmF1bHQpICQoZWxlbSkuZGF0YSgnc2VsZWN0ZWQnLCB0cnVlKTtcXHJcXG5cXHJcXG4gICAgcmV0dXJuIHZhbEhvb2tzLl9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXHJcXG4gIH07XFxyXFxuXFxyXFxuICB2YXIgY2hhbmdlZEFyZ3VtZW50cyA9IG51bGw7XFxyXFxuXFxyXFxuICB2YXIgRXZlbnRJc1N1cHBvcnRlZCA9IChmdW5jdGlvbiAoKSB7XFxyXFxuICAgIHRyeSB7XFxyXFxuICAgICAgbmV3IEV2ZW50KCdjaGFuZ2UnKTtcXHJcXG4gICAgICByZXR1cm4gdHJ1ZTtcXHJcXG4gICAgfSBjYXRjaCAoZSkge1xcclxcbiAgICAgIHJldHVybiBmYWxzZTtcXHJcXG4gICAgfVxcclxcbiAgfSkoKTtcXHJcXG5cXHJcXG4gICQuZm4udHJpZ2dlck5hdGl2ZSA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcXHJcXG4gICAgdmFyIGVsID0gdGhpc1swXSxcXHJcXG4gICAgICAgIGV2ZW50O1xcclxcblxcclxcbiAgICBpZiAoZWwuZGlzcGF0Y2hFdmVudCkgeyAvLyBmb3IgbW9kZXJuIGJyb3dzZXJzICYgSUU5K1xcclxcbiAgICAgIGlmIChFdmVudElzU3VwcG9ydGVkKSB7XFxyXFxuICAgICAgICAvLyBGb3IgbW9kZXJuIGJyb3dzZXJzXFxyXFxuICAgICAgICBldmVudCA9IG5ldyBFdmVudChldmVudE5hbWUsIHtcXHJcXG4gICAgICAgICAgYnViYmxlczogdHJ1ZVxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIC8vIEZvciBJRSBzaW5jZSBpdCBkb2Vzbid0IHN1cHBvcnQgRXZlbnQgY29uc3RydWN0b3JcXHJcXG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XFxyXFxuICAgICAgICBldmVudC5pbml0RXZlbnQoZXZlbnROYW1lLCB0cnVlLCBmYWxzZSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xcclxcbiAgICB9IGVsc2UgaWYgKGVsLmZpcmVFdmVudCkgeyAvLyBmb3IgSUU4XFxyXFxuICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xcclxcbiAgICAgIGV2ZW50LmV2ZW50VHlwZSA9IGV2ZW50TmFtZTtcXHJcXG4gICAgICBlbC5maXJlRXZlbnQoJ29uJyArIGV2ZW50TmFtZSwgZXZlbnQpO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIC8vIGZhbGwgYmFjayB0byBqUXVlcnkudHJpZ2dlclxcclxcbiAgICAgIHRoaXMudHJpZ2dlcihldmVudE5hbWUpO1xcclxcbiAgICB9XFxyXFxuICB9O1xcclxcbiAgLy8gPC9lZGl0b3ItZm9sZD5cXHJcXG5cXHJcXG4gIGZ1bmN0aW9uIHN0cmluZ1NlYXJjaCAobGksIHNlYXJjaFN0cmluZywgbWV0aG9kLCBub3JtYWxpemUpIHtcXHJcXG4gICAgdmFyIHN0cmluZ1R5cGVzID0gW1xcclxcbiAgICAgICAgICAnZGlzcGxheScsXFxyXFxuICAgICAgICAgICdzdWJ0ZXh0JyxcXHJcXG4gICAgICAgICAgJ3Rva2VucydcXHJcXG4gICAgICAgIF0sXFxyXFxuICAgICAgICBzZWFyY2hTdWNjZXNzID0gZmFsc2U7XFxyXFxuXFxyXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVHlwZXMubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICB2YXIgc3RyaW5nVHlwZSA9IHN0cmluZ1R5cGVzW2ldLFxcclxcbiAgICAgICAgICBzdHJpbmcgPSBsaVtzdHJpbmdUeXBlXTtcXHJcXG5cXHJcXG4gICAgICBpZiAoc3RyaW5nKSB7XFxyXFxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoKTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIFN0cmlwIEhUTUwgdGFncy4gVGhpcyBpc24ndCBwZXJmZWN0LCBidXQgaXQncyBtdWNoIGZhc3RlciB0aGFuIGFueSBvdGhlciBtZXRob2RcXHJcXG4gICAgICAgIGlmIChzdHJpbmdUeXBlID09PSAnZGlzcGxheScpIHtcXHJcXG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoLzxbXj5dKz4vZywgJycpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKG5vcm1hbGl6ZSkgc3RyaW5nID0gbm9ybWFsaXplVG9CYXNlKHN0cmluZyk7XFxyXFxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcudG9VcHBlckNhc2UoKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChtZXRob2QgPT09ICdjb250YWlucycpIHtcXHJcXG4gICAgICAgICAgc2VhcmNoU3VjY2VzcyA9IHN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZykgPj0gMDtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHNlYXJjaFN1Y2Nlc3MgPSBzdHJpbmcuc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKHNlYXJjaFN1Y2Nlc3MpIGJyZWFrO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICByZXR1cm4gc2VhcmNoU3VjY2VzcztcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGZ1bmN0aW9uIHRvSW50ZWdlciAodmFsdWUpIHtcXHJcXG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMCkgfHwgMDtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC8vIEJvcnJvd2VkIGZyb20gTG9kYXNoIChfLmRlYnVycilcXHJcXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cXHJcXG4gIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XFxyXFxuICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cXHJcXG4gICAgJ1xcXFx4YzAnOiAnQScsICAnXFxcXHhjMSc6ICdBJywgJ1xcXFx4YzInOiAnQScsICdcXFxceGMzJzogJ0EnLCAnXFxcXHhjNCc6ICdBJywgJ1xcXFx4YzUnOiAnQScsXFxyXFxuICAgICdcXFxceGUwJzogJ2EnLCAgJ1xcXFx4ZTEnOiAnYScsICdcXFxceGUyJzogJ2EnLCAnXFxcXHhlMyc6ICdhJywgJ1xcXFx4ZTQnOiAnYScsICdcXFxceGU1JzogJ2EnLFxcclxcbiAgICAnXFxcXHhjNyc6ICdDJywgICdcXFxceGU3JzogJ2MnLFxcclxcbiAgICAnXFxcXHhkMCc6ICdEJywgICdcXFxceGYwJzogJ2QnLFxcclxcbiAgICAnXFxcXHhjOCc6ICdFJywgICdcXFxceGM5JzogJ0UnLCAnXFxcXHhjYSc6ICdFJywgJ1xcXFx4Y2InOiAnRScsXFxyXFxuICAgICdcXFxceGU4JzogJ2UnLCAgJ1xcXFx4ZTknOiAnZScsICdcXFxceGVhJzogJ2UnLCAnXFxcXHhlYic6ICdlJyxcXHJcXG4gICAgJ1xcXFx4Y2MnOiAnSScsICAnXFxcXHhjZCc6ICdJJywgJ1xcXFx4Y2UnOiAnSScsICdcXFxceGNmJzogJ0knLFxcclxcbiAgICAnXFxcXHhlYyc6ICdpJywgICdcXFxceGVkJzogJ2knLCAnXFxcXHhlZSc6ICdpJywgJ1xcXFx4ZWYnOiAnaScsXFxyXFxuICAgICdcXFxceGQxJzogJ04nLCAgJ1xcXFx4ZjEnOiAnbicsXFxyXFxuICAgICdcXFxceGQyJzogJ08nLCAgJ1xcXFx4ZDMnOiAnTycsICdcXFxceGQ0JzogJ08nLCAnXFxcXHhkNSc6ICdPJywgJ1xcXFx4ZDYnOiAnTycsICdcXFxceGQ4JzogJ08nLFxcclxcbiAgICAnXFxcXHhmMic6ICdvJywgICdcXFxceGYzJzogJ28nLCAnXFxcXHhmNCc6ICdvJywgJ1xcXFx4ZjUnOiAnbycsICdcXFxceGY2JzogJ28nLCAnXFxcXHhmOCc6ICdvJyxcXHJcXG4gICAgJ1xcXFx4ZDknOiAnVScsICAnXFxcXHhkYSc6ICdVJywgJ1xcXFx4ZGInOiAnVScsICdcXFxceGRjJzogJ1UnLFxcclxcbiAgICAnXFxcXHhmOSc6ICd1JywgICdcXFxceGZhJzogJ3UnLCAnXFxcXHhmYic6ICd1JywgJ1xcXFx4ZmMnOiAndScsXFxyXFxuICAgICdcXFxceGRkJzogJ1knLCAgJ1xcXFx4ZmQnOiAneScsICdcXFxceGZmJzogJ3knLFxcclxcbiAgICAnXFxcXHhjNic6ICdBZScsICdcXFxceGU2JzogJ2FlJyxcXHJcXG4gICAgJ1xcXFx4ZGUnOiAnVGgnLCAnXFxcXHhmZSc6ICd0aCcsXFxyXFxuICAgICdcXFxceGRmJzogJ3NzJyxcXHJcXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cXHJcXG4gICAgJ1xcXFx1MDEwMCc6ICdBJywgICdcXFxcdTAxMDInOiAnQScsICdcXFxcdTAxMDQnOiAnQScsXFxyXFxuICAgICdcXFxcdTAxMDEnOiAnYScsICAnXFxcXHUwMTAzJzogJ2EnLCAnXFxcXHUwMTA1JzogJ2EnLFxcclxcbiAgICAnXFxcXHUwMTA2JzogJ0MnLCAgJ1xcXFx1MDEwOCc6ICdDJywgJ1xcXFx1MDEwYSc6ICdDJywgJ1xcXFx1MDEwYyc6ICdDJyxcXHJcXG4gICAgJ1xcXFx1MDEwNyc6ICdjJywgICdcXFxcdTAxMDknOiAnYycsICdcXFxcdTAxMGInOiAnYycsICdcXFxcdTAxMGQnOiAnYycsXFxyXFxuICAgICdcXFxcdTAxMGUnOiAnRCcsICAnXFxcXHUwMTEwJzogJ0QnLCAnXFxcXHUwMTBmJzogJ2QnLCAnXFxcXHUwMTExJzogJ2QnLFxcclxcbiAgICAnXFxcXHUwMTEyJzogJ0UnLCAgJ1xcXFx1MDExNCc6ICdFJywgJ1xcXFx1MDExNic6ICdFJywgJ1xcXFx1MDExOCc6ICdFJywgJ1xcXFx1MDExYSc6ICdFJyxcXHJcXG4gICAgJ1xcXFx1MDExMyc6ICdlJywgICdcXFxcdTAxMTUnOiAnZScsICdcXFxcdTAxMTcnOiAnZScsICdcXFxcdTAxMTknOiAnZScsICdcXFxcdTAxMWInOiAnZScsXFxyXFxuICAgICdcXFxcdTAxMWMnOiAnRycsICAnXFxcXHUwMTFlJzogJ0cnLCAnXFxcXHUwMTIwJzogJ0cnLCAnXFxcXHUwMTIyJzogJ0cnLFxcclxcbiAgICAnXFxcXHUwMTFkJzogJ2cnLCAgJ1xcXFx1MDExZic6ICdnJywgJ1xcXFx1MDEyMSc6ICdnJywgJ1xcXFx1MDEyMyc6ICdnJyxcXHJcXG4gICAgJ1xcXFx1MDEyNCc6ICdIJywgICdcXFxcdTAxMjYnOiAnSCcsICdcXFxcdTAxMjUnOiAnaCcsICdcXFxcdTAxMjcnOiAnaCcsXFxyXFxuICAgICdcXFxcdTAxMjgnOiAnSScsICAnXFxcXHUwMTJhJzogJ0knLCAnXFxcXHUwMTJjJzogJ0knLCAnXFxcXHUwMTJlJzogJ0knLCAnXFxcXHUwMTMwJzogJ0knLFxcclxcbiAgICAnXFxcXHUwMTI5JzogJ2knLCAgJ1xcXFx1MDEyYic6ICdpJywgJ1xcXFx1MDEyZCc6ICdpJywgJ1xcXFx1MDEyZic6ICdpJywgJ1xcXFx1MDEzMSc6ICdpJyxcXHJcXG4gICAgJ1xcXFx1MDEzNCc6ICdKJywgICdcXFxcdTAxMzUnOiAnaicsXFxyXFxuICAgICdcXFxcdTAxMzYnOiAnSycsICAnXFxcXHUwMTM3JzogJ2snLCAnXFxcXHUwMTM4JzogJ2snLFxcclxcbiAgICAnXFxcXHUwMTM5JzogJ0wnLCAgJ1xcXFx1MDEzYic6ICdMJywgJ1xcXFx1MDEzZCc6ICdMJywgJ1xcXFx1MDEzZic6ICdMJywgJ1xcXFx1MDE0MSc6ICdMJyxcXHJcXG4gICAgJ1xcXFx1MDEzYSc6ICdsJywgICdcXFxcdTAxM2MnOiAnbCcsICdcXFxcdTAxM2UnOiAnbCcsICdcXFxcdTAxNDAnOiAnbCcsICdcXFxcdTAxNDInOiAnbCcsXFxyXFxuICAgICdcXFxcdTAxNDMnOiAnTicsICAnXFxcXHUwMTQ1JzogJ04nLCAnXFxcXHUwMTQ3JzogJ04nLCAnXFxcXHUwMTRhJzogJ04nLFxcclxcbiAgICAnXFxcXHUwMTQ0JzogJ24nLCAgJ1xcXFx1MDE0Nic6ICduJywgJ1xcXFx1MDE0OCc6ICduJywgJ1xcXFx1MDE0Yic6ICduJyxcXHJcXG4gICAgJ1xcXFx1MDE0Yyc6ICdPJywgICdcXFxcdTAxNGUnOiAnTycsICdcXFxcdTAxNTAnOiAnTycsXFxyXFxuICAgICdcXFxcdTAxNGQnOiAnbycsICAnXFxcXHUwMTRmJzogJ28nLCAnXFxcXHUwMTUxJzogJ28nLFxcclxcbiAgICAnXFxcXHUwMTU0JzogJ1InLCAgJ1xcXFx1MDE1Nic6ICdSJywgJ1xcXFx1MDE1OCc6ICdSJyxcXHJcXG4gICAgJ1xcXFx1MDE1NSc6ICdyJywgICdcXFxcdTAxNTcnOiAncicsICdcXFxcdTAxNTknOiAncicsXFxyXFxuICAgICdcXFxcdTAxNWEnOiAnUycsICAnXFxcXHUwMTVjJzogJ1MnLCAnXFxcXHUwMTVlJzogJ1MnLCAnXFxcXHUwMTYwJzogJ1MnLFxcclxcbiAgICAnXFxcXHUwMTViJzogJ3MnLCAgJ1xcXFx1MDE1ZCc6ICdzJywgJ1xcXFx1MDE1Zic6ICdzJywgJ1xcXFx1MDE2MSc6ICdzJyxcXHJcXG4gICAgJ1xcXFx1MDE2Mic6ICdUJywgICdcXFxcdTAxNjQnOiAnVCcsICdcXFxcdTAxNjYnOiAnVCcsXFxyXFxuICAgICdcXFxcdTAxNjMnOiAndCcsICAnXFxcXHUwMTY1JzogJ3QnLCAnXFxcXHUwMTY3JzogJ3QnLFxcclxcbiAgICAnXFxcXHUwMTY4JzogJ1UnLCAgJ1xcXFx1MDE2YSc6ICdVJywgJ1xcXFx1MDE2Yyc6ICdVJywgJ1xcXFx1MDE2ZSc6ICdVJywgJ1xcXFx1MDE3MCc6ICdVJywgJ1xcXFx1MDE3Mic6ICdVJyxcXHJcXG4gICAgJ1xcXFx1MDE2OSc6ICd1JywgICdcXFxcdTAxNmInOiAndScsICdcXFxcdTAxNmQnOiAndScsICdcXFxcdTAxNmYnOiAndScsICdcXFxcdTAxNzEnOiAndScsICdcXFxcdTAxNzMnOiAndScsXFxyXFxuICAgICdcXFxcdTAxNzQnOiAnVycsICAnXFxcXHUwMTc1JzogJ3cnLFxcclxcbiAgICAnXFxcXHUwMTc2JzogJ1knLCAgJ1xcXFx1MDE3Nyc6ICd5JywgJ1xcXFx1MDE3OCc6ICdZJyxcXHJcXG4gICAgJ1xcXFx1MDE3OSc6ICdaJywgICdcXFxcdTAxN2InOiAnWicsICdcXFxcdTAxN2QnOiAnWicsXFxyXFxuICAgICdcXFxcdTAxN2EnOiAneicsICAnXFxcXHUwMTdjJzogJ3onLCAnXFxcXHUwMTdlJzogJ3onLFxcclxcbiAgICAnXFxcXHUwMTMyJzogJ0lKJywgJ1xcXFx1MDEzMyc6ICdpaicsXFxyXFxuICAgICdcXFxcdTAxNTInOiAnT2UnLCAnXFxcXHUwMTUzJzogJ29lJyxcXHJcXG4gICAgJ1xcXFx1MDE0OSc6IFxcXCInblxcXCIsICdcXFxcdTAxN2YnOiAncydcXHJcXG4gIH07XFxyXFxuXFxyXFxuICAvKiogVXNlZCB0byBtYXRjaCBMYXRpbiBVbmljb2RlIGxldHRlcnMgKGV4Y2x1ZGluZyBtYXRoZW1hdGljYWwgb3BlcmF0b3JzKS4gKi9cXHJcXG4gIHZhciByZUxhdGluID0gL1tcXFxceGMwLVxcXFx4ZDZcXFxceGQ4LVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmZcXFxcdTAxMDAtXFxcXHUwMTdmXS9nO1xcclxcblxcclxcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNoYXJhY3RlciBjbGFzc2VzLiAqL1xcclxcbiAgdmFyIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFxcXFxcdTAzMDAtXFxcXFxcXFx1MDM2ZicsXFxyXFxuICAgICAgcmVDb21ib0hhbGZNYXJrc1JhbmdlID0gJ1xcXFxcXFxcdWZlMjAtXFxcXFxcXFx1ZmUyZicsXFxyXFxuICAgICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcXFxcXHUyMGQwLVxcXFxcXFxcdTIwZmYnLFxcclxcbiAgICAgIHJzQ29tYm9NYXJrc0V4dGVuZGVkUmFuZ2UgPSAnXFxcXFxcXFx1MWFiMC1cXFxcXFxcXHUxYWZmJyxcXHJcXG4gICAgICByc0NvbWJvTWFya3NTdXBwbGVtZW50UmFuZ2UgPSAnXFxcXFxcXFx1MWRjMC1cXFxcXFxcXHUxZGZmJyxcXHJcXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UgKyByc0NvbWJvTWFya3NFeHRlbmRlZFJhbmdlICsgcnNDb21ib01hcmtzU3VwcGxlbWVudFJhbmdlO1xcclxcblxcclxcbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xcclxcbiAgdmFyIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXSc7XFxyXFxuXFxyXFxuICAvKipcXHJcXG4gICAqIFVzZWQgdG8gbWF0Y2ggW2NvbWJpbmluZyBkaWFjcml0aWNhbCBtYXJrc10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29tYmluaW5nX0RpYWNyaXRpY2FsX01hcmtzKSBhbmRcXHJcXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXFxyXFxuICAgKi9cXHJcXG4gIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCAnZycpO1xcclxcblxcclxcbiAgZnVuY3Rpb24gZGVidXJyTGV0dGVyIChrZXkpIHtcXHJcXG4gICAgcmV0dXJuIGRlYnVycmVkTGV0dGVyc1trZXldO1xcclxcbiAgfTtcXHJcXG5cXHJcXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVRvQmFzZSAoc3RyaW5nKSB7XFxyXFxuICAgIHN0cmluZyA9IHN0cmluZy50b1N0cmluZygpO1xcclxcbiAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cXHJcXG4gIHZhciBlc2NhcGVNYXAgPSB7XFxyXFxuICAgICcmJzogJyZhbXA7JyxcXHJcXG4gICAgJzwnOiAnJmx0OycsXFxyXFxuICAgICc+JzogJyZndDsnLFxcclxcbiAgICAnXFxcIic6ICcmcXVvdDsnLFxcclxcbiAgICBcXFwiJ1xcXCI6ICcmI3gyNzsnLFxcclxcbiAgICAnYCc6ICcmI3g2MDsnXFxyXFxuICB9O1xcclxcblxcclxcbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxcclxcbiAgdmFyIGNyZWF0ZUVzY2FwZXIgPSBmdW5jdGlvbiAobWFwKSB7XFxyXFxuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24gKG1hdGNoKSB7XFxyXFxuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XFxyXFxuICAgIH07XFxyXFxuICAgIC8vIFJlZ2V4ZXMgZm9yIGlkZW50aWZ5aW5nIGEga2V5IHRoYXQgbmVlZHMgdG8gYmUgZXNjYXBlZC5cXHJcXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgT2JqZWN0LmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XFxyXFxuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XFxyXFxuICAgIHZhciByZXBsYWNlUmVnZXhwID0gUmVnRXhwKHNvdXJjZSwgJ2cnKTtcXHJcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHJpbmcpIHtcXHJcXG4gICAgICBzdHJpbmcgPSBzdHJpbmcgPT0gbnVsbCA/ICcnIDogJycgKyBzdHJpbmc7XFxyXFxuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XFxyXFxuICAgIH07XFxyXFxuICB9O1xcclxcblxcclxcbiAgdmFyIGh0bWxFc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XFxyXFxuXFxyXFxuICAvKipcXHJcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcclxcbiAgICogQ29uc3RhbnRzXFxyXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXHJcXG4gICAqL1xcclxcblxcclxcbiAgdmFyIGtleUNvZGVNYXAgPSB7XFxyXFxuICAgIDMyOiAnICcsXFxyXFxuICAgIDQ4OiAnMCcsXFxyXFxuICAgIDQ5OiAnMScsXFxyXFxuICAgIDUwOiAnMicsXFxyXFxuICAgIDUxOiAnMycsXFxyXFxuICAgIDUyOiAnNCcsXFxyXFxuICAgIDUzOiAnNScsXFxyXFxuICAgIDU0OiAnNicsXFxyXFxuICAgIDU1OiAnNycsXFxyXFxuICAgIDU2OiAnOCcsXFxyXFxuICAgIDU3OiAnOScsXFxyXFxuICAgIDU5OiAnOycsXFxyXFxuICAgIDY1OiAnQScsXFxyXFxuICAgIDY2OiAnQicsXFxyXFxuICAgIDY3OiAnQycsXFxyXFxuICAgIDY4OiAnRCcsXFxyXFxuICAgIDY5OiAnRScsXFxyXFxuICAgIDcwOiAnRicsXFxyXFxuICAgIDcxOiAnRycsXFxyXFxuICAgIDcyOiAnSCcsXFxyXFxuICAgIDczOiAnSScsXFxyXFxuICAgIDc0OiAnSicsXFxyXFxuICAgIDc1OiAnSycsXFxyXFxuICAgIDc2OiAnTCcsXFxyXFxuICAgIDc3OiAnTScsXFxyXFxuICAgIDc4OiAnTicsXFxyXFxuICAgIDc5OiAnTycsXFxyXFxuICAgIDgwOiAnUCcsXFxyXFxuICAgIDgxOiAnUScsXFxyXFxuICAgIDgyOiAnUicsXFxyXFxuICAgIDgzOiAnUycsXFxyXFxuICAgIDg0OiAnVCcsXFxyXFxuICAgIDg1OiAnVScsXFxyXFxuICAgIDg2OiAnVicsXFxyXFxuICAgIDg3OiAnVycsXFxyXFxuICAgIDg4OiAnWCcsXFxyXFxuICAgIDg5OiAnWScsXFxyXFxuICAgIDkwOiAnWicsXFxyXFxuICAgIDk2OiAnMCcsXFxyXFxuICAgIDk3OiAnMScsXFxyXFxuICAgIDk4OiAnMicsXFxyXFxuICAgIDk5OiAnMycsXFxyXFxuICAgIDEwMDogJzQnLFxcclxcbiAgICAxMDE6ICc1JyxcXHJcXG4gICAgMTAyOiAnNicsXFxyXFxuICAgIDEwMzogJzcnLFxcclxcbiAgICAxMDQ6ICc4JyxcXHJcXG4gICAgMTA1OiAnOSdcXHJcXG4gIH07XFxyXFxuXFxyXFxuICB2YXIga2V5Q29kZXMgPSB7XFxyXFxuICAgIEVTQ0FQRTogMjcsIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIEVzY2FwZSAoRXNjKSBrZXlcXHJcXG4gICAgRU5URVI6IDEzLCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFbnRlciBrZXlcXHJcXG4gICAgU1BBQ0U6IDMyLCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBzcGFjZSBrZXlcXHJcXG4gICAgVEFCOiA5LCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB0YWIga2V5XFxyXFxuICAgIEFSUk9XX1VQOiAzOCwgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdXAgYXJyb3cga2V5XFxyXFxuICAgIEFSUk9XX0RPV046IDQwIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGRvd24gYXJyb3cga2V5XFxyXFxuICB9XFxyXFxuXFxyXFxuICB2YXIgdmVyc2lvbiA9IHtcXHJcXG4gICAgc3VjY2VzczogZmFsc2UsXFxyXFxuICAgIG1ham9yOiAnMydcXHJcXG4gIH07XFxyXFxuXFxyXFxuICB0cnkge1xcclxcbiAgICB2ZXJzaW9uLmZ1bGwgPSAoJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvci5WRVJTSU9OIHx8ICcnKS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJyk7XFxyXFxuICAgIHZlcnNpb24ubWFqb3IgPSB2ZXJzaW9uLmZ1bGxbMF07XFxyXFxuICAgIHZlcnNpb24uc3VjY2VzcyA9IHRydWU7XFxyXFxuICB9IGNhdGNoIChlcnIpIHtcXHJcXG4gICAgLy8gZG8gbm90aGluZ1xcclxcbiAgfVxcclxcblxcclxcbiAgdmFyIHNlbGVjdElkID0gMDtcXHJcXG5cXHJcXG4gIHZhciBFVkVOVF9LRVkgPSAnLmJzLnNlbGVjdCc7XFxyXFxuXFxyXFxuICB2YXIgY2xhc3NOYW1lcyA9IHtcXHJcXG4gICAgRElTQUJMRUQ6ICdkaXNhYmxlZCcsXFxyXFxuICAgIERJVklERVI6ICdkaXZpZGVyJyxcXHJcXG4gICAgU0hPVzogJ29wZW4nLFxcclxcbiAgICBEUk9QVVA6ICdkcm9wdXAnLFxcclxcbiAgICBNRU5VOiAnZHJvcGRvd24tbWVudScsXFxyXFxuICAgIE1FTlVSSUdIVDogJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnLFxcclxcbiAgICBNRU5VTEVGVDogJ2Ryb3Bkb3duLW1lbnUtbGVmdCcsXFxyXFxuICAgIC8vIHRvLWRvOiByZXBsYWNlIHdpdGggbW9yZSBhZHZhbmNlZCB0ZW1wbGF0ZS9jdXN0b21pemF0aW9uIG9wdGlvbnNcXHJcXG4gICAgQlVUVE9OQ0xBU1M6ICdidG4tZGVmYXVsdCcsXFxyXFxuICAgIFBPUE9WRVJIRUFERVI6ICdwb3BvdmVyLXRpdGxlJyxcXHJcXG4gICAgSUNPTkJBU0U6ICdnbHlwaGljb24nLFxcclxcbiAgICBUSUNLSUNPTjogJ2dseXBoaWNvbi1vaydcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHZhciBTZWxlY3RvciA9IHtcXHJcXG4gICAgTUVOVTogJy4nICsgY2xhc3NOYW1lcy5NRU5VXFxyXFxuICB9XFxyXFxuXFxyXFxuICB2YXIgZWxlbWVudFRlbXBsYXRlcyA9IHtcXHJcXG4gICAgZGl2OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcXHJcXG4gICAgc3BhbjogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpLFxcclxcbiAgICBpOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJyksXFxyXFxuICAgIHN1YnRleHQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NtYWxsJyksXFxyXFxuICAgIGE6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKSxcXHJcXG4gICAgbGk6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyksXFxyXFxuICAgIHdoaXRlc3BhY2U6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXFxcdTAwQTAnKSxcXHJcXG4gICAgZnJhZ21lbnQ6IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxcclxcbiAgfVxcclxcblxcclxcbiAgZWxlbWVudFRlbXBsYXRlcy5ub1Jlc3VsdHMgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuICBlbGVtZW50VGVtcGxhdGVzLm5vUmVzdWx0cy5jbGFzc05hbWUgPSAnbm8tcmVzdWx0cyc7XFxyXFxuXFxyXFxuICBlbGVtZW50VGVtcGxhdGVzLmEuc2V0QXR0cmlidXRlKCdyb2xlJywgJ29wdGlvbicpO1xcclxcbiAgZWxlbWVudFRlbXBsYXRlcy5hLmNsYXNzTmFtZSA9ICdkcm9wZG93bi1pdGVtJztcXHJcXG5cXHJcXG4gIGVsZW1lbnRUZW1wbGF0ZXMuc3VidGV4dC5jbGFzc05hbWUgPSAndGV4dC1tdXRlZCc7XFxyXFxuXFxyXFxuICBlbGVtZW50VGVtcGxhdGVzLnRleHQgPSBlbGVtZW50VGVtcGxhdGVzLnNwYW4uY2xvbmVOb2RlKGZhbHNlKTtcXHJcXG4gIGVsZW1lbnRUZW1wbGF0ZXMudGV4dC5jbGFzc05hbWUgPSAndGV4dCc7XFxyXFxuXFxyXFxuICBlbGVtZW50VGVtcGxhdGVzLmNoZWNrTWFyayA9IGVsZW1lbnRUZW1wbGF0ZXMuc3Bhbi5jbG9uZU5vZGUoZmFsc2UpO1xcclxcblxcclxcbiAgdmFyIFJFR0VYUF9BUlJPVyA9IG5ldyBSZWdFeHAoa2V5Q29kZXMuQVJST1dfVVAgKyAnfCcgKyBrZXlDb2Rlcy5BUlJPV19ET1dOKTtcXHJcXG4gIHZhciBSRUdFWFBfVEFCX09SX0VTQ0FQRSA9IG5ldyBSZWdFeHAoJ14nICsga2V5Q29kZXMuVEFCICsgJyR8JyArIGtleUNvZGVzLkVTQ0FQRSk7XFxyXFxuXFxyXFxuICB2YXIgZ2VuZXJhdGVPcHRpb24gPSB7XFxyXFxuICAgIGxpOiBmdW5jdGlvbiAoY29udGVudCwgY2xhc3Nlcywgb3B0Z3JvdXApIHtcXHJcXG4gICAgICB2YXIgbGkgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuXFxyXFxuICAgICAgaWYgKGNvbnRlbnQpIHtcXHJcXG4gICAgICAgIGlmIChjb250ZW50Lm5vZGVUeXBlID09PSAxIHx8IGNvbnRlbnQubm9kZVR5cGUgPT09IDExKSB7XFxyXFxuICAgICAgICAgIGxpLmFwcGVuZENoaWxkKGNvbnRlbnQpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgbGkuaW5uZXJIVE1MID0gY29udGVudDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHR5cGVvZiBjbGFzc2VzICE9PSAndW5kZWZpbmVkJyAmJiBjbGFzc2VzICE9PSAnJykgbGkuY2xhc3NOYW1lID0gY2xhc3NlcztcXHJcXG4gICAgICBpZiAodHlwZW9mIG9wdGdyb3VwICE9PSAndW5kZWZpbmVkJyAmJiBvcHRncm91cCAhPT0gbnVsbCkgbGkuY2xhc3NMaXN0LmFkZCgnb3B0Z3JvdXAtJyArIG9wdGdyb3VwKTtcXHJcXG5cXHJcXG4gICAgICByZXR1cm4gbGk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGE6IGZ1bmN0aW9uICh0ZXh0LCBjbGFzc2VzLCBpbmxpbmUpIHtcXHJcXG4gICAgICB2YXIgYSA9IGVsZW1lbnRUZW1wbGF0ZXMuYS5jbG9uZU5vZGUodHJ1ZSk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRleHQpIHtcXHJcXG4gICAgICAgIGlmICh0ZXh0Lm5vZGVUeXBlID09PSAxMSkge1xcclxcbiAgICAgICAgICBhLmFwcGVuZENoaWxkKHRleHQpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgYS5pbnNlcnRBZGphY2VudEhUTUwoJ2JlZm9yZWVuZCcsIHRleHQpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAodHlwZW9mIGNsYXNzZXMgIT09ICd1bmRlZmluZWQnICYmIGNsYXNzZXMgIT09ICcnKSBhLmNsYXNzTGlzdC5hZGQuYXBwbHkoYS5jbGFzc0xpc3QsIGNsYXNzZXMuc3BsaXQoL1xcXFxzKy8pKTtcXHJcXG4gICAgICBpZiAoaW5saW5lKSBhLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBpbmxpbmUpO1xcclxcblxcclxcbiAgICAgIHJldHVybiBhO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICB0ZXh0OiBmdW5jdGlvbiAob3B0aW9ucywgdXNlRnJhZ21lbnQpIHtcXHJcXG4gICAgICB2YXIgdGV4dEVsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLnRleHQuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgc3VidGV4dEVsZW1lbnQsXFxyXFxuICAgICAgICAgIGljb25FbGVtZW50O1xcclxcblxcclxcbiAgICAgIGlmIChvcHRpb25zLmNvbnRlbnQpIHtcXHJcXG4gICAgICAgIHRleHRFbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMuY29udGVudDtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdGV4dEVsZW1lbnQudGV4dENvbnRlbnQgPSBvcHRpb25zLnRleHQ7XFxyXFxuXFxyXFxuICAgICAgICBpZiAob3B0aW9ucy5pY29uKSB7XFxyXFxuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlID0gZWxlbWVudFRlbXBsYXRlcy53aGl0ZXNwYWNlLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuXFxyXFxuICAgICAgICAgIC8vIG5lZWQgdG8gdXNlIDxpPiBmb3IgaWNvbnMgaW4gdGhlIGJ1dHRvbiB0byBwcmV2ZW50IGEgYnJlYWtpbmcgY2hhbmdlXFxyXFxuICAgICAgICAgIC8vIG5vdGU6IHN3aXRjaCB0byBzcGFuIGluIG5leHQgbWFqb3IgcmVsZWFzZVxcclxcbiAgICAgICAgICBpY29uRWxlbWVudCA9ICh1c2VGcmFnbWVudCA9PT0gdHJ1ZSA/IGVsZW1lbnRUZW1wbGF0ZXMuaSA6IGVsZW1lbnRUZW1wbGF0ZXMuc3BhbikuY2xvbmVOb2RlKGZhbHNlKTtcXHJcXG4gICAgICAgICAgaWNvbkVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmljb25CYXNlICsgJyAnICsgb3B0aW9ucy5pY29uO1xcclxcblxcclxcbiAgICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcXHJcXG4gICAgICAgICAgZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5hcHBlbmRDaGlsZCh3aGl0ZXNwYWNlKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChvcHRpb25zLnN1YnRleHQpIHtcXHJcXG4gICAgICAgICAgc3VidGV4dEVsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLnN1YnRleHQuY2xvbmVOb2RlKGZhbHNlKTtcXHJcXG4gICAgICAgICAgc3VidGV4dEVsZW1lbnQudGV4dENvbnRlbnQgPSBvcHRpb25zLnN1YnRleHQ7XFxyXFxuICAgICAgICAgIHRleHRFbGVtZW50LmFwcGVuZENoaWxkKHN1YnRleHRFbGVtZW50KTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHVzZUZyYWdtZW50ID09PSB0cnVlKSB7XFxyXFxuICAgICAgICB3aGlsZSAodGV4dEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGggPiAwKSB7XFxyXFxuICAgICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQuY2hpbGROb2Rlc1swXSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICByZXR1cm4gZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudDtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgbGFiZWw6IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxyXFxuICAgICAgdmFyIHRleHRFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy50ZXh0LmNsb25lTm9kZShmYWxzZSksXFxyXFxuICAgICAgICAgIHN1YnRleHRFbGVtZW50LFxcclxcbiAgICAgICAgICBpY29uRWxlbWVudDtcXHJcXG5cXHJcXG4gICAgICB0ZXh0RWxlbWVudC5pbm5lckhUTUwgPSBvcHRpb25zLmRpc3BsYXk7XFxyXFxuXFxyXFxuICAgICAgaWYgKG9wdGlvbnMuaWNvbikge1xcclxcbiAgICAgICAgdmFyIHdoaXRlc3BhY2UgPSBlbGVtZW50VGVtcGxhdGVzLndoaXRlc3BhY2UuY2xvbmVOb2RlKGZhbHNlKTtcXHJcXG5cXHJcXG4gICAgICAgIGljb25FbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5zcGFuLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuICAgICAgICBpY29uRWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLm9wdGlvbnMuaWNvbkJhc2UgKyAnICcgKyBvcHRpb25zLmljb247XFxyXFxuXFxyXFxuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKGljb25FbGVtZW50KTtcXHJcXG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQod2hpdGVzcGFjZSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmIChvcHRpb25zLnN1YnRleHQpIHtcXHJcXG4gICAgICAgIHN1YnRleHRFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5zdWJ0ZXh0LmNsb25lTm9kZShmYWxzZSk7XFxyXFxuICAgICAgICBzdWJ0ZXh0RWxlbWVudC50ZXh0Q29udGVudCA9IG9wdGlvbnMuc3VidGV4dDtcXHJcXG4gICAgICAgIHRleHRFbGVtZW50LmFwcGVuZENoaWxkKHN1YnRleHRFbGVtZW50KTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5hcHBlbmRDaGlsZCh0ZXh0RWxlbWVudCk7XFxyXFxuXFxyXFxuICAgICAgcmV0dXJuIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQ7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGZ1bmN0aW9uIHNob3dOb1Jlc3VsdHMgKHNlYXJjaE1hdGNoLCBzZWFyY2hWYWx1ZSkge1xcclxcbiAgICBpZiAoIXNlYXJjaE1hdGNoLmxlbmd0aCkge1xcclxcbiAgICAgIGVsZW1lbnRUZW1wbGF0ZXMubm9SZXN1bHRzLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5ub25lUmVzdWx0c1RleHQucmVwbGFjZSgnezB9JywgJ1xcXCInICsgaHRtbEVzY2FwZShzZWFyY2hWYWx1ZSkgKyAnXFxcIicpO1xcclxcbiAgICAgIHRoaXMuJG1lbnVJbm5lclswXS5maXJzdENoaWxkLmFwcGVuZENoaWxkKGVsZW1lbnRUZW1wbGF0ZXMubm9SZXN1bHRzKTtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcblxcclxcbiAgdmFyIFNlbGVjdHBpY2tlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBvcHRpb25zKSB7XFxyXFxuICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG5cXHJcXG4gICAgLy8gYm9vdHN0cmFwLXNlbGVjdCBoYXMgYmVlbiBpbml0aWFsaXplZCAtIHJldmVydCB2YWxIb29rcy5zZWxlY3Quc2V0IGJhY2sgdG8gaXRzIG9yaWdpbmFsIGZ1bmN0aW9uXFxyXFxuICAgIGlmICghdmFsSG9va3MudXNlRGVmYXVsdCkge1xcclxcbiAgICAgICQudmFsSG9va3Muc2VsZWN0LnNldCA9IHZhbEhvb2tzLl9zZXQ7XFxyXFxuICAgICAgdmFsSG9va3MudXNlRGVmYXVsdCA9IHRydWU7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XFxyXFxuICAgIHRoaXMuJG5ld0VsZW1lbnQgPSBudWxsO1xcclxcbiAgICB0aGlzLiRidXR0b24gPSBudWxsO1xcclxcbiAgICB0aGlzLiRtZW51ID0gbnVsbDtcXHJcXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXHJcXG4gICAgdGhpcy5zZWxlY3RwaWNrZXIgPSB7XFxyXFxuICAgICAgbWFpbjoge30sXFxyXFxuICAgICAgc2VhcmNoOiB7fSxcXHJcXG4gICAgICBjdXJyZW50OiB7fSwgLy8gY3VycmVudCBjaGFuZ2VzIGlmIGEgc2VhcmNoIGlzIGluIHByb2dyZXNzXFxyXFxuICAgICAgdmlldzoge30sXFxyXFxuICAgICAgaXNTZWFyY2hpbmc6IGZhbHNlLFxcclxcbiAgICAgIGtleWRvd246IHtcXHJcXG4gICAgICAgIGtleUhpc3Rvcnk6ICcnLFxcclxcbiAgICAgICAgcmVzZXRLZXlIaXN0b3J5OiB7XFxyXFxuICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5ID0gJyc7XFxyXFxuICAgICAgICAgICAgfSwgODAwKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG5cXHJcXG4gICAgdGhpcy5zaXplSW5mbyA9IHt9O1xcclxcblxcclxcbiAgICAvLyBJZiB3ZSBoYXZlIG5vIHRpdGxlIHlldCwgdHJ5IHRvIHB1bGwgaXQgZnJvbSB0aGUgaHRtbCB0aXRsZSBhdHRyaWJ1dGUgKGpRdWVyeSBkb2VzbnQnIHBpY2sgaXQgdXAgYXMgaXQncyBub3QgYVxcclxcbiAgICAvLyBkYXRhLWF0dHJpYnV0ZSlcXHJcXG4gICAgaWYgKHRoaXMub3B0aW9ucy50aXRsZSA9PT0gbnVsbCkge1xcclxcbiAgICAgIHRoaXMub3B0aW9ucy50aXRsZSA9IHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnKTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyBGb3JtYXQgd2luZG93IHBhZGRpbmdcXHJcXG4gICAgdmFyIHdpblBhZCA9IHRoaXMub3B0aW9ucy53aW5kb3dQYWRkaW5nO1xcclxcbiAgICBpZiAodHlwZW9mIHdpblBhZCA9PT0gJ251bWJlcicpIHtcXHJcXG4gICAgICB0aGlzLm9wdGlvbnMud2luZG93UGFkZGluZyA9IFt3aW5QYWQsIHdpblBhZCwgd2luUGFkLCB3aW5QYWRdO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIC8vIEV4cG9zZSBwdWJsaWMgbWV0aG9kc1xcclxcbiAgICB0aGlzLnZhbCA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUudmFsO1xcclxcbiAgICB0aGlzLnJlbmRlciA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUucmVuZGVyO1xcclxcbiAgICB0aGlzLnJlZnJlc2ggPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnJlZnJlc2g7XFxyXFxuICAgIHRoaXMuc2V0U3R5bGUgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnNldFN0eWxlO1xcclxcbiAgICB0aGlzLnNlbGVjdEFsbCA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUuc2VsZWN0QWxsO1xcclxcbiAgICB0aGlzLmRlc2VsZWN0QWxsID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5kZXNlbGVjdEFsbDtcXHJcXG4gICAgdGhpcy5kZXN0cm95ID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5kZXN0cm95O1xcclxcbiAgICB0aGlzLnJlbW92ZSA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUucmVtb3ZlO1xcclxcbiAgICB0aGlzLnNob3cgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnNob3c7XFxyXFxuICAgIHRoaXMuaGlkZSA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUuaGlkZTtcXHJcXG5cXHJcXG4gICAgdGhpcy5pbml0KCk7XFxyXFxuICB9O1xcclxcblxcclxcbiAgU2VsZWN0cGlja2VyLlZFUlNJT04gPSAnMS4xMy4xOCc7XFxyXFxuXFxyXFxuICAvLyBwYXJ0IG9mIHRoaXMgaXMgZHVwbGljYXRlZCBpbiBpMThuL2RlZmF1bHRzLWVuX1VTLmpzLiBNYWtlIHN1cmUgdG8gdXBkYXRlIGJvdGguXFxyXFxuICBTZWxlY3RwaWNrZXIuREVGQVVMVFMgPSB7XFxyXFxuICAgIG5vbmVTZWxlY3RlZFRleHQ6ICdOb3RoaW5nIHNlbGVjdGVkJyxcXHJcXG4gICAgbm9uZVJlc3VsdHNUZXh0OiAnTm8gcmVzdWx0cyBtYXRjaGVkIHswfScsXFxyXFxuICAgIGNvdW50U2VsZWN0ZWRUZXh0OiBmdW5jdGlvbiAobnVtU2VsZWN0ZWQsIG51bVRvdGFsKSB7XFxyXFxuICAgICAgcmV0dXJuIChudW1TZWxlY3RlZCA9PSAxKSA/ICd7MH0gaXRlbSBzZWxlY3RlZCcgOiAnezB9IGl0ZW1zIHNlbGVjdGVkJztcXHJcXG4gICAgfSxcXHJcXG4gICAgbWF4T3B0aW9uc1RleHQ6IGZ1bmN0aW9uIChudW1BbGwsIG51bUdyb3VwKSB7XFxyXFxuICAgICAgcmV0dXJuIFtcXHJcXG4gICAgICAgIChudW1BbGwgPT0gMSkgPyAnTGltaXQgcmVhY2hlZCAoe259IGl0ZW0gbWF4KScgOiAnTGltaXQgcmVhY2hlZCAoe259IGl0ZW1zIG1heCknLFxcclxcbiAgICAgICAgKG51bUdyb3VwID09IDEpID8gJ0dyb3VwIGxpbWl0IHJlYWNoZWQgKHtufSBpdGVtIG1heCknIDogJ0dyb3VwIGxpbWl0IHJlYWNoZWQgKHtufSBpdGVtcyBtYXgpJ1xcclxcbiAgICAgIF07XFxyXFxuICAgIH0sXFxyXFxuICAgIHNlbGVjdEFsbFRleHQ6ICdTZWxlY3QgQWxsJyxcXHJcXG4gICAgZGVzZWxlY3RBbGxUZXh0OiAnRGVzZWxlY3QgQWxsJyxcXHJcXG4gICAgZG9uZUJ1dHRvbjogZmFsc2UsXFxyXFxuICAgIGRvbmVCdXR0b25UZXh0OiAnQ2xvc2UnLFxcclxcbiAgICBtdWx0aXBsZVNlcGFyYXRvcjogJywgJyxcXHJcXG4gICAgc3R5bGVCYXNlOiAnYnRuJyxcXHJcXG4gICAgc3R5bGU6IGNsYXNzTmFtZXMuQlVUVE9OQ0xBU1MsXFxyXFxuICAgIHNpemU6ICdhdXRvJyxcXHJcXG4gICAgdGl0bGU6IG51bGwsXFxyXFxuICAgIHNlbGVjdGVkVGV4dEZvcm1hdDogJ3ZhbHVlcycsXFxyXFxuICAgIHdpZHRoOiBmYWxzZSxcXHJcXG4gICAgY29udGFpbmVyOiBmYWxzZSxcXHJcXG4gICAgaGlkZURpc2FibGVkOiBmYWxzZSxcXHJcXG4gICAgc2hvd1N1YnRleHQ6IGZhbHNlLFxcclxcbiAgICBzaG93SWNvbjogdHJ1ZSxcXHJcXG4gICAgc2hvd0NvbnRlbnQ6IHRydWUsXFxyXFxuICAgIGRyb3B1cEF1dG86IHRydWUsXFxyXFxuICAgIGhlYWRlcjogZmFsc2UsXFxyXFxuICAgIGxpdmVTZWFyY2g6IGZhbHNlLFxcclxcbiAgICBsaXZlU2VhcmNoUGxhY2Vob2xkZXI6IG51bGwsXFxyXFxuICAgIGxpdmVTZWFyY2hOb3JtYWxpemU6IGZhbHNlLFxcclxcbiAgICBsaXZlU2VhcmNoU3R5bGU6ICdjb250YWlucycsXFxyXFxuICAgIGFjdGlvbnNCb3g6IGZhbHNlLFxcclxcbiAgICBpY29uQmFzZTogY2xhc3NOYW1lcy5JQ09OQkFTRSxcXHJcXG4gICAgdGlja0ljb246IGNsYXNzTmFtZXMuVElDS0lDT04sXFxyXFxuICAgIHNob3dUaWNrOiBmYWxzZSxcXHJcXG4gICAgdGVtcGxhdGU6IHtcXHJcXG4gICAgICBjYXJldDogJzxzcGFuIGNsYXNzPVxcXCJjYXJldFxcXCI+PC9zcGFuPidcXHJcXG4gICAgfSxcXHJcXG4gICAgbWF4T3B0aW9uczogZmFsc2UsXFxyXFxuICAgIG1vYmlsZTogZmFsc2UsXFxyXFxuICAgIHNlbGVjdE9uVGFiOiBmYWxzZSxcXHJcXG4gICAgZHJvcGRvd25BbGlnblJpZ2h0OiBmYWxzZSxcXHJcXG4gICAgd2luZG93UGFkZGluZzogMCxcXHJcXG4gICAgdmlydHVhbFNjcm9sbDogNjAwLFxcclxcbiAgICBkaXNwbGF5OiBmYWxzZSxcXHJcXG4gICAgc2FuaXRpemU6IHRydWUsXFxyXFxuICAgIHNhbml0aXplRm46IG51bGwsXFxyXFxuICAgIHdoaXRlTGlzdDogRGVmYXVsdFdoaXRlbGlzdFxcclxcbiAgfTtcXHJcXG5cXHJcXG4gIFNlbGVjdHBpY2tlci5wcm90b3R5cGUgPSB7XFxyXFxuXFxyXFxuICAgIGNvbnN0cnVjdG9yOiBTZWxlY3RwaWNrZXIsXFxyXFxuXFxyXFxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxyXFxuICAgICAgICAgIGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpLFxcclxcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXSxcXHJcXG4gICAgICAgICAgZm9ybSA9IGVsZW1lbnQuZm9ybTtcXHJcXG5cXHJcXG4gICAgICBzZWxlY3RJZCsrO1xcclxcbiAgICAgIHRoaXMuc2VsZWN0SWQgPSAnYnMtc2VsZWN0LScgKyBzZWxlY3RJZDtcXHJcXG5cXHJcXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2JzLXNlbGVjdC1oaWRkZW4nKTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLm11bHRpcGxlID0gdGhpcy4kZWxlbWVudC5wcm9wKCdtdWx0aXBsZScpO1xcclxcbiAgICAgIHRoaXMuYXV0b2ZvY3VzID0gdGhpcy4kZWxlbWVudC5wcm9wKCdhdXRvZm9jdXMnKTtcXHJcXG5cXHJcXG4gICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3Nob3ctdGljaycpKSB7XFxyXFxuICAgICAgICB0aGlzLm9wdGlvbnMuc2hvd1RpY2sgPSB0cnVlO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50ID0gdGhpcy5jcmVhdGVEcm9wZG93bigpO1xcclxcbiAgICAgIHRoaXMuYnVpbGREYXRhKCk7XFxyXFxuICAgICAgdGhpcy4kZWxlbWVudFxcclxcbiAgICAgICAgLmFmdGVyKHRoaXMuJG5ld0VsZW1lbnQpXFxyXFxuICAgICAgICAucHJlcGVuZFRvKHRoaXMuJG5ld0VsZW1lbnQpO1xcclxcblxcclxcbiAgICAgIC8vIGVuc3VyZSBzZWxlY3QgaXMgYXNzb2NpYXRlZCB3aXRoIGZvcm0gZWxlbWVudCBpZiBpdCBnb3QgdW5saW5rZWQgYWZ0ZXIgbW92aW5nIGl0IGluc2lkZSBuZXdFbGVtZW50XFxyXFxuICAgICAgaWYgKGZvcm0gJiYgZWxlbWVudC5mb3JtID09PSBudWxsKSB7XFxyXFxuICAgICAgICBpZiAoIWZvcm0uaWQpIGZvcm0uaWQgPSAnZm9ybS0nICsgdGhpcy5zZWxlY3RJZDtcXHJcXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb3JtJywgZm9ybS5pZCk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHRoaXMuJGJ1dHRvbiA9IHRoaXMuJG5ld0VsZW1lbnQuY2hpbGRyZW4oJ2J1dHRvbicpO1xcclxcbiAgICAgIHRoaXMuJG1lbnUgPSB0aGlzLiRuZXdFbGVtZW50LmNoaWxkcmVuKFNlbGVjdG9yLk1FTlUpO1xcclxcbiAgICAgIHRoaXMuJG1lbnVJbm5lciA9IHRoaXMuJG1lbnUuY2hpbGRyZW4oJy5pbm5lcicpO1xcclxcbiAgICAgIHRoaXMuJHNlYXJjaGJveCA9IHRoaXMuJG1lbnUuZmluZCgnaW5wdXQnKTtcXHJcXG5cXHJcXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2JzLXNlbGVjdC1oaWRkZW4nKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3Bkb3duQWxpZ25SaWdodCA9PT0gdHJ1ZSkgdGhpcy4kbWVudVswXS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZXMuTUVOVVJJR0hUKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodHlwZW9mIGlkICE9PSAndW5kZWZpbmVkJykge1xcclxcbiAgICAgICAgdGhpcy4kYnV0dG9uLmF0dHIoJ2RhdGEtaWQnLCBpZCk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHRoaXMuY2hlY2tEaXNhYmxlZCgpO1xcclxcbiAgICAgIHRoaXMuY2xpY2tMaXN0ZW5lcigpO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgdGhpcy5saXZlU2VhcmNoTGlzdGVuZXIoKTtcXHJcXG4gICAgICAgIHRoaXMuZm9jdXNlZFBhcmVudCA9IHRoaXMuJHNlYXJjaGJveFswXTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdGhpcy5mb2N1c2VkUGFyZW50ID0gdGhpcy4kbWVudUlubmVyWzBdO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLnNldFN0eWxlKCk7XFxyXFxuICAgICAgdGhpcy5yZW5kZXIoKTtcXHJcXG4gICAgICB0aGlzLnNldFdpZHRoKCk7XFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250YWluZXIpIHtcXHJcXG4gICAgICAgIHRoaXMuc2VsZWN0UG9zaXRpb24oKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignaGlkZScgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgaWYgKHRoYXQuaXNWaXJ0dWFsKCkpIHtcXHJcXG4gICAgICAgICAgICAvLyBlbXB0eSBtZW51IG9uIGNsb3NlXFxyXFxuICAgICAgICAgICAgdmFyIG1lbnVJbm5lciA9IHRoYXQuJG1lbnVJbm5lclswXSxcXHJcXG4gICAgICAgICAgICAgICAgZW1wdHlNZW51ID0gbWVudUlubmVyLmZpcnN0Q2hpbGQuY2xvbmVOb2RlKGZhbHNlKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBleGlzdGluZyBVTCB3aXRoIGFuIGVtcHR5IG9uZSAtIHRoaXMgaXMgZmFzdGVyIHRoYW4gJC5lbXB0eSgpIG9yIGlubmVySFRNTCA9ICcnXFxyXFxuICAgICAgICAgICAgbWVudUlubmVyLnJlcGxhY2VDaGlsZChlbXB0eU1lbnUsIG1lbnVJbm5lci5maXJzdENoaWxkKTtcXHJcXG4gICAgICAgICAgICBtZW51SW5uZXIuc2Nyb2xsVG9wID0gMDtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIHRoaXMuJG1lbnUuZGF0YSgndGhpcycsIHRoaXMpO1xcclxcbiAgICAgIHRoaXMuJG5ld0VsZW1lbnQuZGF0YSgndGhpcycsIHRoaXMpO1xcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubW9iaWxlKSB0aGlzLm1vYmlsZSgpO1xcclxcblxcclxcbiAgICAgIHRoaXMuJG5ld0VsZW1lbnQub24oe1xcclxcbiAgICAgICAgJ2hpZGUuYnMuZHJvcGRvd24nOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2hpZGUnICsgRVZFTlRfS0VZLCBlKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICAnaGlkZGVuLmJzLmRyb3Bkb3duJzogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRkZW4nICsgRVZFTlRfS0VZLCBlKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICAnc2hvdy5icy5kcm9wZG93bic6IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignc2hvdycgKyBFVkVOVF9LRVksIGUpO1xcclxcbiAgICAgICAgfSxcXHJcXG4gICAgICAgICdzaG93bi5icy5kcm9wZG93bic6IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignc2hvd24nICsgRVZFTlRfS0VZLCBlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JlcXVpcmVkJykpIHtcXHJcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2ludmFsaWQnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJGJ1dHRvblswXS5jbGFzc0xpc3QuYWRkKCdicy1pbnZhbGlkJyk7XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuJGVsZW1lbnRcXHJcXG4gICAgICAgICAgICAub24oJ3Nob3duJyArIEVWRU5UX0tFWSArICcuaW52YWxpZCcsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnRcXHJcXG4gICAgICAgICAgICAgICAgLnZhbCh0aGF0LiRlbGVtZW50LnZhbCgpKSAvLyBzZXQgdGhlIHZhbHVlIHRvIGhpZGUgdGhlIHZhbGlkYXRpb24gbWVzc2FnZSBpbiBDaHJvbWUgd2hlbiBtZW51IGlzIG9wZW5lZFxcclxcbiAgICAgICAgICAgICAgICAub2ZmKCdzaG93bicgKyBFVkVOVF9LRVkgKyAnLmludmFsaWQnKTtcXHJcXG4gICAgICAgICAgICB9KVxcclxcbiAgICAgICAgICAgIC5vbigncmVuZGVyZWQnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgICAvLyBpZiBzZWxlY3QgaXMgbm8gbG9uZ2VyIGludmFsaWQsIHJlbW92ZSB0aGUgYnMtaW52YWxpZCBjbGFzc1xcclxcbiAgICAgICAgICAgICAgaWYgKHRoaXMudmFsaWRpdHkudmFsaWQpIHRoYXQuJGJ1dHRvblswXS5jbGFzc0xpc3QucmVtb3ZlKCdicy1pbnZhbGlkJyk7XFxyXFxuICAgICAgICAgICAgICB0aGF0LiRlbGVtZW50Lm9mZigncmVuZGVyZWQnICsgRVZFTlRfS0VZKTtcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICAgICAgdGhhdC4kYnV0dG9uLm9uKCdibHVyJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKCdibHVyJyk7XFxyXFxuICAgICAgICAgICAgdGhhdC4kYnV0dG9uLm9mZignYmx1cicgKyBFVkVOVF9LRVkpO1xcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHRoYXQuYnVpbGRMaXN0KCk7XFxyXFxuICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2xvYWRlZCcgKyBFVkVOVF9LRVkpO1xcclxcbiAgICAgIH0pO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBjcmVhdGVEcm9wZG93bjogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIC8vIE9wdGlvbnNcXHJcXG4gICAgICAvLyBJZiB3ZSBhcmUgbXVsdGlwbGUgb3Igc2hvd1RpY2sgb3B0aW9uIGlzIHNldCwgdGhlbiBhZGQgdGhlIHNob3ctdGljayBjbGFzc1xcclxcbiAgICAgIHZhciBzaG93VGljayA9ICh0aGlzLm11bHRpcGxlIHx8IHRoaXMub3B0aW9ucy5zaG93VGljaykgPyAnIHNob3ctdGljaycgOiAnJyxcXHJcXG4gICAgICAgICAgbXVsdGlzZWxlY3RhYmxlID0gdGhpcy5tdWx0aXBsZSA/ICcgYXJpYS1tdWx0aXNlbGVjdGFibGU9XFxcInRydWVcXFwiJyA6ICcnLFxcclxcbiAgICAgICAgICBpbnB1dEdyb3VwID0gJycsXFxyXFxuICAgICAgICAgIGF1dG9mb2N1cyA9IHRoaXMuYXV0b2ZvY3VzID8gJyBhdXRvZm9jdXMnIDogJyc7XFxyXFxuXFxyXFxuICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPCA0ICYmIHRoaXMuJGVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoJ2lucHV0LWdyb3VwJykpIHtcXHJcXG4gICAgICAgIGlucHV0R3JvdXAgPSAnIGlucHV0LWdyb3VwLWJ0bic7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIC8vIEVsZW1lbnRzXFxyXFxuICAgICAgdmFyIGRyb3AsXFxyXFxuICAgICAgICAgIGhlYWRlciA9ICcnLFxcclxcbiAgICAgICAgICBzZWFyY2hib3ggPSAnJyxcXHJcXG4gICAgICAgICAgYWN0aW9uc2JveCA9ICcnLFxcclxcbiAgICAgICAgICBkb25lYnV0dG9uID0gJyc7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXIpIHtcXHJcXG4gICAgICAgIGhlYWRlciA9XFxyXFxuICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCInICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSICsgJ1xcXCI+JyArXFxyXFxuICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiY2xvc2VcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj4mdGltZXM7PC9idXR0b24+JyArXFxyXFxuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaGVhZGVyICtcXHJcXG4gICAgICAgICAgJzwvZGl2Pic7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgc2VhcmNoYm94ID1cXHJcXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImJzLXNlYXJjaGJveFxcXCI+JyArXFxyXFxuICAgICAgICAgICAgJzxpbnB1dCB0eXBlPVxcXCJzZWFyY2hcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIicgK1xcclxcbiAgICAgICAgICAgICAgKFxcclxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaFBsYWNlaG9sZGVyID09PSBudWxsID8gJydcXHJcXG4gICAgICAgICAgICAgICAgOlxcclxcbiAgICAgICAgICAgICAgICAnIHBsYWNlaG9sZGVyPVxcXCInICsgaHRtbEVzY2FwZSh0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaFBsYWNlaG9sZGVyKSArICdcXFwiJ1xcclxcbiAgICAgICAgICAgICAgKSArXFxyXFxuICAgICAgICAgICAgICAnIHJvbGU9XFxcImNvbWJvYm94XFxcIiBhcmlhLWxhYmVsPVxcXCJTZWFyY2hcXFwiIGFyaWEtY29udHJvbHM9XFxcIicgKyB0aGlzLnNlbGVjdElkICsgJ1xcXCIgYXJpYS1hdXRvY29tcGxldGU9XFxcImxpc3RcXFwiPicgK1xcclxcbiAgICAgICAgICAnPC9kaXY+JztcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMubXVsdGlwbGUgJiYgdGhpcy5vcHRpb25zLmFjdGlvbnNCb3gpIHtcXHJcXG4gICAgICAgIGFjdGlvbnNib3ggPVxcclxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cXFwiYnMtYWN0aW9uc2JveFxcXCI+JyArXFxyXFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cCBidG4tZ3JvdXAtc20gYnRuLWJsb2NrXFxcIj4nICtcXHJcXG4gICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImFjdGlvbnMtYnRuIGJzLXNlbGVjdC1hbGwgYnRuICcgKyBjbGFzc05hbWVzLkJVVFRPTkNMQVNTICsgJ1xcXCI+JyArXFxyXFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zZWxlY3RBbGxUZXh0ICtcXHJcXG4gICAgICAgICAgICAgICc8L2J1dHRvbj4nICtcXHJcXG4gICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImFjdGlvbnMtYnRuIGJzLWRlc2VsZWN0LWFsbCBidG4gJyArIGNsYXNzTmFtZXMuQlVUVE9OQ0xBU1MgKyAnXFxcIj4nICtcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRlc2VsZWN0QWxsVGV4dCArXFxyXFxuICAgICAgICAgICAgICAnPC9idXR0b24+JyArXFxyXFxuICAgICAgICAgICAgJzwvZGl2PicgK1xcclxcbiAgICAgICAgICAnPC9kaXY+JztcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMubXVsdGlwbGUgJiYgdGhpcy5vcHRpb25zLmRvbmVCdXR0b24pIHtcXHJcXG4gICAgICAgIGRvbmVidXR0b24gPVxcclxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cXFwiYnMtZG9uZWJ1dHRvblxcXCI+JyArXFxyXFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImJ0bi1ncm91cCBidG4tYmxvY2tcXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgJzxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSAnICsgY2xhc3NOYW1lcy5CVVRUT05DTEFTUyArICdcXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZG9uZUJ1dHRvblRleHQgK1xcclxcbiAgICAgICAgICAgICAgJzwvYnV0dG9uPicgK1xcclxcbiAgICAgICAgICAgICc8L2Rpdj4nICtcXHJcXG4gICAgICAgICAgJzwvZGl2Pic7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGRyb3AgPVxcclxcbiAgICAgICAgJzxkaXYgY2xhc3M9XFxcImRyb3Bkb3duIGJvb3RzdHJhcC1zZWxlY3QnICsgc2hvd1RpY2sgKyBpbnB1dEdyb3VwICsgJ1xcXCI+JyArXFxyXFxuICAgICAgICAgICc8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiBjbGFzcz1cXFwiJyArIHRoaXMub3B0aW9ucy5zdHlsZUJhc2UgKyAnIGRyb3Bkb3duLXRvZ2dsZVxcXCIgJyArICh0aGlzLm9wdGlvbnMuZGlzcGxheSA9PT0gJ3N0YXRpYycgPyAnZGF0YS1kaXNwbGF5PVxcXCJzdGF0aWNcXFwiJyA6ICcnKSArICdkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiJyArIGF1dG9mb2N1cyArICcgcm9sZT1cXFwiY29tYm9ib3hcXFwiIGFyaWEtb3ducz1cXFwiJyArIHRoaXMuc2VsZWN0SWQgKyAnXFxcIiBhcmlhLWhhc3BvcHVwPVxcXCJsaXN0Ym94XFxcIiBhcmlhLWV4cGFuZGVkPVxcXCJmYWxzZVxcXCI+JyArXFxyXFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImZpbHRlci1vcHRpb25cXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImZpbHRlci1vcHRpb24taW5uZXJcXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cXFwiZmlsdGVyLW9wdGlvbi1pbm5lci1pbm5lclxcXCI+PC9kaXY+JyArXFxyXFxuICAgICAgICAgICAgICAnPC9kaXY+ICcgK1xcclxcbiAgICAgICAgICAgICc8L2Rpdj4nICtcXHJcXG4gICAgICAgICAgICAoXFxyXFxuICAgICAgICAgICAgICB2ZXJzaW9uLm1ham9yID09PSAnNCcgPyAnJ1xcclxcbiAgICAgICAgICAgICAgOlxcclxcbiAgICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJicy1jYXJldFxcXCI+JyArXFxyXFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50ZW1wbGF0ZS5jYXJldCArXFxyXFxuICAgICAgICAgICAgICAnPC9zcGFuPidcXHJcXG4gICAgICAgICAgICApICtcXHJcXG4gICAgICAgICAgJzwvYnV0dG9uPicgK1xcclxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cXFwiJyArIGNsYXNzTmFtZXMuTUVOVSArICcgJyArICh2ZXJzaW9uLm1ham9yID09PSAnNCcgPyAnJyA6IGNsYXNzTmFtZXMuU0hPVykgKyAnXFxcIj4nICtcXHJcXG4gICAgICAgICAgICBoZWFkZXIgK1xcclxcbiAgICAgICAgICAgIHNlYXJjaGJveCArXFxyXFxuICAgICAgICAgICAgYWN0aW9uc2JveCArXFxyXFxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImlubmVyICcgKyBjbGFzc05hbWVzLlNIT1cgKyAnXFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIiBpZD1cXFwiJyArIHRoaXMuc2VsZWN0SWQgKyAnXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiICcgKyBtdWx0aXNlbGVjdGFibGUgKyAnPicgK1xcclxcbiAgICAgICAgICAgICAgICAnPHVsIGNsYXNzPVxcXCInICsgY2xhc3NOYW1lcy5NRU5VICsgJyBpbm5lciAnICsgKHZlcnNpb24ubWFqb3IgPT09ICc0JyA/IGNsYXNzTmFtZXMuU0hPVyA6ICcnKSArICdcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyArXFxyXFxuICAgICAgICAgICAgICAgICc8L3VsPicgK1xcclxcbiAgICAgICAgICAgICc8L2Rpdj4nICtcXHJcXG4gICAgICAgICAgICBkb25lYnV0dG9uICtcXHJcXG4gICAgICAgICAgJzwvZGl2PicgK1xcclxcbiAgICAgICAgJzwvZGl2Pic7XFxyXFxuXFxyXFxuICAgICAgcmV0dXJuICQoZHJvcCk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNldFBvc2l0aW9uRGF0YTogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0ID0gW107XFxyXFxuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5zaXplID0gMDtcXHJcXG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXggPSBmYWxzZTtcXHJcXG5cXHJcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgdmFyIGxpID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2ldLFxcclxcbiAgICAgICAgICAgIGNhbkhpZ2hsaWdodCA9IHRydWU7XFxyXFxuXFxyXFxuICAgICAgICBpZiAobGkudHlwZSA9PT0gJ2RpdmlkZXInKSB7XFxyXFxuICAgICAgICAgIGNhbkhpZ2hsaWdodCA9IGZhbHNlO1xcclxcbiAgICAgICAgICBsaS5oZWlnaHQgPSB0aGlzLnNpemVJbmZvLmRpdmlkZXJIZWlnaHQ7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKGxpLnR5cGUgPT09ICdvcHRncm91cC1sYWJlbCcpIHtcXHJcXG4gICAgICAgICAgY2FuSGlnaGxpZ2h0ID0gZmFsc2U7XFxyXFxuICAgICAgICAgIGxpLmhlaWdodCA9IHRoaXMuc2l6ZUluZm8uZHJvcGRvd25IZWFkZXJIZWlnaHQ7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICBsaS5oZWlnaHQgPSB0aGlzLnNpemVJbmZvLmxpSGVpZ2h0O1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKGxpLmRpc2FibGVkKSBjYW5IaWdobGlnaHQgPSBmYWxzZTtcXHJcXG5cXHJcXG4gICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0LnB1c2goY2FuSGlnaGxpZ2h0KTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChjYW5IaWdobGlnaHQpIHtcXHJcXG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5zaXplKys7XFxyXFxuICAgICAgICAgIGxpLnBvc2luc2V0ID0gdGhpcy5zZWxlY3RwaWNrZXIudmlldy5zaXplO1xcclxcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4ID09PSBmYWxzZSkgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4ID0gaTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGxpLnBvc2l0aW9uID0gKGkgPT09IDAgPyAwIDogdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2kgLSAxXS5wb3NpdGlvbikgKyBsaS5oZWlnaHQ7XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBpc1ZpcnR1YWw6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICByZXR1cm4gKHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsICE9PSBmYWxzZSkgJiYgKHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHMubGVuZ3RoID49IHRoaXMub3B0aW9ucy52aXJ0dWFsU2Nyb2xsKSB8fCB0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbCA9PT0gdHJ1ZTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgY3JlYXRlVmlldzogZnVuY3Rpb24gKGlzU2VhcmNoaW5nLCBzZXRTaXplLCByZWZyZXNoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICBzY3JvbGxUb3AgPSAwLFxcclxcbiAgICAgICAgICBhY3RpdmUgPSBbXSxcXHJcXG4gICAgICAgICAgc2VsZWN0ZWQsXFxyXFxuICAgICAgICAgIHByZXZBY3RpdmU7XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuaXNTZWFyY2hpbmcgPSBpc1NlYXJjaGluZztcXHJcXG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50ID0gaXNTZWFyY2hpbmcgPyB0aGlzLnNlbGVjdHBpY2tlci5zZWFyY2ggOiB0aGlzLnNlbGVjdHBpY2tlci5tYWluO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25EYXRhKCk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHNldFNpemUpIHtcXHJcXG4gICAgICAgIGlmIChyZWZyZXNoKSB7XFxyXFxuICAgICAgICAgIHNjcm9sbFRvcCA9IHRoaXMuJG1lbnVJbm5lclswXS5zY3JvbGxUb3A7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKCF0aGF0Lm11bHRpcGxlKSB7XFxyXFxuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhhdC4kZWxlbWVudFswXSxcXHJcXG4gICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXggPSAoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0gfHwge30pLmxpSW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWRJbmRleCA9PT0gJ251bWJlcicgJiYgdGhhdC5vcHRpb25zLnNpemUgIT09IGZhbHNlKSB7XFxyXFxuICAgICAgICAgICAgdmFyIHNlbGVjdGVkRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtzZWxlY3RlZEluZGV4XSxcXHJcXG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzZWxlY3RlZERhdGEgJiYgc2VsZWN0ZWREYXRhLnBvc2l0aW9uO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xcclxcbiAgICAgICAgICAgICAgc2Nyb2xsVG9wID0gcG9zaXRpb24gLSAoKHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0ICsgdGhhdC5zaXplSW5mby5saUhlaWdodCkgLyAyKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgc2Nyb2xsKHNjcm9sbFRvcCwgdHJ1ZSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbWVudUlubmVyLm9mZignc2Nyb2xsLmNyZWF0ZVZpZXcnKS5vbignc2Nyb2xsLmNyZWF0ZVZpZXcnLCBmdW5jdGlvbiAoZSwgdXBkYXRlVmFsdWUpIHtcXHJcXG4gICAgICAgIGlmICghdGhhdC5ub1Njcm9sbCkgc2Nyb2xsKHRoaXMuc2Nyb2xsVG9wLCB1cGRhdGVWYWx1ZSk7XFxyXFxuICAgICAgICB0aGF0Lm5vU2Nyb2xsID0gZmFsc2U7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgZnVuY3Rpb24gc2Nyb2xsIChzY3JvbGxUb3AsIGluaXQpIHtcXHJcXG4gICAgICAgIHZhciBzaXplID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5sZW5ndGgsXFxyXFxuICAgICAgICAgICAgY2h1bmtzID0gW10sXFxyXFxuICAgICAgICAgICAgY2h1bmtTaXplLFxcclxcbiAgICAgICAgICAgIGNodW5rQ291bnQsXFxyXFxuICAgICAgICAgICAgZmlyc3RDaHVuayxcXHJcXG4gICAgICAgICAgICBsYXN0Q2h1bmssXFxyXFxuICAgICAgICAgICAgY3VycmVudENodW5rLFxcclxcbiAgICAgICAgICAgIHByZXZQb3NpdGlvbnMsXFxyXFxuICAgICAgICAgICAgcG9zaXRpb25Jc0RpZmZlcmVudCxcXHJcXG4gICAgICAgICAgICBwcmV2aW91c0VsZW1lbnRzLFxcclxcbiAgICAgICAgICAgIG1lbnVJc0RpZmZlcmVudCA9IHRydWUsXFxyXFxuICAgICAgICAgICAgaXNWaXJ0dWFsID0gdGhhdC5pc1ZpcnR1YWwoKTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xcclxcblxcclxcbiAgICAgICAgY2h1bmtTaXplID0gTWF0aC5jZWlsKHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0IC8gdGhhdC5zaXplSW5mby5saUhlaWdodCAqIDEuNSk7IC8vIG51bWJlciBvZiBvcHRpb25zIGluIGEgY2h1bmtcXHJcXG4gICAgICAgIGNodW5rQ291bnQgPSBNYXRoLnJvdW5kKHNpemUgLyBjaHVua1NpemUpIHx8IDE7IC8vIG51bWJlciBvZiBjaHVua3NcXHJcXG5cXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmtDb3VudDsgaSsrKSB7XFxyXFxuICAgICAgICAgIHZhciBlbmRPZkNodW5rID0gKGkgKyAxKSAqIGNodW5rU2l6ZTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKGkgPT09IGNodW5rQ291bnQgLSAxKSB7XFxyXFxuICAgICAgICAgICAgZW5kT2ZDaHVuayA9IHNpemU7XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgY2h1bmtzW2ldID0gW1xcclxcbiAgICAgICAgICAgIChpKSAqIGNodW5rU2l6ZSArICghaSA/IDAgOiAxKSxcXHJcXG4gICAgICAgICAgICBlbmRPZkNodW5rXFxyXFxuICAgICAgICAgIF07XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICghc2l6ZSkgYnJlYWs7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChjdXJyZW50Q2h1bmsgPT09IHVuZGVmaW5lZCAmJiBzY3JvbGxUb3AgLSAxIDw9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtlbmRPZkNodW5rIC0gMV0ucG9zaXRpb24gLSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodCkge1xcclxcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9IGk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChjdXJyZW50Q2h1bmsgPT09IHVuZGVmaW5lZCkgY3VycmVudENodW5rID0gMDtcXHJcXG5cXHJcXG4gICAgICAgIHByZXZQb3NpdGlvbnMgPSBbdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAsIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xXTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIGFsd2F5cyBkaXNwbGF5IHByZXZpb3VzLCBjdXJyZW50LCBhbmQgbmV4dCBjaHVua3NcXHJcXG4gICAgICAgIGZpcnN0Q2h1bmsgPSBNYXRoLm1heCgwLCBjdXJyZW50Q2h1bmsgLSAxKTtcXHJcXG4gICAgICAgIGxhc3RDaHVuayA9IE1hdGgubWluKGNodW5rQ291bnQgLSAxLCBjdXJyZW50Q2h1bmsgKyAxKTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wID0gaXNWaXJ0dWFsID09PSBmYWxzZSA/IDAgOiAoTWF0aC5tYXgoMCwgY2h1bmtzW2ZpcnN0Q2h1bmtdWzBdKSB8fCAwKTtcXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xID0gaXNWaXJ0dWFsID09PSBmYWxzZSA/IHNpemUgOiAoTWF0aC5taW4oc2l6ZSwgY2h1bmtzW2xhc3RDaHVua11bMV0pIHx8IDApO1xcclxcblxcclxcbiAgICAgICAgcG9zaXRpb25Jc0RpZmZlcmVudCA9IHByZXZQb3NpdGlvbnNbMF0gIT09IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wIHx8IHByZXZQb3NpdGlvbnNbMV0gIT09IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xO1xcclxcblxcclxcbiAgICAgICAgaWYgKHRoYXQuYWN0aXZlSW5kZXggIT09IHVuZGVmaW5lZCkge1xcclxcbiAgICAgICAgICBwcmV2QWN0aXZlID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50c1t0aGF0LnByZXZBY3RpdmVJbmRleF07XFxyXFxuICAgICAgICAgIGFjdGl2ZSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbdGhhdC5hY3RpdmVJbmRleF07XFxyXFxuICAgICAgICAgIHNlbGVjdGVkID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50c1t0aGF0LnNlbGVjdGVkSW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoaW5pdCkge1xcclxcbiAgICAgICAgICAgIGlmICh0aGF0LmFjdGl2ZUluZGV4ICE9PSB0aGF0LnNlbGVjdGVkSW5kZXgpIHtcXHJcXG4gICAgICAgICAgICAgIHRoYXQuZGVmb2N1c0l0ZW0oYWN0aXZlKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgdGhhdC5hY3RpdmVJbmRleCA9IHVuZGVmaW5lZDtcXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICBpZiAodGhhdC5hY3RpdmVJbmRleCAmJiB0aGF0LmFjdGl2ZUluZGV4ICE9PSB0aGF0LnNlbGVjdGVkSW5kZXgpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKHNlbGVjdGVkKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKHRoYXQucHJldkFjdGl2ZUluZGV4ICE9PSB1bmRlZmluZWQgJiYgdGhhdC5wcmV2QWN0aXZlSW5kZXggIT09IHRoYXQuYWN0aXZlSW5kZXggJiYgdGhhdC5wcmV2QWN0aXZlSW5kZXggIT09IHRoYXQuc2VsZWN0ZWRJbmRleCkge1xcclxcbiAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKHByZXZBY3RpdmUpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKGluaXQgfHwgcG9zaXRpb25Jc0RpZmZlcmVudCkge1xcclxcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnRzID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMgPyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cy5zbGljZSgpIDogW107XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChpc1ZpcnR1YWwgPT09IGZhbHNlKSB7XFxyXFxuICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzO1xcclxcbiAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5zbGljZSh0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCwgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjEpO1xcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuc2V0T3B0aW9uU3RhdHVzKCk7XFxyXFxuXFxyXFxuICAgICAgICAgIC8vIGlmIHNlYXJjaGluZywgY2hlY2sgdG8gbWFrZSBzdXJlIHRoZSBsaXN0IGhhcyBhY3R1YWxseSBiZWVuIHVwZGF0ZWQgYmVmb3JlIHVwZGF0aW5nIERPTVxcclxcbiAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIHVubmVjZXNzYXJ5IHJlcGFpbnRzXFxyXFxuICAgICAgICAgIGlmIChpc1NlYXJjaGluZyB8fCAoaXNWaXJ0dWFsID09PSBmYWxzZSAmJiBpbml0KSkgbWVudUlzRGlmZmVyZW50ID0gIWlzRXF1YWwocHJldmlvdXNFbGVtZW50cywgdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMpO1xcclxcblxcclxcbiAgICAgICAgICAvLyBpZiB2aXJ0dWFsIHNjcm9sbCBpcyBkaXNhYmxlZCBhbmQgbm90IHNlYXJjaGluZyxcXHJcXG4gICAgICAgICAgLy8gbWVudSBzaG91bGQgbmV2ZXIgbmVlZCB0byBiZSB1cGRhdGVkIG1vcmUgdGhhbiBvbmNlXFxyXFxuICAgICAgICAgIGlmICgoaW5pdCB8fCBpc1ZpcnR1YWwgPT09IHRydWUpICYmIG1lbnVJc0RpZmZlcmVudCkge1xcclxcbiAgICAgICAgICAgIHZhciBtZW51SW5uZXIgPSB0aGF0LiRtZW51SW5uZXJbMF0sXFxyXFxuICAgICAgICAgICAgICAgIG1lbnVGcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcXHJcXG4gICAgICAgICAgICAgICAgZW1wdHlNZW51ID0gbWVudUlubmVyLmZpcnN0Q2hpbGQuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wLFxcclxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20sXFxyXFxuICAgICAgICAgICAgICAgIGVsZW1lbnRzID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMsXFxyXFxuICAgICAgICAgICAgICAgIHRvU2FuaXRpemUgPSBbXTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBleGlzdGluZyBVTCB3aXRoIGFuIGVtcHR5IG9uZSAtIHRoaXMgaXMgZmFzdGVyIHRoYW4gJC5lbXB0eSgpXFxyXFxuICAgICAgICAgICAgbWVudUlubmVyLnJlcGxhY2VDaGlsZChlbXB0eU1lbnUsIG1lbnVJbm5lci5maXJzdENoaWxkKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdmlzaWJsZUVsZW1lbnRzTGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgdmlzaWJsZUVsZW1lbnRzTGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV0sXFxyXFxuICAgICAgICAgICAgICAgICAgZWxUZXh0LFxcclxcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnREYXRhO1xcclxcblxcclxcbiAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zYW5pdGl6ZSkge1xcclxcbiAgICAgICAgICAgICAgICBlbFRleHQgPSBlbGVtZW50Lmxhc3RDaGlsZDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKGVsVGV4dCkge1xcclxcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnREYXRhID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2kgKyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMF07XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgaWYgKGVsZW1lbnREYXRhICYmIGVsZW1lbnREYXRhLmNvbnRlbnQgJiYgIWVsZW1lbnREYXRhLnNhbml0aXplZCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdG9TYW5pdGl6ZS5wdXNoKGVsVGV4dCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50RGF0YS5zYW5pdGl6ZWQgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgbWVudUZyYWdtZW50LmFwcGVuZENoaWxkKGVsZW1lbnQpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNhbml0aXplICYmIHRvU2FuaXRpemUubGVuZ3RoKSB7XFxyXFxuICAgICAgICAgICAgICBzYW5pdGl6ZUh0bWwodG9TYW5pdGl6ZSwgdGhhdC5vcHRpb25zLndoaXRlTGlzdCwgdGhhdC5vcHRpb25zLnNhbml0aXplRm4pO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoaXNWaXJ0dWFsID09PSB0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSAodGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAgPT09IDAgPyAwIDogdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW3RoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wIC0gMV0ucG9zaXRpb24pO1xcclxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xID4gc2l6ZSAtIDEgPyAwIDogdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW3NpemUgLSAxXS5wb3NpdGlvbiAtIHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVt0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMSAtIDFdLnBvc2l0aW9uKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLnN0eWxlLm1hcmdpblRvcCA9IG1hcmdpblRvcCArICdweCc7XFxyXFxuICAgICAgICAgICAgICBtZW51SW5uZXIuZmlyc3RDaGlsZC5zdHlsZS5tYXJnaW5Cb3R0b20gPSBtYXJnaW5Cb3R0b20gKyAncHgnO1xcclxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICBtZW51SW5uZXIuZmlyc3RDaGlsZC5zdHlsZS5tYXJnaW5Ub3AgPSAwO1xcclxcbiAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWFyZ2luQm90dG9tID0gMDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQobWVudUZyYWdtZW50KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBpZiBhbiBvcHRpb24gaXMgZW5jb3VudGVyZWQgdGhhdCBpcyB3aWRlciB0aGFuIHRoZSBjdXJyZW50IG1lbnUgd2lkdGgsIHVwZGF0ZSB0aGUgbWVudSB3aWR0aCBhY2NvcmRpbmdseVxcclxcbiAgICAgICAgICAgIC8vIHN3aXRjaCB0byBSZXNpemVPYnNlcnZlciB3aXRoIGluY3JlYXNlZCBicm93c2VyIHN1cHBvcnRcXHJcXG4gICAgICAgICAgICBpZiAoaXNWaXJ0dWFsID09PSB0cnVlICYmIHRoYXQuc2l6ZUluZm8uaGFzU2Nyb2xsQmFyKSB7XFxyXFxuICAgICAgICAgICAgICB2YXIgbWVudUlubmVySW5uZXJXaWR0aCA9IG1lbnVJbm5lci5maXJzdENoaWxkLm9mZnNldFdpZHRoO1xcclxcblxcclxcbiAgICAgICAgICAgICAgaWYgKGluaXQgJiYgbWVudUlubmVySW5uZXJXaWR0aCA8IHRoYXQuc2l6ZUluZm8ubWVudUlubmVySW5uZXJXaWR0aCAmJiB0aGF0LnNpemVJbmZvLnRvdGFsTWVudVdpZHRoID4gdGhhdC5zaXplSW5mby5zZWxlY3RXaWR0aCkge1xcclxcbiAgICAgICAgICAgICAgICBtZW51SW5uZXIuZmlyc3RDaGlsZC5zdHlsZS5taW5XaWR0aCA9IHRoYXQuc2l6ZUluZm8ubWVudUlubmVySW5uZXJXaWR0aCArICdweCc7XFxyXFxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1lbnVJbm5lcklubmVyV2lkdGggPiB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGgpIHtcXHJcXG4gICAgICAgICAgICAgICAgLy8gc2V0IHRvIDAgdG8gZ2V0IGFjdHVhbCB3aWR0aCBvZiBtZW51XFxyXFxuICAgICAgICAgICAgICAgIHRoYXQuJG1lbnVbMF0uc3R5bGUubWluV2lkdGggPSAwO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICB2YXIgYWN0dWFsTWVudVdpZHRoID0gbWVudUlubmVyLmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGg7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChhY3R1YWxNZW51V2lkdGggPiB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggPSBhY3R1YWxNZW51V2lkdGg7XFxyXFxuICAgICAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWluV2lkdGggPSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggKyAncHgnO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IHRvIGRlZmF1bHQgQ1NTIHN0eWxpbmdcXHJcXG4gICAgICAgICAgICAgICAgdGhhdC4kbWVudVswXS5zdHlsZS5taW5XaWR0aCA9ICcnO1xcclxcbiAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgdGhhdC5wcmV2QWN0aXZlSW5kZXggPSB0aGF0LmFjdGl2ZUluZGV4O1xcclxcblxcclxcbiAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgICB0aGF0LiRtZW51SW5uZXIudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNTZWFyY2hpbmcgJiYgaW5pdCkge1xcclxcbiAgICAgICAgICB2YXIgaW5kZXggPSAwLFxcclxcbiAgICAgICAgICAgICAgbmV3QWN0aXZlO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoIXRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0W2luZGV4XSkge1xcclxcbiAgICAgICAgICAgIGluZGV4ID0gMSArIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0LnNsaWNlKDEpLmluZGV4T2YodHJ1ZSk7XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgbmV3QWN0aXZlID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHNbaW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY3VycmVudEFjdGl2ZSk7XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuYWN0aXZlSW5kZXggPSAodGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2luZGV4XSB8fCB7fSkuaW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuZm9jdXNJdGVtKG5ld0FjdGl2ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgICQod2luZG93KVxcclxcbiAgICAgICAgLm9mZigncmVzaXplJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnLmNyZWF0ZVZpZXcnKVxcclxcbiAgICAgICAgLm9uKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuY3JlYXRlVmlldycsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0gdGhhdC4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIHNjcm9sbCh0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wKTtcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBmb2N1c0l0ZW06IGZ1bmN0aW9uIChsaSwgbGlEYXRhLCBub1N0eWxlKSB7XFxyXFxuICAgICAgaWYgKGxpKSB7XFxyXFxuICAgICAgICBsaURhdGEgPSBsaURhdGEgfHwgdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW3RoaXMuYWN0aXZlSW5kZXhdO1xcclxcbiAgICAgICAgdmFyIGEgPSBsaS5maXJzdENoaWxkO1xcclxcblxcclxcbiAgICAgICAgaWYgKGEpIHtcXHJcXG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2V0c2l6ZScsIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuc2l6ZSk7XFxyXFxuICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdhcmlhLXBvc2luc2V0JywgbGlEYXRhLnBvc2luc2V0KTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKG5vU3R5bGUgIT09IHRydWUpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLmZvY3VzZWRQYXJlbnQuc2V0QXR0cmlidXRlKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBhLmlkKTtcXHJcXG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcXHJcXG4gICAgICAgICAgICBhLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBkZWZvY3VzSXRlbTogZnVuY3Rpb24gKGxpKSB7XFxyXFxuICAgICAgaWYgKGxpKSB7XFxyXFxuICAgICAgICBsaS5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcXHJcXG4gICAgICAgIGlmIChsaS5maXJzdENoaWxkKSBsaS5maXJzdENoaWxkLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgc2V0UGxhY2Vob2xkZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxyXFxuICAgICAgICAgIHVwZGF0ZUluZGV4ID0gZmFsc2U7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aXRsZSAmJiAhdGhpcy5tdWx0aXBsZSkge1xcclxcbiAgICAgICAgaWYgKCF0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uKSB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XFxyXFxuXFxyXFxuICAgICAgICAvLyB0aGlzIG9wdGlvbiBkb2Vzbid0IGNyZWF0ZSBhIG5ldyA8bGk+IGVsZW1lbnQsIGJ1dCBkb2VzIGFkZCBhIG5ldyBvcHRpb24gYXQgdGhlIHN0YXJ0LFxcclxcbiAgICAgICAgLy8gc28gc3RhcnRJbmRleCBzaG91bGQgaW5jcmVhc2UgdG8gcHJldmVudCBoYXZpbmcgdG8gY2hlY2sgZXZlcnkgb3B0aW9uIGZvciB0aGUgYnMtdGl0bGUtb3B0aW9uIGNsYXNzXFxyXFxuICAgICAgICB1cGRhdGVJbmRleCA9IHRydWU7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnRbMF0sXFxyXFxuICAgICAgICAgICAgc2VsZWN0VGl0bGVPcHRpb24gPSBmYWxzZSxcXHJcXG4gICAgICAgICAgICB0aXRsZU5vdEFwcGVuZGVkID0gIXRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24ucGFyZW50Tm9kZSxcXHJcXG4gICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4LFxcclxcbiAgICAgICAgICAgIHNlbGVjdGVkT3B0aW9uID0gZWxlbWVudC5vcHRpb25zW3NlbGVjdGVkSW5kZXhdLFxcclxcbiAgICAgICAgICAgIG5hdmlnYXRpb24gPSB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoJ25hdmlnYXRpb24nKSxcXHJcXG4gICAgICAgICAgICAvLyBTYWZhcmkgZG9lc24ndCBzdXBwb3J0IGdldEVudHJpZXNCeVR5cGUoJ25hdmlnYXRpb24nKSAtIGZhbGwgYmFjayB0byBwZXJmb3JtYW5jZS5uYXZpZ2F0aW9uXFxyXFxuICAgICAgICAgICAgaXNOb3RCYWNrRm9yd2FyZCA9IChuYXZpZ2F0aW9uICYmIG5hdmlnYXRpb24ubGVuZ3RoKSA/IG5hdmlnYXRpb25bMF0udHlwZSAhPT0gJ2JhY2tfZm9yd2FyZCcgOiB3aW5kb3cucGVyZm9ybWFuY2UubmF2aWdhdGlvbi50eXBlICE9PSAyO1xcclxcblxcclxcbiAgICAgICAgaWYgKHRpdGxlTm90QXBwZW5kZWQpIHtcXHJcXG4gICAgICAgICAgLy8gVXNlIG5hdGl2ZSBKUyB0byBwcmVwZW5kIG9wdGlvbiAoZmFzdGVyKVxcclxcbiAgICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLmNsYXNzTmFtZSA9ICdicy10aXRsZS1vcHRpb24nO1xcclxcbiAgICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLnZhbHVlID0gJyc7XFxyXFxuXFxyXFxuICAgICAgICAgIC8vIENoZWNrIGlmIHNlbGVjdGVkIG9yIGRhdGEtc2VsZWN0ZWQgYXR0cmlidXRlIGlzIGFscmVhZHkgc2V0IG9uIGFuIG9wdGlvbi4gSWYgbm90LCBzZWxlY3QgdGhlIHRpdGxlT3B0aW9uIG9wdGlvbi5cXHJcXG4gICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGl0ZW0gbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIGJ5IHVzZXIgb3IgcHJvZ3JhbW1hdGljYWxseSBiZWZvcmUgdGhlIGJvb3RzdHJhcCBzZWxlY3QgcGx1Z2luIHJ1bnMsXFxyXFxuICAgICAgICAgIC8vIGlmIHNvLCB0aGUgc2VsZWN0IHdpbGwgaGF2ZSB0aGUgZGF0YS1zZWxlY3RlZCBhdHRyaWJ1dGVcXHJcXG4gICAgICAgICAgc2VsZWN0VGl0bGVPcHRpb24gPSAhc2VsZWN0ZWRPcHRpb24gfHwgKHNlbGVjdGVkSW5kZXggPT09IDAgJiYgc2VsZWN0ZWRPcHRpb24uZGVmYXVsdFNlbGVjdGVkID09PSBmYWxzZSAmJiB0aGlzLiRlbGVtZW50LmRhdGEoJ3NlbGVjdGVkJykgPT09IHVuZGVmaW5lZCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAodGl0bGVOb3RBcHBlbmRlZCB8fCB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLmluZGV4ICE9PSAwKSB7XFxyXFxuICAgICAgICAgIGVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24sIGVsZW1lbnQuZmlyc3RDaGlsZCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBTZXQgc2VsZWN0ZWQgKmFmdGVyKiBhcHBlbmRpbmcgdG8gc2VsZWN0LFxcclxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHRoZSBvcHRpb24gZG9lc24ndCBnZXQgc2VsZWN0ZWQgaW4gSUVcXHJcXG4gICAgICAgIC8vIHNldCB1c2luZyBzZWxlY3RlZEluZGV4LCBhcyBzZXR0aW5nIHRoZSBzZWxlY3RlZCBhdHRyIHRvIHRydWUgaGVyZSBkb2Vzbid0IHdvcmsgaW4gSUUxMVxcclxcbiAgICAgICAgaWYgKHNlbGVjdFRpdGxlT3B0aW9uICYmIGlzTm90QmFja0ZvcndhcmQpIHtcXHJcXG4gICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gMDtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xcclxcbiAgICAgICAgICAvLyBpZiBuYXZpZ2F0aW9uIHR5cGUgaXMgYmFja19mb3J3YXJkLCB0aGVyZSdzIGEgY2hhbmNlIHRoZSBzZWxlY3Qgd2lsbCBoYXZlIGl0cyB2YWx1ZSBzZXQgYnkgQkZDYWNoZVxcclxcbiAgICAgICAgICAvLyB3YWl0IGZvciB0aGF0IHZhbHVlIHRvIGJlIHNldCwgdGhlbiBydW4gcmVuZGVyIGFnYWluXFxyXFxuICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwYWdlc2hvdycsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICBpZiAodGhhdC5zZWxlY3RwaWNrZXIudmlldy5kaXNwbGF5ZWRWYWx1ZSAhPT0gZWxlbWVudC52YWx1ZSkgdGhhdC5yZW5kZXIoKTtcXHJcXG4gICAgICAgICAgfSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHJldHVybiB1cGRhdGVJbmRleDtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgYnVpbGREYXRhOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIG9wdGlvblNlbGVjdG9yID0gJzpub3QoW2hpZGRlbl0pOm5vdChbZGF0YS1oaWRkZW49XFxcInRydWVcXFwiXSknLFxcclxcbiAgICAgICAgICBtYWluRGF0YSA9IFtdLFxcclxcbiAgICAgICAgICBvcHRJRCA9IDAsXFxyXFxuICAgICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLnNldFBsYWNlaG9sZGVyKCkgPyAxIDogMDsgLy8gYXBwZW5kIHRoZSB0aXRsZU9wdGlvbiBpZiBuZWNlc3NhcnkgYW5kIHNraXAgdGhlIGZpcnN0IG9wdGlvbiBpbiB0aGUgbG9vcFxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGlkZURpc2FibGVkKSBvcHRpb25TZWxlY3RvciArPSAnOm5vdCg6ZGlzYWJsZWQpJztcXHJcXG5cXHJcXG4gICAgICB2YXIgc2VsZWN0T3B0aW9ucyA9IHRoaXMuJGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0ID4gKicgKyBvcHRpb25TZWxlY3Rvcik7XFxyXFxuXFxyXFxuICAgICAgZnVuY3Rpb24gYWRkRGl2aWRlciAoY29uZmlnKSB7XFxyXFxuICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gbWFpbkRhdGFbbWFpbkRhdGEubGVuZ3RoIC0gMV07XFxyXFxuXFxyXFxuICAgICAgICAvLyBlbnN1cmUgb3B0Z3JvdXAgZG9lc24ndCBjcmVhdGUgYmFjay10by1iYWNrIGRpdmlkZXJzXFxyXFxuICAgICAgICBpZiAoXFxyXFxuICAgICAgICAgIHByZXZpb3VzRGF0YSAmJlxcclxcbiAgICAgICAgICBwcmV2aW91c0RhdGEudHlwZSA9PT0gJ2RpdmlkZXInICYmXFxyXFxuICAgICAgICAgIChwcmV2aW91c0RhdGEub3B0SUQgfHwgY29uZmlnLm9wdElEKVxcclxcbiAgICAgICAgKSB7XFxyXFxuICAgICAgICAgIHJldHVybjtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcXHJcXG4gICAgICAgIGNvbmZpZy50eXBlID0gJ2RpdmlkZXInO1xcclxcblxcclxcbiAgICAgICAgbWFpbkRhdGEucHVzaChjb25maWcpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBmdW5jdGlvbiBhZGRPcHRpb24gKG9wdGlvbiwgY29uZmlnKSB7XFxyXFxuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XFxyXFxuXFxyXFxuICAgICAgICBjb25maWcuZGl2aWRlciA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGl2aWRlcicpID09PSAndHJ1ZSc7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoY29uZmlnLmRpdmlkZXIpIHtcXHJcXG4gICAgICAgICAgYWRkRGl2aWRlcih7XFxyXFxuICAgICAgICAgICAgb3B0SUQ6IGNvbmZpZy5vcHRJRFxcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHZhciBsaUluZGV4ID0gbWFpbkRhdGEubGVuZ3RoLFxcclxcbiAgICAgICAgICAgICAgY3NzVGV4dCA9IG9wdGlvbi5zdHlsZS5jc3NUZXh0LFxcclxcbiAgICAgICAgICAgICAgaW5saW5lU3R5bGUgPSBjc3NUZXh0ID8gaHRtbEVzY2FwZShjc3NUZXh0KSA6ICcnLFxcclxcbiAgICAgICAgICAgICAgb3B0aW9uQ2xhc3MgPSAob3B0aW9uLmNsYXNzTmFtZSB8fCAnJykgKyAoY29uZmlnLm9wdGdyb3VwQ2xhc3MgfHwgJycpO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoY29uZmlnLm9wdElEKSBvcHRpb25DbGFzcyA9ICdvcHQgJyArIG9wdGlvbkNsYXNzO1xcclxcblxcclxcbiAgICAgICAgICBjb25maWcub3B0aW9uQ2xhc3MgPSBvcHRpb25DbGFzcy50cmltKCk7XFxyXFxuICAgICAgICAgIGNvbmZpZy5pbmxpbmVTdHlsZSA9IGlubGluZVN0eWxlO1xcclxcbiAgICAgICAgICBjb25maWcudGV4dCA9IG9wdGlvbi50ZXh0Q29udGVudDtcXHJcXG5cXHJcXG4gICAgICAgICAgY29uZmlnLmNvbnRlbnQgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRlbnQnKTtcXHJcXG4gICAgICAgICAgY29uZmlnLnRva2VucyA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtdG9rZW5zJyk7XFxyXFxuICAgICAgICAgIGNvbmZpZy5zdWJ0ZXh0ID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1zdWJ0ZXh0Jyk7XFxyXFxuICAgICAgICAgIGNvbmZpZy5pY29uID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1pY29uJyk7XFxyXFxuXFxyXFxuICAgICAgICAgIG9wdGlvbi5saUluZGV4ID0gbGlJbmRleDtcXHJcXG5cXHJcXG4gICAgICAgICAgY29uZmlnLmRpc3BsYXkgPSBjb25maWcuY29udGVudCB8fCBjb25maWcudGV4dDtcXHJcXG4gICAgICAgICAgY29uZmlnLnR5cGUgPSAnb3B0aW9uJztcXHJcXG4gICAgICAgICAgY29uZmlnLmluZGV4ID0gbGlJbmRleDtcXHJcXG4gICAgICAgICAgY29uZmlnLm9wdGlvbiA9IG9wdGlvbjtcXHJcXG4gICAgICAgICAgY29uZmlnLnNlbGVjdGVkID0gISFvcHRpb24uc2VsZWN0ZWQ7XFxyXFxuICAgICAgICAgIGNvbmZpZy5kaXNhYmxlZCA9IGNvbmZpZy5kaXNhYmxlZCB8fCAhIW9wdGlvbi5kaXNhYmxlZDtcXHJcXG5cXHJcXG4gICAgICAgICAgbWFpbkRhdGEucHVzaChjb25maWcpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBmdW5jdGlvbiBhZGRPcHRncm91cCAoaW5kZXgsIHNlbGVjdE9wdGlvbnMpIHtcXHJcXG4gICAgICAgIHZhciBvcHRncm91cCA9IHNlbGVjdE9wdGlvbnNbaW5kZXhdLFxcclxcbiAgICAgICAgICAgIC8vIHNraXAgcGxhY2Vob2xkZXIgb3B0aW9uXFxyXFxuICAgICAgICAgICAgcHJldmlvdXMgPSBpbmRleCAtIDEgPCBzdGFydEluZGV4ID8gZmFsc2UgOiBzZWxlY3RPcHRpb25zW2luZGV4IC0gMV0sXFxyXFxuICAgICAgICAgICAgbmV4dCA9IHNlbGVjdE9wdGlvbnNbaW5kZXggKyAxXSxcXHJcXG4gICAgICAgICAgICBvcHRpb25zID0gb3B0Z3JvdXAucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uJyArIG9wdGlvblNlbGVjdG9yKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmICghb3B0aW9ucy5sZW5ndGgpIHJldHVybjtcXHJcXG5cXHJcXG4gICAgICAgIHZhciBjb25maWcgPSB7XFxyXFxuICAgICAgICAgICAgICBkaXNwbGF5OiBodG1sRXNjYXBlKG9wdGdyb3VwLmxhYmVsKSxcXHJcXG4gICAgICAgICAgICAgIHN1YnRleHQ6IG9wdGdyb3VwLmdldEF0dHJpYnV0ZSgnZGF0YS1zdWJ0ZXh0JyksXFxyXFxuICAgICAgICAgICAgICBpY29uOiBvcHRncm91cC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWNvbicpLFxcclxcbiAgICAgICAgICAgICAgdHlwZTogJ29wdGdyb3VwLWxhYmVsJyxcXHJcXG4gICAgICAgICAgICAgIG9wdGdyb3VwQ2xhc3M6ICcgJyArIChvcHRncm91cC5jbGFzc05hbWUgfHwgJycpXFxyXFxuICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICBoZWFkZXJJbmRleCxcXHJcXG4gICAgICAgICAgICBsYXN0SW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICBvcHRJRCsrO1xcclxcblxcclxcbiAgICAgICAgaWYgKHByZXZpb3VzKSB7XFxyXFxuICAgICAgICAgIGFkZERpdmlkZXIoeyBvcHRJRDogb3B0SUQgfSk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBjb25maWcub3B0SUQgPSBvcHRJRDtcXHJcXG5cXHJcXG4gICAgICAgIG1haW5EYXRhLnB1c2goY29uZmlnKTtcXHJcXG5cXHJcXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBvcHRpb25zLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XFxyXFxuICAgICAgICAgIHZhciBvcHRpb24gPSBvcHRpb25zW2pdO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoaiA9PT0gMCkge1xcclxcbiAgICAgICAgICAgIGhlYWRlckluZGV4ID0gbWFpbkRhdGEubGVuZ3RoIC0gMTtcXHJcXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBoZWFkZXJJbmRleCArIGxlbjtcXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICBhZGRPcHRpb24ob3B0aW9uLCB7XFxyXFxuICAgICAgICAgICAgaGVhZGVySW5kZXg6IGhlYWRlckluZGV4LFxcclxcbiAgICAgICAgICAgIGxhc3RJbmRleDogbGFzdEluZGV4LFxcclxcbiAgICAgICAgICAgIG9wdElEOiBjb25maWcub3B0SUQsXFxyXFxuICAgICAgICAgICAgb3B0Z3JvdXBDbGFzczogY29uZmlnLm9wdGdyb3VwQ2xhc3MsXFxyXFxuICAgICAgICAgICAgZGlzYWJsZWQ6IG9wdGdyb3VwLmRpc2FibGVkXFxyXFxuICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKG5leHQpIHtcXHJcXG4gICAgICAgICAgYWRkRGl2aWRlcih7IG9wdElEOiBvcHRJRCB9KTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZm9yICh2YXIgbGVuID0gc2VsZWN0T3B0aW9ucy5sZW5ndGgsIGkgPSBzdGFydEluZGV4OyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIHZhciBpdGVtID0gc2VsZWN0T3B0aW9uc1tpXTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChpdGVtLnRhZ05hbWUgIT09ICdPUFRHUk9VUCcpIHtcXHJcXG4gICAgICAgICAgYWRkT3B0aW9uKGl0ZW0sIHt9KTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIGFkZE9wdGdyb3VwKGksIHNlbGVjdE9wdGlvbnMpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmRhdGEgPSB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEgPSBtYWluRGF0YTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgYnVpbGRMaXN0OiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICBzZWxlY3REYXRhID0gdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhLFxcclxcbiAgICAgICAgICBtYWluRWxlbWVudHMgPSBbXSxcXHJcXG4gICAgICAgICAgd2lkZXN0T3B0aW9uTGVuZ3RoID0gMDtcXHJcXG5cXHJcXG4gICAgICBpZiAoKHRoYXQub3B0aW9ucy5zaG93VGljayB8fCB0aGF0Lm11bHRpcGxlKSAmJiAhZWxlbWVudFRlbXBsYXRlcy5jaGVja01hcmsucGFyZW50Tm9kZSkge1xcclxcbiAgICAgICAgZWxlbWVudFRlbXBsYXRlcy5jaGVja01hcmsuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmljb25CYXNlICsgJyAnICsgdGhhdC5vcHRpb25zLnRpY2tJY29uICsgJyBjaGVjay1tYXJrJztcXHJcXG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuYS5hcHBlbmRDaGlsZChlbGVtZW50VGVtcGxhdGVzLmNoZWNrTWFyayk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGZ1bmN0aW9uIGJ1aWxkRWxlbWVudCAoaXRlbSkge1xcclxcbiAgICAgICAgdmFyIGxpRWxlbWVudCxcXHJcXG4gICAgICAgICAgICBjb21iaW5lZExlbmd0aCA9IDA7XFxyXFxuXFxyXFxuICAgICAgICBzd2l0Y2ggKGl0ZW0udHlwZSkge1xcclxcbiAgICAgICAgICBjYXNlICdkaXZpZGVyJzpcXHJcXG4gICAgICAgICAgICBsaUVsZW1lbnQgPSBnZW5lcmF0ZU9wdGlvbi5saShcXHJcXG4gICAgICAgICAgICAgIGZhbHNlLFxcclxcbiAgICAgICAgICAgICAgY2xhc3NOYW1lcy5ESVZJREVSLFxcclxcbiAgICAgICAgICAgICAgKGl0ZW0ub3B0SUQgPyBpdGVtLm9wdElEICsgJ2RpdicgOiB1bmRlZmluZWQpXFxyXFxuICAgICAgICAgICAgKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG5cXHJcXG4gICAgICAgICAgY2FzZSAnb3B0aW9uJzpcXHJcXG4gICAgICAgICAgICBsaUVsZW1lbnQgPSBnZW5lcmF0ZU9wdGlvbi5saShcXHJcXG4gICAgICAgICAgICAgIGdlbmVyYXRlT3B0aW9uLmEoXFxyXFxuICAgICAgICAgICAgICAgIGdlbmVyYXRlT3B0aW9uLnRleHQuY2FsbCh0aGF0LCBpdGVtKSxcXHJcXG4gICAgICAgICAgICAgICAgaXRlbS5vcHRpb25DbGFzcyxcXHJcXG4gICAgICAgICAgICAgICAgaXRlbS5pbmxpbmVTdHlsZVxcclxcbiAgICAgICAgICAgICAgKSxcXHJcXG4gICAgICAgICAgICAgICcnLFxcclxcbiAgICAgICAgICAgICAgaXRlbS5vcHRJRFxcclxcbiAgICAgICAgICAgICk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGxpRWxlbWVudC5maXJzdENoaWxkKSB7XFxyXFxuICAgICAgICAgICAgICBsaUVsZW1lbnQuZmlyc3RDaGlsZC5pZCA9IHRoYXQuc2VsZWN0SWQgKyAnLScgKyBpdGVtLmluZGV4O1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG5cXHJcXG4gICAgICAgICAgY2FzZSAnb3B0Z3JvdXAtbGFiZWwnOlxcclxcbiAgICAgICAgICAgIGxpRWxlbWVudCA9IGdlbmVyYXRlT3B0aW9uLmxpKFxcclxcbiAgICAgICAgICAgICAgZ2VuZXJhdGVPcHRpb24ubGFiZWwuY2FsbCh0aGF0LCBpdGVtKSxcXHJcXG4gICAgICAgICAgICAgICdkcm9wZG93bi1oZWFkZXInICsgaXRlbS5vcHRncm91cENsYXNzLFxcclxcbiAgICAgICAgICAgICAgaXRlbS5vcHRJRFxcclxcbiAgICAgICAgICAgICk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpdGVtLmVsZW1lbnQgPSBsaUVsZW1lbnQ7XFxyXFxuICAgICAgICBtYWluRWxlbWVudHMucHVzaChsaUVsZW1lbnQpO1xcclxcblxcclxcbiAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGluIHRoZSBvcHRpb24gLSBub3QgcGVyZmVjdCwgYnV0IHNob3VsZCB3b3JrIGluIG1vc3QgY2FzZXNcXHJcXG4gICAgICAgIGlmIChpdGVtLmRpc3BsYXkpIGNvbWJpbmVkTGVuZ3RoICs9IGl0ZW0uZGlzcGxheS5sZW5ndGg7XFxyXFxuICAgICAgICBpZiAoaXRlbS5zdWJ0ZXh0KSBjb21iaW5lZExlbmd0aCArPSBpdGVtLnN1YnRleHQubGVuZ3RoO1xcclxcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gaWNvbiwgZW5zdXJlIHRoaXMgb3B0aW9uJ3Mgd2lkdGggaXMgY2hlY2tlZFxcclxcbiAgICAgICAgaWYgKGl0ZW0uaWNvbikgY29tYmluZWRMZW5ndGggKz0gMTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChjb21iaW5lZExlbmd0aCA+IHdpZGVzdE9wdGlvbkxlbmd0aCkge1xcclxcbiAgICAgICAgICB3aWRlc3RPcHRpb25MZW5ndGggPSBjb21iaW5lZExlbmd0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgLy8gZ3Vlc3Mgd2hpY2ggb3B0aW9uIGlzIHRoZSB3aWRlc3RcXHJcXG4gICAgICAgICAgLy8gdXNlIHRoaXMgd2hlbiBjYWxjdWxhdGluZyBtZW51IHdpZHRoXFxyXFxuICAgICAgICAgIC8vIG5vdCBwZXJmZWN0LCBidXQgaXQncyBmYXN0LCBhbmQgdGhlIHdpZHRoIHdpbGwgYmUgdXBkYXRpbmcgYWNjb3JkaW5nbHkgd2hlbiBzY3JvbGxpbmdcXHJcXG4gICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy53aWRlc3RPcHRpb24gPSBtYWluRWxlbWVudHNbbWFpbkVsZW1lbnRzLmxlbmd0aCAtIDFdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBmb3IgKHZhciBsZW4gPSBzZWxlY3REYXRhLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgdmFyIGl0ZW0gPSBzZWxlY3REYXRhW2ldO1xcclxcblxcclxcbiAgICAgICAgYnVpbGRFbGVtZW50KGl0ZW0pO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cyA9IG1haW5FbGVtZW50cztcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgZmluZExpczogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHJldHVybiB0aGlzLiRtZW51SW5uZXIuZmluZCgnLmlubmVyID4gbGknKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXSxcXHJcXG4gICAgICAgICAgLy8gZW5zdXJlIHRpdGxlT3B0aW9uIGlzIGFwcGVuZGVkIGFuZCBzZWxlY3RlZCAoaWYgbmVjZXNzYXJ5KSBiZWZvcmUgZ2V0dGluZyBzZWxlY3RlZE9wdGlvbnNcXHJcXG4gICAgICAgICAgcGxhY2Vob2xkZXJTZWxlY3RlZCA9IHRoaXMuc2V0UGxhY2Vob2xkZXIoKSAmJiBlbGVtZW50LnNlbGVjdGVkSW5kZXggPT09IDAsXFxyXFxuICAgICAgICAgIHNlbGVjdGVkT3B0aW9ucyA9IGdldFNlbGVjdGVkT3B0aW9ucyhlbGVtZW50LCB0aGlzLm9wdGlvbnMuaGlkZURpc2FibGVkKSxcXHJcXG4gICAgICAgICAgc2VsZWN0ZWRDb3VudCA9IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGgsXFxyXFxuICAgICAgICAgIGJ1dHRvbiA9IHRoaXMuJGJ1dHRvblswXSxcXHJcXG4gICAgICAgICAgYnV0dG9uSW5uZXIgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLmZpbHRlci1vcHRpb24taW5uZXItaW5uZXInKSxcXHJcXG4gICAgICAgICAgbXVsdGlwbGVTZXBhcmF0b3IgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLm9wdGlvbnMubXVsdGlwbGVTZXBhcmF0b3IpLFxcclxcbiAgICAgICAgICB0aXRsZUZyYWdtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5jbG9uZU5vZGUoZmFsc2UpLFxcclxcbiAgICAgICAgICBzaG93Q291bnQsXFxyXFxuICAgICAgICAgIGNvdW50TWF4LFxcclxcbiAgICAgICAgICBoYXNDb250ZW50ID0gZmFsc2U7XFxyXFxuXFxyXFxuICAgICAgYnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoJ2JzLXBsYWNlaG9sZGVyJywgdGhhdC5tdWx0aXBsZSA/ICFzZWxlY3RlZENvdW50IDogIWdldFNlbGVjdFZhbHVlcyhlbGVtZW50LCBzZWxlY3RlZE9wdGlvbnMpKTtcXHJcXG5cXHJcXG4gICAgICBpZiAoIXRoYXQubXVsdGlwbGUgJiYgc2VsZWN0ZWRPcHRpb25zLmxlbmd0aCA9PT0gMSkge1xcclxcbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5kaXNwbGF5ZWRWYWx1ZSA9IGdldFNlbGVjdFZhbHVlcyhlbGVtZW50LCBzZWxlY3RlZE9wdGlvbnMpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNlbGVjdGVkVGV4dEZvcm1hdCA9PT0gJ3N0YXRpYycpIHtcXHJcXG4gICAgICAgIHRpdGxlRnJhZ21lbnQgPSBnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhpcywgeyB0ZXh0OiB0aGlzLm9wdGlvbnMudGl0bGUgfSwgdHJ1ZSk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHNob3dDb3VudCA9IHRoaXMubXVsdGlwbGUgJiYgdGhpcy5vcHRpb25zLnNlbGVjdGVkVGV4dEZvcm1hdC5pbmRleE9mKCdjb3VudCcpICE9PSAtMSAmJiBzZWxlY3RlZENvdW50ID4gMTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIGRldGVybWluZSBpZiB0aGUgbnVtYmVyIG9mIHNlbGVjdGVkIG9wdGlvbnMgd2lsbCBiZSBzaG93biAoc2hvd0NvdW50ID09PSB0cnVlKVxcclxcbiAgICAgICAgaWYgKHNob3dDb3VudCkge1xcclxcbiAgICAgICAgICBjb3VudE1heCA9IHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQuc3BsaXQoJz4nKTtcXHJcXG4gICAgICAgICAgc2hvd0NvdW50ID0gKGNvdW50TWF4Lmxlbmd0aCA+IDEgJiYgc2VsZWN0ZWRDb3VudCA+IGNvdW50TWF4WzFdKSB8fCAoY291bnRNYXgubGVuZ3RoID09PSAxICYmIHNlbGVjdGVkQ291bnQgPj0gMik7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAvLyBvbmx5IGxvb3AgdGhyb3VnaCBhbGwgc2VsZWN0ZWQgb3B0aW9ucyBpZiB0aGUgY291bnQgd29uJ3QgYmUgc2hvd25cXHJcXG4gICAgICAgIGlmIChzaG93Q291bnQgPT09IGZhbHNlKSB7XFxyXFxuICAgICAgICAgIGlmICghcGxhY2Vob2xkZXJTZWxlY3RlZCkge1xcclxcbiAgICAgICAgICAgIGZvciAodmFyIHNlbGVjdGVkSW5kZXggPSAwOyBzZWxlY3RlZEluZGV4IDwgc2VsZWN0ZWRDb3VudDsgc2VsZWN0ZWRJbmRleCsrKSB7XFxyXFxuICAgICAgICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCA8IDUwKSB7XFxyXFxuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbc2VsZWN0ZWRJbmRleF0sXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGlzRGF0YSA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtvcHRpb24ubGlJbmRleF0sXFxyXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMgPSB7fTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUgJiYgc2VsZWN0ZWRJbmRleCA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgICB0aXRsZUZyYWdtZW50LmFwcGVuZENoaWxkKG11bHRpcGxlU2VwYXJhdG9yLmNsb25lTm9kZShmYWxzZSkpO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChvcHRpb24udGl0bGUpIHtcXHJcXG4gICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMudGV4dCA9IG9wdGlvbi50aXRsZTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzRGF0YSkge1xcclxcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzRGF0YS5jb250ZW50ICYmIHRoYXQub3B0aW9ucy5zaG93Q29udGVudCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVPcHRpb25zLmNvbnRlbnQgPSB0aGlzRGF0YS5jb250ZW50LnRvU3RyaW5nKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBoYXNDb250ZW50ID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zaG93SWNvbikge1xcclxcbiAgICAgICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMuaWNvbiA9IHRoaXNEYXRhLmljb247XFxyXFxuICAgICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5vcHRpb25zLnNob3dTdWJ0ZXh0ICYmICF0aGF0Lm11bHRpcGxlICYmIHRoaXNEYXRhLnN1YnRleHQpIHRpdGxlT3B0aW9ucy5zdWJ0ZXh0ID0gJyAnICsgdGhpc0RhdGEuc3VidGV4dDtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlT3B0aW9ucy50ZXh0ID0gb3B0aW9uLnRleHRDb250ZW50LnRyaW0oKTtcXHJcXG4gICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgdGl0bGVGcmFnbWVudC5hcHBlbmRDaGlsZChnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhpcywgdGl0bGVPcHRpb25zLCB0cnVlKSk7XFxyXFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gYWRkIGVsbGlwc2lzXFxyXFxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ291bnQgPiA0OSkge1xcclxcbiAgICAgICAgICAgICAgdGl0bGVGcmFnbWVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLi4uJykpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgdmFyIG9wdGlvblNlbGVjdG9yID0gJzpub3QoW2hpZGRlbl0pOm5vdChbZGF0YS1oaWRkZW49XFxcInRydWVcXFwiXSk6bm90KFtkYXRhLWRpdmlkZXI9XFxcInRydWVcXFwiXSknO1xcclxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCkgb3B0aW9uU2VsZWN0b3IgKz0gJzpub3QoOmRpc2FibGVkKSc7XFxyXFxuXFxyXFxuICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBtdWx0aXNlbGVjdCwgYW5kIHNlbGVjdGVkVGV4dEZvcm1hdCBpcyBjb3VudCwgdGhlbiBzaG93IDEgb2YgMiBzZWxlY3RlZCwgZXRjLlxcclxcbiAgICAgICAgICB2YXIgdG90YWxDb3VudCA9IHRoaXMuJGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnc2VsZWN0ID4gb3B0aW9uJyArIG9wdGlvblNlbGVjdG9yICsgJywgb3B0Z3JvdXAnICsgb3B0aW9uU2VsZWN0b3IgKyAnIG9wdGlvbicgKyBvcHRpb25TZWxlY3RvcikubGVuZ3RoLFxcclxcbiAgICAgICAgICAgICAgdHI4blRleHQgPSAodHlwZW9mIHRoaXMub3B0aW9ucy5jb3VudFNlbGVjdGVkVGV4dCA9PT0gJ2Z1bmN0aW9uJykgPyB0aGlzLm9wdGlvbnMuY291bnRTZWxlY3RlZFRleHQoc2VsZWN0ZWRDb3VudCwgdG90YWxDb3VudCkgOiB0aGlzLm9wdGlvbnMuY291bnRTZWxlY3RlZFRleHQ7XFxyXFxuXFxyXFxuICAgICAgICAgIHRpdGxlRnJhZ21lbnQgPSBnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhpcywge1xcclxcbiAgICAgICAgICAgIHRleHQ6IHRyOG5UZXh0LnJlcGxhY2UoJ3swfScsIHNlbGVjdGVkQ291bnQudG9TdHJpbmcoKSkucmVwbGFjZSgnezF9JywgdG90YWxDb3VudC50b1N0cmluZygpKVxcclxcbiAgICAgICAgICB9LCB0cnVlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aXRsZSA9PSB1bmRlZmluZWQpIHtcXHJcXG4gICAgICAgIC8vIHVzZSAuYXR0ciB0byBlbnN1cmUgdW5kZWZpbmVkIGlzIHJldHVybmVkIGlmIHRpdGxlIGF0dHJpYnV0ZSBpcyBub3Qgc2V0XFxyXFxuICAgICAgICB0aGlzLm9wdGlvbnMudGl0bGUgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJyk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIC8vIElmIHRoZSBzZWxlY3QgZG9lc24ndCBoYXZlIGEgdGl0bGUsIHRoZW4gdXNlIHRoZSBkZWZhdWx0LCBvciBpZiBub3RoaW5nIGlzIHNldCBhdCBhbGwsIHVzZSBub25lU2VsZWN0ZWRUZXh0XFxyXFxuICAgICAgaWYgKCF0aXRsZUZyYWdtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSB7XFxyXFxuICAgICAgICB0aXRsZUZyYWdtZW50ID0gZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHtcXHJcXG4gICAgICAgICAgdGV4dDogdHlwZW9mIHRoaXMub3B0aW9ucy50aXRsZSAhPT0gJ3VuZGVmaW5lZCcgPyB0aGlzLm9wdGlvbnMudGl0bGUgOiB0aGlzLm9wdGlvbnMubm9uZVNlbGVjdGVkVGV4dFxcclxcbiAgICAgICAgfSwgdHJ1ZSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIC8vIHN0cmlwIGFsbCBIVE1MIHRhZ3MgYW5kIHRyaW0gdGhlIHJlc3VsdCwgdGhlbiB1bmVzY2FwZSBhbnkgZXNjYXBlZCB0YWdzXFxyXFxuICAgICAgYnV0dG9uLnRpdGxlID0gdGl0bGVGcmFnbWVudC50ZXh0Q29udGVudC5yZXBsYWNlKC88W14+XSo+Py9nLCAnJykudHJpbSgpO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2FuaXRpemUgJiYgaGFzQ29udGVudCkge1xcclxcbiAgICAgICAgc2FuaXRpemVIdG1sKFt0aXRsZUZyYWdtZW50XSwgdGhhdC5vcHRpb25zLndoaXRlTGlzdCwgdGhhdC5vcHRpb25zLnNhbml0aXplRm4pO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBidXR0b25Jbm5lci5pbm5lckhUTUwgPSAnJztcXHJcXG4gICAgICBidXR0b25Jbm5lci5hcHBlbmRDaGlsZCh0aXRsZUZyYWdtZW50KTtcXHJcXG5cXHJcXG4gICAgICBpZiAodmVyc2lvbi5tYWpvciA8IDQgJiYgdGhpcy4kbmV3RWxlbWVudFswXS5jbGFzc0xpc3QuY29udGFpbnMoJ2JzMy1oYXMtYWRkb24nKSkge1xcclxcbiAgICAgICAgdmFyIGZpbHRlckV4cGFuZCA9IGJ1dHRvbi5xdWVyeVNlbGVjdG9yKCcuZmlsdGVyLWV4cGFuZCcpLFxcclxcbiAgICAgICAgICAgIGNsb25lID0gYnV0dG9uSW5uZXIuY2xvbmVOb2RlKHRydWUpO1xcclxcblxcclxcbiAgICAgICAgY2xvbmUuY2xhc3NOYW1lID0gJ2ZpbHRlci1leHBhbmQnO1xcclxcblxcclxcbiAgICAgICAgaWYgKGZpbHRlckV4cGFuZCkge1xcclxcbiAgICAgICAgICBidXR0b24ucmVwbGFjZUNoaWxkKGNsb25lLCBmaWx0ZXJFeHBhbmQpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGNsb25lKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdyZW5kZXJlZCcgKyBFVkVOVF9LRVkpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogQHBhcmFtIFtzdHlsZV1cXHJcXG4gICAgICogQHBhcmFtIFtzdGF0dXNdXFxyXFxuICAgICAqL1xcclxcbiAgICBzZXRTdHlsZTogZnVuY3Rpb24gKG5ld1N0eWxlLCBzdGF0dXMpIHtcXHJcXG4gICAgICB2YXIgYnV0dG9uID0gdGhpcy4kYnV0dG9uWzBdLFxcclxcbiAgICAgICAgICBuZXdFbGVtZW50ID0gdGhpcy4kbmV3RWxlbWVudFswXSxcXHJcXG4gICAgICAgICAgc3R5bGUgPSB0aGlzLm9wdGlvbnMuc3R5bGUudHJpbSgpLFxcclxcbiAgICAgICAgICBidXR0b25DbGFzcztcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpKSB7XFxyXFxuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmFkZENsYXNzKHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKS5yZXBsYWNlKC9zZWxlY3RwaWNrZXJ8bW9iaWxlLWRldmljZXxicy1zZWxlY3QtaGlkZGVufHZhbGlkYXRlXFxcXFsuKlxcXFxdL2dpLCAnJykpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAodmVyc2lvbi5tYWpvciA8IDQpIHtcXHJcXG4gICAgICAgIG5ld0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYnMzJyk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAobmV3RWxlbWVudC5wYXJlbnROb2RlLmNsYXNzTGlzdCAmJiBuZXdFbGVtZW50LnBhcmVudE5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbnB1dC1ncm91cCcpICYmXFxyXFxuICAgICAgICAgICAgKG5ld0VsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyB8fCBuZXdFbGVtZW50Lm5leHRFbGVtZW50U2libGluZykgJiZcXHJcXG4gICAgICAgICAgICAobmV3RWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nIHx8IG5ld0VsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5jbGFzc0xpc3QuY29udGFpbnMoJ2lucHV0LWdyb3VwLWFkZG9uJylcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2JzMy1oYXMtYWRkb24nKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKG5ld1N0eWxlKSB7XFxyXFxuICAgICAgICBidXR0b25DbGFzcyA9IG5ld1N0eWxlLnRyaW0oKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgYnV0dG9uQ2xhc3MgPSBzdHlsZTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHN0YXR1cyA9PSAnYWRkJykge1xcclxcbiAgICAgICAgaWYgKGJ1dHRvbkNsYXNzKSBidXR0b24uY2xhc3NMaXN0LmFkZC5hcHBseShidXR0b24uY2xhc3NMaXN0LCBidXR0b25DbGFzcy5zcGxpdCgnICcpKTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PSAncmVtb3ZlJykge1xcclxcbiAgICAgICAgaWYgKGJ1dHRvbkNsYXNzKSBidXR0b24uY2xhc3NMaXN0LnJlbW92ZS5hcHBseShidXR0b24uY2xhc3NMaXN0LCBidXR0b25DbGFzcy5zcGxpdCgnICcpKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgaWYgKHN0eWxlKSBidXR0b24uY2xhc3NMaXN0LnJlbW92ZS5hcHBseShidXR0b24uY2xhc3NMaXN0LCBzdHlsZS5zcGxpdCgnICcpKTtcXHJcXG4gICAgICAgIGlmIChidXR0b25DbGFzcykgYnV0dG9uLmNsYXNzTGlzdC5hZGQuYXBwbHkoYnV0dG9uLmNsYXNzTGlzdCwgYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBsaUhlaWdodDogZnVuY3Rpb24gKHJlZnJlc2gpIHtcXHJcXG4gICAgICBpZiAoIXJlZnJlc2ggJiYgKHRoaXMub3B0aW9ucy5zaXplID09PSBmYWxzZSB8fCBPYmplY3Qua2V5cyh0aGlzLnNpemVJbmZvKS5sZW5ndGgpKSByZXR1cm47XFxyXFxuXFxyXFxuICAgICAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50VGVtcGxhdGVzLmRpdi5jbG9uZU5vZGUoZmFsc2UpLFxcclxcbiAgICAgICAgICBtZW51ID0gZWxlbWVudFRlbXBsYXRlcy5kaXYuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgbWVudUlubmVyID0gZWxlbWVudFRlbXBsYXRlcy5kaXYuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgbWVudUlubmVySW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpLFxcclxcbiAgICAgICAgICBkaXZpZGVyID0gZWxlbWVudFRlbXBsYXRlcy5saS5jbG9uZU5vZGUoZmFsc2UpLFxcclxcbiAgICAgICAgICBkcm9wZG93bkhlYWRlciA9IGVsZW1lbnRUZW1wbGF0ZXMubGkuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgbGksXFxyXFxuICAgICAgICAgIGEgPSBlbGVtZW50VGVtcGxhdGVzLmEuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgdGV4dCA9IGVsZW1lbnRUZW1wbGF0ZXMuc3Bhbi5jbG9uZU5vZGUoZmFsc2UpLFxcclxcbiAgICAgICAgICBoZWFkZXIgPSB0aGlzLm9wdGlvbnMuaGVhZGVyICYmIHRoaXMuJG1lbnUuZmluZCgnLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoJy4nICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSKVswXS5jbG9uZU5vZGUodHJ1ZSkgOiBudWxsLFxcclxcbiAgICAgICAgICBzZWFyY2ggPSB0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaCA/IGVsZW1lbnRUZW1wbGF0ZXMuZGl2LmNsb25lTm9kZShmYWxzZSkgOiBudWxsLFxcclxcbiAgICAgICAgICBhY3Rpb25zID0gdGhpcy5vcHRpb25zLmFjdGlvbnNCb3ggJiYgdGhpcy5tdWx0aXBsZSAmJiB0aGlzLiRtZW51LmZpbmQoJy5icy1hY3Rpb25zYm94JykubGVuZ3RoID4gMCA/IHRoaXMuJG1lbnUuZmluZCgnLmJzLWFjdGlvbnNib3gnKVswXS5jbG9uZU5vZGUodHJ1ZSkgOiBudWxsLFxcclxcbiAgICAgICAgICBkb25lQnV0dG9uID0gdGhpcy5vcHRpb25zLmRvbmVCdXR0b24gJiYgdGhpcy5tdWx0aXBsZSAmJiB0aGlzLiRtZW51LmZpbmQoJy5icy1kb25lYnV0dG9uJykubGVuZ3RoID4gMCA/IHRoaXMuJG1lbnUuZmluZCgnLmJzLWRvbmVidXR0b24nKVswXS5jbG9uZU5vZGUodHJ1ZSkgOiBudWxsLFxcclxcbiAgICAgICAgICBmaXJzdE9wdGlvbiA9IHRoaXMuJGVsZW1lbnQuZmluZCgnb3B0aW9uJylbMF07XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5zZWxlY3RXaWR0aCA9IHRoaXMuJG5ld0VsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XFxyXFxuXFxyXFxuICAgICAgdGV4dC5jbGFzc05hbWUgPSAndGV4dCc7XFxyXFxuICAgICAgYS5jbGFzc05hbWUgPSAnZHJvcGRvd24taXRlbSAnICsgKGZpcnN0T3B0aW9uID8gZmlyc3RPcHRpb24uY2xhc3NOYW1lIDogJycpO1xcclxcbiAgICAgIG5ld0VsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy4kbWVudVswXS5wYXJlbnROb2RlLmNsYXNzTmFtZSArICcgJyArIGNsYXNzTmFtZXMuU0hPVztcXHJcXG4gICAgICBuZXdFbGVtZW50LnN0eWxlLndpZHRoID0gMDsgLy8gZW5zdXJlIGJ1dHRvbiB3aWR0aCBkb2Vzbid0IGFmZmVjdCBuYXR1cmFsIHdpZHRoIG9mIG1lbnUgd2hlbiBjYWxjdWxhdGluZ1xcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2lkdGggPT09ICdhdXRvJykgbWVudS5zdHlsZS5taW5XaWR0aCA9IDA7XFxyXFxuICAgICAgbWVudS5jbGFzc05hbWUgPSBjbGFzc05hbWVzLk1FTlUgKyAnICcgKyBjbGFzc05hbWVzLlNIT1c7XFxyXFxuICAgICAgbWVudUlubmVyLmNsYXNzTmFtZSA9ICdpbm5lciAnICsgY2xhc3NOYW1lcy5TSE9XO1xcclxcbiAgICAgIG1lbnVJbm5lcklubmVyLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuTUVOVSArICcgaW5uZXIgJyArICh2ZXJzaW9uLm1ham9yID09PSAnNCcgPyBjbGFzc05hbWVzLlNIT1cgOiAnJyk7XFxyXFxuICAgICAgZGl2aWRlci5jbGFzc05hbWUgPSBjbGFzc05hbWVzLkRJVklERVI7XFxyXFxuICAgICAgZHJvcGRvd25IZWFkZXIuY2xhc3NOYW1lID0gJ2Ryb3Bkb3duLWhlYWRlcic7XFxyXFxuXFxyXFxuICAgICAgdGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFxcXHUyMDBiJykpO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoKSB7XFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpXTtcXHJcXG4gICAgICAgICAgaWYgKGRhdGEudHlwZSA9PT0gJ29wdGlvbicpIHtcXHJcXG4gICAgICAgICAgICBsaSA9IGRhdGEuZWxlbWVudDtcXHJcXG4gICAgICAgICAgICBicmVhaztcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBsaSA9IGVsZW1lbnRUZW1wbGF0ZXMubGkuY2xvbmVOb2RlKGZhbHNlKTtcXHJcXG4gICAgICAgIGEuYXBwZW5kQ2hpbGQodGV4dCk7XFxyXFxuICAgICAgICBsaS5hcHBlbmRDaGlsZChhKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZHJvcGRvd25IZWFkZXIuYXBwZW5kQ2hpbGQodGV4dC5jbG9uZU5vZGUodHJ1ZSkpO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLnNlbGVjdHBpY2tlci52aWV3LndpZGVzdE9wdGlvbikge1xcclxcbiAgICAgICAgbWVudUlubmVySW5uZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWxlY3RwaWNrZXIudmlldy53aWRlc3RPcHRpb24uY2xvbmVOb2RlKHRydWUpKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgbWVudUlubmVySW5uZXIuYXBwZW5kQ2hpbGQobGkpO1xcclxcbiAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKGRpdmlkZXIpO1xcclxcbiAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKGRyb3Bkb3duSGVhZGVyKTtcXHJcXG4gICAgICBpZiAoaGVhZGVyKSBtZW51LmFwcGVuZENoaWxkKGhlYWRlcik7XFxyXFxuICAgICAgaWYgKHNlYXJjaCkge1xcclxcbiAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcXHJcXG4gICAgICAgIHNlYXJjaC5jbGFzc05hbWUgPSAnYnMtc2VhcmNoYm94JztcXHJcXG4gICAgICAgIGlucHV0LmNsYXNzTmFtZSA9ICdmb3JtLWNvbnRyb2wnO1xcclxcbiAgICAgICAgc2VhcmNoLmFwcGVuZENoaWxkKGlucHV0KTtcXHJcXG4gICAgICAgIG1lbnUuYXBwZW5kQ2hpbGQoc2VhcmNoKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgaWYgKGFjdGlvbnMpIG1lbnUuYXBwZW5kQ2hpbGQoYWN0aW9ucyk7XFxyXFxuICAgICAgbWVudUlubmVyLmFwcGVuZENoaWxkKG1lbnVJbm5lcklubmVyKTtcXHJcXG4gICAgICBtZW51LmFwcGVuZENoaWxkKG1lbnVJbm5lcik7XFxyXFxuICAgICAgaWYgKGRvbmVCdXR0b24pIG1lbnUuYXBwZW5kQ2hpbGQoZG9uZUJ1dHRvbik7XFxyXFxuICAgICAgbmV3RWxlbWVudC5hcHBlbmRDaGlsZChtZW51KTtcXHJcXG5cXHJcXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xcclxcblxcclxcbiAgICAgIHZhciBsaUhlaWdodCA9IGxpLm9mZnNldEhlaWdodCxcXHJcXG4gICAgICAgICAgZHJvcGRvd25IZWFkZXJIZWlnaHQgPSBkcm9wZG93bkhlYWRlciA/IGRyb3Bkb3duSGVhZGVyLm9mZnNldEhlaWdodCA6IDAsXFxyXFxuICAgICAgICAgIGhlYWRlckhlaWdodCA9IGhlYWRlciA/IGhlYWRlci5vZmZzZXRIZWlnaHQgOiAwLFxcclxcbiAgICAgICAgICBzZWFyY2hIZWlnaHQgPSBzZWFyY2ggPyBzZWFyY2gub2Zmc2V0SGVpZ2h0IDogMCxcXHJcXG4gICAgICAgICAgYWN0aW9uc0hlaWdodCA9IGFjdGlvbnMgPyBhY3Rpb25zLm9mZnNldEhlaWdodCA6IDAsXFxyXFxuICAgICAgICAgIGRvbmVCdXR0b25IZWlnaHQgPSBkb25lQnV0dG9uID8gZG9uZUJ1dHRvbi5vZmZzZXRIZWlnaHQgOiAwLFxcclxcbiAgICAgICAgICBkaXZpZGVySGVpZ2h0ID0gJChkaXZpZGVyKS5vdXRlckhlaWdodCh0cnVlKSxcXHJcXG4gICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGpRdWVyeSBpZiBnZXRDb21wdXRlZFN0eWxlIGlzIG5vdCBzdXBwb3J0ZWRcXHJcXG4gICAgICAgICAgbWVudVN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShtZW51KSA6IGZhbHNlLFxcclxcbiAgICAgICAgICBtZW51V2lkdGggPSBtZW51Lm9mZnNldFdpZHRoLFxcclxcbiAgICAgICAgICAkbWVudSA9IG1lbnVTdHlsZSA/IG51bGwgOiAkKG1lbnUpLFxcclxcbiAgICAgICAgICBtZW51UGFkZGluZyA9IHtcXHJcXG4gICAgICAgICAgICB2ZXJ0OiB0b0ludGVnZXIobWVudVN0eWxlID8gbWVudVN0eWxlLnBhZGRpbmdUb3AgOiAkbWVudS5jc3MoJ3BhZGRpbmdUb3AnKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUucGFkZGluZ0JvdHRvbSA6ICRtZW51LmNzcygncGFkZGluZ0JvdHRvbScpKSArXFxyXFxuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5ib3JkZXJUb3BXaWR0aCA6ICRtZW51LmNzcygnYm9yZGVyVG9wV2lkdGgnKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUuYm9yZGVyQm90dG9tV2lkdGggOiAkbWVudS5jc3MoJ2JvcmRlckJvdHRvbVdpZHRoJykpLFxcclxcbiAgICAgICAgICAgIGhvcml6OiB0b0ludGVnZXIobWVudVN0eWxlID8gbWVudVN0eWxlLnBhZGRpbmdMZWZ0IDogJG1lbnUuY3NzKCdwYWRkaW5nTGVmdCcpKSArXFxyXFxuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5wYWRkaW5nUmlnaHQgOiAkbWVudS5jc3MoJ3BhZGRpbmdSaWdodCcpKSArXFxyXFxuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5ib3JkZXJMZWZ0V2lkdGggOiAkbWVudS5jc3MoJ2JvcmRlckxlZnRXaWR0aCcpKSArXFxyXFxuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5ib3JkZXJSaWdodFdpZHRoIDogJG1lbnUuY3NzKCdib3JkZXJSaWdodFdpZHRoJykpXFxyXFxuICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgIG1lbnVFeHRyYXMgPSB7XFxyXFxuICAgICAgICAgICAgdmVydDogbWVudVBhZGRpbmcudmVydCArXFxyXFxuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5tYXJnaW5Ub3AgOiAkbWVudS5jc3MoJ21hcmdpblRvcCcpKSArXFxyXFxuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5tYXJnaW5Cb3R0b20gOiAkbWVudS5jc3MoJ21hcmdpbkJvdHRvbScpKSArIDIsXFxyXFxuICAgICAgICAgICAgaG9yaXo6IG1lbnVQYWRkaW5nLmhvcml6ICtcXHJcXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlID8gbWVudVN0eWxlLm1hcmdpbkxlZnQgOiAkbWVudS5jc3MoJ21hcmdpbkxlZnQnKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUubWFyZ2luUmlnaHQgOiAkbWVudS5jc3MoJ21hcmdpblJpZ2h0JykpICsgMlxcclxcbiAgICAgICAgICB9LFxcclxcbiAgICAgICAgICBzY3JvbGxCYXJXaWR0aDtcXHJcXG5cXHJcXG4gICAgICBtZW51SW5uZXIuc3R5bGUub3ZlcmZsb3dZID0gJ3Njcm9sbCc7XFxyXFxuXFxyXFxuICAgICAgc2Nyb2xsQmFyV2lkdGggPSBtZW51Lm9mZnNldFdpZHRoIC0gbWVudVdpZHRoO1xcclxcblxcclxcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobmV3RWxlbWVudCk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5saUhlaWdodCA9IGxpSGVpZ2h0O1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uZHJvcGRvd25IZWFkZXJIZWlnaHQgPSBkcm9wZG93bkhlYWRlckhlaWdodDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLmhlYWRlckhlaWdodCA9IGhlYWRlckhlaWdodDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlYXJjaEhlaWdodCA9IHNlYXJjaEhlaWdodDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLmFjdGlvbnNIZWlnaHQgPSBhY3Rpb25zSGVpZ2h0O1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uZG9uZUJ1dHRvbkhlaWdodCA9IGRvbmVCdXR0b25IZWlnaHQ7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5kaXZpZGVySGVpZ2h0ID0gZGl2aWRlckhlaWdodDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVQYWRkaW5nID0gbWVudVBhZGRpbmc7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5tZW51RXh0cmFzID0gbWVudUV4dHJhcztcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVXaWR0aCA9IG1lbnVXaWR0aDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggPSBtZW51V2lkdGggLSBtZW51UGFkZGluZy5ob3JpejtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnRvdGFsTWVudVdpZHRoID0gdGhpcy5zaXplSW5mby5tZW51V2lkdGg7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5zY3JvbGxCYXJXaWR0aCA9IHNjcm9sbEJhcldpZHRoO1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0SGVpZ2h0ID0gdGhpcy4kbmV3RWxlbWVudFswXS5vZmZzZXRIZWlnaHQ7XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zZXRQb3NpdGlvbkRhdGEoKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgZ2V0U2VsZWN0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxyXFxuICAgICAgICAgICR3aW5kb3cgPSAkKHdpbmRvdyksXFxyXFxuICAgICAgICAgIHBvcyA9IHRoYXQuJG5ld0VsZW1lbnQub2Zmc2V0KCksXFxyXFxuICAgICAgICAgICRjb250YWluZXIgPSAkKHRoYXQub3B0aW9ucy5jb250YWluZXIpLFxcclxcbiAgICAgICAgICBjb250YWluZXJQb3M7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoYXQub3B0aW9ucy5jb250YWluZXIgJiYgJGNvbnRhaW5lci5sZW5ndGggJiYgISRjb250YWluZXIuaXMoJ2JvZHknKSkge1xcclxcbiAgICAgICAgY29udGFpbmVyUG9zID0gJGNvbnRhaW5lci5vZmZzZXQoKTtcXHJcXG4gICAgICAgIGNvbnRhaW5lclBvcy50b3AgKz0gcGFyc2VJbnQoJGNvbnRhaW5lci5jc3MoJ2JvcmRlclRvcFdpZHRoJykpO1xcclxcbiAgICAgICAgY29udGFpbmVyUG9zLmxlZnQgKz0gcGFyc2VJbnQoJGNvbnRhaW5lci5jc3MoJ2JvcmRlckxlZnRXaWR0aCcpKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgY29udGFpbmVyUG9zID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdmFyIHdpblBhZCA9IHRoYXQub3B0aW9ucy53aW5kb3dQYWRkaW5nO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wID0gcG9zLnRvcCAtIGNvbnRhaW5lclBvcy50b3AgLSAkd2luZG93LnNjcm9sbFRvcCgpO1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0Qm90ID0gJHdpbmRvdy5oZWlnaHQoKSAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wIC0gdGhpcy5zaXplSW5mby5zZWxlY3RIZWlnaHQgLSBjb250YWluZXJQb3MudG9wIC0gd2luUGFkWzJdO1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0TGVmdCA9IHBvcy5sZWZ0IC0gY29udGFpbmVyUG9zLmxlZnQgLSAkd2luZG93LnNjcm9sbExlZnQoKTtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFJpZ2h0ID0gJHdpbmRvdy53aWR0aCgpIC0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRMZWZ0IC0gdGhpcy5zaXplSW5mby5zZWxlY3RXaWR0aCAtIGNvbnRhaW5lclBvcy5sZWZ0IC0gd2luUGFkWzFdO1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wIC09IHdpblBhZFswXTtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldExlZnQgLT0gd2luUGFkWzNdO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBzZXRNZW51U2l6ZTogZnVuY3Rpb24gKGlzQXV0bykge1xcclxcbiAgICAgIHRoaXMuZ2V0U2VsZWN0UG9zaXRpb24oKTtcXHJcXG5cXHJcXG4gICAgICB2YXIgc2VsZWN0V2lkdGggPSB0aGlzLnNpemVJbmZvLnNlbGVjdFdpZHRoLFxcclxcbiAgICAgICAgICBsaUhlaWdodCA9IHRoaXMuc2l6ZUluZm8ubGlIZWlnaHQsXFxyXFxuICAgICAgICAgIGhlYWRlckhlaWdodCA9IHRoaXMuc2l6ZUluZm8uaGVhZGVySGVpZ2h0LFxcclxcbiAgICAgICAgICBzZWFyY2hIZWlnaHQgPSB0aGlzLnNpemVJbmZvLnNlYXJjaEhlaWdodCxcXHJcXG4gICAgICAgICAgYWN0aW9uc0hlaWdodCA9IHRoaXMuc2l6ZUluZm8uYWN0aW9uc0hlaWdodCxcXHJcXG4gICAgICAgICAgZG9uZUJ1dHRvbkhlaWdodCA9IHRoaXMuc2l6ZUluZm8uZG9uZUJ1dHRvbkhlaWdodCxcXHJcXG4gICAgICAgICAgZGl2SGVpZ2h0ID0gdGhpcy5zaXplSW5mby5kaXZpZGVySGVpZ2h0LFxcclxcbiAgICAgICAgICBtZW51UGFkZGluZyA9IHRoaXMuc2l6ZUluZm8ubWVudVBhZGRpbmcsXFxyXFxuICAgICAgICAgIG1lbnVJbm5lckhlaWdodCxcXHJcXG4gICAgICAgICAgbWVudUhlaWdodCxcXHJcXG4gICAgICAgICAgZGl2TGVuZ3RoID0gMCxcXHJcXG4gICAgICAgICAgbWluSGVpZ2h0LFxcclxcbiAgICAgICAgICBfbWluSGVpZ2h0LFxcclxcbiAgICAgICAgICBtYXhIZWlnaHQsXFxyXFxuICAgICAgICAgIG1lbnVJbm5lck1pbkhlaWdodCxcXHJcXG4gICAgICAgICAgZXN0aW1hdGUsXFxyXFxuICAgICAgICAgIGlzRHJvcHVwO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcHVwQXV0bykge1xcclxcbiAgICAgICAgLy8gR2V0IHRoZSBlc3RpbWF0ZWQgaGVpZ2h0IG9mIHRoZSBtZW51IHdpdGhvdXQgc2Nyb2xsYmFycy5cXHJcXG4gICAgICAgIC8vIFRoaXMgaXMgdXNlZnVsIGZvciBzbWFsbGVyIG1lbnVzLCB3aGVyZSB0aGVyZSBtaWdodCBiZSBwbGVudHkgb2Ygcm9vbVxcclxcbiAgICAgICAgLy8gYmVsb3cgdGhlIGJ1dHRvbiB3aXRob3V0IHNldHRpbmcgZHJvcHVwLCBidXQgd2UgY2FuJ3Qga25vd1xcclxcbiAgICAgICAgLy8gdGhlIGV4YWN0IGhlaWdodCBvZiB0aGUgbWVudSB1bnRpbCBjcmVhdGVWaWV3IGlzIGNhbGxlZCBsYXRlclxcclxcbiAgICAgICAgZXN0aW1hdGUgPSBsaUhlaWdodCAqIHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMubGVuZ3RoICsgbWVudVBhZGRpbmcudmVydDtcXHJcXG5cXHJcXG4gICAgICAgIGlzRHJvcHVwID0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRUb3AgLSB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldEJvdCA+IHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0ICYmIGVzdGltYXRlICsgdGhpcy5zaXplSW5mby5tZW51RXh0cmFzLnZlcnQgKyA1MCA+IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0Qm90O1xcclxcblxcclxcbiAgICAgICAgLy8gZW5zdXJlIGRyb3B1cCBkb2Vzbid0IGNoYW5nZSB3aGlsZSBzZWFyY2hpbmcgKHNvIG1lbnUgZG9lc24ndCBib3VuY2UgYmFjayBhbmQgZm9ydGgpXFxyXFxuICAgICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIuaXNTZWFyY2hpbmcgPT09IHRydWUpIHtcXHJcXG4gICAgICAgICAgaXNEcm9wdXAgPSB0aGlzLnNlbGVjdHBpY2tlci5kcm9wdXA7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuRFJPUFVQLCBpc0Ryb3B1cCk7XFxyXFxuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci5kcm9wdXAgPSBpc0Ryb3B1cDtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaXplID09PSAnYXV0bycpIHtcXHJcXG4gICAgICAgIF9taW5IZWlnaHQgPSB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzLmxlbmd0aCA+IDMgPyB0aGlzLnNpemVJbmZvLmxpSGVpZ2h0ICogMyArIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0IC0gMiA6IDA7XFxyXFxuICAgICAgICBtZW51SGVpZ2h0ID0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRCb3QgLSB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMudmVydDtcXHJcXG4gICAgICAgIG1pbkhlaWdodCA9IF9taW5IZWlnaHQgKyBoZWFkZXJIZWlnaHQgKyBzZWFyY2hIZWlnaHQgKyBhY3Rpb25zSGVpZ2h0ICsgZG9uZUJ1dHRvbkhlaWdodDtcXHJcXG4gICAgICAgIG1lbnVJbm5lck1pbkhlaWdodCA9IE1hdGgubWF4KF9taW5IZWlnaHQgLSBtZW51UGFkZGluZy52ZXJ0LCAwKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmICh0aGlzLiRuZXdFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuRFJPUFVQKSkge1xcclxcbiAgICAgICAgICBtZW51SGVpZ2h0ID0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRUb3AgLSB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMudmVydDtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIG1heEhlaWdodCA9IG1lbnVIZWlnaHQ7XFxyXFxuICAgICAgICBtZW51SW5uZXJIZWlnaHQgPSBtZW51SGVpZ2h0IC0gaGVhZGVySGVpZ2h0IC0gc2VhcmNoSGVpZ2h0IC0gYWN0aW9uc0hlaWdodCAtIGRvbmVCdXR0b25IZWlnaHQgLSBtZW51UGFkZGluZy52ZXJ0O1xcclxcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNpemUgJiYgdGhpcy5vcHRpb25zLnNpemUgIT0gJ2F1dG8nICYmIHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5vcHRpb25zLnNpemUpIHtcXHJcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLnNpemU7IGkrKykge1xcclxcbiAgICAgICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2ldLnR5cGUgPT09ICdkaXZpZGVyJykgZGl2TGVuZ3RoKys7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBtZW51SGVpZ2h0ID0gbGlIZWlnaHQgKiB0aGlzLm9wdGlvbnMuc2l6ZSArIGRpdkxlbmd0aCAqIGRpdkhlaWdodCArIG1lbnVQYWRkaW5nLnZlcnQ7XFxyXFxuICAgICAgICBtZW51SW5uZXJIZWlnaHQgPSBtZW51SGVpZ2h0IC0gbWVudVBhZGRpbmcudmVydDtcXHJcXG4gICAgICAgIG1heEhlaWdodCA9IG1lbnVIZWlnaHQgKyBoZWFkZXJIZWlnaHQgKyBzZWFyY2hIZWlnaHQgKyBhY3Rpb25zSGVpZ2h0ICsgZG9uZUJ1dHRvbkhlaWdodDtcXHJcXG4gICAgICAgIG1pbkhlaWdodCA9IG1lbnVJbm5lck1pbkhlaWdodCA9ICcnO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLiRtZW51LmNzcyh7XFxyXFxuICAgICAgICAnbWF4LWhlaWdodCc6IG1heEhlaWdodCArICdweCcsXFxyXFxuICAgICAgICAnb3ZlcmZsb3cnOiAnaGlkZGVuJyxcXHJcXG4gICAgICAgICdtaW4taGVpZ2h0JzogbWluSGVpZ2h0ICsgJ3B4J1xcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJG1lbnVJbm5lci5jc3Moe1xcclxcbiAgICAgICAgJ21heC1oZWlnaHQnOiBtZW51SW5uZXJIZWlnaHQgKyAncHgnLFxcclxcbiAgICAgICAgJ292ZXJmbG93LXknOiAnYXV0bycsXFxyXFxuICAgICAgICAnbWluLWhlaWdodCc6IG1lbnVJbm5lck1pbkhlaWdodCArICdweCdcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICAvLyBlbnN1cmUgbWVudUlubmVySGVpZ2h0IGlzIGFsd2F5cyBhIHBvc2l0aXZlIG51bWJlciB0byBwcmV2ZW50IGlzc3VlcyBjYWxjdWxhdGluZyBjaHVua1NpemUgaW4gY3JlYXRlVmlld1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0ID0gTWF0aC5tYXgobWVudUlubmVySGVpZ2h0LCAxKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCAmJiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCAtIDFdLnBvc2l0aW9uID4gdGhpcy5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQpIHtcXHJcXG4gICAgICAgIHRoaXMuc2l6ZUluZm8uaGFzU2Nyb2xsQmFyID0gdHJ1ZTtcXHJcXG4gICAgICAgIHRoaXMuc2l6ZUluZm8udG90YWxNZW51V2lkdGggPSB0aGlzLnNpemVJbmZvLm1lbnVXaWR0aCArIHRoaXMuc2l6ZUluZm8uc2Nyb2xsQmFyV2lkdGg7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJvcGRvd25BbGlnblJpZ2h0ID09PSAnYXV0bycpIHtcXHJcXG4gICAgICAgIHRoaXMuJG1lbnUudG9nZ2xlQ2xhc3MoY2xhc3NOYW1lcy5NRU5VUklHSFQsIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0TGVmdCA+IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0UmlnaHQgJiYgdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRSaWdodCA8ICh0aGlzLnNpemVJbmZvLnRvdGFsTWVudVdpZHRoIC0gc2VsZWN0V2lkdGgpKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMuZHJvcGRvd24gJiYgdGhpcy5kcm9wZG93bi5fcG9wcGVyKSB0aGlzLmRyb3Bkb3duLl9wb3BwZXIudXBkYXRlKCk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNldFNpemU6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XFxyXFxuICAgICAgdGhpcy5saUhlaWdodChyZWZyZXNoKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcikgdGhpcy4kbWVudS5jc3MoJ3BhZGRpbmctdG9wJywgMCk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaXplICE9PSBmYWxzZSkge1xcclxcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICAgICR3aW5kb3cgPSAkKHdpbmRvdyk7XFxyXFxuXFxyXFxuICAgICAgICB0aGlzLnNldE1lbnVTaXplKCk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgICAgdGhpcy4kc2VhcmNoYm94XFxyXFxuICAgICAgICAgICAgLm9mZignaW5wdXQuc2V0TWVudVNpemUgcHJvcGVydHljaGFuZ2Uuc2V0TWVudVNpemUnKVxcclxcbiAgICAgICAgICAgIC5vbignaW5wdXQuc2V0TWVudVNpemUgcHJvcGVydHljaGFuZ2Uuc2V0TWVudVNpemUnLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5zZXRNZW51U2l6ZSgpO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaXplID09PSAnYXV0bycpIHtcXHJcXG4gICAgICAgICAgJHdpbmRvd1xcclxcbiAgICAgICAgICAgIC5vZmYoJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScgKyAnIHNjcm9sbCcgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScpXFxyXFxuICAgICAgICAgICAgLm9uKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnICsgJyBzY3JvbGwnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgICByZXR1cm4gdGhhdC5zZXRNZW51U2l6ZSgpO1xcclxcbiAgICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSAmJiB0aGlzLm9wdGlvbnMuc2l6ZSAhPSAnYXV0bycgJiYgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5sZW5ndGggPiB0aGlzLm9wdGlvbnMuc2l6ZSkge1xcclxcbiAgICAgICAgICAkd2luZG93Lm9mZigncmVzaXplJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnLnNldE1lbnVTaXplJyArICcgc2Nyb2xsJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnLnNldE1lbnVTaXplJyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHRoaXMuY3JlYXRlVmlldyhmYWxzZSwgdHJ1ZSwgcmVmcmVzaCk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNldFdpZHRoOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMud2lkdGggPT09ICdhdXRvJykge1xcclxcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kbWVudS5jc3MoJ21pbi13aWR0aCcsICcwJyk7XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuJGVsZW1lbnQub24oJ2xvYWRlZCcgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LmxpSGVpZ2h0KCk7XFxyXFxuICAgICAgICAgICAgdGhhdC5zZXRNZW51U2l6ZSgpO1xcclxcblxcclxcbiAgICAgICAgICAgIC8vIEdldCBjb3JyZWN0IHdpZHRoIGlmIGVsZW1lbnQgaXMgaGlkZGVuXFxyXFxuICAgICAgICAgICAgdmFyICRzZWxlY3RDbG9uZSA9IHRoYXQuJG5ld0VsZW1lbnQuY2xvbmUoKS5hcHBlbmRUbygnYm9keScpLFxcclxcbiAgICAgICAgICAgICAgICBidG5XaWR0aCA9ICRzZWxlY3RDbG9uZS5jc3MoJ3dpZHRoJywgJ2F1dG8nKS5jaGlsZHJlbignYnV0dG9uJykub3V0ZXJXaWR0aCgpO1xcclxcblxcclxcbiAgICAgICAgICAgICRzZWxlY3RDbG9uZS5yZW1vdmUoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBTZXQgd2lkdGggdG8gd2hhdGV2ZXIncyBsYXJnZXIsIGJ1dHRvbiB0aXRsZSBvciBsb25nZXN0IG9wdGlvblxcclxcbiAgICAgICAgICAgIHRoYXQuc2l6ZUluZm8uc2VsZWN0V2lkdGggPSBNYXRoLm1heCh0aGF0LnNpemVJbmZvLnRvdGFsTWVudVdpZHRoLCBidG5XaWR0aCk7XFxyXFxuICAgICAgICAgICAgdGhhdC4kbmV3RWxlbWVudC5jc3MoJ3dpZHRoJywgdGhhdC5zaXplSW5mby5zZWxlY3RXaWR0aCArICdweCcpO1xcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLndpZHRoID09PSAnZml0Jykge1xcclxcbiAgICAgICAgLy8gUmVtb3ZlIGlubGluZSBtaW4td2lkdGggc28gd2lkdGggY2FuIGJlIGNoYW5nZWQgZnJvbSAnYXV0bydcXHJcXG4gICAgICAgIHRoaXMuJG1lbnUuY3NzKCdtaW4td2lkdGgnLCAnJyk7XFxyXFxuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmNzcygnd2lkdGgnLCAnJykuYWRkQ2xhc3MoJ2ZpdC13aWR0aCcpO1xcclxcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLndpZHRoKSB7XFxyXFxuICAgICAgICAvLyBSZW1vdmUgaW5saW5lIG1pbi13aWR0aCBzbyB3aWR0aCBjYW4gYmUgY2hhbmdlZCBmcm9tICdhdXRvJ1xcclxcbiAgICAgICAgdGhpcy4kbWVudS5jc3MoJ21pbi13aWR0aCcsICcnKTtcXHJcXG4gICAgICAgIHRoaXMuJG5ld0VsZW1lbnQuY3NzKCd3aWR0aCcsIHRoaXMub3B0aW9ucy53aWR0aCk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIC8vIFJlbW92ZSBpbmxpbmUgbWluLXdpZHRoL3dpZHRoIHNvIHdpZHRoIGNhbiBiZSBjaGFuZ2VkXFxyXFxuICAgICAgICB0aGlzLiRtZW51LmNzcygnbWluLXdpZHRoJywgJycpO1xcclxcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5jc3MoJ3dpZHRoJywgJycpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICAvLyBSZW1vdmUgZml0LXdpZHRoIGNsYXNzIGlmIHdpZHRoIGlzIGNoYW5nZWQgcHJvZ3JhbW1hdGljYWxseVxcclxcbiAgICAgIGlmICh0aGlzLiRuZXdFbGVtZW50Lmhhc0NsYXNzKCdmaXQtd2lkdGgnKSAmJiB0aGlzLm9wdGlvbnMud2lkdGggIT09ICdmaXQnKSB7XFxyXFxuICAgICAgICB0aGlzLiRuZXdFbGVtZW50WzBdLmNsYXNzTGlzdC5yZW1vdmUoJ2ZpdC13aWR0aCcpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgc2VsZWN0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB0aGlzLiRic0NvbnRhaW5lciA9ICQoJzxkaXYgY2xhc3M9XFxcImJzLWNvbnRhaW5lclxcXCIgLz4nKTtcXHJcXG5cXHJcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxyXFxuICAgICAgICAgICRjb250YWluZXIgPSAkKHRoaXMub3B0aW9ucy5jb250YWluZXIpLFxcclxcbiAgICAgICAgICBwb3MsXFxyXFxuICAgICAgICAgIGNvbnRhaW5lclBvcyxcXHJcXG4gICAgICAgICAgYWN0dWFsSGVpZ2h0LFxcclxcbiAgICAgICAgICBnZXRQbGFjZW1lbnQgPSBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcXHJcXG4gICAgICAgICAgICB2YXIgY29udGFpbmVyUG9zaXRpb24gPSB7fSxcXHJcXG4gICAgICAgICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGRyb3Bkb3duJ3MgZGVmYXVsdCBkaXNwbGF5IHNldHRpbmcgaWYgZGlzcGxheSBpcyBub3QgbWFudWFsbHkgc2V0XFxyXFxuICAgICAgICAgICAgICAgIGRpc3BsYXkgPSB0aGF0Lm9wdGlvbnMuZGlzcGxheSB8fCAoXFxyXFxuICAgICAgICAgICAgICAgICAgLy8gQm9vdHN0cmFwIDMgZG9lc24ndCBoYXZlICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuRGVmYXVsdFxcclxcbiAgICAgICAgICAgICAgICAgICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuRGVmYXVsdCA/ICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuRGVmYXVsdC5kaXNwbGF5XFxyXFxuICAgICAgICAgICAgICAgICAgOiBmYWxzZVxcclxcbiAgICAgICAgICAgICAgICApO1xcclxcblxcclxcbiAgICAgICAgICAgIHRoYXQuJGJzQ29udGFpbmVyLmFkZENsYXNzKCRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZSgvZm9ybS1jb250cm9sfGZpdC13aWR0aC9naSwgJycpKS50b2dnbGVDbGFzcyhjbGFzc05hbWVzLkRST1BVUCwgJGVsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5EUk9QVVApKTtcXHJcXG4gICAgICAgICAgICBwb3MgPSAkZWxlbWVudC5vZmZzZXQoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoISRjb250YWluZXIuaXMoJ2JvZHknKSkge1xcclxcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zID0gJGNvbnRhaW5lci5vZmZzZXQoKTtcXHJcXG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvcy50b3AgKz0gcGFyc2VJbnQoJGNvbnRhaW5lci5jc3MoJ2JvcmRlclRvcFdpZHRoJykpIC0gJGNvbnRhaW5lci5zY3JvbGxUb3AoKTtcXHJcXG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvcy5sZWZ0ICs9IHBhcnNlSW50KCRjb250YWluZXIuY3NzKCdib3JkZXJMZWZ0V2lkdGgnKSkgLSAkY29udGFpbmVyLnNjcm9sbExlZnQoKTtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgYWN0dWFsSGVpZ2h0ID0gJGVsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5EUk9QVVApID8gMCA6ICRlbGVtZW50WzBdLm9mZnNldEhlaWdodDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBCb290c3RyYXAgNCsgdXNlcyBQb3BwZXIgZm9yIG1lbnUgcG9zaXRpb25pbmdcXHJcXG4gICAgICAgICAgICBpZiAodmVyc2lvbi5tYWpvciA8IDQgfHwgZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcXHJcXG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvc2l0aW9uLnRvcCA9IHBvcy50b3AgLSBjb250YWluZXJQb3MudG9wICsgYWN0dWFsSGVpZ2h0O1xcclxcbiAgICAgICAgICAgICAgY29udGFpbmVyUG9zaXRpb24ubGVmdCA9IHBvcy5sZWZ0IC0gY29udGFpbmVyUG9zLmxlZnQ7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGNvbnRhaW5lclBvc2l0aW9uLndpZHRoID0gJGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC4kYnNDb250YWluZXIuY3NzKGNvbnRhaW5lclBvc2l0aW9uKTtcXHJcXG4gICAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRidXR0b24ub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgaWYgKHRoYXQuaXNEaXNhYmxlZCgpKSB7XFxyXFxuICAgICAgICAgIHJldHVybjtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGdldFBsYWNlbWVudCh0aGF0LiRuZXdFbGVtZW50KTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuJGJzQ29udGFpbmVyXFxyXFxuICAgICAgICAgIC5hcHBlbmRUbyh0aGF0Lm9wdGlvbnMuY29udGFpbmVyKVxcclxcbiAgICAgICAgICAudG9nZ2xlQ2xhc3MoY2xhc3NOYW1lcy5TSE9XLCAhdGhhdC4kYnV0dG9uLmhhc0NsYXNzKGNsYXNzTmFtZXMuU0hPVykpXFxyXFxuICAgICAgICAgIC5hcHBlbmQodGhhdC4kbWVudSk7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgJCh3aW5kb3cpXFxyXFxuICAgICAgICAub2ZmKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcgc2Nyb2xsJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQpXFxyXFxuICAgICAgICAub24oJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJyBzY3JvbGwnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCwgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICB2YXIgaXNBY3RpdmUgPSB0aGF0LiRuZXdFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuU0hPVyk7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChpc0FjdGl2ZSkgZ2V0UGxhY2VtZW50KHRoYXQuJG5ld0VsZW1lbnQpO1xcclxcbiAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kZWxlbWVudC5vbignaGlkZScgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHRoYXQuJG1lbnUuZGF0YSgnaGVpZ2h0JywgdGhhdC4kbWVudS5oZWlnaHQoKSk7XFxyXFxuICAgICAgICB0aGF0LiRic0NvbnRhaW5lci5kZXRhY2goKTtcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgc2V0T3B0aW9uU3RhdHVzOiBmdW5jdGlvbiAoc2VsZWN0ZWRPbmx5KSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcblxcclxcbiAgICAgIHRoYXQubm9TY3JvbGwgPSBmYWxzZTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMgJiYgdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMubGVuZ3RoKSB7XFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgIHZhciBsaURhdGEgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaSArIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wXSxcXHJcXG4gICAgICAgICAgICAgIG9wdGlvbiA9IGxpRGF0YS5vcHRpb247XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChvcHRpb24pIHtcXHJcXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRPbmx5ICE9PSB0cnVlKSB7XFxyXFxuICAgICAgICAgICAgICB0aGF0LnNldERpc2FibGVkKFxcclxcbiAgICAgICAgICAgICAgICBsaURhdGEuaW5kZXgsXFxyXFxuICAgICAgICAgICAgICAgIGxpRGF0YS5kaXNhYmxlZFxcclxcbiAgICAgICAgICAgICAgKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChcXHJcXG4gICAgICAgICAgICAgIGxpRGF0YS5pbmRleCxcXHJcXG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZFxcclxcbiAgICAgICAgICAgICk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIG9wdGlvbiB0aGF0IGlzIGJlaW5nIGNoYW5nZWRcXHJcXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZCAtIHRydWUgaWYgdGhlIG9wdGlvbiBpcyBiZWluZyBzZWxlY3RlZCwgZmFsc2UgaWYgYmVpbmcgZGVzZWxlY3RlZFxcclxcbiAgICAgKi9cXHJcXG4gICAgc2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIChpbmRleCwgc2VsZWN0ZWQpIHtcXHJcXG4gICAgICB2YXIgbGkgPSB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzW2luZGV4XSxcXHJcXG4gICAgICAgICAgbGlEYXRhID0gdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW2luZGV4XSxcXHJcXG4gICAgICAgICAgYWN0aXZlSW5kZXhJc1NldCA9IHRoaXMuYWN0aXZlSW5kZXggIT09IHVuZGVmaW5lZCxcXHJcXG4gICAgICAgICAgdGhpc0lzQWN0aXZlID0gdGhpcy5hY3RpdmVJbmRleCA9PT0gaW5kZXgsXFxyXFxuICAgICAgICAgIHByZXZBY3RpdmUsXFxyXFxuICAgICAgICAgIGEsXFxyXFxuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgb3B0aW9uIGlzIGFscmVhZHkgYWN0aXZlXFxyXFxuICAgICAgICAgIC8vIE9SXFxyXFxuICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IG9wdGlvbiBpcyBiZWluZyBzZWxlY3RlZCwgaXQncyBOT1QgbXVsdGlwbGUsIGFuZFxcclxcbiAgICAgICAgICAvLyBhY3RpdmVJbmRleCBpcyB1bmRlZmluZWQ6XFxyXFxuICAgICAgICAgIC8vICAtIHdoZW4gdGhlIG1lbnUgaXMgZmlyc3QgYmVpbmcgb3BlbmVkLCBPUlxcclxcbiAgICAgICAgICAvLyAgLSBhZnRlciBhIHNlYXJjaCBoYXMgYmVlbiBwZXJmb3JtZWQsIE9SXFxyXFxuICAgICAgICAgIC8vICAtIHdoZW4gcmV0YWluQWN0aXZlIGlzIGZhbHNlIHdoZW4gc2VsZWN0aW5nIGEgbmV3IG9wdGlvbiAoaS5lLiBpbmRleCBvZiB0aGUgbmV3bHkgc2VsZWN0ZWQgb3B0aW9uIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBhY3RpdmVJbmRleClcXHJcXG4gICAgICAgICAga2VlcEFjdGl2ZSA9IHRoaXNJc0FjdGl2ZSB8fCAoc2VsZWN0ZWQgJiYgIXRoaXMubXVsdGlwbGUgJiYgIWFjdGl2ZUluZGV4SXNTZXQpO1xcclxcblxcclxcbiAgICAgIGxpRGF0YS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xcclxcblxcclxcbiAgICAgIGEgPSBsaS5maXJzdENoaWxkO1xcclxcblxcclxcbiAgICAgIGlmIChzZWxlY3RlZCkge1xcclxcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gaW5kZXg7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGxpLmNsYXNzTGlzdC50b2dnbGUoJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xcclxcblxcclxcbiAgICAgIGlmIChrZWVwQWN0aXZlKSB7XFxyXFxuICAgICAgICB0aGlzLmZvY3VzSXRlbShsaSwgbGlEYXRhKTtcXHJcXG4gICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuY3VycmVudEFjdGl2ZSA9IGxpO1xcclxcbiAgICAgICAgdGhpcy5hY3RpdmVJbmRleCA9IGluZGV4O1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICB0aGlzLmRlZm9jdXNJdGVtKGxpKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKGEpIHtcXHJcXG4gICAgICAgIGEuY2xhc3NMaXN0LnRvZ2dsZSgnc2VsZWN0ZWQnLCBzZWxlY3RlZCk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcXHJcXG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlKSB7XFxyXFxuICAgICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxyXFxuICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgYS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAoIWtlZXBBY3RpdmUgJiYgIWFjdGl2ZUluZGV4SXNTZXQgJiYgc2VsZWN0ZWQgJiYgdGhpcy5wcmV2QWN0aXZlSW5kZXggIT09IHVuZGVmaW5lZCkge1xcclxcbiAgICAgICAgcHJldkFjdGl2ZSA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbdGhpcy5wcmV2QWN0aXZlSW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgdGhpcy5kZWZvY3VzSXRlbShwcmV2QWN0aXZlKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIC8qKlxcclxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIG9wdGlvbiB0aGF0IGlzIGJlaW5nIGRpc2FibGVkXFxyXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgLSB0cnVlIGlmIHRoZSBvcHRpb24gaXMgYmVpbmcgZGlzYWJsZWQsIGZhbHNlIGlmIGJlaW5nIGVuYWJsZWRcXHJcXG4gICAgICovXFxyXFxuICAgIHNldERpc2FibGVkOiBmdW5jdGlvbiAoaW5kZXgsIGRpc2FibGVkKSB7XFxyXFxuICAgICAgdmFyIGxpID0gdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50c1tpbmRleF0sXFxyXFxuICAgICAgICAgIGE7XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW2luZGV4XS5kaXNhYmxlZCA9IGRpc2FibGVkO1xcclxcblxcclxcbiAgICAgIGEgPSBsaS5maXJzdENoaWxkO1xcclxcblxcclxcbiAgICAgIGxpLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lcy5ESVNBQkxFRCwgZGlzYWJsZWQpO1xcclxcblxcclxcbiAgICAgIGlmIChhKSB7XFxyXFxuICAgICAgICBpZiAodmVyc2lvbi5tYWpvciA9PT0gJzQnKSBhLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lcy5ESVNBQkxFRCwgZGlzYWJsZWQpO1xcclxcblxcclxcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XFxyXFxuICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQpO1xcclxcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICBhLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcpO1xcclxcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGlzRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICByZXR1cm4gdGhpcy4kZWxlbWVudFswXS5kaXNhYmxlZDtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgY2hlY2tEaXNhYmxlZDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xcclxcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudFswXS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZXMuRElTQUJMRUQpO1xcclxcbiAgICAgICAgdGhpcy4kYnV0dG9uLmFkZENsYXNzKGNsYXNzTmFtZXMuRElTQUJMRUQpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgaWYgKHRoaXMuJGJ1dHRvblswXS5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lcy5ESVNBQkxFRCkpIHtcXHJcXG4gICAgICAgICAgdGhpcy4kbmV3RWxlbWVudFswXS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZXMuRElTQUJMRUQpO1xcclxcbiAgICAgICAgICB0aGlzLiRidXR0b24ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lcy5ESVNBQkxFRCkuYXR0cignYXJpYS1kaXNhYmxlZCcsIGZhbHNlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGNsaWNrTGlzdGVuZXI6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB2YXIgdGhhdCA9IHRoaXMsXFxyXFxuICAgICAgICAgICRkb2N1bWVudCA9ICQoZG9jdW1lbnQpO1xcclxcblxcclxcbiAgICAgICRkb2N1bWVudC5kYXRhKCdzcGFjZVNlbGVjdCcsIGZhbHNlKTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRidXR0b24ub24oJ2tleXVwJywgZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgIGlmICgvKDMyKS8udGVzdChlLmtleUNvZGUudG9TdHJpbmcoMTApKSAmJiAkZG9jdW1lbnQuZGF0YSgnc3BhY2VTZWxlY3QnKSkge1xcclxcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICAgICRkb2N1bWVudC5kYXRhKCdzcGFjZVNlbGVjdCcsIGZhbHNlKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50Lm9uKCdzaG93LmJzLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPiAzICYmICF0aGF0LmRyb3Bkb3duKSB7XFxyXFxuICAgICAgICAgIHRoYXQuZHJvcGRvd24gPSB0aGF0LiRidXR0b24uZGF0YSgnYnMuZHJvcGRvd24nKTtcXHJcXG4gICAgICAgICAgdGhhdC5kcm9wZG93bi5fbWVudSA9IHRoYXQuJG1lbnVbMF07XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kYnV0dG9uLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIGlmICghdGhhdC4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpKSB7XFxyXFxuICAgICAgICAgIHRoYXQuc2V0U2l6ZSgpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIGZ1bmN0aW9uIHNldEZvY3VzICgpIHtcXHJcXG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHRoYXQuJG1lbnVJbm5lci50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBmdW5jdGlvbiBjaGVja1BvcHBlckV4aXN0cyAoKSB7XFxyXFxuICAgICAgICBpZiAodGhhdC5kcm9wZG93biAmJiB0aGF0LmRyb3Bkb3duLl9wb3BwZXIgJiYgdGhhdC5kcm9wZG93bi5fcG9wcGVyLnN0YXRlLmlzQ3JlYXRlZCkge1xcclxcbiAgICAgICAgICBzZXRGb2N1cygpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNoZWNrUG9wcGVyRXhpc3RzKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kZWxlbWVudC5vbignc2hvd24nICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICBpZiAodGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCAhPT0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5zY3JvbGxUb3ApIHtcXHJcXG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuc2Nyb2xsVG9wO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPiAzKSB7XFxyXFxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVja1BvcHBlckV4aXN0cyk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICBzZXRGb2N1cygpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIC8vIGVuc3VyZSBwb3NpbnNldCBhbmQgc2V0c2l6ZSBhcmUgY29ycmVjdCBiZWZvcmUgc2VsZWN0aW5nIGFuIG9wdGlvbiB2aWEgYSBjbGlja1xcclxcbiAgICAgIHRoaXMuJG1lbnVJbm5lci5vbignbW91c2VlbnRlcicsICdsaSBhJywgZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgIHZhciBob3ZlckxpID0gdGhpcy5wYXJlbnRFbGVtZW50LFxcclxcbiAgICAgICAgICAgIHBvc2l0aW9uMCA9IHRoYXQuaXNWaXJ0dWFsKCkgPyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCA6IDAsXFxyXFxuICAgICAgICAgICAgaW5kZXggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGhvdmVyTGkucGFyZW50RWxlbWVudC5jaGlsZHJlbiwgaG92ZXJMaSksXFxyXFxuICAgICAgICAgICAgaG92ZXJEYXRhID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2luZGV4ICsgcG9zaXRpb24wXTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuZm9jdXNJdGVtKGhvdmVyTGksIGhvdmVyRGF0YSwgdHJ1ZSk7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbWVudUlubmVyLm9uKCdjbGljaycsICdsaSBhJywgZnVuY3Rpb24gKGUsIHJldGFpbkFjdGl2ZSkge1xcclxcbiAgICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcXHJcXG4gICAgICAgICAgICBlbGVtZW50ID0gdGhhdC4kZWxlbWVudFswXSxcXHJcXG4gICAgICAgICAgICBwb3NpdGlvbjAgPSB0aGF0LmlzVmlydHVhbCgpID8gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAgOiAwLFxcclxcbiAgICAgICAgICAgIGNsaWNrZWREYXRhID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhWyR0aGlzLnBhcmVudCgpLmluZGV4KCkgKyBwb3NpdGlvbjBdLFxcclxcbiAgICAgICAgICAgIGNsaWNrZWRJbmRleCA9IGNsaWNrZWREYXRhLmluZGV4LFxcclxcbiAgICAgICAgICAgIHByZXZWYWx1ZSA9IGdldFNlbGVjdFZhbHVlcyhlbGVtZW50KSxcXHJcXG4gICAgICAgICAgICBwcmV2SW5kZXggPSBlbGVtZW50LnNlbGVjdGVkSW5kZXgsXFxyXFxuICAgICAgICAgICAgcHJldk9wdGlvbiA9IGVsZW1lbnQub3B0aW9uc1twcmV2SW5kZXhdLFxcclxcbiAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSB0cnVlO1xcclxcblxcclxcbiAgICAgICAgLy8gRG9uJ3QgY2xvc2Ugb24gbXVsdGkgY2hvaWNlIG1lbnVcXHJcXG4gICAgICAgIGlmICh0aGF0Lm11bHRpcGxlICYmIHRoYXQub3B0aW9ucy5tYXhPcHRpb25zICE9PSAxKSB7XFxyXFxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuXFxyXFxuICAgICAgICAvLyBEb24ndCBydW4gaWYgdGhlIHNlbGVjdCBpcyBkaXNhYmxlZFxcclxcbiAgICAgICAgaWYgKCF0aGF0LmlzRGlzYWJsZWQoKSAmJiAhJHRoaXMucGFyZW50KCkuaGFzQ2xhc3MoY2xhc3NOYW1lcy5ESVNBQkxFRCkpIHtcXHJcXG4gICAgICAgICAgdmFyIG9wdGlvbiA9IGNsaWNrZWREYXRhLm9wdGlvbixcXHJcXG4gICAgICAgICAgICAgICRvcHRpb24gPSAkKG9wdGlvbiksXFxyXFxuICAgICAgICAgICAgICBzdGF0ZSA9IG9wdGlvbi5zZWxlY3RlZCxcXHJcXG4gICAgICAgICAgICAgICRvcHRncm91cCA9ICRvcHRpb24ucGFyZW50KCdvcHRncm91cCcpLFxcclxcbiAgICAgICAgICAgICAgJG9wdGdyb3VwT3B0aW9ucyA9ICRvcHRncm91cC5maW5kKCdvcHRpb24nKSxcXHJcXG4gICAgICAgICAgICAgIG1heE9wdGlvbnMgPSB0aGF0Lm9wdGlvbnMubWF4T3B0aW9ucyxcXHJcXG4gICAgICAgICAgICAgIG1heE9wdGlvbnNHcnAgPSAkb3B0Z3JvdXAuZGF0YSgnbWF4T3B0aW9ucycpIHx8IGZhbHNlO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoY2xpY2tlZEluZGV4ID09PSB0aGF0LmFjdGl2ZUluZGV4KSByZXRhaW5BY3RpdmUgPSB0cnVlO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoIXJldGFpbkFjdGl2ZSkge1xcclxcbiAgICAgICAgICAgIHRoYXQucHJldkFjdGl2ZUluZGV4ID0gdGhhdC5hY3RpdmVJbmRleDtcXHJcXG4gICAgICAgICAgICB0aGF0LmFjdGl2ZUluZGV4ID0gdW5kZWZpbmVkO1xcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICghdGhhdC5tdWx0aXBsZSkgeyAvLyBEZXNlbGVjdCBhbGwgb3RoZXJzIGlmIG5vdCBtdWx0aSBzZWxlY3QgYm94XFxyXFxuICAgICAgICAgICAgaWYgKHByZXZPcHRpb24pIHByZXZPcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xcclxcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQoY2xpY2tlZEluZGV4LCB0cnVlKTtcXHJcXG4gICAgICAgICAgfSBlbHNlIHsgLy8gVG9nZ2xlIHRoZSBvbmUgd2UgaGF2ZSBjaG9zZW4gaWYgd2UgYXJlIG11bHRpIHNlbGVjdC5cXHJcXG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSAhc3RhdGU7XFxyXFxuXFxyXFxuICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChjbGlja2VkSW5kZXgsICFzdGF0ZSk7XFxyXFxuICAgICAgICAgICAgdGhhdC5mb2N1c2VkUGFyZW50LmZvY3VzKCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKG1heE9wdGlvbnMgIT09IGZhbHNlIHx8IG1heE9wdGlvbnNHcnAgIT09IGZhbHNlKSB7XFxyXFxuICAgICAgICAgICAgICB2YXIgbWF4UmVhY2hlZCA9IG1heE9wdGlvbnMgPCBnZXRTZWxlY3RlZE9wdGlvbnMoZWxlbWVudCkubGVuZ3RoLFxcclxcbiAgICAgICAgICAgICAgICAgIG1heFJlYWNoZWRHcnAgPSBtYXhPcHRpb25zR3JwIDwgJG9wdGdyb3VwLmZpbmQoJ29wdGlvbjpzZWxlY3RlZCcpLmxlbmd0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgIGlmICgobWF4T3B0aW9ucyAmJiBtYXhSZWFjaGVkKSB8fCAobWF4T3B0aW9uc0dycCAmJiBtYXhSZWFjaGVkR3JwKSkge1xcclxcbiAgICAgICAgICAgICAgICBpZiAobWF4T3B0aW9ucyAmJiBtYXhPcHRpb25zID09IDEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICBlbGVtZW50LnNlbGVjdGVkSW5kZXggPSAtMTtcXHJcXG4gICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICAgIHRoYXQuc2V0T3B0aW9uU3RhdHVzKHRydWUpO1xcclxcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1heE9wdGlvbnNHcnAgJiYgbWF4T3B0aW9uc0dycCA9PSAxKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAkb3B0Z3JvdXBPcHRpb25zLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICB2YXIgX29wdGlvbiA9ICRvcHRncm91cE9wdGlvbnNbaV07XFxyXFxuICAgICAgICAgICAgICAgICAgICBfb3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKF9vcHRpb24ubGlJbmRleCwgZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQoY2xpY2tlZEluZGV4LCB0cnVlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICB2YXIgbWF4T3B0aW9uc1RleHQgPSB0eXBlb2YgdGhhdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0ID09PSAnc3RyaW5nJyA/IFt0aGF0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHQsIHRoYXQub3B0aW9ucy5tYXhPcHRpb25zVGV4dF0gOiB0aGF0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHQsXFxyXFxuICAgICAgICAgICAgICAgICAgICAgIG1heE9wdGlvbnNBcnIgPSB0eXBlb2YgbWF4T3B0aW9uc1RleHQgPT09ICdmdW5jdGlvbicgPyBtYXhPcHRpb25zVGV4dChtYXhPcHRpb25zLCBtYXhPcHRpb25zR3JwKSA6IG1heE9wdGlvbnNUZXh0LFxcclxcbiAgICAgICAgICAgICAgICAgICAgICBtYXhUeHQgPSBtYXhPcHRpb25zQXJyWzBdLnJlcGxhY2UoJ3tufScsIG1heE9wdGlvbnMpLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICBtYXhUeHRHcnAgPSBtYXhPcHRpb25zQXJyWzFdLnJlcGxhY2UoJ3tufScsIG1heE9wdGlvbnNHcnApLFxcclxcbiAgICAgICAgICAgICAgICAgICAgICAkbm90aWZ5ID0gJCgnPGRpdiBjbGFzcz1cXFwibm90aWZ5XFxcIj48L2Rpdj4nKTtcXHJcXG4gICAgICAgICAgICAgICAgICAvLyBJZiB7dmFyfSBpcyBzZXQgaW4gYXJyYXksIHJlcGxhY2UgaXRcXHJcXG4gICAgICAgICAgICAgICAgICAvKiogQGRlcHJlY2F0ZWQgKi9cXHJcXG4gICAgICAgICAgICAgICAgICBpZiAobWF4T3B0aW9uc0FyclsyXSkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF4VHh0ID0gbWF4VHh0LnJlcGxhY2UoJ3t2YXJ9JywgbWF4T3B0aW9uc0FyclsyXVttYXhPcHRpb25zID4gMSA/IDAgOiAxXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICBtYXhUeHRHcnAgPSBtYXhUeHRHcnAucmVwbGFjZSgne3Zhcn0nLCBtYXhPcHRpb25zQXJyWzJdW21heE9wdGlvbnNHcnAgPiAxID8gMCA6IDFdKTtcXHJcXG4gICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgdGhhdC4kbWVudS5hcHBlbmQoJG5vdGlmeSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgaWYgKG1heE9wdGlvbnMgJiYgbWF4UmVhY2hlZCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgJG5vdGlmeS5hcHBlbmQoJCgnPGRpdj4nICsgbWF4VHh0ICsgJzwvZGl2PicpKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignbWF4UmVhY2hlZCcgKyBFVkVOVF9LRVkpO1xcclxcbiAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICBpZiAobWF4T3B0aW9uc0dycCAmJiBtYXhSZWFjaGVkR3JwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAkbm90aWZ5LmFwcGVuZCgkKCc8ZGl2PicgKyBtYXhUeHRHcnAgKyAnPC9kaXY+JykpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZSA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdtYXhSZWFjaGVkR3JwJyArIEVWRU5UX0tFWSk7XFxyXFxuICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChjbGlja2VkSW5kZXgsIGZhbHNlKTtcXHJcXG4gICAgICAgICAgICAgICAgICB9LCAxMCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgJG5vdGlmeVswXS5jbGFzc0xpc3QuYWRkKCdmYWRlT3V0Jyk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgICAkbm90aWZ5LnJlbW92ZSgpO1xcclxcbiAgICAgICAgICAgICAgICAgIH0sIDEwNTApO1xcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICghdGhhdC5tdWx0aXBsZSB8fCAodGhhdC5tdWx0aXBsZSAmJiB0aGF0Lm9wdGlvbnMubWF4T3B0aW9ucyA9PT0gMSkpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LiRidXR0b24udHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIC8vIFRyaWdnZXIgc2VsZWN0ICdjaGFuZ2UnXFxyXFxuICAgICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHRoYXQubXVsdGlwbGUgfHwgcHJldkluZGV4ICE9PSBlbGVtZW50LnNlbGVjdGVkSW5kZXgpIHtcXHJcXG4gICAgICAgICAgICAgIC8vICRvcHRpb24ucHJvcCgnc2VsZWN0ZWQnKSBpcyBjdXJyZW50IG9wdGlvbiBzdGF0ZSAoc2VsZWN0ZWQvdW5zZWxlY3RlZCkuIHByZXZWYWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlbGVjdCBwcmlvciB0byBiZWluZyBjaGFuZ2VkLlxcclxcbiAgICAgICAgICAgICAgY2hhbmdlZEFyZ3VtZW50cyA9IFtvcHRpb24uaW5kZXgsICRvcHRpb24ucHJvcCgnc2VsZWN0ZWQnKSwgcHJldlZhbHVlXTtcXHJcXG4gICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnRcXHJcXG4gICAgICAgICAgICAgICAgLnRyaWdnZXJOYXRpdmUoJ2NoYW5nZScpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJG1lbnUub24oJ2NsaWNrJywgJ2xpLicgKyBjbGFzc05hbWVzLkRJU0FCTEVEICsgJyBhLCAuJyArIGNsYXNzTmFtZXMuUE9QT1ZFUkhFQURFUiArICcsIC4nICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSICsgJyA6bm90KC5jbG9zZSknLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgaWYgKGUuY3VycmVudFRhcmdldCA9PSB0aGlzKSB7XFxyXFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXHJcXG4gICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoICYmICEkKGUudGFyZ2V0KS5oYXNDbGFzcygnY2xvc2UnKSkge1xcclxcbiAgICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbWVudUlubmVyLm9uKCdjbGljaycsICcuZGl2aWRlciwgLmRyb3Bkb3duLWhlYWRlcicsIGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcclxcbiAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbWVudS5vbignY2xpY2snLCAnLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgKyAnIC5jbG9zZScsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdjbGljaycpO1xcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJHNlYXJjaGJveC5vbignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRtZW51Lm9uKCdjbGljaycsICcuYWN0aW9ucy1idG4nLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcclxcblxcclxcbiAgICAgICAgaWYgKCQodGhpcykuaGFzQ2xhc3MoJ2JzLXNlbGVjdC1hbGwnKSkge1xcclxcbiAgICAgICAgICB0aGF0LnNlbGVjdEFsbCgpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgdGhhdC5kZXNlbGVjdEFsbCgpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJGJ1dHRvblxcclxcbiAgICAgICAgLm9uKCdmb2N1cycgKyBFVkVOVF9LRVksIGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgIHZhciB0YWJpbmRleCA9IHRoYXQuJGVsZW1lbnRbMF0uZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xcclxcblxcclxcbiAgICAgICAgICAvLyBvbmx5IGNoYW5nZSB3aGVuIGJ1dHRvbiBpcyBhY3R1YWxseSBmb2N1c2VkXFxyXFxuICAgICAgICAgIGlmICh0YWJpbmRleCAhPT0gdW5kZWZpbmVkICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuaXNUcnVzdGVkKSB7XFxyXFxuICAgICAgICAgICAgLy8gYXBwbHkgc2VsZWN0IGVsZW1lbnQncyB0YWJpbmRleCB0byBlbnN1cmUgY29ycmVjdCBvcmRlciBpcyBmb2xsb3dlZCB3aGVuIHRhYmJpbmcgdG8gdGhlIG5leHQgZWxlbWVudFxcclxcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYmluZGV4KTtcXHJcXG4gICAgICAgICAgICAvLyBzZXQgZWxlbWVudCdzIHRhYmluZGV4IHRvIC0xIHRvIGFsbG93IGZvciByZXZlcnNlIHRhYmJpbmdcXHJcXG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50WzBdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XFxyXFxuICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy50YWJpbmRleCA9IHRhYmluZGV4O1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9KVxcclxcbiAgICAgICAgLm9uKCdibHVyJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgLy8gcmV2ZXJ0IGV2ZXJ5dGhpbmcgdG8gb3JpZ2luYWwgdGFiaW5kZXhcXHJcXG4gICAgICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudGFiaW5kZXggIT09IHVuZGVmaW5lZCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmlzVHJ1c3RlZCkge1xcclxcbiAgICAgICAgICAgIHRoYXQuJGVsZW1lbnRbMF0uc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudGFiaW5kZXgpO1xcclxcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIC0xKTtcXHJcXG4gICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnRhYmluZGV4ID0gdW5kZWZpbmVkO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRlbGVtZW50XFxyXFxuICAgICAgICAub24oJ2NoYW5nZScgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgdGhhdC5yZW5kZXIoKTtcXHJcXG4gICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdjaGFuZ2VkJyArIEVWRU5UX0tFWSwgY2hhbmdlZEFyZ3VtZW50cyk7XFxyXFxuICAgICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBudWxsO1xcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIC5vbignZm9jdXMnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgIGlmICghdGhhdC5vcHRpb25zLm1vYmlsZSkgdGhhdC4kYnV0dG9uWzBdLmZvY3VzKCk7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgbGl2ZVNlYXJjaExpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xcclxcblxcclxcbiAgICAgIHRoaXMuJGJ1dHRvbi5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICBpZiAoISF0aGF0LiRzZWFyY2hib3gudmFsKCkpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnZhbCgnJyk7XFxyXFxuICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5wcmV2aW91c1ZhbHVlID0gdW5kZWZpbmVkO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJHNlYXJjaGJveC5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGkgZm9jdXMuYnMuZHJvcGRvd24uZGF0YS1hcGkgdG91Y2hlbmQuYnMuZHJvcGRvd24uZGF0YS1hcGknLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRzZWFyY2hib3gub24oJ2lucHV0IHByb3BlcnR5Y2hhbmdlJywgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgdmFyIHNlYXJjaFZhbHVlID0gdGhhdC4kc2VhcmNoYm94WzBdLnZhbHVlO1xcclxcblxcclxcbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLmVsZW1lbnRzID0gW107XFxyXFxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2guZGF0YSA9IFtdO1xcclxcblxcclxcbiAgICAgICAgaWYgKHNlYXJjaFZhbHVlKSB7XFxyXFxuICAgICAgICAgIHZhciBpLFxcclxcbiAgICAgICAgICAgICAgc2VhcmNoTWF0Y2ggPSBbXSxcXHJcXG4gICAgICAgICAgICAgIHEgPSBzZWFyY2hWYWx1ZS50b1VwcGVyQ2FzZSgpLFxcclxcbiAgICAgICAgICAgICAgY2FjaGUgPSB7fSxcXHJcXG4gICAgICAgICAgICAgIGNhY2hlQXJyID0gW10sXFxyXFxuICAgICAgICAgICAgICBzZWFyY2hTdHlsZSA9IHRoYXQuX3NlYXJjaFN0eWxlKCksXFxyXFxuICAgICAgICAgICAgICBub3JtYWxpemVTZWFyY2ggPSB0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaE5vcm1hbGl6ZTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKG5vcm1hbGl6ZVNlYXJjaCkgcSA9IG5vcm1hbGl6ZVRvQmFzZShxKTtcXHJcXG5cXHJcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmRhdGEubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgICAgICB2YXIgbGkgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmRhdGFbaV07XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKCFjYWNoZVtpXSkge1xcclxcbiAgICAgICAgICAgICAgY2FjaGVbaV0gPSBzdHJpbmdTZWFyY2gobGksIHEsIHNlYXJjaFN0eWxlLCBub3JtYWxpemVTZWFyY2gpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAoY2FjaGVbaV0gJiYgbGkuaGVhZGVySW5kZXggIT09IHVuZGVmaW5lZCAmJiBjYWNoZUFyci5pbmRleE9mKGxpLmhlYWRlckluZGV4KSA9PT0gLTEpIHtcXHJcXG4gICAgICAgICAgICAgIGlmIChsaS5oZWFkZXJJbmRleCA+IDApIHtcXHJcXG4gICAgICAgICAgICAgICAgY2FjaGVbbGkuaGVhZGVySW5kZXggLSAxXSA9IHRydWU7XFxyXFxuICAgICAgICAgICAgICAgIGNhY2hlQXJyLnB1c2gobGkuaGVhZGVySW5kZXggLSAxKTtcXHJcXG4gICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgIGNhY2hlW2xpLmhlYWRlckluZGV4XSA9IHRydWU7XFxyXFxuICAgICAgICAgICAgICBjYWNoZUFyci5wdXNoKGxpLmhlYWRlckluZGV4KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgIGNhY2hlW2xpLmxhc3RJbmRleCArIDFdID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGNhY2hlW2ldICYmIGxpLnR5cGUgIT09ICdvcHRncm91cC1sYWJlbCcpIGNhY2hlQXJyLnB1c2goaSk7XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGNhY2hlTGVuID0gY2FjaGVBcnIubGVuZ3RoOyBpIDwgY2FjaGVMZW47IGkrKykge1xcclxcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGNhY2hlQXJyW2ldLFxcclxcbiAgICAgICAgICAgICAgICBwcmV2SW5kZXggPSBjYWNoZUFycltpIC0gMV0sXFxyXFxuICAgICAgICAgICAgICAgIGxpID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW2luZGV4XSxcXHJcXG4gICAgICAgICAgICAgICAgbGlQcmV2ID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW3ByZXZJbmRleF07XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGxpLnR5cGUgIT09ICdkaXZpZGVyJyB8fCAobGkudHlwZSA9PT0gJ2RpdmlkZXInICYmIGxpUHJldiAmJiBsaVByZXYudHlwZSAhPT0gJ2RpdmlkZXInICYmIGNhY2hlTGVuIC0gMSAhPT0gaSkpIHtcXHJcXG4gICAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5kYXRhLnB1c2gobGkpO1xcclxcbiAgICAgICAgICAgICAgc2VhcmNoTWF0Y2gucHVzaCh0aGF0LnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzW2luZGV4XSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuYWN0aXZlSW5kZXggPSB1bmRlZmluZWQ7XFxyXFxuICAgICAgICAgIHRoYXQubm9TY3JvbGwgPSB0cnVlO1xcclxcbiAgICAgICAgICB0aGF0LiRtZW51SW5uZXIuc2Nyb2xsVG9wKDApO1xcclxcbiAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2guZWxlbWVudHMgPSBzZWFyY2hNYXRjaDtcXHJcXG4gICAgICAgICAgdGhhdC5jcmVhdGVWaWV3KHRydWUpO1xcclxcbiAgICAgICAgICBzaG93Tm9SZXN1bHRzLmNhbGwodGhhdCwgc2VhcmNoTWF0Y2gsIHNlYXJjaFZhbHVlKTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLnByZXZpb3VzVmFsdWUpIHsgLy8gZm9yIElFMTEgKCMyNDAyKVxcclxcbiAgICAgICAgICB0aGF0LiRtZW51SW5uZXIuc2Nyb2xsVG9wKDApO1xcclxcbiAgICAgICAgICB0aGF0LmNyZWF0ZVZpZXcoZmFsc2UpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLnByZXZpb3VzVmFsdWUgPSAgc2VhcmNoVmFsdWU7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIF9zZWFyY2hTdHlsZTogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGl2ZVNlYXJjaFN0eWxlIHx8ICdjb250YWlucyc7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHZhbDogZnVuY3Rpb24gKHZhbHVlKSB7XFxyXFxuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50WzBdO1xcclxcblxcclxcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XFxyXFxuICAgICAgICB2YXIgcHJldlZhbHVlID0gZ2V0U2VsZWN0VmFsdWVzKGVsZW1lbnQpO1xcclxcblxcclxcbiAgICAgICAgY2hhbmdlZEFyZ3VtZW50cyA9IFtudWxsLCBudWxsLCBwcmV2VmFsdWVdO1xcclxcblxcclxcbiAgICAgICAgdGhpcy4kZWxlbWVudFxcclxcbiAgICAgICAgICAudmFsKHZhbHVlKVxcclxcbiAgICAgICAgICAudHJpZ2dlcignY2hhbmdlZCcgKyBFVkVOVF9LRVksIGNoYW5nZWRBcmd1bWVudHMpO1xcclxcblxcclxcbiAgICAgICAgaWYgKHRoaXMuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKSkge1xcclxcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xcclxcbiAgICAgICAgICAgIHRoaXMuc2V0T3B0aW9uU3RhdHVzKHRydWUpO1xcclxcbiAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHZhciBsaVNlbGVjdGVkSW5kZXggPSAoZWxlbWVudC5vcHRpb25zW2VsZW1lbnQuc2VsZWN0ZWRJbmRleF0gfHwge30pLmxpSW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaVNlbGVjdGVkSW5kZXggPT09ICdudW1iZXInKSB7XFxyXFxuICAgICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkKHRoaXMuc2VsZWN0ZWRJbmRleCwgZmFsc2UpO1xcclxcbiAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZChsaVNlbGVjdGVkSW5kZXgsIHRydWUpO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcXHJcXG5cXHJcXG4gICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBudWxsO1xcclxcblxcclxcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQ7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50LnZhbCgpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgY2hhbmdlQWxsOiBmdW5jdGlvbiAoc3RhdHVzKSB7XFxyXFxuICAgICAgaWYgKCF0aGlzLm11bHRpcGxlKSByZXR1cm47XFxyXFxuICAgICAgaWYgKHR5cGVvZiBzdGF0dXMgPT09ICd1bmRlZmluZWQnKSBzdGF0dXMgPSB0cnVlO1xcclxcblxcclxcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXSxcXHJcXG4gICAgICAgICAgcHJldmlvdXNTZWxlY3RlZCA9IDAsXFxyXFxuICAgICAgICAgIGN1cnJlbnRTZWxlY3RlZCA9IDAsXFxyXFxuICAgICAgICAgIHByZXZWYWx1ZSA9IGdldFNlbGVjdFZhbHVlcyhlbGVtZW50KTtcXHJcXG5cXHJcXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2JzLXNlbGVjdC1oaWRkZW4nKTtcXHJcXG5cXHJcXG4gICAgICBmb3IgKHZhciBpID0gMCwgZGF0YSA9IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YSwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgdmFyIGxpRGF0YSA9IGRhdGFbaV0sXFxyXFxuICAgICAgICAgICAgb3B0aW9uID0gbGlEYXRhLm9wdGlvbjtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChvcHRpb24gJiYgIWxpRGF0YS5kaXNhYmxlZCAmJiBsaURhdGEudHlwZSAhPT0gJ2RpdmlkZXInKSB7XFxyXFxuICAgICAgICAgIGlmIChsaURhdGEuc2VsZWN0ZWQpIHByZXZpb3VzU2VsZWN0ZWQrKztcXHJcXG4gICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gc3RhdHVzO1xcclxcbiAgICAgICAgICBpZiAoc3RhdHVzID09PSB0cnVlKSBjdXJyZW50U2VsZWN0ZWQrKztcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdicy1zZWxlY3QtaGlkZGVuJyk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHByZXZpb3VzU2VsZWN0ZWQgPT09IGN1cnJlbnRTZWxlY3RlZCkgcmV0dXJuO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2V0T3B0aW9uU3RhdHVzKCk7XFxyXFxuXFxyXFxuICAgICAgY2hhbmdlZEFyZ3VtZW50cyA9IFtudWxsLCBudWxsLCBwcmV2VmFsdWVdO1xcclxcblxcclxcbiAgICAgIHRoaXMuJGVsZW1lbnRcXHJcXG4gICAgICAgIC50cmlnZ2VyTmF0aXZlKCdjaGFuZ2UnKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlQWxsKHRydWUpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBkZXNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHJldHVybiB0aGlzLmNoYW5nZUFsbChmYWxzZSk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHRvZ2dsZTogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XFxyXFxuXFxyXFxuICAgICAgaWYgKGUpIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kYnV0dG9uLnRyaWdnZXIoJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJyk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGtleWRvd246IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKSxcXHJcXG4gICAgICAgICAgaXNUb2dnbGUgPSAkdGhpcy5oYXNDbGFzcygnZHJvcGRvd24tdG9nZ2xlJyksXFxyXFxuICAgICAgICAgICRwYXJlbnQgPSBpc1RvZ2dsZSA/ICR0aGlzLmNsb3Nlc3QoJy5kcm9wZG93bicpIDogJHRoaXMuY2xvc2VzdChTZWxlY3Rvci5NRU5VKSxcXHJcXG4gICAgICAgICAgdGhhdCA9ICRwYXJlbnQuZGF0YSgndGhpcycpLFxcclxcbiAgICAgICAgICAkaXRlbXMgPSB0aGF0LmZpbmRMaXMoKSxcXHJcXG4gICAgICAgICAgaW5kZXgsXFxyXFxuICAgICAgICAgIGlzQWN0aXZlLFxcclxcbiAgICAgICAgICBsaUFjdGl2ZSxcXHJcXG4gICAgICAgICAgYWN0aXZlTGksXFxyXFxuICAgICAgICAgIG9mZnNldCxcXHJcXG4gICAgICAgICAgdXBkYXRlU2Nyb2xsID0gZmFsc2UsXFxyXFxuICAgICAgICAgIGRvd25PblRhYiA9IGUud2hpY2ggPT09IGtleUNvZGVzLlRBQiAmJiAhaXNUb2dnbGUgJiYgIXRoYXQub3B0aW9ucy5zZWxlY3RPblRhYixcXHJcXG4gICAgICAgICAgaXNBcnJvd0tleSA9IFJFR0VYUF9BUlJPVy50ZXN0KGUud2hpY2gpIHx8IGRvd25PblRhYixcXHJcXG4gICAgICAgICAgc2Nyb2xsVG9wID0gdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCxcXHJcXG4gICAgICAgICAgaXNWaXJ0dWFsID0gdGhhdC5pc1ZpcnR1YWwoKSxcXHJcXG4gICAgICAgICAgcG9zaXRpb24wID0gaXNWaXJ0dWFsID09PSB0cnVlID8gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAgOiAwO1xcclxcblxcclxcbiAgICAgIC8vIGRvIG5vdGhpbmcgaWYgYSBmdW5jdGlvbiBrZXkgaXMgcHJlc3NlZFxcclxcbiAgICAgIGlmIChlLndoaWNoID49IDExMiAmJiBlLndoaWNoIDw9IDEyMykgcmV0dXJuO1xcclxcblxcclxcbiAgICAgIGlzQWN0aXZlID0gdGhhdC4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpO1xcclxcblxcclxcbiAgICAgIGlmIChcXHJcXG4gICAgICAgICFpc0FjdGl2ZSAmJlxcclxcbiAgICAgICAgKFxcclxcbiAgICAgICAgICBpc0Fycm93S2V5IHx8XFxyXFxuICAgICAgICAgIChlLndoaWNoID49IDQ4ICYmIGUud2hpY2ggPD0gNTcpIHx8XFxyXFxuICAgICAgICAgIChlLndoaWNoID49IDk2ICYmIGUud2hpY2ggPD0gMTA1KSB8fFxcclxcbiAgICAgICAgICAoZS53aGljaCA+PSA2NSAmJiBlLndoaWNoIDw9IDkwKVxcclxcbiAgICAgICAgKVxcclxcbiAgICAgICkge1xcclxcbiAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJyk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICAgIHJldHVybjtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkVTQ0FQRSAmJiBpc0FjdGl2ZSkge1xcclxcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcbiAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJykudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKGlzQXJyb3dLZXkpIHsgLy8gaWYgdXAgb3IgZG93blxcclxcbiAgICAgICAgaWYgKCEkaXRlbXMubGVuZ3RoKSByZXR1cm47XFxyXFxuXFxyXFxuICAgICAgICBsaUFjdGl2ZSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbdGhhdC5hY3RpdmVJbmRleF07XFxyXFxuICAgICAgICBpbmRleCA9IGxpQWN0aXZlID8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChsaUFjdGl2ZS5wYXJlbnRFbGVtZW50LmNoaWxkcmVuLCBsaUFjdGl2ZSkgOiAtMTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcXHJcXG4gICAgICAgICAgdGhhdC5kZWZvY3VzSXRlbShsaUFjdGl2ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAoZS53aGljaCA9PT0ga2V5Q29kZXMuQVJST1dfVVApIHsgLy8gdXBcXHJcXG4gICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgaW5kZXgtLTtcXHJcXG4gICAgICAgICAgaWYgKGluZGV4ICsgcG9zaXRpb24wIDwgMCkgaW5kZXggKz0gJGl0ZW1zLmxlbmd0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKCF0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodFtpbmRleCArIHBvc2l0aW9uMF0pIHtcXHJcXG4gICAgICAgICAgICBpbmRleCA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0LnNsaWNlKDAsIGluZGV4ICsgcG9zaXRpb24wKS5sYXN0SW5kZXhPZih0cnVlKSAtIHBvc2l0aW9uMDtcXHJcXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSBpbmRleCA9ICRpdGVtcy5sZW5ndGggLSAxO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX0RPV04gfHwgZG93bk9uVGFiKSB7IC8vIGRvd25cXHJcXG4gICAgICAgICAgaW5kZXgrKztcXHJcXG4gICAgICAgICAgaWYgKGluZGV4ICsgcG9zaXRpb24wID49IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0Lmxlbmd0aCkgaW5kZXggPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICghdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHRbaW5kZXggKyBwb3NpdGlvbjBdKSB7XFxyXFxuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDEgKyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5zbGljZShpbmRleCArIHBvc2l0aW9uMCArIDEpLmluZGV4T2YodHJ1ZSk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG5cXHJcXG4gICAgICAgIHZhciBsaUFjdGl2ZUluZGV4ID0gcG9zaXRpb24wICsgaW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoZS53aGljaCA9PT0ga2V5Q29kZXMuQVJST1dfVVApIHsgLy8gdXBcXHJcXG4gICAgICAgICAgLy8gc2Nyb2xsIHRvIGJvdHRvbSBhbmQgaGlnaGxpZ2h0IGxhc3Qgb3B0aW9uXFxyXFxuICAgICAgICAgIGlmIChwb3NpdGlvbjAgPT09IDAgJiYgaW5kZXggPT09ICRpdGVtcy5sZW5ndGggLSAxKSB7XFxyXFxuICAgICAgICAgICAgdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxIZWlnaHQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgbGlBY3RpdmVJbmRleCA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMubGVuZ3RoIC0gMTtcXHJcXG4gICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBhY3RpdmVMaSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtsaUFjdGl2ZUluZGV4XTtcXHJcXG4gICAgICAgICAgICBvZmZzZXQgPSBhY3RpdmVMaS5wb3NpdGlvbiAtIGFjdGl2ZUxpLmhlaWdodDtcXHJcXG5cXHJcXG4gICAgICAgICAgICB1cGRhdGVTY3JvbGwgPSBvZmZzZXQgPCBzY3JvbGxUb3A7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0gZWxzZSBpZiAoZS53aGljaCA9PT0ga2V5Q29kZXMuQVJST1dfRE9XTiB8fCBkb3duT25UYWIpIHsgLy8gZG93blxcclxcbiAgICAgICAgICAvLyBzY3JvbGwgdG8gdG9wIGFuZCBoaWdobGlnaHQgZmlyc3Qgb3B0aW9uXFxyXFxuICAgICAgICAgIGlmIChpbmRleCA9PT0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4KSB7XFxyXFxuICAgICAgICAgICAgdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAgICAgbGlBY3RpdmVJbmRleCA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuZmlyc3RIaWdobGlnaHRJbmRleDtcXHJcXG4gICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICBhY3RpdmVMaSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtsaUFjdGl2ZUluZGV4XTtcXHJcXG4gICAgICAgICAgICBvZmZzZXQgPSBhY3RpdmVMaS5wb3NpdGlvbiAtIHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0O1xcclxcblxcclxcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbCA9IG9mZnNldCA+IHNjcm9sbFRvcDtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgbGlBY3RpdmUgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzW2xpQWN0aXZlSW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgdGhhdC5hY3RpdmVJbmRleCA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtsaUFjdGl2ZUluZGV4XS5pbmRleDtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuZm9jdXNJdGVtKGxpQWN0aXZlKTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY3VycmVudEFjdGl2ZSA9IGxpQWN0aXZlO1xcclxcblxcclxcbiAgICAgICAgaWYgKHVwZGF0ZVNjcm9sbCkgdGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCA9IG9mZnNldDtcXHJcXG5cXHJcXG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSBlbHNlIGlmIChcXHJcXG4gICAgICAgICghJHRoaXMuaXMoJ2lucHV0JykgJiYgIVJFR0VYUF9UQUJfT1JfRVNDQVBFLnRlc3QoZS53aGljaCkpIHx8XFxyXFxuICAgICAgICAoZS53aGljaCA9PT0ga2V5Q29kZXMuU1BBQ0UgJiYgdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5KVxcclxcbiAgICAgICkge1xcclxcbiAgICAgICAgdmFyIHNlYXJjaE1hdGNoLFxcclxcbiAgICAgICAgICAgIG1hdGNoZXMgPSBbXSxcXHJcXG4gICAgICAgICAgICBrZXlIaXN0b3J5O1xcclxcblxcclxcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcblxcclxcbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5ICs9IGtleUNvZGVNYXBbZS53aGljaF07XFxyXFxuXFxyXFxuICAgICAgICBpZiAodGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5yZXNldEtleUhpc3RvcnkuY2FuY2VsKSBjbGVhclRpbWVvdXQodGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5yZXNldEtleUhpc3RvcnkuY2FuY2VsKTtcXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ucmVzZXRLZXlIaXN0b3J5LmNhbmNlbCA9IHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ucmVzZXRLZXlIaXN0b3J5LnN0YXJ0KCk7XFxyXFxuXFxyXFxuICAgICAgICBrZXlIaXN0b3J5ID0gdGhhdC5zZWxlY3RwaWNrZXIua2V5ZG93bi5rZXlIaXN0b3J5O1xcclxcblxcclxcbiAgICAgICAgLy8gaWYgYWxsIGxldHRlcnMgYXJlIHRoZSBzYW1lLCBzZXQga2V5SGlzdG9yeSB0byBqdXN0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgd2hlbiBzZWFyY2hpbmdcXHJcXG4gICAgICAgIGlmICgvXiguKVxcXFwxKyQvLnRlc3Qoa2V5SGlzdG9yeSkpIHtcXHJcXG4gICAgICAgICAga2V5SGlzdG9yeSA9IGtleUhpc3RvcnkuY2hhckF0KDApO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gZmluZCBtYXRjaGVzXFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICB2YXIgbGkgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaV0sXFxyXFxuICAgICAgICAgICAgICBoYXNNYXRjaDtcXHJcXG5cXHJcXG4gICAgICAgICAgaGFzTWF0Y2ggPSBzdHJpbmdTZWFyY2gobGksIGtleUhpc3RvcnksICdzdGFydHNXaXRoJywgdHJ1ZSk7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChoYXNNYXRjaCAmJiB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodFtpXSkge1xcclxcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChsaS5pbmRleCk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCkge1xcclxcbiAgICAgICAgICB2YXIgbWF0Y2hJbmRleCA9IDA7XFxyXFxuXFxyXFxuICAgICAgICAgICRpdGVtcy5yZW1vdmVDbGFzcygnYWN0aXZlJykuZmluZCgnYScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgLy8gZWl0aGVyIG9ubHkgb25lIGtleSBoYXMgYmVlbiBwcmVzc2VkIG9yIHRoZXkgYXJlIGFsbCB0aGUgc2FtZSBrZXlcXHJcXG4gICAgICAgICAgaWYgKGtleUhpc3RvcnkubGVuZ3RoID09PSAxKSB7XFxyXFxuICAgICAgICAgICAgbWF0Y2hJbmRleCA9IG1hdGNoZXMuaW5kZXhPZih0aGF0LmFjdGl2ZUluZGV4KTtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAobWF0Y2hJbmRleCA9PT0gLTEgfHwgbWF0Y2hJbmRleCA9PT0gbWF0Y2hlcy5sZW5ndGggLSAxKSB7XFxyXFxuICAgICAgICAgICAgICBtYXRjaEluZGV4ID0gMDtcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgbWF0Y2hJbmRleCsrO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICBzZWFyY2hNYXRjaCA9IG1hdGNoZXNbbWF0Y2hJbmRleF07XFxyXFxuXFxyXFxuICAgICAgICAgIGFjdGl2ZUxpID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW3NlYXJjaE1hdGNoXTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKHNjcm9sbFRvcCAtIGFjdGl2ZUxpLnBvc2l0aW9uID4gMCkge1xcclxcbiAgICAgICAgICAgIG9mZnNldCA9IGFjdGl2ZUxpLnBvc2l0aW9uIC0gYWN0aXZlTGkuaGVpZ2h0O1xcclxcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbCA9IHRydWU7XFxyXFxuICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgb2Zmc2V0ID0gYWN0aXZlTGkucG9zaXRpb24gLSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodDtcXHJcXG4gICAgICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIGlzIGFscmVhZHkgdmlzaWJsZSBhdCB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24sIGp1c3Qga2VlcCBpdCB0aGUgc2FtZVxcclxcbiAgICAgICAgICAgIHVwZGF0ZVNjcm9sbCA9IGFjdGl2ZUxpLnBvc2l0aW9uID4gc2Nyb2xsVG9wICsgdGhhdC5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQ7XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgbGlBY3RpdmUgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzW3NlYXJjaE1hdGNoXTtcXHJcXG5cXHJcXG4gICAgICAgICAgdGhhdC5hY3RpdmVJbmRleCA9IG1hdGNoZXNbbWF0Y2hJbmRleF07XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuZm9jdXNJdGVtKGxpQWN0aXZlKTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKGxpQWN0aXZlKSBsaUFjdGl2ZS5maXJzdENoaWxkLmZvY3VzKCk7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICh1cGRhdGVTY3JvbGwpIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSBvZmZzZXQ7XFxyXFxuXFxyXFxuICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIC8vIFNlbGVjdCBmb2N1c2VkIG9wdGlvbiBpZiBcXFwiRW50ZXJcXFwiLCBcXFwiU3BhY2ViYXJcXFwiIG9yIFxcXCJUYWJcXFwiICh3aGVuIHNlbGVjdE9uVGFiIGlzIHRydWUpIGFyZSBwcmVzc2VkIGluc2lkZSB0aGUgbWVudS5cXHJcXG4gICAgICBpZiAoXFxyXFxuICAgICAgICBpc0FjdGl2ZSAmJlxcclxcbiAgICAgICAgKFxcclxcbiAgICAgICAgICAoZS53aGljaCA9PT0ga2V5Q29kZXMuU1BBQ0UgJiYgIXRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeSkgfHxcXHJcXG4gICAgICAgICAgZS53aGljaCA9PT0ga2V5Q29kZXMuRU5URVIgfHxcXHJcXG4gICAgICAgICAgKGUud2hpY2ggPT09IGtleUNvZGVzLlRBQiAmJiB0aGF0Lm9wdGlvbnMuc2VsZWN0T25UYWIpXFxyXFxuICAgICAgICApXFxyXFxuICAgICAgKSB7XFxyXFxuICAgICAgICBpZiAoZS53aGljaCAhPT0ga2V5Q29kZXMuU1BBQ0UpIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmICghdGhhdC5vcHRpb25zLmxpdmVTZWFyY2ggfHwgZS53aGljaCAhPT0ga2V5Q29kZXMuU1BBQ0UpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyLmZpbmQoJy5hY3RpdmUgYScpLnRyaWdnZXIoJ2NsaWNrJywgdHJ1ZSk7IC8vIHJldGFpbiBhY3RpdmUgY2xhc3NcXHJcXG4gICAgICAgICAgJHRoaXMudHJpZ2dlcignZm9jdXMnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2NyZWVuIGZyb20gc2Nyb2xsaW5nIGlmIHRoZSB1c2VyIGhpdHMgdGhlIHNwYWNlYmFyXFxyXFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcbiAgICAgICAgICAgIC8vIEZpeGVzIHNwYWNlYmFyIHNlbGVjdGlvbiBvZiBkcm9wZG93biBpdGVtcyBpbiBGRiAmIElFXFxyXFxuICAgICAgICAgICAgJChkb2N1bWVudCkuZGF0YSgnc3BhY2VTZWxlY3QnLCB0cnVlKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgbW9iaWxlOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgLy8gZW5zdXJlIG1vYmlsZSBpcyBzZXQgdG8gdHJ1ZSBpZiBtb2JpbGUgZnVuY3Rpb24gaXMgY2FsbGVkIGFmdGVyIGluaXRcXHJcXG4gICAgICB0aGlzLm9wdGlvbnMubW9iaWxlID0gdHJ1ZTtcXHJcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTGlzdC5hZGQoJ21vYmlsZS1kZXZpY2UnKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIC8vIHVwZGF0ZSBvcHRpb25zIGlmIGRhdGEgYXR0cmlidXRlcyBoYXZlIGJlZW4gY2hhbmdlZFxcclxcbiAgICAgIHZhciBjb25maWcgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCB0aGlzLiRlbGVtZW50LmRhdGEoKSk7XFxyXFxuICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnO1xcclxcblxcclxcbiAgICAgIHRoaXMuY2hlY2tEaXNhYmxlZCgpO1xcclxcbiAgICAgIHRoaXMuYnVpbGREYXRhKCk7XFxyXFxuICAgICAgdGhpcy5zZXRTdHlsZSgpO1xcclxcbiAgICAgIHRoaXMucmVuZGVyKCk7XFxyXFxuICAgICAgdGhpcy5idWlsZExpc3QoKTtcXHJcXG4gICAgICB0aGlzLnNldFdpZHRoKCk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zZXRTaXplKHRydWUpO1xcclxcblxcclxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncmVmcmVzaGVkJyArIEVWRU5UX0tFWSk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50LmhpZGUoKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgc2hvdzogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHRoaXMuJG5ld0VsZW1lbnQuc2hvdygpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50LnJlbW92ZSgpO1xcclxcbiAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlKCk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50LmJlZm9yZSh0aGlzLiRlbGVtZW50KS5yZW1vdmUoKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy4kYnNDb250YWluZXIpIHtcXHJcXG4gICAgICAgIHRoaXMuJGJzQ29udGFpbmVyLnJlbW92ZSgpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICB0aGlzLiRtZW51LnJlbW92ZSgpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbiAmJiB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLnBhcmVudE5vZGUpIHtcXHJcXG4gICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kZWxlbWVudFxcclxcbiAgICAgICAgLm9mZihFVkVOVF9LRVkpXFxyXFxuICAgICAgICAucmVtb3ZlRGF0YSgnc2VsZWN0cGlja2VyJylcXHJcXG4gICAgICAgIC5yZW1vdmVDbGFzcygnYnMtc2VsZWN0LWhpZGRlbiBzZWxlY3RwaWNrZXInKTtcXHJcXG5cXHJcXG4gICAgICAkKHdpbmRvdykub2ZmKEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQpO1xcclxcbiAgICB9XFxyXFxuICB9O1xcclxcblxcclxcbiAgLy8gU0VMRUNUUElDS0VSIFBMVUdJTiBERUZJTklUSU9OXFxyXFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cXHJcXG4gIGZ1bmN0aW9uIFBsdWdpbiAob3B0aW9uKSB7XFxyXFxuICAgIC8vIGdldCB0aGUgYXJncyBvZiB0aGUgb3V0ZXIgZnVuY3Rpb24uLlxcclxcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcXHJcXG4gICAgLy8gVGhlIGFyZ3VtZW50cyBvZiB0aGUgZnVuY3Rpb24gYXJlIGV4cGxpY2l0bHkgcmUtZGVmaW5lZCBmcm9tIHRoZSBhcmd1bWVudCBsaXN0LCBiZWNhdXNlIHRoZSBzaGlmdCBjYXVzZXMgdGhlbVxcclxcbiAgICAvLyB0byBnZXQgbG9zdC9jb3JydXB0ZWQgaW4gYW5kcm9pZCAyLjMgYW5kIElFOSAjNzE1ICM3NzVcXHJcXG4gICAgdmFyIF9vcHRpb24gPSBvcHRpb247XFxyXFxuXFxyXFxuICAgIFtdLnNoaWZ0LmFwcGx5KGFyZ3MpO1xcclxcblxcclxcbiAgICAvLyBpZiB0aGUgdmVyc2lvbiB3YXMgbm90IHNldCBzdWNjZXNzZnVsbHlcXHJcXG4gICAgaWYgKCF2ZXJzaW9uLnN1Y2Nlc3MpIHtcXHJcXG4gICAgICAvLyB0cnkgdG8gcmV0cmVpdmUgaXQgYWdhaW5cXHJcXG4gICAgICB0cnkge1xcclxcbiAgICAgICAgdmVyc2lvbi5mdWxsID0gKCQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuVkVSU0lPTiB8fCAnJykuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpO1xcclxcbiAgICAgIH0gY2F0Y2ggKGVycikge1xcclxcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHVzZSBCb290c3RyYXBWZXJzaW9uIGlmIHNldFxcclxcbiAgICAgICAgaWYgKFNlbGVjdHBpY2tlci5Cb290c3RyYXBWZXJzaW9uKSB7XFxyXFxuICAgICAgICAgIHZlcnNpb24uZnVsbCA9IFNlbGVjdHBpY2tlci5Cb290c3RyYXBWZXJzaW9uLnNwbGl0KCcgJylbMF0uc3BsaXQoJy4nKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHZlcnNpb24uZnVsbCA9IFt2ZXJzaW9uLm1ham9yLCAnMCcsICcwJ107XFxyXFxuXFxyXFxuICAgICAgICAgIGNvbnNvbGUud2FybihcXHJcXG4gICAgICAgICAgICAnVGhlcmUgd2FzIGFuIGlzc3VlIHJldHJpZXZpbmcgQm9vdHN0cmFwXFxcXCdzIHZlcnNpb24uICcgK1xcclxcbiAgICAgICAgICAgICdFbnN1cmUgQm9vdHN0cmFwIGlzIGJlaW5nIGxvYWRlZCBiZWZvcmUgYm9vdHN0cmFwLXNlbGVjdCBhbmQgdGhlcmUgaXMgbm8gbmFtZXNwYWNlIGNvbGxpc2lvbi4gJyArXFxyXFxuICAgICAgICAgICAgJ0lmIGxvYWRpbmcgQm9vdHN0cmFwIGFzeW5jaHJvbm91c2x5LCB0aGUgdmVyc2lvbiBtYXkgbmVlZCB0byBiZSBtYW51YWxseSBzcGVjaWZpZWQgdmlhICQuZm4uc2VsZWN0cGlja2VyLkNvbnN0cnVjdG9yLkJvb3RzdHJhcFZlcnNpb24uJyxcXHJcXG4gICAgICAgICAgICBlcnJcXHJcXG4gICAgICAgICAgKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdmVyc2lvbi5tYWpvciA9IHZlcnNpb24uZnVsbFswXTtcXHJcXG4gICAgICB2ZXJzaW9uLnN1Y2Nlc3MgPSB0cnVlO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGlmICh2ZXJzaW9uLm1ham9yID09PSAnNCcpIHtcXHJcXG4gICAgICAvLyBzb21lIGRlZmF1bHRzIG5lZWQgdG8gYmUgY2hhbmdlZCBpZiB1c2luZyBCb290c3RyYXAgNFxcclxcbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGV5IGhhdmUgYWxyZWFkeSBiZWVuIG1hbnVhbGx5IGNoYW5nZWQgYmVmb3JlIGZvcmNpbmcgdGhlbSB0byB1cGRhdGVcXHJcXG4gICAgICB2YXIgdG9VcGRhdGUgPSBbXTtcXHJcXG5cXHJcXG4gICAgICBpZiAoU2VsZWN0cGlja2VyLkRFRkFVTFRTLnN0eWxlID09PSBjbGFzc05hbWVzLkJVVFRPTkNMQVNTKSB0b1VwZGF0ZS5wdXNoKHsgbmFtZTogJ3N0eWxlJywgY2xhc3NOYW1lOiAnQlVUVE9OQ0xBU1MnIH0pO1xcclxcbiAgICAgIGlmIChTZWxlY3RwaWNrZXIuREVGQVVMVFMuaWNvbkJhc2UgPT09IGNsYXNzTmFtZXMuSUNPTkJBU0UpIHRvVXBkYXRlLnB1c2goeyBuYW1lOiAnaWNvbkJhc2UnLCBjbGFzc05hbWU6ICdJQ09OQkFTRScgfSk7XFxyXFxuICAgICAgaWYgKFNlbGVjdHBpY2tlci5ERUZBVUxUUy50aWNrSWNvbiA9PT0gY2xhc3NOYW1lcy5USUNLSUNPTikgdG9VcGRhdGUucHVzaCh7IG5hbWU6ICd0aWNrSWNvbicsIGNsYXNzTmFtZTogJ1RJQ0tJQ09OJyB9KTtcXHJcXG5cXHJcXG4gICAgICBjbGFzc05hbWVzLkRJVklERVIgPSAnZHJvcGRvd24tZGl2aWRlcic7XFxyXFxuICAgICAgY2xhc3NOYW1lcy5TSE9XID0gJ3Nob3cnO1xcclxcbiAgICAgIGNsYXNzTmFtZXMuQlVUVE9OQ0xBU1MgPSAnYnRuLWxpZ2h0JztcXHJcXG4gICAgICBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgPSAncG9wb3Zlci1oZWFkZXInO1xcclxcbiAgICAgIGNsYXNzTmFtZXMuSUNPTkJBU0UgPSAnJztcXHJcXG4gICAgICBjbGFzc05hbWVzLlRJQ0tJQ09OID0gJ2JzLW9rLWRlZmF1bHQnO1xcclxcblxcclxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9VcGRhdGUubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgIHZhciBvcHRpb24gPSB0b1VwZGF0ZVtpXTtcXHJcXG4gICAgICAgIFNlbGVjdHBpY2tlci5ERUZBVUxUU1tvcHRpb24ubmFtZV0gPSBjbGFzc05hbWVzW29wdGlvbi5jbGFzc05hbWVdO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfVxcclxcblxcclxcbiAgICB2YXIgdmFsdWU7XFxyXFxuICAgIHZhciBjaGFpbiA9IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcXHJcXG4gICAgICBpZiAoJHRoaXMuaXMoJ3NlbGVjdCcpKSB7XFxyXFxuICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoJ3NlbGVjdHBpY2tlcicpLFxcclxcbiAgICAgICAgICAgIG9wdGlvbnMgPSB0eXBlb2YgX29wdGlvbiA9PSAnb2JqZWN0JyAmJiBfb3B0aW9uO1xcclxcblxcclxcbiAgICAgICAgaWYgKCFkYXRhKSB7XFxyXFxuICAgICAgICAgIHZhciBkYXRhQXR0cmlidXRlcyA9ICR0aGlzLmRhdGEoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgZm9yICh2YXIgZGF0YUF0dHIgaW4gZGF0YUF0dHJpYnV0ZXMpIHtcXHJcXG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFBdHRyaWJ1dGVzLCBkYXRhQXR0cikgJiYgJC5pbkFycmF5KGRhdGFBdHRyLCBESVNBTExPV0VEX0FUVFJJQlVURVMpICE9PSAtMSkge1xcclxcbiAgICAgICAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyXTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgdmFyIGNvbmZpZyA9ICQuZXh0ZW5kKHt9LCBTZWxlY3RwaWNrZXIuREVGQVVMVFMsICQuZm4uc2VsZWN0cGlja2VyLmRlZmF1bHRzIHx8IHt9LCBkYXRhQXR0cmlidXRlcywgb3B0aW9ucyk7XFxyXFxuICAgICAgICAgIGNvbmZpZy50ZW1wbGF0ZSA9ICQuZXh0ZW5kKHt9LCBTZWxlY3RwaWNrZXIuREVGQVVMVFMudGVtcGxhdGUsICgkLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cyA/ICQuZm4uc2VsZWN0cGlja2VyLmRlZmF1bHRzLnRlbXBsYXRlIDoge30pLCBkYXRhQXR0cmlidXRlcy50ZW1wbGF0ZSwgb3B0aW9ucy50ZW1wbGF0ZSk7XFxyXFxuICAgICAgICAgICR0aGlzLmRhdGEoJ3NlbGVjdHBpY2tlcicsIChkYXRhID0gbmV3IFNlbGVjdHBpY2tlcih0aGlzLCBjb25maWcpKSk7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcXHJcXG4gICAgICAgICAgZm9yICh2YXIgaSBpbiBvcHRpb25zKSB7XFxyXFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBpKSkge1xcclxcbiAgICAgICAgICAgICAgZGF0YS5vcHRpb25zW2ldID0gb3B0aW9uc1tpXTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmICh0eXBlb2YgX29wdGlvbiA9PSAnc3RyaW5nJykge1xcclxcbiAgICAgICAgICBpZiAoZGF0YVtfb3B0aW9uXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XFxyXFxuICAgICAgICAgICAgdmFsdWUgPSBkYXRhW19vcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xcclxcbiAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YS5vcHRpb25zW19vcHRpb25dO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9KTtcXHJcXG5cXHJcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXHJcXG4gICAgICAvLyBub2luc3BlY3Rpb24gSlNVbnVzZWRBc3NpZ25tZW50XFxyXFxuICAgICAgcmV0dXJuIHZhbHVlO1xcclxcbiAgICB9IGVsc2Uge1xcclxcbiAgICAgIHJldHVybiBjaGFpbjtcXHJcXG4gICAgfVxcclxcbiAgfVxcclxcblxcclxcbiAgdmFyIG9sZCA9ICQuZm4uc2VsZWN0cGlja2VyO1xcclxcbiAgJC5mbi5zZWxlY3RwaWNrZXIgPSBQbHVnaW47XFxyXFxuICAkLmZuLnNlbGVjdHBpY2tlci5Db25zdHJ1Y3RvciA9IFNlbGVjdHBpY2tlcjtcXHJcXG5cXHJcXG4gIC8vIFNFTEVDVFBJQ0tFUiBOTyBDT05GTElDVFxcclxcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuICAkLmZuLnNlbGVjdHBpY2tlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAkLmZuLnNlbGVjdHBpY2tlciA9IG9sZDtcXHJcXG4gICAgcmV0dXJuIHRoaXM7XFxyXFxuICB9O1xcclxcblxcclxcbiAgLy8gZ2V0IEJvb3RzdHJhcCdzIGtleWRvd24gZXZlbnQgaGFuZGxlciBmb3IgZWl0aGVyIEJvb3RzdHJhcCA0IG9yIEJvb3RzdHJhcCAzXFxyXFxuICBmdW5jdGlvbiBrZXlkb3duSGFuZGxlciAoKSB7XFxyXFxuICAgIGlmICgkLmZuLmRyb3Bkb3duKSB7XFxyXFxuICAgICAgLy8gd2FpdCB0byBkZWZpbmUgdW50aWwgZnVuY3Rpb24gaXMgY2FsbGVkIGluIGNhc2UgQm9vdHN0cmFwIGlzbid0IGxvYWRlZCB5ZXRcXHJcXG4gICAgICB2YXIgYm9vdHN0cmFwS2V5ZG93biA9ICQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuX2RhdGFBcGlLZXlkb3duSGFuZGxlciB8fCAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLnByb3RvdHlwZS5rZXlkb3duO1xcclxcbiAgICAgIHJldHVybiBib290c3RyYXBLZXlkb3duLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gICQoZG9jdW1lbnQpXFxyXFxuICAgIC5vZmYoJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknKVxcclxcbiAgICAub24oJ2tleWRvd24uYnMuZHJvcGRvd24uZGF0YS1hcGknLCAnOm5vdCguYm9vdHN0cmFwLXNlbGVjdCkgPiBbZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIl0nLCBrZXlkb3duSGFuZGxlcilcXHJcXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJzpub3QoLmJvb3RzdHJhcC1zZWxlY3QpID4gLmRyb3Bkb3duLW1lbnUnLCBrZXlkb3duSGFuZGxlcilcXHJcXG4gICAgLm9uKCdrZXlkb3duJyArIEVWRU5UX0tFWSwgJy5ib290c3RyYXAtc2VsZWN0IFtkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiXSwgLmJvb3RzdHJhcC1zZWxlY3QgW3JvbGU9XFxcImxpc3Rib3hcXFwiXSwgLmJvb3RzdHJhcC1zZWxlY3QgLmJzLXNlYXJjaGJveCBpbnB1dCcsIFNlbGVjdHBpY2tlci5wcm90b3R5cGUua2V5ZG93bilcXHJcXG4gICAgLm9uKCdmb2N1c2luLm1vZGFsJywgJy5ib290c3RyYXAtc2VsZWN0IFtkYXRhLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiXSwgLmJvb3RzdHJhcC1zZWxlY3QgW3JvbGU9XFxcImxpc3Rib3hcXFwiXSwgLmJvb3RzdHJhcC1zZWxlY3QgLmJzLXNlYXJjaGJveCBpbnB1dCcsIGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXHJcXG4gICAgfSk7XFxyXFxuXFxyXFxuICAvLyBTRUxFQ1RQSUNLRVIgREFUQS1BUElcXHJcXG4gIC8vID09PT09PT09PT09PT09PT09PT09PVxcclxcbiAgJCh3aW5kb3cpLm9uKCdsb2FkJyArIEVWRU5UX0tFWSArICcuZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICQoJy5zZWxlY3RwaWNrZXInKS5lYWNoKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB2YXIgJHNlbGVjdHBpY2tlciA9ICQodGhpcyk7XFxyXFxuICAgICAgUGx1Z2luLmNhbGwoJHNlbGVjdHBpY2tlciwgJHNlbGVjdHBpY2tlci5kYXRhKCkpO1xcclxcbiAgICB9KVxcclxcbiAgfSk7XFxyXFxufSkoalF1ZXJ5KTtcXHJcXG5cXHJcXG5cXHJcXG59KSk7XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICAqIEJvb3RzdHJhcCB2NS4yLjAgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXFxuICAqIENvcHlyaWdodCAyMDExLTIwMjIgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAqL1xcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XFxuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnQHBvcHBlcmpzL2NvcmUnKSkgOlxcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnQHBvcHBlcmpzL2NvcmUnXSwgZmFjdG9yeSkgOlxcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmJvb3RzdHJhcCA9IGZhY3RvcnkoZ2xvYmFsLlBvcHBlcikpO1xcbn0pKHRoaXMsIChmdW5jdGlvbiAoUG9wcGVyKSB7ICd1c2Ugc3RyaWN0JztcXG5cXG4gIGZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcXG4gICAgaWYgKGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcXG4gICAgY29uc3QgbiA9IE9iamVjdC5jcmVhdGUobnVsbCwgeyBbU3ltYm9sLnRvU3RyaW5nVGFnXTogeyB2YWx1ZTogJ01vZHVsZScgfSB9KTtcXG4gICAgaWYgKGUpIHtcXG4gICAgICBmb3IgKGNvbnN0IGsgaW4gZSkge1xcbiAgICAgICAgaWYgKGsgIT09ICdkZWZhdWx0Jykge1xcbiAgICAgICAgICBjb25zdCBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBrKTtcXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgICAgICAgIGdldDogKCkgPT4gZVtrXVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgbi5kZWZhdWx0ID0gZTtcXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XFxuICB9XFxuXFxuICBjb25zdCBQb3BwZXJfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZShQb3BwZXIpO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL2luZGV4LmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIGNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xcbiAgY29uc3QgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwO1xcbiAgY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7IC8vIFNob3V0LW91dCBBbmd1cyBDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxcblxcbiAgY29uc3QgdG9UeXBlID0gb2JqZWN0ID0+IHtcXG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybiBgJHtvYmplY3R9YDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkubWF0Y2goL1xcXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcXG4gIH07XFxuICAvKipcXG4gICAqIFB1YmxpYyBVdGlsIEFQSVxcbiAgICovXFxuXFxuXFxuICBjb25zdCBnZXRVSUQgPSBwcmVmaXggPT4ge1xcbiAgICBkbyB7XFxuICAgICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xcbiAgICB9IHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKTtcXG5cXG4gICAgcmV0dXJuIHByZWZpeDtcXG4gIH07XFxuXFxuICBjb25zdCBnZXRTZWxlY3RvciA9IGVsZW1lbnQgPT4ge1xcbiAgICBsZXQgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy10YXJnZXQnKTtcXG5cXG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XFxuICAgICAgbGV0IGhyZWZBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpOyAvLyBUaGUgb25seSB2YWxpZCBjb250ZW50IHRoYXQgY291bGQgZG91YmxlIGFzIGEgc2VsZWN0b3IgYXJlIElEcyBvciBjbGFzc2VzLFxcbiAgICAgIC8vIHNvIGV2ZXJ5dGhpbmcgc3RhcnRpbmcgd2l0aCBgI2Agb3IgYC5gLiBJZiBhIFxcXCJyZWFsXFxcIiBVUkwgaXMgdXNlZCBhcyB0aGUgc2VsZWN0b3IsXFxuICAgICAgLy8gYGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JgIHdpbGwgcmlnaHRmdWxseSBjb21wbGFpbiBpdCBpcyBpbnZhbGlkLlxcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzMyMjczXFxuXFxuICAgICAgaWYgKCFocmVmQXR0cmlidXRlIHx8ICFocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnLicpKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9IC8vIEp1c3QgaW4gY2FzZSBzb21lIENNUyBwdXRzIG91dCBhIGZ1bGwgVVJMIHdpdGggdGhlIGFuY2hvciBhcHBlbmRlZFxcblxcblxcbiAgICAgIGlmIChocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnIycpKSB7XFxuICAgICAgICBocmVmQXR0cmlidXRlID0gYCMke2hyZWZBdHRyaWJ1dGUuc3BsaXQoJyMnKVsxXX1gO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWxlY3RvciA9IGhyZWZBdHRyaWJ1dGUgJiYgaHJlZkF0dHJpYnV0ZSAhPT0gJyMnID8gaHJlZkF0dHJpYnV0ZS50cmltKCkgOiBudWxsO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBzZWxlY3RvcjtcXG4gIH07XFxuXFxuICBjb25zdCBnZXRTZWxlY3RvckZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XFxuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XFxuXFxuICAgIGlmIChzZWxlY3Rvcikge1xcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH07XFxuXFxuICBjb25zdCBnZXRFbGVtZW50RnJvbVNlbGVjdG9yID0gZWxlbWVudCA9PiB7XFxuICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XFxuICAgIHJldHVybiBzZWxlY3RvciA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIDogbnVsbDtcXG4gIH07XFxuXFxuICBjb25zdCBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xcbiAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfSAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxcblxcblxcbiAgICBsZXQge1xcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbixcXG4gICAgICB0cmFuc2l0aW9uRGVsYXlcXG4gICAgfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XFxuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTsgLy8gUmV0dXJuIDAgaWYgZWxlbWVudCBvciB0cmFuc2l0aW9uIGR1cmF0aW9uIGlzIG5vdCBmb3VuZFxcblxcbiAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9IC8vIElmIG11bHRpcGxlIGR1cmF0aW9ucyBhcmUgZGVmaW5lZCwgdGFrZSB0aGUgZmlyc3RcXG5cXG5cXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdHJhbnNpdGlvbkR1cmF0aW9uLnNwbGl0KCcsJylbMF07XFxuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xcbiAgICByZXR1cm4gKE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbikgKyBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpKSAqIE1JTExJU0VDT05EU19NVUxUSVBMSUVSO1xcbiAgfTtcXG5cXG4gIGNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XFxuICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoVFJBTlNJVElPTl9FTkQpKTtcXG4gIH07XFxuXFxuICBjb25zdCBpc0VsZW1lbnQgPSBvYmplY3QgPT4ge1xcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIG9iamVjdC5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgb2JqZWN0ID0gb2JqZWN0WzBdO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlICE9PSAndW5kZWZpbmVkJztcXG4gIH07XFxuXFxuICBjb25zdCBnZXRFbGVtZW50ID0gb2JqZWN0ID0+IHtcXG4gICAgLy8gaXQncyBhIGpRdWVyeSBvYmplY3Qgb3IgYSBub2RlIGVsZW1lbnRcXG4gICAgaWYgKGlzRWxlbWVudChvYmplY3QpKSB7XFxuICAgICAgcmV0dXJuIG9iamVjdC5qcXVlcnkgPyBvYmplY3RbMF0gOiBvYmplY3Q7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XFxuICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iob2JqZWN0KTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbnVsbDtcXG4gIH07XFxuXFxuICBjb25zdCBpc1Zpc2libGUgPSBlbGVtZW50ID0+IHtcXG4gICAgaWYgKCFpc0VsZW1lbnQoZWxlbWVudCkgfHwgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBlbGVtZW50SXNWaXNpYmxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCd2aXNpYmlsaXR5JykgPT09ICd2aXNpYmxlJzsgLy8gSGFuZGxlIGBkZXRhaWxzYCBlbGVtZW50IGFzIGl0cyBjb250ZW50IG1heSBmYWxzaWUgYXBwZWFyIHZpc2libGUgd2hlbiBpdCBpcyBjbG9zZWRcXG5cXG4gICAgY29uc3QgY2xvc2VkRGV0YWlscyA9IGVsZW1lbnQuY2xvc2VzdCgnZGV0YWlsczpub3QoW29wZW5dKScpO1xcblxcbiAgICBpZiAoIWNsb3NlZERldGFpbHMpIHtcXG4gICAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcXG4gICAgfVxcblxcbiAgICBpZiAoY2xvc2VkRGV0YWlscyAhPT0gZWxlbWVudCkge1xcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBlbGVtZW50LmNsb3Nlc3QoJ3N1bW1hcnknKTtcXG5cXG4gICAgICBpZiAoc3VtbWFyeSAmJiBzdW1tYXJ5LnBhcmVudE5vZGUgIT09IGNsb3NlZERldGFpbHMpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHN1bW1hcnkgPT09IG51bGwpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XFxuICB9O1xcblxcbiAgY29uc3QgaXNEaXNhYmxlZCA9IGVsZW1lbnQgPT4ge1xcbiAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZGlzYWJsZWQgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXNhYmxlZCcpICE9PSAnZmFsc2UnO1xcbiAgfTtcXG5cXG4gIGNvbnN0IGZpbmRTaGFkb3dSb290ID0gZWxlbWVudCA9PiB7XFxuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmF0dGFjaFNoYWRvdykge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9IC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxcblxcblxcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpO1xcbiAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xcbiAgICB9XFxuXFxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xcbiAgICAgIHJldHVybiBlbGVtZW50O1xcbiAgICB9IC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XFxuXFxuXFxuICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZpbmRTaGFkb3dSb290KGVsZW1lbnQucGFyZW50Tm9kZSk7XFxuICB9O1xcblxcbiAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xcbiAgLyoqXFxuICAgKiBUcmljayB0byByZXN0YXJ0IGFuIGVsZW1lbnQncyBhbmltYXRpb25cXG4gICAqXFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XFxuICAgKiBAcmV0dXJuIHZvaWRcXG4gICAqXFxuICAgKiBAc2VlIGh0dHBzOi8vd3d3LmNoYXJpc3RoZW8uaW8vYmxvZy8yMDIxLzAyL3Jlc3RhcnQtYS1jc3MtYW5pbWF0aW9uLXdpdGgtamF2YXNjcmlwdC8jcmVzdGFydGluZy1hLWNzcy1hbmltYXRpb25cXG4gICAqL1xcblxcblxcbiAgY29uc3QgcmVmbG93ID0gZWxlbWVudCA9PiB7XFxuICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xcbiAgfTtcXG5cXG4gIGNvbnN0IGdldGpRdWVyeSA9ICgpID0+IHtcXG4gICAgaWYgKHdpbmRvdy5qUXVlcnkgJiYgIWRvY3VtZW50LmJvZHkuaGFzQXR0cmlidXRlKCdkYXRhLWJzLW5vLWpxdWVyeScpKSB7XFxuICAgICAgcmV0dXJuIHdpbmRvdy5qUXVlcnk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcblxcbiAgY29uc3QgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcyA9IFtdO1xcblxcbiAgY29uc3Qgb25ET01Db250ZW50TG9hZGVkID0gY2FsbGJhY2sgPT4ge1xcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XFxuICAgICAgLy8gYWRkIGxpc3RlbmVyIG9uIHRoZSBmaXJzdCBjYWxsIHdoZW4gdGhlIGRvY3VtZW50IGlzIGluIGxvYWRpbmcgc3RhdGVcXG4gICAgICBpZiAoIURPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MubGVuZ3RoKSB7XFxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xcbiAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MpIHtcXG4gICAgICAgICAgICBjYWxsYmFjaygpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjYWxsYmFjaygpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgY29uc3QgaXNSVEwgPSAoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID09PSAncnRsJztcXG5cXG4gIGNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IHBsdWdpbiA9PiB7XFxuICAgIG9uRE9NQ29udGVudExvYWRlZCgoKSA9PiB7XFxuICAgICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xcblxcbiAgICAgIGlmICgkKSB7XFxuICAgICAgICBjb25zdCBuYW1lID0gcGx1Z2luLk5BTUU7XFxuICAgICAgICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW25hbWVdO1xcbiAgICAgICAgJC5mbltuYW1lXSA9IHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XFxuICAgICAgICAkLmZuW25hbWVdLkNvbnN0cnVjdG9yID0gcGx1Z2luO1xcblxcbiAgICAgICAgJC5mbltuYW1lXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xcbiAgICAgICAgICAkLmZuW25hbWVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xcbiAgICAgICAgICByZXR1cm4gcGx1Z2luLmpRdWVyeUludGVyZmFjZTtcXG4gICAgICAgIH07XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH07XFxuXFxuICBjb25zdCBleGVjdXRlID0gY2FsbGJhY2sgPT4ge1xcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgY2FsbGJhY2soKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIGNvbnN0IGV4ZWN1dGVBZnRlclRyYW5zaXRpb24gPSAoY2FsbGJhY2ssIHRyYW5zaXRpb25FbGVtZW50LCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHRydWUpID0+IHtcXG4gICAgaWYgKCF3YWl0Rm9yVHJhbnNpdGlvbikge1xcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCBkdXJhdGlvblBhZGRpbmcgPSA1O1xcbiAgICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodHJhbnNpdGlvbkVsZW1lbnQpICsgZHVyYXRpb25QYWRkaW5nO1xcbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XFxuXFxuICAgIGNvbnN0IGhhbmRsZXIgPSAoe1xcbiAgICAgIHRhcmdldFxcbiAgICB9KSA9PiB7XFxuICAgICAgaWYgKHRhcmdldCAhPT0gdHJhbnNpdGlvbkVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY2FsbGVkID0gdHJ1ZTtcXG4gICAgICB0cmFuc2l0aW9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcXG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgfTtcXG5cXG4gICAgdHJhbnNpdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgIGlmICghY2FsbGVkKSB7XFxuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRWxlbWVudCk7XFxuICAgICAgfVxcbiAgICB9LCBlbXVsYXRlZER1cmF0aW9uKTtcXG4gIH07XFxuICAvKipcXG4gICAqIFJldHVybiB0aGUgcHJldmlvdXMvbmV4dCBlbGVtZW50IG9mIGEgbGlzdC5cXG4gICAqXFxuICAgKiBAcGFyYW0ge2FycmF5fSBsaXN0ICAgIFRoZSBsaXN0IG9mIGVsZW1lbnRzXFxuICAgKiBAcGFyYW0gYWN0aXZlRWxlbWVudCAgIFRoZSBhY3RpdmUgZWxlbWVudFxcbiAgICogQHBhcmFtIHNob3VsZEdldE5leHQgICBDaG9vc2UgdG8gZ2V0IG5leHQgb3IgcHJldmlvdXMgZWxlbWVudFxcbiAgICogQHBhcmFtIGlzQ3ljbGVBbGxvd2VkXFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fGVsZW19IFRoZSBwcm9wZXIgZWxlbWVudFxcbiAgICovXFxuXFxuXFxuICBjb25zdCBnZXROZXh0QWN0aXZlRWxlbWVudCA9IChsaXN0LCBhY3RpdmVFbGVtZW50LCBzaG91bGRHZXROZXh0LCBpc0N5Y2xlQWxsb3dlZCkgPT4ge1xcbiAgICBjb25zdCBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XFxuICAgIGxldCBpbmRleCA9IGxpc3QuaW5kZXhPZihhY3RpdmVFbGVtZW50KTsgLy8gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3QgcmV0dXJuIGFuIGVsZW1lbnRcXG4gICAgLy8gZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb24gYW5kIGlmIGN5Y2xlIGlzIGFsbG93ZWRcXG5cXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xcbiAgICAgIHJldHVybiAhc2hvdWxkR2V0TmV4dCAmJiBpc0N5Y2xlQWxsb3dlZCA/IGxpc3RbbGlzdExlbmd0aCAtIDFdIDogbGlzdFswXTtcXG4gICAgfVxcblxcbiAgICBpbmRleCArPSBzaG91bGRHZXROZXh0ID8gMSA6IC0xO1xcblxcbiAgICBpZiAoaXNDeWNsZUFsbG93ZWQpIHtcXG4gICAgICBpbmRleCA9IChpbmRleCArIGxpc3RMZW5ndGgpICUgbGlzdExlbmd0aDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbGlzdFtNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbGlzdExlbmd0aCAtIDEpKV07XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBkb20vZXZlbnQtaGFuZGxlci5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBuYW1lc3BhY2VSZWdleCA9IC9bXi5dKig/PVxcXFwuLiopXFxcXC58LiovO1xcbiAgY29uc3Qgc3RyaXBOYW1lUmVnZXggPSAvXFxcXC4uKi87XFxuICBjb25zdCBzdHJpcFVpZFJlZ2V4ID0gLzo6XFxcXGQrJC87XFxuICBjb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXFxuXFxuICBsZXQgdWlkRXZlbnQgPSAxO1xcbiAgY29uc3QgY3VzdG9tRXZlbnRzID0ge1xcbiAgICBtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcXG4gICAgbW91c2VsZWF2ZTogJ21vdXNlb3V0J1xcbiAgfTtcXG4gIGNvbnN0IG5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdjb250ZXh0bWVudScsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnc2VsZWN0c3RhcnQnLCAnc2VsZWN0ZW5kJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJsZWF2ZScsICdwb2ludGVyY2FuY2VsJywgJ2dlc3R1cmVzdGFydCcsICdnZXN0dXJlY2hhbmdlJywgJ2dlc3R1cmVlbmQnLCAnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnLCAncmVzZXQnLCAnc2VsZWN0JywgJ3N1Ym1pdCcsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2xvYWQnLCAndW5sb2FkJywgJ2JlZm9yZXVubG9hZCcsICdyZXNpemUnLCAnbW92ZScsICdET01Db250ZW50TG9hZGVkJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAnZXJyb3InLCAnYWJvcnQnLCAnc2Nyb2xsJ10pO1xcbiAgLyoqXFxuICAgKiBQcml2YXRlIG1ldGhvZHNcXG4gICAqL1xcblxcbiAgZnVuY3Rpb24gbWFrZUV2ZW50VWlkKGVsZW1lbnQsIHVpZCkge1xcbiAgICByZXR1cm4gdWlkICYmIGAke3VpZH06OiR7dWlkRXZlbnQrK31gIHx8IGVsZW1lbnQudWlkRXZlbnQgfHwgdWlkRXZlbnQrKztcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCkge1xcbiAgICBjb25zdCB1aWQgPSBtYWtlRXZlbnRVaWQoZWxlbWVudCk7XFxuICAgIGVsZW1lbnQudWlkRXZlbnQgPSB1aWQ7XFxuICAgIGV2ZW50UmVnaXN0cnlbdWlkXSA9IGV2ZW50UmVnaXN0cnlbdWlkXSB8fCB7fTtcXG4gICAgcmV0dXJuIGV2ZW50UmVnaXN0cnlbdWlkXTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgZm4pIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcXG4gICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7XFxuICAgICAgICBkZWxlZ2F0ZVRhcmdldDogZWxlbWVudFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBmbik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmbi5hcHBseShlbGVtZW50LCBbZXZlbnRdKTtcXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIHNlbGVjdG9yLCBmbikge1xcbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xcbiAgICAgIGNvbnN0IGRvbUVsZW1lbnRzID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcXG5cXG4gICAgICBmb3IgKGxldCB7XFxuICAgICAgICB0YXJnZXRcXG4gICAgICB9ID0gZXZlbnQ7IHRhcmdldCAmJiB0YXJnZXQgIT09IHRoaXM7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XFxuICAgICAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9tRWxlbWVudHMpIHtcXG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQgIT09IHRhcmdldCkge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcXG4gICAgICAgICAgICBkZWxlZ2F0ZVRhcmdldDogdGFyZ2V0XFxuICAgICAgICAgIH0pO1xcblxcbiAgICAgICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcXG4gICAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIHNlbGVjdG9yLCBmbik7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRhcmdldCwgW2V2ZW50XSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gZmluZEhhbmRsZXIoZXZlbnRzLCBjYWxsYWJsZSwgZGVsZWdhdGlvblNlbGVjdG9yID0gbnVsbCkge1xcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhldmVudHMpLmZpbmQoZXZlbnQgPT4gZXZlbnQuY2FsbGFibGUgPT09IGNhbGxhYmxlICYmIGV2ZW50LmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZGVsZWdhdGlvblNlbGVjdG9yKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xcbiAgICBjb25zdCBpc0RlbGVnYXRlZCA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJzsgLy8gdG9kbzogdG9vbHRpcCBwYXNzZXMgYGZhbHNlYCBpbnN0ZWFkIG9mIHNlbGVjdG9yLCBzbyB3ZSBuZWVkIHRvIGNoZWNrXFxuXFxuICAgIGNvbnN0IGNhbGxhYmxlID0gaXNEZWxlZ2F0ZWQgPyBkZWxlZ2F0aW9uRnVuY3Rpb24gOiBoYW5kbGVyIHx8IGRlbGVnYXRpb25GdW5jdGlvbjtcXG4gICAgbGV0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChvcmlnaW5hbFR5cGVFdmVudCk7XFxuXFxuICAgIGlmICghbmF0aXZlRXZlbnRzLmhhcyh0eXBlRXZlbnQpKSB7XFxuICAgICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnQ7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIG9uZU9mZikge1xcbiAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBsZXQgW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbik7IC8vIGluIGNhc2Ugb2YgbW91c2VlbnRlciBvciBtb3VzZWxlYXZlIHdyYXAgdGhlIGhhbmRsZXIgd2l0aGluIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgZm9yIGl0cyBET00gcG9zaXRpb25cXG4gICAgLy8gdGhpcyBwcmV2ZW50cyB0aGUgaGFuZGxlciBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgdGhlIHNhbWUgd2F5IGFzIG1vdXNlb3ZlciBvciBtb3VzZW91dCBkb2VzXFxuXFxuICAgIGlmIChvcmlnaW5hbFR5cGVFdmVudCBpbiBjdXN0b21FdmVudHMpIHtcXG4gICAgICBjb25zdCB3cmFwRnVuY3Rpb24gPSBmbiA9PiB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0ICE9PSBldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiAhZXZlbnQuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcXG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH07XFxuICAgICAgfTtcXG5cXG4gICAgICBjYWxsYWJsZSA9IHdyYXBGdW5jdGlvbihjYWxsYWJsZSk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcXG4gICAgY29uc3QgaGFuZGxlcnMgPSBldmVudHNbdHlwZUV2ZW50XSB8fCAoZXZlbnRzW3R5cGVFdmVudF0gPSB7fSk7XFxuICAgIGNvbnN0IHByZXZpb3VzRnVuY3Rpb24gPSBmaW5kSGFuZGxlcihoYW5kbGVycywgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xcblxcbiAgICBpZiAocHJldmlvdXNGdW5jdGlvbikge1xcbiAgICAgIHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmID0gcHJldmlvdXNGdW5jdGlvbi5vbmVPZmYgJiYgb25lT2ZmO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjb25zdCB1aWQgPSBtYWtlRXZlbnRVaWQoY2FsbGFibGUsIG9yaWdpbmFsVHlwZUV2ZW50LnJlcGxhY2UobmFtZXNwYWNlUmVnZXgsICcnKSk7XFxuICAgIGNvbnN0IGZuID0gaXNEZWxlZ2F0ZWQgPyBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBjYWxsYWJsZSkgOiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGNhbGxhYmxlKTtcXG4gICAgZm4uZGVsZWdhdGlvblNlbGVjdG9yID0gaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbDtcXG4gICAgZm4uY2FsbGFibGUgPSBjYWxsYWJsZTtcXG4gICAgZm4ub25lT2ZmID0gb25lT2ZmO1xcbiAgICBmbi51aWRFdmVudCA9IHVpZDtcXG4gICAgaGFuZGxlcnNbdWlkXSA9IGZuO1xcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgaXNEZWxlZ2F0ZWQpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKSB7XFxuICAgIGNvbnN0IGZuID0gZmluZEhhbmRsZXIoZXZlbnRzW3R5cGVFdmVudF0sIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcik7XFxuXFxuICAgIGlmICghZm4pIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIEJvb2xlYW4oZGVsZWdhdGlvblNlbGVjdG9yKSk7XFxuICAgIGRlbGV0ZSBldmVudHNbdHlwZUV2ZW50XVtmbi51aWRFdmVudF07XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIG5hbWVzcGFjZSkge1xcbiAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xcblxcbiAgICBmb3IgKGNvbnN0IGhhbmRsZXJLZXkgb2YgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XFxuICAgICAgaWYgKGhhbmRsZXJLZXkuaW5jbHVkZXMobmFtZXNwYWNlKSkge1xcbiAgICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtoYW5kbGVyS2V5XTtcXG4gICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gZ2V0VHlwZUV2ZW50KGV2ZW50KSB7XFxuICAgIC8vIGFsbG93IHRvIGdldCB0aGUgbmF0aXZlIGV2ZW50cyBmcm9tIG5hbWVzcGFjZWQgZXZlbnRzICgnY2xpY2suYnMuYnV0dG9uJyAtLT4gJ2NsaWNrJylcXG4gICAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XFxuICAgIHJldHVybiBjdXN0b21FdmVudHNbZXZlbnRdIHx8IGV2ZW50O1xcbiAgfVxcblxcbiAgY29uc3QgRXZlbnRIYW5kbGVyID0ge1xcbiAgICBvbihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XFxuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBmYWxzZSk7XFxuICAgIH0sXFxuXFxuICAgIG9uZShlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XFxuICAgICAgYWRkSGFuZGxlcihlbGVtZW50LCBldmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCB0cnVlKTtcXG4gICAgfSxcXG5cXG4gICAgb2ZmKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcXG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVHlwZUV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdID0gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKTtcXG4gICAgICBjb25zdCBpbk5hbWVzcGFjZSA9IHR5cGVFdmVudCAhPT0gb3JpZ2luYWxUeXBlRXZlbnQ7XFxuICAgICAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcXG4gICAgICBjb25zdCBzdG9yZUVsZW1lbnRFdmVudCA9IGV2ZW50c1t0eXBlRXZlbnRdIHx8IHt9O1xcbiAgICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xcblxcbiAgICAgIGlmICh0eXBlb2YgY2FsbGFibGUgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAvLyBTaW1wbGVzdCBjYXNlOiBoYW5kbGVyIGlzIHBhc3NlZCwgcmVtb3ZlIHRoYXQgbGlzdGVuZXIgT05MWS5cXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmxlbmd0aCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc05hbWVzcGFjZSkge1xcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50RXZlbnQgb2YgT2JqZWN0LmtleXMoZXZlbnRzKSkge1xcbiAgICAgICAgICByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCBlbGVtZW50RXZlbnQsIG9yaWdpbmFsVHlwZUV2ZW50LnNsaWNlKDEpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChjb25zdCBrZXlIYW5kbGVycyBvZiBPYmplY3Qua2V5cyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcXG4gICAgICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBrZXlIYW5kbGVycy5yZXBsYWNlKHN0cmlwVWlkUmVnZXgsICcnKTtcXG5cXG4gICAgICAgIGlmICghaW5OYW1lc3BhY2UgfHwgb3JpZ2luYWxUeXBlRXZlbnQuaW5jbHVkZXMoaGFuZGxlcktleSkpIHtcXG4gICAgICAgICAgY29uc3QgZXZlbnQgPSBzdG9yZUVsZW1lbnRFdmVudFtrZXlIYW5kbGVyc107XFxuICAgICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgdHJpZ2dlcihlbGVtZW50LCBldmVudCwgYXJncykge1xcbiAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xcbiAgICAgIGNvbnN0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChldmVudCk7XFxuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSBldmVudCAhPT0gdHlwZUV2ZW50O1xcbiAgICAgIGxldCBqUXVlcnlFdmVudCA9IG51bGw7XFxuICAgICAgbGV0IGJ1YmJsZXMgPSB0cnVlO1xcbiAgICAgIGxldCBuYXRpdmVEaXNwYXRjaCA9IHRydWU7XFxuICAgICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcXG5cXG4gICAgICBpZiAoaW5OYW1lc3BhY2UgJiYgJCkge1xcbiAgICAgICAgalF1ZXJ5RXZlbnQgPSAkLkV2ZW50KGV2ZW50LCBhcmdzKTtcXG4gICAgICAgICQoZWxlbWVudCkudHJpZ2dlcihqUXVlcnlFdmVudCk7XFxuICAgICAgICBidWJibGVzID0gIWpRdWVyeUV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7XFxuICAgICAgICBuYXRpdmVEaXNwYXRjaCA9ICFqUXVlcnlFdmVudC5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpO1xcbiAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IGpRdWVyeUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgZXZ0ID0gbmV3IEV2ZW50KGV2ZW50LCB7XFxuICAgICAgICBidWJibGVzLFxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxcbiAgICAgIH0pO1xcbiAgICAgIGV2dCA9IGh5ZHJhdGVPYmooZXZ0LCBhcmdzKTtcXG5cXG4gICAgICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChuYXRpdmVEaXNwYXRjaCkge1xcbiAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChldnQuZGVmYXVsdFByZXZlbnRlZCAmJiBqUXVlcnlFdmVudCkge1xcbiAgICAgICAgalF1ZXJ5RXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGV2dDtcXG4gICAgfVxcblxcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIGh5ZHJhdGVPYmoob2JqLCBtZXRhKSB7XFxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGEgfHwge30pKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XFxuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG5cXG4gICAgICAgICAgZ2V0KCkge1xcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBvYmo7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IGRvbS9kYXRhLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG4gIGNvbnN0IGVsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XFxuICBjb25zdCBEYXRhID0ge1xcbiAgICBzZXQoZWxlbWVudCwga2V5LCBpbnN0YW5jZSkge1xcbiAgICAgIGlmICghZWxlbWVudE1hcC5oYXMoZWxlbWVudCkpIHtcXG4gICAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7IC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxcbiAgICAgIC8vIGNhbiBiZSByZW1vdmVkIGxhdGVyIHdoZW4gbXVsdGlwbGUga2V5L2luc3RhbmNlcyBhcmUgZmluZSB0byBiZSB1c2VkXFxuXFxuICAgICAgaWYgKCFpbnN0YW5jZU1hcC5oYXMoa2V5KSAmJiBpbnN0YW5jZU1hcC5zaXplICE9PSAwKSB7XFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxcbiAgICAgICAgY29uc29sZS5lcnJvcihgQm9vdHN0cmFwIGRvZXNuJ3QgYWxsb3cgbW9yZSB0aGFuIG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudC4gQm91bmQgaW5zdGFuY2U6ICR7QXJyYXkuZnJvbShpbnN0YW5jZU1hcC5rZXlzKCkpWzBdfS5gKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaW5zdGFuY2VNYXAuc2V0KGtleSwgaW5zdGFuY2UpO1xcbiAgICB9LFxcblxcbiAgICBnZXQoZWxlbWVudCwga2V5KSB7XFxuICAgICAgaWYgKGVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XFxuICAgICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0sXFxuXFxuICAgIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcXG4gICAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGluc3RhbmNlTWFwID0gZWxlbWVudE1hcC5nZXQoZWxlbWVudCk7XFxuICAgICAgaW5zdGFuY2VNYXAuZGVsZXRlKGtleSk7IC8vIGZyZWUgdXAgZWxlbWVudCByZWZlcmVuY2VzIGlmIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgbGVmdCBmb3IgYW4gZWxlbWVudFxcblxcbiAgICAgIGlmIChpbnN0YW5jZU1hcC5zaXplID09PSAwKSB7XFxuICAgICAgICBlbGVtZW50TWFwLmRlbGV0ZShlbGVtZW50KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gIH07XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IGRvbS9tYW5pcHVsYXRvci5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICBmdW5jdGlvbiBub3JtYWxpemVEYXRhKHZhbHVlKSB7XFxuICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyKHZhbHVlKS50b1N0cmluZygpKSB7XFxuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ251bGwnKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1cXG5cXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcXG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xcbiAgICAgIHJldHVybiB2YWx1ZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YUtleShrZXkpIHtcXG4gICAgcmV0dXJuIGtleS5yZXBsYWNlKC9bQS1aXS9nLCBjaHIgPT4gYC0ke2Noci50b0xvd2VyQ2FzZSgpfWApO1xcbiAgfVxcblxcbiAgY29uc3QgTWFuaXB1bGF0b3IgPSB7XFxuICAgIHNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGBkYXRhLWJzLSR7bm9ybWFsaXplRGF0YUtleShrZXkpfWAsIHZhbHVlKTtcXG4gICAgfSxcXG5cXG4gICAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcXG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKTtcXG4gICAgfSxcXG5cXG4gICAgZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkge1xcbiAgICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIHt9O1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBhdHRyaWJ1dGVzID0ge307XFxuICAgICAgY29uc3QgYnNLZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5kYXRhc2V0KS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdicycpICYmICFrZXkuc3RhcnRzV2l0aCgnYnNDb25maWcnKSk7XFxuXFxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYnNLZXlzKSB7XFxuICAgICAgICBsZXQgcHVyZUtleSA9IGtleS5yZXBsYWNlKC9eYnMvLCAnJyk7XFxuICAgICAgICBwdXJlS2V5ID0gcHVyZUtleS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHB1cmVLZXkuc2xpY2UoMSwgcHVyZUtleS5sZW5ndGgpO1xcbiAgICAgICAgYXR0cmlidXRlc1twdXJlS2V5XSA9IG5vcm1hbGl6ZURhdGEoZWxlbWVudC5kYXRhc2V0W2tleV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcXG4gICAgfSxcXG5cXG4gICAgZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcXG4gICAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSk7XFxuICAgIH1cXG5cXG4gIH07XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHV0aWwvY29uZmlnLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBDb25maWcge1xcbiAgICAvLyBHZXR0ZXJzXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4ge307XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4ge307XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGhhdmUgdG8gaW1wbGVtZW50IHRoZSBzdGF0aWMgbWV0aG9kIFxcXCJOQU1FXFxcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnKTtcXG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XFxuXFxuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XFxuXFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9XFxuXFxuICAgIF9tZXJnZUNvbmZpZ09iaihjb25maWcsIGVsZW1lbnQpIHtcXG4gICAgICBjb25zdCBqc29uQ29uZmlnID0gaXNFbGVtZW50KGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCAnY29uZmlnJykgOiB7fTsgLy8gdHJ5IHRvIHBhcnNlXFxuXFxuICAgICAgcmV0dXJuIHsgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxcbiAgICAgICAgLi4uKHR5cGVvZiBqc29uQ29uZmlnID09PSAnb2JqZWN0JyA/IGpzb25Db25maWcgOiB7fSksXFxuICAgICAgICAuLi4oaXNFbGVtZW50KGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkgOiB7fSksXFxuICAgICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiB7fSlcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnLCBjb25maWdUeXBlcyA9IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpIHtcXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIE9iamVjdC5rZXlzKGNvbmZpZ1R5cGVzKSkge1xcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XTtcXG4gICAgICAgIGNvbnN0IHZhbHVlID0gY29uZmlnW3Byb3BlcnR5XTtcXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGlzRWxlbWVudCh2YWx1ZSkgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpO1xcblxcbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXMuY29uc3RydWN0b3IuTkFNRS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFxcXCIke3Byb3BlcnR5fVxcXCIgcHJvdmlkZWQgdHlwZSBcXFwiJHt2YWx1ZVR5cGV9XFxcIiBidXQgZXhwZWN0ZWQgdHlwZSBcXFwiJHtleHBlY3RlZFR5cGVzfVxcXCIuYCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IGJhc2UtY29tcG9uZW50LmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IFZFUlNJT04gPSAnNS4yLjAnO1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIEJhc2VDb21wb25lbnQgZXh0ZW5kcyBDb25maWcge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcigpO1xcbiAgICAgIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW1lbnQpO1xcblxcbiAgICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgICBEYXRhLnNldCh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKTtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgZGlzcG9zZSgpIHtcXG4gICAgICBEYXRhLnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IHByb3BlcnR5TmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcbiAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX3F1ZXVlQ2FsbGJhY2soY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQgPSB0cnVlKSB7XFxuICAgICAgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbihjYWxsYmFjaywgZWxlbWVudCwgaXNBbmltYXRlZCk7XFxuICAgIH1cXG5cXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcsIHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcXG5cXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcXG5cXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudCkge1xcbiAgICAgIHJldHVybiBEYXRhLmdldChnZXRFbGVtZW50KGVsZW1lbnQpLCB0aGlzLkRBVEFfS0VZKTtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCBjb25maWcgPSB7fSkge1xcbiAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbCk7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xcbiAgICAgIHJldHVybiBWRVJTSU9OO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XFxuICAgICAgcmV0dXJuIGBicy4ke3RoaXMuTkFNRX1gO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRVZFTlRfS0VZKCkge1xcbiAgICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBldmVudE5hbWUobmFtZSkge1xcbiAgICAgIHJldHVybiBgJHtuYW1lfSR7dGhpcy5FVkVOVF9LRVl9YDtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL2NvbXBvbmVudC1mdW5jdGlvbnMuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcblxcbiAgY29uc3QgZW5hYmxlRGlzbWlzc1RyaWdnZXIgPSAoY29tcG9uZW50LCBtZXRob2QgPSAnaGlkZScpID0+IHtcXG4gICAgY29uc3QgY2xpY2tFdmVudCA9IGBjbGljay5kaXNtaXNzJHtjb21wb25lbnQuRVZFTlRfS0VZfWA7XFxuICAgIGNvbnN0IG5hbWUgPSBjb21wb25lbnQuTkFNRTtcXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBjbGlja0V2ZW50LCBgW2RhdGEtYnMtZGlzbWlzcz1cXFwiJHtuYW1lfVxcXCJdYCwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke25hbWV9YCk7XFxuICAgICAgY29uc3QgaW5zdGFuY2UgPSBjb21wb25lbnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpOyAvLyBNZXRob2QgYXJndW1lbnQgaXMgbGVmdCwgZm9yIEFsZXJ0IGFuZCBvbmx5LCBhcyBpdCBkb2Vzbid0IGltcGxlbWVudCB0aGUgJ2hpZGUnIG1ldGhvZFxcblxcbiAgICAgIGluc3RhbmNlW21ldGhvZF0oKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBhbGVydC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJGYgPSAnYWxlcnQnO1xcbiAgY29uc3QgREFUQV9LRVkkYSA9ICdicy5hbGVydCc7XFxuICBjb25zdCBFVkVOVF9LRVkkYiA9IGAuJHtEQVRBX0tFWSRhfWA7XFxuICBjb25zdCBFVkVOVF9DTE9TRSA9IGBjbG9zZSR7RVZFTlRfS0VZJGJ9YDtcXG4gIGNvbnN0IEVWRU5UX0NMT1NFRCA9IGBjbG9zZWQke0VWRU5UX0tFWSRifWA7XFxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNSA9ICdmYWRlJztcXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ4ID0gJ3Nob3cnO1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICAgIC8vIEdldHRlcnNcXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJGY7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIGNsb3NlKCkge1xcbiAgICAgIGNvbnN0IGNsb3NlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRSk7XFxuXFxuICAgICAgaWYgKGNsb3NlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDgpO1xcblxcbiAgICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkNSk7XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9kZXN0cm95RWxlbWVudCgpLCB0aGlzLl9lbGVtZW50LCBpc0FuaW1hdGVkKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9kZXN0cm95RWxlbWVudCgpIHtcXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xcblxcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFRCk7XFxuICAgICAgdGhpcy5kaXNwb3NlKCk7XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gQWxlcnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gIH1cXG4gIC8qKlxcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cXG4gICAqL1xcblxcblxcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEFsZXJ0KTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogYnV0dG9uLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUkZSA9ICdidXR0b24nO1xcbiAgY29uc3QgREFUQV9LRVkkOSA9ICdicy5idXR0b24nO1xcbiAgY29uc3QgRVZFTlRfS0VZJGEgPSBgLiR7REFUQV9LRVkkOX1gO1xcbiAgY29uc3QgREFUQV9BUElfS0VZJDYgPSAnLmRhdGEtYXBpJztcXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDMgPSAnYWN0aXZlJztcXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJidXR0b25cXFwiXSc7XFxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2ID0gYGNsaWNrJHtFVkVOVF9LRVkkYX0ke0RBVEFfQVBJX0tFWSQ2fWA7XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICAgIC8vIEdldHRlcnNcXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJGU7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIHRvZ2dsZSgpIHtcXG4gICAgICAvLyBUb2dnbGUgY2xhc3MgYW5kIHN5bmMgdGhlIGBhcmlhLXByZXNzZWRgIGF0dHJpYnV0ZSB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGAudG9nZ2xlKClgIG1ldGhvZFxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9BQ1RJVkUkMykpO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xcblxcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gJ3RvZ2dsZScpIHtcXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gIH1cXG4gIC8qKlxcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cXG4gICAqL1xcblxcblxcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1LCBldmVudCA9PiB7XFxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIGNvbnN0IGJ1dHRvbiA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUpO1xcbiAgICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UoYnV0dG9uKTtcXG4gICAgZGF0YS50b2dnbGUoKTtcXG4gIH0pO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEJ1dHRvbik7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IGRvbS9zZWxlY3Rvci1lbmdpbmUuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgU2VsZWN0b3JFbmdpbmUgPSB7XFxuICAgIGZpbmQoc2VsZWN0b3IsIGVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xcbiAgICB9LFxcblxcbiAgICBmaW5kT25lKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XFxuICAgIH0sXFxuXFxuICAgIGNoaWxkcmVuKGVsZW1lbnQsIHNlbGVjdG9yKSB7XFxuICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xcbiAgICB9LFxcblxcbiAgICBwYXJlbnRzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XFxuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xcbiAgICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcXG5cXG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcXG4gICAgICAgIHBhcmVudHMucHVzaChhbmNlc3Rvcik7XFxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBwYXJlbnRzO1xcbiAgICB9LFxcblxcbiAgICBwcmV2KGVsZW1lbnQsIHNlbGVjdG9yKSB7XFxuICAgICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xcblxcbiAgICAgIHdoaWxlIChwcmV2aW91cykge1xcbiAgICAgICAgaWYgKHByZXZpb3VzLm1hdGNoZXMoc2VsZWN0b3IpKSB7XFxuICAgICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcHJldmlvdXMgPSBwcmV2aW91cy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gW107XFxuICAgIH0sXFxuXFxuICAgIC8vIFRPRE86IHRoaXMgaXMgbm93IHVudXNlZDsgcmVtb3ZlIGxhdGVyIGFsb25nIHdpdGggcHJldigpXFxuICAgIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcXG4gICAgICBsZXQgbmV4dCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nO1xcblxcbiAgICAgIHdoaWxlIChuZXh0KSB7XFxuICAgICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgICByZXR1cm4gW25leHRdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gW107XFxuICAgIH0sXFxuXFxuICAgIGZvY3VzYWJsZUNoaWxkcmVuKGVsZW1lbnQpIHtcXG4gICAgICBjb25zdCBmb2N1c2FibGVzID0gWydhJywgJ2J1dHRvbicsICdpbnB1dCcsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnZGV0YWlscycsICdbdGFiaW5kZXhdJywgJ1tjb250ZW50ZWRpdGFibGU9XFxcInRydWVcXFwiXSddLm1hcChzZWxlY3RvciA9PiBgJHtzZWxlY3Rvcn06bm90KFt0YWJpbmRleF49XFxcIi1cXFwiXSlgKS5qb2luKCcsJyk7XFxuICAgICAgcmV0dXJuIHRoaXMuZmluZChmb2N1c2FibGVzLCBlbGVtZW50KS5maWx0ZXIoZWwgPT4gIWlzRGlzYWJsZWQoZWwpICYmIGlzVmlzaWJsZShlbCkpO1xcbiAgICB9XFxuXFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL3N3aXBlLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUkZCA9ICdzd2lwZSc7XFxuICBjb25zdCBFVkVOVF9LRVkkOSA9ICcuYnMuc3dpcGUnO1xcbiAgY29uc3QgRVZFTlRfVE9VQ0hTVEFSVCA9IGB0b3VjaHN0YXJ0JHtFVkVOVF9LRVkkOX1gO1xcbiAgY29uc3QgRVZFTlRfVE9VQ0hNT1ZFID0gYHRvdWNobW92ZSR7RVZFTlRfS0VZJDl9YDtcXG4gIGNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVkkOX1gO1xcbiAgY29uc3QgRVZFTlRfUE9JTlRFUkRPV04gPSBgcG9pbnRlcmRvd24ke0VWRU5UX0tFWSQ5fWA7XFxuICBjb25zdCBFVkVOVF9QT0lOVEVSVVAgPSBgcG9pbnRlcnVwJHtFVkVOVF9LRVkkOX1gO1xcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcXG4gIGNvbnN0IFBPSU5URVJfVFlQRV9QRU4gPSAncGVuJztcXG4gIGNvbnN0IENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCA9ICdwb2ludGVyLWV2ZW50JztcXG4gIGNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xcbiAgY29uc3QgRGVmYXVsdCRjID0ge1xcbiAgICBlbmRDYWxsYmFjazogbnVsbCxcXG4gICAgbGVmdENhbGxiYWNrOiBudWxsLFxcbiAgICByaWdodENhbGxiYWNrOiBudWxsXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkYyA9IHtcXG4gICAgZW5kQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxcbiAgICBsZWZ0Q2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxcbiAgICByaWdodENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBTd2lwZSBleHRlbmRzIENvbmZpZyB7XFxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICAgIHN1cGVyKCk7XFxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XFxuXFxuICAgICAgaWYgKCFlbGVtZW50IHx8ICFTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICAgIHRoaXMuX2RlbHRhWCA9IDA7XFxuICAgICAgdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQpO1xcblxcbiAgICAgIHRoaXMuX2luaXRFdmVudHMoKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCRjO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGM7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJGQ7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVkkOSk7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfc3RhcnQoZXZlbnQpIHtcXG4gICAgICBpZiAoIXRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XFxuICAgICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2VuZChldmVudCkge1xcbiAgICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX2RlbHRhWDtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKTtcXG5cXG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5lbmRDYWxsYmFjayk7XFxuICAgIH1cXG5cXG4gICAgX21vdmUoZXZlbnQpIHtcXG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XFxuICAgIH1cXG5cXG4gICAgX2hhbmRsZVN3aXBlKCkge1xcbiAgICAgIGNvbnN0IGFic0RlbHRhWCA9IE1hdGguYWJzKHRoaXMuX2RlbHRhWCk7XFxuXFxuICAgICAgaWYgKGFic0RlbHRhWCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gYWJzRGVsdGFYIC8gdGhpcy5fZGVsdGFYO1xcbiAgICAgIHRoaXMuX2RlbHRhWCA9IDA7XFxuXFxuICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZXhlY3V0ZShkaXJlY3Rpb24gPiAwID8gdGhpcy5fY29uZmlnLnJpZ2h0Q2FsbGJhY2sgOiB0aGlzLl9jb25maWcubGVmdENhbGxiYWNrKTtcXG4gICAgfVxcblxcbiAgICBfaW5pdEV2ZW50cygpIHtcXG4gICAgICBpZiAodGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9QT0lOVEVSVVAsIGV2ZW50ID0+IHRoaXMuX2VuZChldmVudCkpO1xcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSFNUQVJULCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNITU9WRSwgZXZlbnQgPT4gdGhpcy5fbW92ZShldmVudCkpO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIRU5ELCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMgJiYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfUEVOIHx8IGV2ZW50LnBvaW50ZXJUeXBlID09PSBQT0lOVEVSX1RZUEVfVE9VQ0gpO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XFxuICAgICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwO1xcbiAgICB9XFxuXFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IGNhcm91c2VsLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUkYyA9ICdjYXJvdXNlbCc7XFxuICBjb25zdCBEQVRBX0tFWSQ4ID0gJ2JzLmNhcm91c2VsJztcXG4gIGNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XFxuICBjb25zdCBBUlJPV19MRUZUX0tFWSQxID0gJ0Fycm93TGVmdCc7XFxuICBjb25zdCBBUlJPV19SSUdIVF9LRVkkMSA9ICdBcnJvd1JpZ2h0JztcXG4gIGNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxcblxcbiAgY29uc3QgT1JERVJfTkVYVCA9ICduZXh0JztcXG4gIGNvbnN0IE9SREVSX1BSRVYgPSAncHJldic7XFxuICBjb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcXG4gIGNvbnN0IERJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XFxuICBjb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZJDh9YDtcXG4gIGNvbnN0IEVWRU5UX1NMSUQgPSBgc2xpZCR7RVZFTlRfS0VZJDh9YDtcXG4gIGNvbnN0IEVWRU5UX0tFWURPV04kMSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOH1gO1xcbiAgY29uc3QgRVZFTlRfTU9VU0VFTlRFUiQxID0gYG1vdXNlZW50ZXIke0VWRU5UX0tFWSQ4fWA7XFxuICBjb25zdCBFVkVOVF9NT1VTRUxFQVZFJDEgPSBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZJDh9YDtcXG4gIGNvbnN0IEVWRU5UX0RSQUdfU1RBUlQgPSBgZHJhZ3N0YXJ0JHtFVkVOVF9LRVkkOH1gO1xcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQzID0gYGxvYWQke0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUgPSBgY2xpY2ske0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcXG4gIGNvbnN0IENMQVNTX05BTUVfQ0FST1VTRUwgPSAnY2Fyb3VzZWwnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMiA9ICdhY3RpdmUnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TTElERSA9ICdzbGlkZSc7XFxuICBjb25zdCBDTEFTU19OQU1FX0VORCA9ICdjYXJvdXNlbC1pdGVtLWVuZCc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NUQVJUID0gJ2Nhcm91c2VsLWl0ZW0tc3RhcnQnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCc7XFxuICBjb25zdCBDTEFTU19OQU1FX1BSRVYgPSAnY2Fyb3VzZWwtaXRlbS1wcmV2JztcXG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJztcXG4gIGNvbnN0IFNFTEVDVE9SX0lURU0gPSAnLmNhcm91c2VsLWl0ZW0nO1xcbiAgY29uc3QgU0VMRUNUT1JfQUNUSVZFX0lURU0gPSBTRUxFQ1RPUl9BQ1RJVkUgKyBTRUxFQ1RPUl9JVEVNO1xcbiAgY29uc3QgU0VMRUNUT1JfSVRFTV9JTUcgPSAnLmNhcm91c2VsLWl0ZW0gaW1nJztcXG4gIGNvbnN0IFNFTEVDVE9SX0lORElDQVRPUlMgPSAnLmNhcm91c2VsLWluZGljYXRvcnMnO1xcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9TTElERSA9ICdbZGF0YS1icy1zbGlkZV0sIFtkYXRhLWJzLXNsaWRlLXRvXSc7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1JJREUgPSAnW2RhdGEtYnMtcmlkZT1cXFwiY2Fyb3VzZWxcXFwiXSc7XFxuICBjb25zdCBLRVlfVE9fRElSRUNUSU9OID0ge1xcbiAgICBbQVJST1dfTEVGVF9LRVkkMV06IERJUkVDVElPTl9SSUdIVCxcXG4gICAgW0FSUk9XX1JJR0hUX0tFWSQxXTogRElSRUNUSU9OX0xFRlRcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0JGIgPSB7XFxuICAgIGludGVydmFsOiA1MDAwLFxcbiAgICBrZXlib2FyZDogdHJ1ZSxcXG4gICAgcGF1c2U6ICdob3ZlcicsXFxuICAgIHJpZGU6IGZhbHNlLFxcbiAgICB0b3VjaDogdHJ1ZSxcXG4gICAgd3JhcDogdHJ1ZVxcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRUeXBlJGIgPSB7XFxuICAgIGludGVydmFsOiAnKG51bWJlcnxib29sZWFuKScsXFxuICAgIC8vIFRPRE86djYgcmVtb3ZlIGJvb2xlYW4gc3VwcG9ydFxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxcbiAgICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxcbiAgICByaWRlOiAnKGJvb2xlYW58c3RyaW5nKScsXFxuICAgIHRvdWNoOiAnYm9vbGVhbicsXFxuICAgIHdyYXA6ICdib29sZWFuJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcXG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcXG4gICAgICB0aGlzLnRvdWNoVGltZW91dCA9IG51bGw7XFxuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBudWxsO1xcbiAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTkRJQ0FUT1JTLCB0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcucmlkZSA9PT0gQ0xBU1NfTkFNRV9DQVJPVVNFTCkge1xcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCRiO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGI7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJGM7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIG5leHQoKSB7XFxuICAgICAgdGhpcy5fc2xpZGUoT1JERVJfTkVYVCk7XFxuICAgIH1cXG5cXG4gICAgbmV4dFdoZW5WaXNpYmxlKCkge1xcbiAgICAgIC8vIEZJWE1FIFRPRE8gdXNlIGBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGVgXFxuICAgICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxcbiAgICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcXG4gICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiBpc1Zpc2libGUodGhpcy5fZWxlbWVudCkpIHtcXG4gICAgICAgIHRoaXMubmV4dCgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBwcmV2KCkge1xcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xcbiAgICB9XFxuXFxuICAgIHBhdXNlKCkge1xcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XFxuICAgIH1cXG5cXG4gICAgY3ljbGUoKSB7XFxuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xcblxcbiAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKCk7XFxuXFxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm5leHRXaGVuVmlzaWJsZSgpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xcbiAgICB9XFxuXFxuICAgIF9tYXliZUVuYWJsZUN5Y2xlKCkge1xcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnJpZGUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmN5Y2xlKCk7XFxuICAgIH1cXG5cXG4gICAgdG8oaW5kZXgpIHtcXG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zKCk7XFxuXFxuICAgICAgaWYgKGluZGV4ID4gaXRlbXMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2dldEFjdGl2ZSgpKTtcXG5cXG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xcblxcbiAgICAgIHRoaXMuX3NsaWRlKG9yZGVyLCBpdGVtc1tpbmRleF0pO1xcbiAgICB9XFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgaWYgKHRoaXMuX3N3aXBlSGVscGVyKSB7XFxuICAgICAgICB0aGlzLl9zd2lwZUhlbHBlci5kaXNwb3NlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xcbiAgICAgIGNvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSBjb25maWcuaW50ZXJ2YWw7XFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04kMSwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XFxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VFTlRFUiQxLCAoKSA9PiB0aGlzLnBhdXNlKCkpO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUkMSwgKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCAmJiBTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XFxuICAgICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xcbiAgICAgIGZvciAoY29uc3QgaW1nIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTV9JTUcsIHRoaXMuX2VsZW1lbnQpKSB7XFxuICAgICAgICBFdmVudEhhbmRsZXIub24oaW1nLCBFVkVOVF9EUkFHX1NUQVJULCBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgZW5kQ2FsbEJhY2sgPSAoKSA9PiB7XFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlICE9PSAnaG92ZXInKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH0gLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgbW91c2UgY29tcGF0aWJpbGl0eSBldmVudHMgb24gZmlyc3QgdGFwIC0gdGhlIGNhcm91c2VsXFxuICAgICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xcbiAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcXG4gICAgICAgIC8vIChhcyBpZiBpdCdzIHRoZSBzZWNvbmQgdGltZSB3ZSB0YXAgb24gaXQsIG1vdXNlZW50ZXIgY29tcGF0IGV2ZW50XFxuICAgICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XFxuICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcXG5cXG5cXG4gICAgICAgIHRoaXMucGF1c2UoKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLnRvdWNoVGltZW91dCkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX21heWJlRW5hYmxlQ3ljbGUoKSwgVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCArIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XFxuICAgICAgfTtcXG5cXG4gICAgICBjb25zdCBzd2lwZUNvbmZpZyA9IHtcXG4gICAgICAgIGxlZnRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fTEVGVCkpLFxcbiAgICAgICAgcmlnaHRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fUklHSFQpKSxcXG4gICAgICAgIGVuZENhbGxiYWNrOiBlbmRDYWxsQmFja1xcbiAgICAgIH07XFxuICAgICAgdGhpcy5fc3dpcGVIZWxwZXIgPSBuZXcgU3dpcGUodGhpcy5fZWxlbWVudCwgc3dpcGVDb25maWcpO1xcbiAgICB9XFxuXFxuICAgIF9rZXlkb3duKGV2ZW50KSB7XFxuICAgICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IEtFWV9UT19ESVJFQ1RJT05bZXZlbnQua2V5XTtcXG5cXG4gICAgICBpZiAoZGlyZWN0aW9uKSB7XFxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcbiAgICAgICAgdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2dldEl0ZW1zKCkuaW5kZXhPZihlbGVtZW50KTtcXG4gICAgfVxcblxcbiAgICBfc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChpbmRleCkge1xcbiAgICAgIGlmICghdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkUsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcXG4gICAgICBhY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyKTtcXG4gICAgICBhY3RpdmVJbmRpY2F0b3IucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnKTtcXG4gICAgICBjb25zdCBuZXdBY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKGBbZGF0YS1icy1zbGlkZS10bz1cXFwiJHtpbmRleH1cXFwiXWAsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcXG5cXG4gICAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XFxuICAgICAgICBuZXdBY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQyKTtcXG4gICAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF91cGRhdGVJbnRlcnZhbCgpIHtcXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCB0aGlzLl9nZXRBY3RpdmUoKTtcXG5cXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgZWxlbWVudEludGVydmFsID0gTnVtYmVyLnBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLWludGVydmFsJyksIDEwKTtcXG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbDtcXG4gICAgfVxcblxcbiAgICBfc2xpZGUob3JkZXIsIGVsZW1lbnQgPSBudWxsKSB7XFxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZ2V0QWN0aXZlKCk7XFxuXFxuICAgICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XFxuICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBlbGVtZW50IHx8IGdldE5leHRBY3RpdmVFbGVtZW50KHRoaXMuX2dldEl0ZW1zKCksIGFjdGl2ZUVsZW1lbnQsIGlzTmV4dCwgdGhpcy5fY29uZmlnLndyYXApO1xcblxcbiAgICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcXG5cXG4gICAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xcbiAgICAgICAgcmV0dXJuIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGV2ZW50TmFtZSwge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcXG4gICAgICAgICAgZnJvbTogdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpLFxcbiAgICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG5cXG4gICAgICBjb25zdCBzbGlkZUV2ZW50ID0gdHJpZ2dlckV2ZW50KEVWRU5UX1NMSURFKTtcXG5cXG4gICAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcXG4gICAgICAgIC8vIFNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxcbiAgICAgICAgLy8gdG9kbzogY2hhbmdlIHRlc3RzIHRoYXQgdXNlIGVtcHR5IGRpdnMgdG8gYXZvaWQgdGhpcyBjaGVja1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcXG4gICAgICB0aGlzLnBhdXNlKCk7XFxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gdHJ1ZTtcXG5cXG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50SW5kZXgpO1xcblxcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcXG4gICAgICBjb25zdCBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfU1RBUlQgOiBDTEFTU19OQU1FX0VORDtcXG4gICAgICBjb25zdCBvcmRlckNsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfTkVYVCA6IENMQVNTX05BTUVfUFJFVjtcXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcXG4gICAgICByZWZsb3cobmV4dEVsZW1lbnQpO1xcbiAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XFxuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XFxuXFxuICAgICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XFxuICAgICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMiwgb3JkZXJDbGFzc05hbWUsIGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcXG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xcbiAgICAgICAgdHJpZ2dlckV2ZW50KEVWRU5UX1NMSUQpO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCBhY3RpdmVFbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xcblxcbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcXG4gICAgICAgIHRoaXMuY3ljbGUoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2lzQW5pbWF0ZWQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRBY3RpdmUoKSB7XFxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRJdGVtcygpIHtcXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCB0aGlzLl9lbGVtZW50KTtcXG4gICAgfVxcblxcbiAgICBfY2xlYXJJbnRlcnZhbCgpIHtcXG4gICAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfZGlyZWN0aW9uVG9PcmRlcihkaXJlY3Rpb24pIHtcXG4gICAgICBpZiAoaXNSVEwoKSkge1xcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9QUkVWIDogT1JERVJfTkVYVDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcXG4gICAgfVxcblxcbiAgICBfb3JkZXJUb0RpcmVjdGlvbihvcmRlcikge1xcbiAgICAgIGlmIChpc1JUTCgpKSB7XFxuICAgICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX1JJR0hUIDogRElSRUNUSU9OX0xFRlQ7XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XFxuICAgICAgICAgIGRhdGEudG8oY29uZmlnKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSwgU0VMRUNUT1JfREFUQV9TTElERSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XFxuXFxuICAgIGlmICghdGFyZ2V0IHx8ICF0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIGNvbnN0IGNhcm91c2VsID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xcbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKTtcXG5cXG4gICAgaWYgKHNsaWRlSW5kZXgpIHtcXG4gICAgICBjYXJvdXNlbC50byhzbGlkZUluZGV4KTtcXG5cXG4gICAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xcblxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLCAnc2xpZGUnKSA9PT0gJ25leHQnKSB7XFxuICAgICAgY2Fyb3VzZWwubmV4dCgpO1xcblxcbiAgICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGNhcm91c2VsLnByZXYoKTtcXG5cXG4gICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcXG4gIH0pO1xcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQzLCAoKSA9PiB7XFxuICAgIGNvbnN0IGNhcm91c2VscyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9SSURFKTtcXG5cXG4gICAgZm9yIChjb25zdCBjYXJvdXNlbCBvZiBjYXJvdXNlbHMpIHtcXG4gICAgICBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKGNhcm91c2VsKTtcXG4gICAgfVxcbiAgfSk7XFxuICAvKipcXG4gICAqIGpRdWVyeVxcbiAgICovXFxuXFxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQ2Fyb3VzZWwpO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBjb2xsYXBzZS5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJGIgPSAnY29sbGFwc2UnO1xcbiAgY29uc3QgREFUQV9LRVkkNyA9ICdicy5jb2xsYXBzZSc7XFxuICBjb25zdCBFVkVOVF9LRVkkNyA9IGAuJHtEQVRBX0tFWSQ3fWA7XFxuICBjb25zdCBEQVRBX0FQSV9LRVkkNCA9ICcuZGF0YS1hcGknO1xcbiAgY29uc3QgRVZFTlRfU0hPVyQ2ID0gYHNob3cke0VWRU5UX0tFWSQ3fWA7XFxuICBjb25zdCBFVkVOVF9TSE9XTiQ2ID0gYHNob3duJHtFVkVOVF9LRVkkN31gO1xcbiAgY29uc3QgRVZFTlRfSElERSQ2ID0gYGhpZGUke0VWRU5UX0tFWSQ3fWA7XFxuICBjb25zdCBFVkVOVF9ISURERU4kNiA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ3fWA7XFxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0ID0gYGNsaWNrJHtFVkVOVF9LRVkkN30ke0RBVEFfQVBJX0tFWSQ0fWA7XFxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNyA9ICdzaG93JztcXG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0UgPSAnY29sbGFwc2UnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTSU5HID0gJ2NvbGxhcHNpbmcnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRUQgPSAnY29sbGFwc2VkJztcXG4gIGNvbnN0IENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOID0gYDpzY29wZSAuJHtDTEFTU19OQU1FX0NPTExBUFNFfSAuJHtDTEFTU19OQU1FX0NPTExBUFNFfWA7XFxuICBjb25zdCBDTEFTU19OQU1FX0hPUklaT05UQUwgPSAnY29sbGFwc2UtaG9yaXpvbnRhbCc7XFxuICBjb25zdCBXSURUSCA9ICd3aWR0aCc7XFxuICBjb25zdCBIRUlHSFQgPSAnaGVpZ2h0JztcXG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRVMgPSAnLmNvbGxhcHNlLnNob3csIC5jb2xsYXBzZS5jb2xsYXBzaW5nJztcXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCJdJztcXG4gIGNvbnN0IERlZmF1bHQkYSA9IHtcXG4gICAgcGFyZW50OiBudWxsLFxcbiAgICB0b2dnbGU6IHRydWVcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSRhID0ge1xcbiAgICBwYXJlbnQ6ICcobnVsbHxlbGVtZW50KScsXFxuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XFxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XFxuICAgICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gW107XFxuICAgICAgY29uc3QgdG9nZ2xlTGlzdCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XFxuXFxuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHRvZ2dsZUxpc3QpIHtcXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtKTtcXG4gICAgICAgIGNvbnN0IGZpbHRlckVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKS5maWx0ZXIoZm91bmRFbGVtZW50ID0+IGZvdW5kRWxlbWVudCA9PT0gdGhpcy5fZWxlbWVudCk7XFxuXFxuICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpO1xcblxcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcXG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XFxuICAgICAgfVxcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0JGE7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYTtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgICAgcmV0dXJuIE5BTUUkYjtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgdG9nZ2xlKCkge1xcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcXG4gICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLnNob3coKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgc2hvdygpIHtcXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgYWN0aXZlQ2hpbGRyZW4gPSBbXTsgLy8gZmluZCBhY3RpdmUgY2hpbGRyZW5cXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnBhcmVudCkge1xcbiAgICAgICAgYWN0aXZlQ2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfQUNUSVZFUykuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCkubWFwKGVsZW1lbnQgPT4gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XFxuICAgICAgICAgIHRvZ2dsZTogZmFsc2VcXG4gICAgICAgIH0pKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGFjdGl2ZUNoaWxkcmVuLmxlbmd0aCAmJiBhY3RpdmVDaGlsZHJlblswXS5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHN0YXJ0RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDYpO1xcblxcbiAgICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChjb25zdCBhY3RpdmVJbnN0YW5jZSBvZiBhY3RpdmVDaGlsZHJlbikge1xcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gMDtcXG5cXG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0cnVlKTtcXG5cXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xcblxcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcXG5cXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDYpO1xcbiAgICAgIH07XFxuXFxuICAgICAgY29uc3QgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcXG4gICAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YDtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdfXB4YDtcXG4gICAgfVxcblxcbiAgICBoaWRlKCkge1xcbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ2KTtcXG5cXG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXX1weGA7XFxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNFLCBDTEFTU19OQU1FX1NIT1ckNyk7XFxuXFxuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRoaXMuX3RyaWdnZXJBcnJheSkge1xcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodHJpZ2dlcik7XFxuXFxuICAgICAgICBpZiAoZWxlbWVudCAmJiAhdGhpcy5faXNTaG93bihlbGVtZW50KSkge1xcbiAgICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW3RyaWdnZXJdLCBmYWxzZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XFxuXFxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG5cXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UpO1xcblxcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDYpO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgX2lzU2hvd24oZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XFxuICAgICAgY29uZmlnLnRvZ2dsZSA9IEJvb2xlYW4oY29uZmlnLnRvZ2dsZSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWVzXFxuXFxuICAgICAgY29uZmlnLnBhcmVudCA9IGdldEVsZW1lbnQoY29uZmlnLnBhcmVudCk7XFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfZ2V0RGltZW5zaW9uKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0hPUklaT05UQUwpID8gV0lEVEggOiBIRUlHSFQ7XFxuICAgIH1cXG5cXG4gICAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XFxuXFxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGNoaWxkcmVuKSB7XFxuICAgICAgICBjb25zdCBzZWxlY3RlZCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCk7XFxuXFxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcXG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFtlbGVtZW50XSwgdGhpcy5faXNTaG93bihzZWxlY3RlZCkpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKHNlbGVjdG9yKSB7XFxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kKENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOLCB0aGlzLl9jb25maWcucGFyZW50KTsgLy8gcmVtb3ZlIGNoaWxkcmVuIGlmIGdyZWF0ZXIgZGVwdGhcXG5cXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKGVsZW1lbnQgPT4gIWNoaWxkcmVuLmluY2x1ZGVzKGVsZW1lbnQpKTtcXG4gICAgfVxcblxcbiAgICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRyaWdnZXJBcnJheSwgaXNPcGVuKSB7XFxuICAgICAgaWYgKCF0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2VyQXJyYXkpIHtcXG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShDTEFTU19OQU1FX0NPTExBUFNFRCwgIWlzT3Blbik7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGlzT3Blbik7XFxuICAgICAgfVxcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIGNvbnN0IF9jb25maWcgPSB7fTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XFxuICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIF9jb25maWcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcXG4gICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XFxuICAgIGNvbnN0IHNlbGVjdG9yRWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKTtcXG5cXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHNlbGVjdG9yRWxlbWVudHMpIHtcXG4gICAgICBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIHtcXG4gICAgICAgIHRvZ2dsZTogZmFsc2VcXG4gICAgICB9KS50b2dnbGUoKTtcXG4gICAgfVxcbiAgfSk7XFxuICAvKipcXG4gICAqIGpRdWVyeVxcbiAgICovXFxuXFxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQ29sbGFwc2UpO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBkcm9wZG93bi5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJGEgPSAnZHJvcGRvd24nO1xcbiAgY29uc3QgREFUQV9LRVkkNiA9ICdicy5kcm9wZG93bic7XFxuICBjb25zdCBFVkVOVF9LRVkkNiA9IGAuJHtEQVRBX0tFWSQ2fWA7XFxuICBjb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xcbiAgY29uc3QgRVNDQVBFX0tFWSQyID0gJ0VzY2FwZSc7XFxuICBjb25zdCBUQUJfS0VZJDEgPSAnVGFiJztcXG4gIGNvbnN0IEFSUk9XX1VQX0tFWSQxID0gJ0Fycm93VXAnO1xcbiAgY29uc3QgQVJST1dfRE9XTl9LRVkkMSA9ICdBcnJvd0Rvd24nO1xcbiAgY29uc3QgUklHSFRfTU9VU0VfQlVUVE9OID0gMjsgLy8gTW91c2VFdmVudC5idXR0b24gdmFsdWUgZm9yIHRoZSBzZWNvbmRhcnkgYnV0dG9uLCB1c3VhbGx5IHRoZSByaWdodCBidXR0b25cXG5cXG4gIGNvbnN0IEVWRU5UX0hJREUkNSA9IGBoaWRlJHtFVkVOVF9LRVkkNn1gO1xcbiAgY29uc3QgRVZFTlRfSElEREVOJDUgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNn1gO1xcbiAgY29uc3QgRVZFTlRfU0hPVyQ1ID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XFxuICBjb25zdCBFVkVOVF9TSE9XTiQ1ID0gYHNob3duJHtFVkVOVF9LRVkkNn1gO1xcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyA9IGBjbGljayR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XFxuICBjb25zdCBFVkVOVF9LRVlVUF9EQVRBX0FQSSA9IGBrZXl1cCR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDYgPSAnc2hvdyc7XFxuICBjb25zdCBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QRU5EID0gJ2Ryb3BlbmQnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QU1RBUlQgPSAnZHJvcHN0YXJ0JztcXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUiA9ICdkcm9wdXAtY2VudGVyJztcXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSID0gJ2Ryb3Bkb3duLWNlbnRlcic7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwiZHJvcGRvd25cXFwiXTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTiA9IGAke1NFTEVDVE9SX0RBVEFfVE9HR0xFJDN9LiR7Q0xBU1NfTkFNRV9TSE9XJDZ9YDtcXG4gIGNvbnN0IFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xcbiAgY29uc3QgU0VMRUNUT1JfTkFWQkFSID0gJy5uYXZiYXInO1xcbiAgY29uc3QgU0VMRUNUT1JfTkFWQkFSX05BViA9ICcubmF2YmFyLW5hdic7XFxuICBjb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcXG4gIGNvbnN0IFBMQUNFTUVOVF9UT1AgPSBpc1JUTCgpID8gJ3RvcC1lbmQnIDogJ3RvcC1zdGFydCc7XFxuICBjb25zdCBQTEFDRU1FTlRfVE9QRU5EID0gaXNSVEwoKSA/ICd0b3Atc3RhcnQnIDogJ3RvcC1lbmQnO1xcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcXG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01FTkQgPSBpc1JUTCgpID8gJ2JvdHRvbS1zdGFydCcgOiAnYm90dG9tLWVuZCc7XFxuICBjb25zdCBQTEFDRU1FTlRfUklHSFQgPSBpc1JUTCgpID8gJ2xlZnQtc3RhcnQnIDogJ3JpZ2h0LXN0YXJ0JztcXG4gIGNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XFxuICBjb25zdCBQTEFDRU1FTlRfVE9QQ0VOVEVSID0gJ3RvcCc7XFxuICBjb25zdCBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSID0gJ2JvdHRvbSc7XFxuICBjb25zdCBEZWZhdWx0JDkgPSB7XFxuICAgIGF1dG9DbG9zZTogdHJ1ZSxcXG4gICAgYm91bmRhcnk6ICdjbGlwcGluZ1BhcmVudHMnLFxcbiAgICBkaXNwbGF5OiAnZHluYW1pYycsXFxuICAgIG9mZnNldDogWzAsIDJdLFxcbiAgICBwb3BwZXJDb25maWc6IG51bGwsXFxuICAgIHJlZmVyZW5jZTogJ3RvZ2dsZSdcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSQ5ID0ge1xcbiAgICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJyxcXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcXG4gICAgZGlzcGxheTogJ3N0cmluZycsXFxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXFxuICAgIHJlZmVyZW5jZTogJyhzdHJpbmd8ZWxlbWVudHxvYmplY3QpJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBEcm9wZG93biBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XFxuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlOyAvLyBkcm9wZG93biB3cmFwcGVyXFxuXFxuICAgICAgdGhpcy5fbWVudSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTUVOVSwgdGhpcy5fcGFyZW50KTtcXG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0JDk7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkOTtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgICAgcmV0dXJuIE5BTUUkYTtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgdG9nZ2xlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xcbiAgICB9XFxuXFxuICAgIHNob3coKSB7XFxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bigpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgICAgfTtcXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDUsIHJlbGF0ZWRUYXJnZXQpO1xcblxcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jcmVhdGVQb3BwZXIoKTsgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgdG8gdGhlIGJvZHkncyBpbW1lZGlhdGUgY2hpbGRyZW47XFxuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcXG5cXG5cXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICF0aGlzLl9wYXJlbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVJfTkFWKSkge1xcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcXG5cXG4gICAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNSwgcmVsYXRlZFRhcmdldCk7XFxuICAgIH1cXG5cXG4gICAgaGlkZSgpIHtcXG4gICAgICBpZiAoaXNEaXNhYmxlZCh0aGlzLl9lbGVtZW50KSB8fCAhdGhpcy5faXNTaG93bigpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XFxuICAgIH1cXG5cXG4gICAgZGlzcG9zZSgpIHtcXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XFxuICAgIH1cXG5cXG4gICAgdXBkYXRlKCkge1xcbiAgICAgIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCk7XFxuXFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCkge1xcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XFxuXFxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XFxuXFxuXFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xcbiAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbWVudS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XFxuXFxuICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJyk7XFxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUsIHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgICAgY29uZmlnID0gc3VwZXIuX2dldENvbmZpZyhjb25maWcpO1xcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudChjb25maWcucmVmZXJlbmNlKSAmJiB0eXBlb2YgY29uZmlnLnJlZmVyZW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIC8vIFBvcHBlciB2aXJ0dWFsIGVsZW1lbnRzIHJlcXVpcmUgYSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbWV0aG9kXFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke05BTUUkYS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFxcXCJyZWZlcmVuY2VcXFwiIHByb3ZpZGVkIHR5cGUgXFxcIm9iamVjdFxcXCIgd2l0aG91dCBhIHJlcXVpcmVkIFxcXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcXFwiIG1ldGhvZC5gKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfY3JlYXRlUG9wcGVyKCkge1xcbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyX19uYW1lc3BhY2UgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGxldCByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fZWxlbWVudDtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9wYXJlbnQ7XFxuICAgICAgfSBlbHNlIGlmIChpc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcXG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBnZXRFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fY29uZmlnLnJlZmVyZW5jZTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgcG9wcGVyQ29uZmlnID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCk7XFxuXFxuICAgICAgdGhpcy5fcG9wcGVyID0gUG9wcGVyX19uYW1lc3BhY2UuY3JlYXRlUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHBvcHBlckNvbmZpZyk7XFxuICAgIH1cXG5cXG4gICAgX2lzU2hvd24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX21lbnUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ2KTtcXG4gICAgfVxcblxcbiAgICBfZ2V0UGxhY2VtZW50KCkge1xcbiAgICAgIGNvbnN0IHBhcmVudERyb3Bkb3duID0gdGhpcy5fcGFyZW50O1xcblxcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcXG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfTEVGVDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUF9DRU5URVIpKSB7XFxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX1RPUENFTlRFUjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcXG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSO1xcbiAgICAgIH0gLy8gV2UgbmVlZCB0byB0cmltIHRoZSB2YWx1ZSBiZWNhdXNlIGN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBhbHNvIGluY2x1ZGUgc3BhY2VzXFxuXFxuXFxuICAgICAgY29uc3QgaXNFbmQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lbnUpLmdldFByb3BlcnR5VmFsdWUoJy0tYnMtcG9zaXRpb24nKS50cmltKCkgPT09ICdlbmQnO1xcblxcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XFxuICAgICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX0JPVFRPTUVORCA6IFBMQUNFTUVOVF9CT1RUT007XFxuICAgIH1cXG5cXG4gICAgX2RldGVjdE5hdmJhcigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX05BVkJBUikgIT09IG51bGw7XFxuICAgIH1cXG5cXG4gICAgX2dldE9mZnNldCgpIHtcXG4gICAgICBjb25zdCB7XFxuICAgICAgICBvZmZzZXRcXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xcblxcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgIH1cXG5cXG4gICAgX2dldFBvcHBlckNvbmZpZygpIHtcXG4gICAgICBjb25zdCBkZWZhdWx0QnNQb3BwZXJDb25maWcgPSB7XFxuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxcbiAgICAgICAgbW9kaWZpZXJzOiBbe1xcbiAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcXG4gICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcXG4gICAgICAgICAgfVxcbiAgICAgICAgfV1cXG4gICAgICB9OyAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXkgb3IgRHJvcGRvd24gaXMgaW4gTmF2YmFyXFxuXFxuICAgICAgaWYgKHRoaXMuX2luTmF2YmFyIHx8IHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSAnc3RhdGljJykge1xcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCAncG9wcGVyJywgJ3N0YXRpYycpOyAvLyB0b2RvOnY2IHJlbW92ZVxcblxcbiAgICAgICAgZGVmYXVsdEJzUG9wcGVyQ29uZmlnLm1vZGlmaWVycyA9IFt7XFxuICAgICAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXFxuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXFxuICAgICAgICB9XTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHsgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxcbiAgICAgICAgLi4uKHR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09PSAnZnVuY3Rpb24nID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhkZWZhdWx0QnNQb3BwZXJDb25maWcpIDogdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZylcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIF9zZWxlY3RNZW51SXRlbSh7XFxuICAgICAga2V5LFxcbiAgICAgIHRhcmdldFxcbiAgICB9KSB7XFxuICAgICAgY29uc3QgaXRlbXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMsIHRoaXMuX21lbnUpLmZpbHRlcihlbGVtZW50ID0+IGlzVmlzaWJsZShlbGVtZW50KSk7XFxuXFxuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIGlmIHRhcmdldCBpc24ndCBpbmNsdWRlZCBpbiBpdGVtcyAoZS5nLiB3aGVuIGV4cGFuZGluZyB0aGUgZHJvcGRvd24pXFxuICAgICAgLy8gYWxsb3cgY3ljbGluZyB0byBnZXQgdGhlIGxhc3QgaXRlbSBpbiBjYXNlIGtleSBlcXVhbHMgQVJST1dfVVBfS0VZXFxuXFxuXFxuICAgICAgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoaXRlbXMsIHRhcmdldCwga2V5ID09PSBBUlJPV19ET1dOX0tFWSQxLCAhaXRlbXMuaW5jbHVkZXModGFyZ2V0KSkuZm9jdXMoKTtcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGNsZWFyTWVudXMoZXZlbnQpIHtcXG4gICAgICBpZiAoZXZlbnQuYnV0dG9uID09PSBSSUdIVF9NT1VTRV9CVVRUT04gfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgIT09IFRBQl9LRVkkMSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBvcGVuVG9nZ2xlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04pO1xcblxcbiAgICAgIGZvciAoY29uc3QgdG9nZ2xlIG9mIG9wZW5Ub2dnbGVzKSB7XFxuICAgICAgICBjb25zdCBjb250ZXh0ID0gRHJvcGRvd24uZ2V0SW5zdGFuY2UodG9nZ2xlKTtcXG5cXG4gICAgICAgIGlmICghY29udGV4dCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSBmYWxzZSkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnN0IGNvbXBvc2VkUGF0aCA9IGV2ZW50LmNvbXBvc2VkUGF0aCgpO1xcbiAgICAgICAgY29uc3QgaXNNZW51VGFyZ2V0ID0gY29tcG9zZWRQYXRoLmluY2x1ZGVzKGNvbnRleHQuX21lbnUpO1xcblxcbiAgICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdvdXRzaWRlJyAmJiBpc01lbnVUYXJnZXQpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcXG5cXG5cXG4gICAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZJDEgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XFxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGNvbnRleHQuX2VsZW1lbnRcXG4gICAgICAgIH07XFxuXFxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnRleHQuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcihldmVudCkge1xcbiAgICAgIC8vIElmIG5vdCBhbiBVUCB8IERPV04gfCBFU0NBUEUga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcXG4gICAgICAvLyBJZiBpbnB1dC90ZXh0YXJlYSAmJiBpZiBrZXkgaXMgb3RoZXIgdGhhbiBFU0NBUEUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxcbiAgICAgIGNvbnN0IGlzSW5wdXQgPSAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKTtcXG4gICAgICBjb25zdCBpc0VzY2FwZUV2ZW50ID0gZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZJDI7XFxuICAgICAgY29uc3QgaXNVcE9yRG93bkV2ZW50ID0gW0FSUk9XX1VQX0tFWSQxLCBBUlJPV19ET1dOX0tFWSQxXS5pbmNsdWRlcyhldmVudC5rZXkpO1xcblxcbiAgICAgIGlmICghaXNVcE9yRG93bkV2ZW50ICYmICFpc0VzY2FwZUV2ZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc0lucHV0ICYmICFpc0VzY2FwZUV2ZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgY29uc3QgZ2V0VG9nZ2xlQnV0dG9uID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBldmVudC5kZWxlZ2F0ZVRhcmdldC5wYXJlbnROb2RlKTtcXG4gICAgICBjb25zdCBpbnN0YW5jZSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UoZ2V0VG9nZ2xlQnV0dG9uKTtcXG5cXG4gICAgICBpZiAoaXNVcE9yRG93bkV2ZW50KSB7XFxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcXG5cXG4gICAgICAgIGluc3RhbmNlLl9zZWxlY3RNZW51SXRlbShldmVudCk7XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpbnN0YW5jZS5faXNTaG93bigpKSB7XFxuICAgICAgICAvLyBlbHNlIGlzIGVzY2FwZSBhbmQgd2UgY2hlY2sgaWYgaXQgaXMgc2hvd25cXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xcbiAgICAgICAgZ2V0VG9nZ2xlQnV0dG9uLmZvY3VzKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfTUVOVSwgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgRHJvcGRvd24uY2xlYXJNZW51cyk7XFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWVVQX0RBVEFfQVBJLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykudG9nZ2xlKCk7XFxuICB9KTtcXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihEcm9wZG93bik7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHV0aWwvc2Nyb2xsQmFyLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XFxuICBjb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XFxuICBjb25zdCBQUk9QRVJUWV9QQURESU5HID0gJ3BhZGRpbmctcmlnaHQnO1xcbiAgY29uc3QgUFJPUEVSVFlfTUFSR0lOID0gJ21hcmdpbi1yaWdodCc7XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgU2Nyb2xsQmFySGVscGVyIHtcXG4gICAgY29uc3RydWN0b3IoKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudCA9IGRvY3VtZW50LmJvZHk7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIGdldFdpZHRoKCkge1xcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvaW5uZXJXaWR0aCN1c2FnZV9ub3Rlc1xcbiAgICAgIGNvbnN0IGRvY3VtZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XFxuICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnRXaWR0aCk7XFxuICAgIH1cXG5cXG4gICAgaGlkZSgpIHtcXG4gICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcXG5cXG4gICAgICB0aGlzLl9kaXNhYmxlT3ZlckZsb3coKTsgLy8gZ2l2ZSBwYWRkaW5nIHRvIGVsZW1lbnQgdG8gYmFsYW5jZSB0aGUgaGlkZGVuIHNjcm9sbGJhciB3aWR0aFxcblxcblxcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFBST1BFUlRZX1BBRERJTkcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7IC8vIHRyaWNrOiBXZSBhZGp1c3QgcG9zaXRpdmUgcGFkZGluZ1JpZ2h0IGFuZCBuZWdhdGl2ZSBtYXJnaW5SaWdodCB0byBzdGlja3ktdG9wIGVsZW1lbnRzIHRvIGtlZXAgc2hvd2luZyBmdWxsd2lkdGhcXG5cXG5cXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xcblxcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX1NUSUNLWV9DT05URU5ULCBQUk9QRVJUWV9NQVJHSU4sIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgLSB3aWR0aCk7XFxuICAgIH1cXG5cXG4gICAgcmVzZXQoKSB7XFxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcXG5cXG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFBST1BFUlRZX1BBRERJTkcpO1xcblxcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORyk7XFxuXFxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOKTtcXG4gICAgfVxcblxcbiAgICBpc092ZXJmbG93aW5nKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX2Rpc2FibGVPdmVyRmxvdygpIHtcXG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XFxuICAgIH1cXG5cXG4gICAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5LCBjYWxsYmFjaykge1xcbiAgICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xcblxcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XFxuICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxiYXJXaWR0aCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcXG5cXG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRWYWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XFxuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIGAke2NhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpfXB4YCk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBtYW5pcHVsYXRpb25DYWxsQmFjayk7XFxuICAgIH1cXG5cXG4gICAgX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpIHtcXG4gICAgICBjb25zdCBhY3R1YWxWYWx1ZSA9IGVsZW1lbnQuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShzdHlsZVByb3BlcnR5KTtcXG5cXG4gICAgICBpZiAoYWN0dWFsVmFsdWUpIHtcXG4gICAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSwgYWN0dWFsVmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wZXJ0eSkge1xcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XFxuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7IC8vIFdlIG9ubHkgd2FudCB0byByZW1vdmUgdGhlIHByb3BlcnR5IGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGA7IHRoZSB2YWx1ZSBjYW4gYWxzbyBiZSB6ZXJvXFxuXFxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcXG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShzdHlsZVByb3BlcnR5KTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xcbiAgICB9XFxuXFxuICAgIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHNlbGVjdG9yLCBjYWxsQmFjaykge1xcbiAgICAgIGlmIChpc0VsZW1lbnQoc2VsZWN0b3IpKSB7XFxuICAgICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoY29uc3Qgc2VsIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpKSB7XFxuICAgICAgICBjYWxsQmFjayhzZWwpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL2JhY2tkcm9wLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUkOSA9ICdiYWNrZHJvcCc7XFxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNCA9ICdmYWRlJztcXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ1ID0gJ3Nob3cnO1xcbiAgY29uc3QgRVZFTlRfTU9VU0VET1dOID0gYG1vdXNlZG93bi5icy4ke05BTUUkOX1gO1xcbiAgY29uc3QgRGVmYXVsdCQ4ID0ge1xcbiAgICBjbGFzc05hbWU6ICdtb2RhbC1iYWNrZHJvcCcsXFxuICAgIGNsaWNrQ2FsbGJhY2s6IG51bGwsXFxuICAgIGlzQW5pbWF0ZWQ6IGZhbHNlLFxcbiAgICBpc1Zpc2libGU6IHRydWUsXFxuICAgIC8vIGlmIGZhbHNlLCB3ZSB1c2UgdGhlIGJhY2tkcm9wIGhlbHBlciB3aXRob3V0IGFkZGluZyBhbnkgZWxlbWVudCB0byB0aGUgZG9tXFxuICAgIHJvb3RFbGVtZW50OiAnYm9keScgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xcblxcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRUeXBlJDggPSB7XFxuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXFxuICAgIGNsaWNrQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxcbiAgICBpc0FuaW1hdGVkOiAnYm9vbGVhbicsXFxuICAgIGlzVmlzaWJsZTogJ2Jvb2xlYW4nLFxcbiAgICByb290RWxlbWVudDogJyhlbGVtZW50fHN0cmluZyknXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIEJhY2tkcm9wIGV4dGVuZHMgQ29uZmlnIHtcXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XFxuICAgICAgc3VwZXIoKTtcXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XFxuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkODtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ4O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSQ5O1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBzaG93KGNhbGxiYWNrKSB7XFxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XFxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fYXBwZW5kKCk7XFxuXFxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcXG4gICAgICAgIHJlZmxvdyhlbGVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ1KTtcXG5cXG4gICAgICB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGhpZGUoY2FsbGJhY2spIHtcXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNSk7XFxuXFxuICAgICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XFxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgaWYgKCF0aGlzLl9pc0FwcGVuZGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xcblxcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9nZXRFbGVtZW50KCkge1xcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudCkge1xcbiAgICAgICAgY29uc3QgYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcXG4gICAgICAgIGJhY2tkcm9wLmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWU7XFxuXFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpIHtcXG4gICAgICAgICAgYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkNCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50ID0gYmFja2Ryb3A7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xcbiAgICB9XFxuXFxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xcbiAgICAgIC8vIHVzZSBnZXRFbGVtZW50KCkgd2l0aCB0aGUgZGVmYXVsdCBcXFwiYm9keVxcXCIgdG8gZ2V0IGEgZnJlc2ggRWxlbWVudCBvbiBlYWNoIGluc3RhbnRpYXRpb25cXG4gICAgICBjb25maWcucm9vdEVsZW1lbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5yb290RWxlbWVudCk7XFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfYXBwZW5kKCkge1xcbiAgICAgIGlmICh0aGlzLl9pc0FwcGVuZGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XFxuXFxuICAgICAgdGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcXG5cXG4gICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOLCAoKSA9PiB7XFxuICAgICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLl9pc0FwcGVuZGVkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBfZW11bGF0ZUFuaW1hdGlvbihjYWxsYmFjaykge1xcbiAgICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIHRoaXMuX2dldEVsZW1lbnQoKSwgdGhpcy5fY29uZmlnLmlzQW5pbWF0ZWQpO1xcbiAgICB9XFxuXFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHV0aWwvZm9jdXN0cmFwLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUkOCA9ICdmb2N1c3RyYXAnO1xcbiAgY29uc3QgREFUQV9LRVkkNSA9ICdicy5mb2N1c3RyYXAnO1xcbiAgY29uc3QgRVZFTlRfS0VZJDUgPSBgLiR7REFUQV9LRVkkNX1gO1xcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiQyID0gYGZvY3VzaW4ke0VWRU5UX0tFWSQ1fWA7XFxuICBjb25zdCBFVkVOVF9LRVlET1dOX1RBQiA9IGBrZXlkb3duLnRhYiR7RVZFTlRfS0VZJDV9YDtcXG4gIGNvbnN0IFRBQl9LRVkgPSAnVGFiJztcXG4gIGNvbnN0IFRBQl9OQVZfRk9SV0FSRCA9ICdmb3J3YXJkJztcXG4gIGNvbnN0IFRBQl9OQVZfQkFDS1dBUkQgPSAnYmFja3dhcmQnO1xcbiAgY29uc3QgRGVmYXVsdCQ3ID0ge1xcbiAgICBhdXRvZm9jdXM6IHRydWUsXFxuICAgIHRyYXBFbGVtZW50OiBudWxsIC8vIFRoZSBlbGVtZW50IHRvIHRyYXAgZm9jdXMgaW5zaWRlIG9mXFxuXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkNyA9IHtcXG4gICAgYXV0b2ZvY3VzOiAnYm9vbGVhbicsXFxuICAgIHRyYXBFbGVtZW50OiAnZWxlbWVudCdcXG4gIH07XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgRm9jdXNUcmFwIGV4dGVuZHMgQ29uZmlnIHtcXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XFxuICAgICAgc3VwZXIoKTtcXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBudWxsO1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0JDc7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNztcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgICAgcmV0dXJuIE5BTUUkODtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgYWN0aXZhdGUoKSB7XFxuICAgICAgaWYgKHRoaXMuX2lzQWN0aXZlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2ZvY3VzKSB7XFxuICAgICAgICB0aGlzLl9jb25maWcudHJhcEVsZW1lbnQuZm9jdXMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZJDUpOyAvLyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGZvY3VzIGxvb3BcXG5cXG4gICAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0ZPQ1VTSU4kMiwgZXZlbnQgPT4gdGhpcy5faGFuZGxlRm9jdXNpbihldmVudCkpO1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9UQUIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUtleWRvd24oZXZlbnQpKTtcXG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgZGVhY3RpdmF0ZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2lzQWN0aXZlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9mZihkb2N1bWVudCwgRVZFTlRfS0VZJDUpO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX2hhbmRsZUZvY3VzaW4oZXZlbnQpIHtcXG4gICAgICBjb25zdCB7XFxuICAgICAgICB0cmFwRWxlbWVudFxcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XFxuXFxuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gZG9jdW1lbnQgfHwgZXZlbnQudGFyZ2V0ID09PSB0cmFwRWxlbWVudCB8fCB0cmFwRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZm9jdXNhYmxlQ2hpbGRyZW4odHJhcEVsZW1lbnQpO1xcblxcbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHRyYXBFbGVtZW50LmZvY3VzKCk7XFxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID09PSBUQUJfTkFWX0JBQ0tXQVJEKSB7XFxuICAgICAgICBlbGVtZW50c1tlbGVtZW50cy5sZW5ndGggLSAxXS5mb2N1cygpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtZW50c1swXS5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfaGFuZGxlS2V5ZG93bihldmVudCkge1xcbiAgICAgIGlmIChldmVudC5rZXkgIT09IFRBQl9LRVkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9IGV2ZW50LnNoaWZ0S2V5ID8gVEFCX05BVl9CQUNLV0FSRCA6IFRBQl9OQVZfRk9SV0FSRDtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBtb2RhbC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJDcgPSAnbW9kYWwnO1xcbiAgY29uc3QgREFUQV9LRVkkNCA9ICdicy5tb2RhbCc7XFxuICBjb25zdCBFVkVOVF9LRVkkNCA9IGAuJHtEQVRBX0tFWSQ0fWA7XFxuICBjb25zdCBEQVRBX0FQSV9LRVkkMiA9ICcuZGF0YS1hcGknO1xcbiAgY29uc3QgRVNDQVBFX0tFWSQxID0gJ0VzY2FwZSc7XFxuICBjb25zdCBFVkVOVF9ISURFJDQgPSBgaGlkZSR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEJDEgPSBgaGlkZVByZXZlbnRlZCR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ0ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX1NIT1ckNCA9IGBzaG93JHtFVkVOVF9LRVkkNH1gO1xcbiAgY29uc3QgRVZFTlRfU0hPV04kNCA9IGBzaG93biR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX1JFU0laRSQxID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTID0gYG1vdXNlZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiA9IGBjbGljayR7RVZFTlRfS0VZJDR9JHtEQVRBX0FQSV9LRVkkMn1gO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9PUEVOID0gJ21vZGFsLW9wZW4nO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDMgPSAnZmFkZSc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNCA9ICdzaG93JztcXG4gIGNvbnN0IENMQVNTX05BTUVfU1RBVElDID0gJ21vZGFsLXN0YXRpYyc7XFxuICBjb25zdCBPUEVOX1NFTEVDVE9SJDEgPSAnLm1vZGFsLnNob3cnO1xcbiAgY29uc3QgU0VMRUNUT1JfRElBTE9HID0gJy5tb2RhbC1kaWFsb2cnO1xcbiAgY29uc3QgU0VMRUNUT1JfTU9EQUxfQk9EWSA9ICcubW9kYWwtYm9keSc7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwibW9kYWxcXFwiXSc7XFxuICBjb25zdCBEZWZhdWx0JDYgPSB7XFxuICAgIGJhY2tkcm9wOiB0cnVlLFxcbiAgICBmb2N1czogdHJ1ZSxcXG4gICAga2V5Ym9hcmQ6IHRydWVcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSQ2ID0ge1xcbiAgICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxcbiAgICBmb2N1czogJ2Jvb2xlYW4nLFxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XFxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XFxuICAgICAgdGhpcy5fZGlhbG9nID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ESUFMT0csIHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XFxuICAgICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpO1xcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9zY3JvbGxCYXIgPSBuZXcgU2Nyb2xsQmFySGVscGVyKCk7XFxuXFxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCQ2O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDY7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJDc7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcXG4gICAgfVxcblxcbiAgICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0XFxuICAgICAgfSk7XFxuXFxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKTtcXG5cXG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9PUEVOKTtcXG5cXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcXG5cXG4gICAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKTtcXG4gICAgfVxcblxcbiAgICBoaWRlKCkge1xcbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ0KTtcXG5cXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5faGlkZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XFxuICAgIH1cXG5cXG4gICAgZGlzcG9zZSgpIHtcXG4gICAgICBmb3IgKGNvbnN0IGh0bWxFbGVtZW50IG9mIFt3aW5kb3csIHRoaXMuX2RpYWxvZ10pIHtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vZmYoaHRtbEVsZW1lbnQsIEVWRU5UX0tFWSQ0KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xcblxcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XFxuXFxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xcbiAgICB9XFxuXFxuICAgIGhhbmRsZVVwZGF0ZSgpIHtcXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XFxuICAgICAgcmV0dXJuIG5ldyBCYWNrZHJvcCh7XFxuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSxcXG4gICAgICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZSxcXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRoaXMuX2lzQW5pbWF0ZWQoKVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xcbiAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcXG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgICAvLyB0cnkgdG8gYXBwZW5kIGR5bmFtaWMgbW9kYWxcXG4gICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5fZWxlbWVudCkpIHtcXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLW1vZGFsJywgdHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xcbiAgICAgIGNvbnN0IG1vZGFsQm9keSA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfTU9EQUxfQk9EWSwgdGhpcy5fZGlhbG9nKTtcXG5cXG4gICAgICBpZiAobW9kYWxCb2R5KSB7XFxuICAgICAgICBtb2RhbEJvZHkuc2Nyb2xsVG9wID0gMDtcXG4gICAgICB9XFxuXFxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNCk7XFxuXFxuICAgICAgY29uc3QgdHJhbnNpdGlvbkNvbXBsZXRlID0gKCkgPT4ge1xcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNCwge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0XFxuICAgICAgICB9KTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2sodHJhbnNpdGlvbkNvbXBsZXRlLCB0aGlzLl9kaWFsb2csIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XFxuICAgIH1cXG5cXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MkMSwgZXZlbnQgPT4ge1xcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gRVNDQVBFX0tFWSQxKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcXG4gICAgICB9KTtcXG4gICAgICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUkMSwgKCkgPT4ge1xcbiAgICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgIXRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xcbiAgICAgICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcXG4gICAgICAgICAgLy8gY2xpY2sgaXMgaW5zaWRlIG1vZGFsLWRpYWxvZ1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xcbiAgICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XFxuXFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgX2hpZGVNb2RhbCgpIHtcXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xcblxcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKCkgPT4ge1xcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XFxuXFxuICAgICAgICB0aGlzLl9yZXNldEFkanVzdG1lbnRzKCk7XFxuXFxuICAgICAgICB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ0KTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBfaXNBbmltYXRlZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDMpO1xcbiAgICB9XFxuXFxuICAgIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEJDEpO1xcblxcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuICAgICAgY29uc3QgaW5pdGlhbE92ZXJmbG93WSA9IHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZOyAvLyByZXR1cm4gaWYgdGhlIGZvbGxvd2luZyBiYWNrZ3JvdW5kIHRyYW5zaXRpb24gaGFzbid0IHlldCBjb21wbGV0ZWRcXG5cXG4gICAgICBpZiAoaW5pdGlhbE92ZXJmbG93WSA9PT0gJ2hpZGRlbicgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TVEFUSUMpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TVEFUSUMpO1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU1RBVElDKTtcXG5cXG4gICAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IGluaXRpYWxPdmVyZmxvd1k7XFxuICAgICAgICB9LCB0aGlzLl9kaWFsb2cpO1xcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xcbiAgICB9XFxuICAgIC8qKlxcbiAgICAgKiBUaGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xcbiAgICAgKi9cXG5cXG5cXG4gICAgX2FkanVzdERpYWxvZygpIHtcXG4gICAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XFxuXFxuICAgICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKTtcXG5cXG4gICAgICBjb25zdCBpc0JvZHlPdmVyZmxvd2luZyA9IHNjcm9sbGJhcldpZHRoID4gMDtcXG5cXG4gICAgICBpZiAoaXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XFxuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGlzUlRMKCkgPyAncGFkZGluZ1JpZ2h0JyA6ICdwYWRkaW5nTGVmdCc7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gJyc7XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXShyZWxhdGVkVGFyZ2V0KTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxcbiAgICovXFxuXFxuXFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xcblxcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcblxcbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfU0hPVyQ0LCBzaG93RXZlbnQgPT4ge1xcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgLy8gb25seSByZWdpc3RlciBmb2N1cyByZXN0b3JlciBpZiBtb2RhbCB3aWxsIGFjdHVhbGx5IGdldCBzaG93blxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDQsICgpID0+IHtcXG4gICAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcXG4gICAgICAgICAgdGhpcy5mb2N1cygpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9KTsgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBtb2RhbCB0b2dnbGVyIHdoaWxlIGFub3RoZXIgb25lIGlzIG9wZW5cXG5cXG4gICAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IkMSk7XFxuXFxuICAgIGlmIChhbHJlYWR5T3Blbikge1xcbiAgICAgIE1vZGFsLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcXG4gICAgZGF0YS50b2dnbGUodGhpcyk7XFxuICB9KTtcXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKE1vZGFsKTtcXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihNb2RhbCk7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IG9mZmNhbnZhcy5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJDYgPSAnb2ZmY2FudmFzJztcXG4gIGNvbnN0IERBVEFfS0VZJDMgPSAnYnMub2ZmY2FudmFzJztcXG4gIGNvbnN0IEVWRU5UX0tFWSQzID0gYC4ke0RBVEFfS0VZJDN9YDtcXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQxID0gJy5kYXRhLWFwaSc7XFxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xcbiAgY29uc3QgRVNDQVBFX0tFWSA9ICdFc2NhcGUnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDMgPSAnc2hvdyc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NIT1dJTkckMSA9ICdzaG93aW5nJztcXG4gIGNvbnN0IENMQVNTX05BTUVfSElESU5HID0gJ2hpZGluZyc7XFxuICBjb25zdCBDTEFTU19OQU1FX0JBQ0tEUk9QID0gJ29mZmNhbnZhcy1iYWNrZHJvcCc7XFxuICBjb25zdCBPUEVOX1NFTEVDVE9SID0gJy5vZmZjYW52YXMuc2hvdyc7XFxuICBjb25zdCBFVkVOVF9TSE9XJDMgPSBgc2hvdyR7RVZFTlRfS0VZJDN9YDtcXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDMgPSBgc2hvd24ke0VWRU5UX0tFWSQzfWA7XFxuICBjb25zdCBFVkVOVF9ISURFJDMgPSBgaGlkZSR7RVZFTlRfS0VZJDN9YDtcXG4gIGNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQzfWA7XFxuICBjb25zdCBFVkVOVF9ISURERU4kMyA9IGBoaWRkZW4ke0VWRU5UX0tFWSQzfWA7XFxuICBjb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVkkM31gO1xcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IGBjbGljayR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDN9YDtcXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEgPSAnW2RhdGEtYnMtdG9nZ2xlPVxcXCJvZmZjYW52YXNcXFwiXSc7XFxuICBjb25zdCBEZWZhdWx0JDUgPSB7XFxuICAgIGJhY2tkcm9wOiB0cnVlLFxcbiAgICBrZXlib2FyZDogdHJ1ZSxcXG4gICAgc2Nyb2xsOiBmYWxzZVxcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRUeXBlJDUgPSB7XFxuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXFxuICAgIHNjcm9sbDogJ2Jvb2xlYW4nXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIE9mZmNhbnZhcyBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcXG5cXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0JDU7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNTtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgICAgcmV0dXJuIE5BTUUkNjtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuXFxuICAgIHNob3cocmVsYXRlZFRhcmdldCkge1xcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMywge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcXG5cXG4gICAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XFxuXFxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XFxuICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkuaGlkZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkckMSk7XFxuXFxuICAgICAgY29uc3QgY29tcGxldGVDYWxsQmFjayA9ICgpID0+IHtcXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCB8fCB0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcXG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDMpO1xcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyQxKTtcXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDMsIHtcXG4gICAgICAgICAgcmVsYXRlZFRhcmdldFxcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xcbiAgICB9XFxuXFxuICAgIGhpZGUoKSB7XFxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkMyk7XFxuXFxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5ibHVyKCk7XFxuXFxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJRElORyk7XFxuXFxuICAgICAgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xcblxcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMsIENMQVNTX05BTUVfSElESU5HKTtcXG5cXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xcblxcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XFxuICAgICAgICAgIG5ldyBTY3JvbGxCYXJIZWxwZXIoKS5yZXNldCgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDMpO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxiYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICBkaXNwb3NlKCkge1xcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcXG5cXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xcblxcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XFxuICAgICAgY29uc3QgY2xpY2tDYWxsYmFjayA9ICgpID0+IHtcXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XFxuICAgICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfTsgLy8gJ3N0YXRpYycgb3B0aW9uIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0cnVlLCBhbmQgYm9vbGVhbnMgd2lsbCBrZWVwIHRoZWlyIHZhbHVlXFxuXFxuXFxuICAgICAgY29uc3QgaXNWaXNpYmxlID0gQm9vbGVhbih0aGlzLl9jb25maWcuYmFja2Ryb3ApO1xcbiAgICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xcbiAgICAgICAgY2xhc3NOYW1lOiBDTEFTU19OQU1FX0JBQ0tEUk9QLFxcbiAgICAgICAgaXNWaXNpYmxlLFxcbiAgICAgICAgaXNBbmltYXRlZDogdHJ1ZSxcXG4gICAgICAgIHJvb3RFbGVtZW50OiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUsXFxuICAgICAgICBjbGlja0NhbGxiYWNrOiBpc1Zpc2libGUgPyBjbGlja0NhbGxiYWNrIDogbnVsbFxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIF9pbml0aWFsaXplRm9jdXNUcmFwKCkge1xcbiAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcXG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOX0RJU01JU1MsIGV2ZW50ID0+IHtcXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLmhpZGUoKTtcXG4gICAgICB9KTtcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxcbiAgICovXFxuXFxuXFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xcblxcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDMsICgpID0+IHtcXG4gICAgICAvLyBmb2N1cyBvbiB0cmlnZ2VyIHdoZW4gaXQgaXMgY2xvc2VkXFxuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xcbiAgICAgICAgdGhpcy5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfSk7IC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgYSB0b2dnbGVyIG9mIGFuIG9mZmNhbnZhcywgd2hpbGUgYW5vdGhlciBpcyBvcGVuXFxuXFxuICAgIGNvbnN0IGFscmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKTtcXG5cXG4gICAgaWYgKGFscmVhZHlPcGVuICYmIGFscmVhZHlPcGVuICE9PSB0YXJnZXQpIHtcXG4gICAgICBPZmZjYW52YXMuZ2V0SW5zdGFuY2UoYWxyZWFkeU9wZW4pLmhpZGUoKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcXG4gICAgZGF0YS50b2dnbGUodGhpcyk7XFxuICB9KTtcXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMiwgKCkgPT4ge1xcbiAgICBmb3IgKGNvbnN0IHNlbGVjdG9yIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoT1BFTl9TRUxFQ1RPUikpIHtcXG4gICAgICBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZShzZWxlY3Rvcikuc2hvdygpO1xcbiAgICB9XFxuICB9KTtcXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSwgKCkgPT4ge1xcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZCgnW2FyaWEtbW9kYWxdW2NsYXNzKj1zaG93XVtjbGFzcyo9b2ZmY2FudmFzLV0nKSkge1xcbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XFxuICAgICAgICBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KS5oaWRlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKE9mZmNhbnZhcyk7XFxuICAvKipcXG4gICAqIGpRdWVyeVxcbiAgICovXFxuXFxuICBkZWZpbmVKUXVlcnlQbHVnaW4oT2ZmY2FudmFzKTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogdXRpbC9zYW5pdGl6ZXIuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgY29uc3QgdXJpQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXSk7XFxuICBjb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXFxcdy1dKiQvaTtcXG4gIC8qKlxcbiAgICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBhIGNvbW1vbmx5IHVzZWZ1bCBzdWJzZXQgb2YgVVJMcyB0aGF0IGFyZSBzYWZlLlxcbiAgICpcXG4gICAqIFNob3V0LW91dCB0byBBbmd1bGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xMi4yLngvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcXG4gICAqL1xcblxcbiAgY29uc3QgU0FGRV9VUkxfUEFUVEVSTiA9IC9eKD86KD86aHR0cHM/fG1haWx0b3xmdHB8dGVsfGZpbGV8c21zKTp8W14jJi86P10qKD86WyMvP118JCkpL2k7XFxuICAvKipcXG4gICAqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvIHR5cGVzLlxcbiAgICpcXG4gICAqIFNob3V0LW91dCB0byBBbmd1bGFyIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi8xMi4yLngvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcXG4gICAqL1xcblxcbiAgY29uc3QgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFxcXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXFxcZCsvYS16XSs9KiQvaTtcXG5cXG4gIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkgPT4ge1xcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgIGlmIChhbGxvd2VkQXR0cmlidXRlTGlzdC5pbmNsdWRlcyhhdHRyaWJ1dGVOYW1lKSkge1xcbiAgICAgIGlmICh1cmlBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGVOYW1lKSkge1xcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oU0FGRV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpIHx8IERBVEFfVVJMX1BBVFRFUk4udGVzdChhdHRyaWJ1dGUubm9kZVZhbHVlKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9IC8vIENoZWNrIGlmIGEgcmVndWxhciBleHByZXNzaW9uIHZhbGlkYXRlcyB0aGUgYXR0cmlidXRlLlxcblxcblxcbiAgICByZXR1cm4gYWxsb3dlZEF0dHJpYnV0ZUxpc3QuZmlsdGVyKGF0dHJpYnV0ZVJlZ2V4ID0+IGF0dHJpYnV0ZVJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKS5zb21lKHJlZ2V4ID0+IHJlZ2V4LnRlc3QoYXR0cmlidXRlTmFtZSkpO1xcbiAgfTtcXG5cXG4gIGNvbnN0IERlZmF1bHRBbGxvd2xpc3QgPSB7XFxuICAgIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXFxuICAgICcqJzogWydjbGFzcycsICdkaXInLCAnaWQnLCAnbGFuZycsICdyb2xlJywgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTl0sXFxuICAgIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXFxuICAgIGFyZWE6IFtdLFxcbiAgICBiOiBbXSxcXG4gICAgYnI6IFtdLFxcbiAgICBjb2w6IFtdLFxcbiAgICBjb2RlOiBbXSxcXG4gICAgZGl2OiBbXSxcXG4gICAgZW06IFtdLFxcbiAgICBocjogW10sXFxuICAgIGgxOiBbXSxcXG4gICAgaDI6IFtdLFxcbiAgICBoMzogW10sXFxuICAgIGg0OiBbXSxcXG4gICAgaDU6IFtdLFxcbiAgICBoNjogW10sXFxuICAgIGk6IFtdLFxcbiAgICBpbWc6IFsnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXFxuICAgIGxpOiBbXSxcXG4gICAgb2w6IFtdLFxcbiAgICBwOiBbXSxcXG4gICAgcHJlOiBbXSxcXG4gICAgczogW10sXFxuICAgIHNtYWxsOiBbXSxcXG4gICAgc3BhbjogW10sXFxuICAgIHN1YjogW10sXFxuICAgIHN1cDogW10sXFxuICAgIHN0cm9uZzogW10sXFxuICAgIHU6IFtdLFxcbiAgICB1bDogW11cXG4gIH07XFxuICBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZ1bmN0aW9uKSB7XFxuICAgIGlmICghdW5zYWZlSHRtbC5sZW5ndGgpIHtcXG4gICAgICByZXR1cm4gdW5zYWZlSHRtbDtcXG4gICAgfVxcblxcbiAgICBpZiAoc2FuaXRpemVGdW5jdGlvbiAmJiB0eXBlb2Ygc2FuaXRpemVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHJldHVybiBzYW5pdGl6ZUZ1bmN0aW9uKHVuc2FmZUh0bWwpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XFxuICAgIGNvbnN0IGNyZWF0ZWREb2N1bWVudCA9IGRvbVBhcnNlci5wYXJzZUZyb21TdHJpbmcodW5zYWZlSHRtbCwgJ3RleHQvaHRtbCcpO1xcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdLmNvbmNhdCguLi5jcmVhdGVkRG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xcblxcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcXG4gICAgICBjb25zdCBlbGVtZW50TmFtZSA9IGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcXG5cXG4gICAgICBpZiAoIU9iamVjdC5rZXlzKGFsbG93TGlzdCkuaW5jbHVkZXMoZWxlbWVudE5hbWUpKSB7XFxuICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBbXS5jb25jYXQoLi4uZWxlbWVudC5hdHRyaWJ1dGVzKTtcXG4gICAgICBjb25zdCBhbGxvd2VkQXR0cmlidXRlcyA9IFtdLmNvbmNhdChhbGxvd0xpc3RbJyonXSB8fCBbXSwgYWxsb3dMaXN0W2VsZW1lbnROYW1lXSB8fCBbXSk7XFxuXFxuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlTGlzdCkge1xcbiAgICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZXMpKSB7XFxuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUw7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHV0aWwvdGVtcGxhdGUtZmFjdG9yeS5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJDUgPSAnVGVtcGxhdGVGYWN0b3J5JztcXG4gIGNvbnN0IERlZmF1bHQkNCA9IHtcXG4gICAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxcbiAgICBjb250ZW50OiB7fSxcXG4gICAgLy8geyBzZWxlY3RvciA6IHRleHQgLCAgc2VsZWN0b3IyIDogdGV4dDIgLCB9XFxuICAgIGV4dHJhQ2xhc3M6ICcnLFxcbiAgICBodG1sOiBmYWxzZSxcXG4gICAgc2FuaXRpemU6IHRydWUsXFxuICAgIHNhbml0aXplRm46IG51bGwsXFxuICAgIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkNCA9IHtcXG4gICAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcXG4gICAgY29udGVudDogJ29iamVjdCcsXFxuICAgIGV4dHJhQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXFxuICAgIGh0bWw6ICdib29sZWFuJyxcXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcXG4gICAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXFxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJ1xcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRDb250ZW50VHlwZSA9IHtcXG4gICAgZW50cnk6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb258bnVsbCknLFxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8ZWxlbWVudCknXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIFRlbXBsYXRlRmFjdG9yeSBleHRlbmRzIENvbmZpZyB7XFxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICAgIHN1cGVyKCk7XFxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkNDtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ0O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSQ1O1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBnZXRDb250ZW50KCkge1xcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KS5tYXAoY29uZmlnID0+IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbmZpZykpLmZpbHRlcihCb29sZWFuKTtcXG4gICAgfVxcblxcbiAgICBoYXNDb250ZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRlbnQoKS5sZW5ndGggPiAwO1xcbiAgICB9XFxuXFxuICAgIGNoYW5nZUNvbnRlbnQoY29udGVudCkge1xcbiAgICAgIHRoaXMuX2NoZWNrQ29udGVudChjb250ZW50KTtcXG5cXG4gICAgICB0aGlzLl9jb25maWcuY29udGVudCA9IHsgLi4udGhpcy5fY29uZmlnLmNvbnRlbnQsXFxuICAgICAgICAuLi5jb250ZW50XFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gdGhpcztcXG4gICAgfVxcblxcbiAgICB0b0h0bWwoKSB7XFxuICAgICAgY29uc3QgdGVtcGxhdGVXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgdGVtcGxhdGVXcmFwcGVyLmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUodGhpcy5fY29uZmlnLnRlbXBsYXRlKTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgdGV4dF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnLmNvbnRlbnQpKSB7XFxuICAgICAgICB0aGlzLl9zZXRDb250ZW50KHRlbXBsYXRlV3JhcHBlciwgdGV4dCwgc2VsZWN0b3IpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlV3JhcHBlci5jaGlsZHJlblswXTtcXG5cXG4gICAgICBjb25zdCBleHRyYUNsYXNzID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmV4dHJhQ2xhc3MpO1xcblxcbiAgICAgIGlmIChleHRyYUNsYXNzKSB7XFxuICAgICAgICB0ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKC4uLmV4dHJhQ2xhc3Muc3BsaXQoJyAnKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnKSB7XFxuICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xcblxcbiAgICAgIHRoaXMuX2NoZWNrQ29udGVudChjb25maWcuY29udGVudCk7XFxuICAgIH1cXG5cXG4gICAgX2NoZWNrQ29udGVudChhcmcpIHtcXG4gICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoYXJnKSkge1xcbiAgICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyh7XFxuICAgICAgICAgIHNlbGVjdG9yLFxcbiAgICAgICAgICBlbnRyeTogY29udGVudFxcbiAgICAgICAgfSwgRGVmYXVsdENvbnRlbnRUeXBlKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX3NldENvbnRlbnQodGVtcGxhdGUsIGNvbnRlbnQsIHNlbGVjdG9yKSB7XFxuICAgICAgY29uc3QgdGVtcGxhdGVFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvciwgdGVtcGxhdGUpO1xcblxcbiAgICAgIGlmICghdGVtcGxhdGVFbGVtZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb250ZW50KTtcXG5cXG4gICAgICBpZiAoIWNvbnRlbnQpIHtcXG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5yZW1vdmUoKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzRWxlbWVudChjb250ZW50KSkge1xcbiAgICAgICAgdGhpcy5fcHV0RWxlbWVudEluVGVtcGxhdGUoZ2V0RWxlbWVudChjb250ZW50KSwgdGVtcGxhdGVFbGVtZW50KTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XFxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZShjb250ZW50KTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcXG4gICAgfVxcblxcbiAgICBfbWF5YmVTYW5pdGl6ZShhcmcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnNhbml0aXplID8gc2FuaXRpemVIdG1sKGFyZywgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pIDogYXJnO1xcbiAgICB9XFxuXFxuICAgIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZyh0aGlzKSA6IGFyZztcXG4gICAgfVxcblxcbiAgICBfcHV0RWxlbWVudEluVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVFbGVtZW50KSB7XFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XFxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gJyc7XFxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBlbGVtZW50LnRleHRDb250ZW50O1xcbiAgICB9XFxuXFxuICB9XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHRvb2x0aXAuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSQ0ID0gJ3Rvb2x0aXAnO1xcbiAgY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbJ3Nhbml0aXplJywgJ2FsbG93TGlzdCcsICdzYW5pdGl6ZUZuJ10pO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDIgPSAnZmFkZSc7XFxuICBjb25zdCBDTEFTU19OQU1FX01PREFMID0gJ21vZGFsJztcXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQyID0gJ3Nob3cnO1xcbiAgY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcic7XFxuICBjb25zdCBTRUxFQ1RPUl9NT0RBTCA9IGAuJHtDTEFTU19OQU1FX01PREFMfWA7XFxuICBjb25zdCBFVkVOVF9NT0RBTF9ISURFID0gJ2hpZGUuYnMubW9kYWwnO1xcbiAgY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3Zlcic7XFxuICBjb25zdCBUUklHR0VSX0ZPQ1VTID0gJ2ZvY3VzJztcXG4gIGNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snO1xcbiAgY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJztcXG4gIGNvbnN0IEVWRU5UX0hJREUkMiA9ICdoaWRlJztcXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQyID0gJ2hpZGRlbic7XFxuICBjb25zdCBFVkVOVF9TSE9XJDIgPSAnc2hvdyc7XFxuICBjb25zdCBFVkVOVF9TSE9XTiQyID0gJ3Nob3duJztcXG4gIGNvbnN0IEVWRU5UX0lOU0VSVEVEID0gJ2luc2VydGVkJztcXG4gIGNvbnN0IEVWRU5UX0NMSUNLJDEgPSAnY2xpY2snO1xcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiQxID0gJ2ZvY3VzaW4nO1xcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQkMSA9ICdmb2N1c291dCc7XFxuICBjb25zdCBFVkVOVF9NT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInO1xcbiAgY29uc3QgRVZFTlRfTU9VU0VMRUFWRSA9ICdtb3VzZWxlYXZlJztcXG4gIGNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XFxuICAgIEFVVE86ICdhdXRvJyxcXG4gICAgVE9QOiAndG9wJyxcXG4gICAgUklHSFQ6IGlzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnLFxcbiAgICBCT1RUT006ICdib3R0b20nLFxcbiAgICBMRUZUOiBpc1JUTCgpID8gJ3JpZ2h0JyA6ICdsZWZ0J1xcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHQkMyA9IHtcXG4gICAgYWxsb3dMaXN0OiBEZWZhdWx0QWxsb3dsaXN0LFxcbiAgICBhbmltYXRpb246IHRydWUsXFxuICAgIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcXG4gICAgY29udGFpbmVyOiBmYWxzZSxcXG4gICAgY3VzdG9tQ2xhc3M6ICcnLFxcbiAgICBkZWxheTogMCxcXG4gICAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLFxcbiAgICBodG1sOiBmYWxzZSxcXG4gICAgb2Zmc2V0OiBbMCwgMF0sXFxuICAgIHBsYWNlbWVudDogJ3RvcCcsXFxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcXG4gICAgc2FuaXRpemU6IHRydWUsXFxuICAgIHNhbml0aXplRm46IG51bGwsXFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwXFxcIiByb2xlPVxcXCJ0b29sdGlwXFxcIj4nICsgJzxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxcbiAgICB0aXRsZTogJycsXFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cydcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSQzID0ge1xcbiAgICBhbGxvd0xpc3Q6ICdvYmplY3QnLFxcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcXG4gICAgY29udGFpbmVyOiAnKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pJyxcXG4gICAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXFxuICAgIGRlbGF5OiAnKG51bWJlcnxvYmplY3QpJyxcXG4gICAgZmFsbGJhY2tQbGFjZW1lbnRzOiAnYXJyYXknLFxcbiAgICBodG1sOiAnYm9vbGVhbicsXFxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcXG4gICAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcXG4gICAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXFxuICAgIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXFxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJyxcXG4gICAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcXG4gICAgdHJpZ2dlcjogJ3N0cmluZydcXG4gIH07XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgVG9vbHRpcCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBpZiAodHlwZW9mIFBvcHBlcl9fbmFtZXNwYWNlID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFxcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7IC8vIFByaXZhdGVcXG5cXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcXG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xcbiAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG51bGw7XFxuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7IC8vIFByb3RlY3RlZFxcblxcbiAgICAgIHRoaXMudGlwID0gbnVsbDtcXG5cXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCQzO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDM7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJDQ7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIGVuYWJsZSgpIHtcXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGRpc2FibGUoKSB7XFxuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgdG9nZ2xlRW5hYmxlZCgpIHtcXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xcbiAgICB9XFxuXFxuICAgIHRvZ2dsZShldmVudCkge1xcbiAgICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChldmVudCkge1xcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XFxuXFxuICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2s7XFxuXFxuICAgICAgICBpZiAoY29udGV4dC5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XFxuICAgICAgICAgIGNvbnRleHQuX2VudGVyKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XFxuICAgICAgICB0aGlzLl9sZWF2ZSgpO1xcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbnRlcigpO1xcbiAgICB9XFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XFxuXFxuICAgICAgaWYgKHRoaXMudGlwKSB7XFxuICAgICAgICB0aGlzLnRpcC5yZW1vdmUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xcblxcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgfVxcblxcbiAgICBzaG93KCkge1xcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoISh0aGlzLl9pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9TSE9XJDIpKTtcXG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZmluZFNoYWRvd1Jvb3QodGhpcy5fZWxlbWVudCk7XFxuXFxuICAgICAgY29uc3QgaXNJblRoZURvbSA9IChzaGFkb3dSb290IHx8IHRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCAhaXNJblRoZURvbSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gdG9kbyB2NiByZW1vdmUgdGhpcyBPUiBtYWtlIGl0IG9wdGlvbmFsXFxuXFxuXFxuICAgICAgaWYgKHRoaXMudGlwKSB7XFxuICAgICAgICB0aGlzLnRpcC5yZW1vdmUoKTtcXG4gICAgICAgIHRoaXMudGlwID0gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwLmdldEF0dHJpYnV0ZSgnaWQnKSk7XFxuXFxuICAgICAgY29uc3Qge1xcbiAgICAgICAgY29udGFpbmVyXFxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcXG5cXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XFxuICAgICAgICBjb250YWluZXIuYXBwZW5kKHRpcCk7XFxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9JTlNFUlRFRCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX3BvcHBlciA9IHRoaXMuX2NyZWF0ZVBvcHBlcih0aXApO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMik7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXFxuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXFxuXFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIGNvbnN0IHByZXZpb3VzSG92ZXJTdGF0ZSA9IHRoaXMuX2lzSG92ZXJlZDtcXG4gICAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPV04kMikpO1xcblxcbiAgICAgICAgaWYgKHByZXZpb3VzSG92ZXJTdGF0ZSkge1xcbiAgICAgICAgICB0aGlzLl9sZWF2ZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XFxuICAgIH1cXG5cXG4gICAgaGlkZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24oKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9ISURFJDIpKTtcXG5cXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xcblxcbiAgICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQyKTsgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxcblxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9DTElDS10gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2U7XFxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xcblxcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xcbiAgICAgICAgaWYgKHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xcbiAgICAgICAgICB0aXAucmVtb3ZlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpO1xcblxcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElEREVOJDIpKTtcXG5cXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xcbiAgICB9XFxuXFxuICAgIHVwZGF0ZSgpIHtcXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XFxuICAgICAgfVxcbiAgICB9IC8vIFByb3RlY3RlZFxcblxcblxcbiAgICBfaXNXaXRoQ29udGVudCgpIHtcXG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXRUaXRsZSgpKTtcXG4gICAgfVxcblxcbiAgICBfZ2V0VGlwRWxlbWVudCgpIHtcXG4gICAgICBpZiAoIXRoaXMudGlwKSB7XFxuICAgICAgICB0aGlzLnRpcCA9IHRoaXMuX2NyZWF0ZVRpcEVsZW1lbnQodGhpcy5fbmV3Q29udGVudCB8fCB0aGlzLl9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcXG4gICAgfVxcblxcbiAgICBfY3JlYXRlVGlwRWxlbWVudChjb250ZW50KSB7XFxuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpLnRvSHRtbCgpOyAvLyB0b2RvOiByZW1vdmUgdGhpcyBjaGVjayBvbiB2NlxcblxcblxcbiAgICAgIGlmICghdGlwKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9GQURFJDIsIENMQVNTX05BTUVfU0hPVyQyKTsgLy8gdG9kbzogb24gdjYgdGhlIGZvbGxvd2luZyBjYW4gYmUgYWNoaWV2ZWQgd2l0aCBDU1Mgb25seVxcblxcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKGBicy0ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXV0b2ApO1xcbiAgICAgIGNvbnN0IHRpcElkID0gZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSkudG9TdHJpbmcoKTtcXG4gICAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcXG5cXG4gICAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XFxuICAgICAgICB0aXAuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkMik7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB0aXA7XFxuICAgIH1cXG5cXG4gICAgc2V0Q29udGVudChjb250ZW50KSB7XFxuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IGNvbnRlbnQ7XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xcbiAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xcblxcbiAgICAgICAgdGhpcy5zaG93KCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkge1xcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZUZhY3RvcnkpIHtcXG4gICAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeS5jaGFuZ2VDb250ZW50KGNvbnRlbnQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBuZXcgVGVtcGxhdGVGYWN0b3J5KHsgLi4udGhpcy5fY29uZmlnLFxcbiAgICAgICAgICAvLyB0aGUgYGNvbnRlbnRgIHZhciBoYXMgdG8gYmUgYWZ0ZXIgYHRoaXMuX2NvbmZpZ2BcXG4gICAgICAgICAgLy8gdG8gb3ZlcnJpZGUgY29uZmlnLmNvbnRlbnQgaW4gY2FzZSBvZiBwb3BvdmVyXFxuICAgICAgICAgIGNvbnRlbnQsXFxuICAgICAgICAgIGV4dHJhQ2xhc3M6IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcylcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVGYWN0b3J5O1xcbiAgICB9XFxuXFxuICAgIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIFtTRUxFQ1RPUl9UT09MVElQX0lOTkVSXTogdGhpcy5fZ2V0VGl0bGUoKVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgX2dldFRpdGxlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcudGl0bGUpIHx8IHRoaXMuX2NvbmZpZy5vcmlnaW5hbFRpdGxlO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCkge1xcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xcbiAgICB9XFxuXFxuICAgIF9pc0FuaW1hdGVkKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcuYW5pbWF0aW9uIHx8IHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMik7XFxuICAgIH1cXG5cXG4gICAgX2lzU2hvd24oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMik7XFxuICAgIH1cXG5cXG4gICAgX2NyZWF0ZVBvcHBlcih0aXApIHtcXG4gICAgICBjb25zdCBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5fY29uZmlnLnBsYWNlbWVudCA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQuY2FsbCh0aGlzLCB0aXAsIHRoaXMuX2VsZW1lbnQpIDogdGhpcy5fY29uZmlnLnBsYWNlbWVudDtcXG4gICAgICBjb25zdCBhdHRhY2htZW50ID0gQXR0YWNobWVudE1hcFtwbGFjZW1lbnQudG9VcHBlckNhc2UoKV07XFxuICAgICAgcmV0dXJuIFBvcHBlcl9fbmFtZXNwYWNlLmNyZWF0ZVBvcHBlcih0aGlzLl9lbGVtZW50LCB0aXAsIHRoaXMuX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSk7XFxuICAgIH1cXG5cXG4gICAgX2dldE9mZnNldCgpIHtcXG4gICAgICBjb25zdCB7XFxuICAgICAgICBvZmZzZXRcXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xcblxcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvZmZzZXQ7XFxuICAgIH1cXG5cXG4gICAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xcbiAgICAgIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnLmNhbGwodGhpcy5fZWxlbWVudCkgOiBhcmc7XFxuICAgIH1cXG5cXG4gICAgX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XFxuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xcbiAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxcbiAgICAgICAgbW9kaWZpZXJzOiBbe1xcbiAgICAgICAgICBuYW1lOiAnZmxpcCcsXFxuICAgICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcXG4gICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcXG4gICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSwge1xcbiAgICAgICAgICBuYW1lOiAnYXJyb3cnLFxcbiAgICAgICAgICBvcHRpb25zOiB7XFxuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgbmFtZTogJ3ByZVNldFBsYWNlbWVudCcsXFxuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXFxuICAgICAgICAgIHBoYXNlOiAnYmVmb3JlTWFpbicsXFxuICAgICAgICAgIGZuOiBkYXRhID0+IHtcXG4gICAgICAgICAgICAvLyBQcmUtc2V0IFBvcHBlcidzIHBsYWNlbWVudCBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gcmVhZCB0aGUgYXJyb3cgc2l6ZXMgcHJvcGVybHkuXFxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBQb3BwZXIgbWl4ZXMgdXAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgZGltZW5zaW9ucyBzaW5jZSB0aGUgaW5pdGlhbCBhcnJvdyBzdHlsZSBpcyBmb3IgdG9wIHBsYWNlbWVudFxcbiAgICAgICAgICAgIHRoaXMuX2dldFRpcEVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCcsIGRhdGEuc3RhdGUucGxhY2VtZW50KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfV1cXG4gICAgICB9O1xcbiAgICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcXG4gICAgICAgIC4uLih0eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcoZGVmYXVsdEJzUG9wcGVyQ29uZmlnKSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcpXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBfc2V0TGlzdGVuZXJzKCkge1xcbiAgICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5fY29uZmlnLnRyaWdnZXIuc3BsaXQoJyAnKTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IHRyaWdnZXIgb2YgdHJpZ2dlcnMpIHtcXG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XFxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9DTElDSyQxKSwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLnRvZ2dsZShldmVudCkpO1xcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xcbiAgICAgICAgICBjb25zdCBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFRU5URVIpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNJTiQxKTtcXG4gICAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VMRUFWRSkgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU09VVCQxKTtcXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50SW4sIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xcblxcbiAgICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcXG5cXG4gICAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c291dCcgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSBjb250ZXh0Ll9lbGVtZW50LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xcblxcbiAgICAgICAgICAgIGNvbnRleHQuX2xlYXZlKCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xcbiAgICAgICAgaWYgKHRoaXMuX2VsZW1lbnQpIHtcXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5zZWxlY3Rvcikge1xcbiAgICAgICAgdGhpcy5fY29uZmlnID0geyAuLi50aGlzLl9jb25maWcsXFxuICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxcbiAgICAgICAgICBzZWxlY3RvcjogJydcXG4gICAgICAgIH07XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9maXhUaXRsZSgpIHtcXG4gICAgICBjb25zdCB0aXRsZSA9IHRoaXMuX2NvbmZpZy5vcmlnaW5hbFRpdGxlO1xcblxcbiAgICAgIGlmICghdGl0bGUpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcpICYmICF0aGlzLl9lbGVtZW50LnRleHRDb250ZW50LnRyaW0oKSkge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xcbiAgICB9XFxuXFxuICAgIF9lbnRlcigpIHtcXG4gICAgICBpZiAodGhpcy5faXNTaG93bigpIHx8IHRoaXMuX2lzSG92ZXJlZCkge1xcbiAgICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gdHJ1ZTtcXG5cXG4gICAgICB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQpIHtcXG4gICAgICAgICAgdGhpcy5zaG93KCk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LnNob3cpO1xcbiAgICB9XFxuXFxuICAgIF9sZWF2ZSgpIHtcXG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgICB9XFxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LmhpZGUpO1xcbiAgICB9XFxuXFxuICAgIF9zZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpIHtcXG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XFxuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCk7XFxuICAgIH1cXG5cXG4gICAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XFxuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fYWN0aXZlVHJpZ2dlcikuaW5jbHVkZXModHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcXG4gICAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIGZvciAoY29uc3QgZGF0YUF0dHJpYnV0ZSBvZiBPYmplY3Qua2V5cyhkYXRhQXR0cmlidXRlcykpIHtcXG4gICAgICAgIGlmIChESVNBTExPV0VEX0FUVFJJQlVURVMuaGFzKGRhdGFBdHRyaWJ1dGUpKSB7XFxuICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cmlidXRlXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgY29uZmlnID0geyAuLi5kYXRhQXR0cmlidXRlcyxcXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcXG4gICAgICB9O1xcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XFxuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xcblxcbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xcblxcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XFxuICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XFxuICAgICAgICBjb25maWcuZGVsYXkgPSB7XFxuICAgICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25maWcub3JpZ2luYWxUaXRsZSA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8ICcnO1xcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRpdGxlID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgY29uZmlnLnRpdGxlID0gY29uZmlnLnRpdGxlLnRvU3RyaW5nKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRlbnQgPT09ICdudW1iZXInKSB7XFxuICAgICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHt9O1xcblxcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuX2NvbmZpZykge1xcbiAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLl9jb25maWdba2V5XSkge1xcbiAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuX2NvbmZpZ1trZXldO1xcbiAgICAgICAgfVxcbiAgICAgIH0gLy8gSW4gdGhlIGZ1dHVyZSBjYW4gYmUgcmVwbGFjZWQgd2l0aDpcXG4gICAgICAvLyBjb25zdCBrZXlzV2l0aERpZmZlcmVudFZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZykuZmlsdGVyKGVudHJ5ID0+IHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtlbnRyeVswXV0gIT09IHRoaXMuX2NvbmZpZ1tlbnRyeVswXV0pXFxuICAgICAgLy8gYE9iamVjdC5mcm9tRW50cmllcyhrZXlzV2l0aERpZmZlcmVudFZhbHVlcylgXFxuXFxuXFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfZGlzcG9zZVBvcHBlcigpIHtcXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xcblxcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gVG9vbHRpcC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gIH1cXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUb29sdGlwKTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogcG9wb3Zlci5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJDMgPSAncG9wb3Zlcic7XFxuICBjb25zdCBTRUxFQ1RPUl9USVRMRSA9ICcucG9wb3Zlci1oZWFkZXInO1xcbiAgY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcXG4gIGNvbnN0IERlZmF1bHQkMiA9IHsgLi4uVG9vbHRpcC5EZWZhdWx0LFxcbiAgICBjb250ZW50OiAnJyxcXG4gICAgb2Zmc2V0OiBbMCwgOF0sXFxuICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyXFxcIiByb2xlPVxcXCJ0b29sdGlwXFxcIj4nICsgJzxkaXYgY2xhc3M9XFxcInBvcG92ZXItYXJyb3dcXFwiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVxcXCJwb3BvdmVyLWhlYWRlclxcXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XFxcInBvcG92ZXItYm9keVxcXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxcbiAgICB0cmlnZ2VyOiAnY2xpY2snXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkMiA9IHsgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcXG4gICAgY29udGVudDogJyhudWxsfHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKSdcXG4gIH07XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgUG9wb3ZlciBleHRlbmRzIFRvb2x0aXAge1xcbiAgICAvLyBHZXR0ZXJzXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCQyO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDI7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJDM7XFxuICAgIH0gLy8gT3ZlcnJpZGVzXFxuXFxuXFxuICAgIF9pc1dpdGhDb250ZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9nZXRUaXRsZSgpIHx8IHRoaXMuX2dldENvbnRlbnQoKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIFtTRUxFQ1RPUl9USVRMRV06IHRoaXMuX2dldFRpdGxlKCksXFxuICAgICAgICBbU0VMRUNUT1JfQ09OVEVOVF06IHRoaXMuX2dldENvbnRlbnQoKVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgX2dldENvbnRlbnQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBQb3BvdmVyLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFBvcG92ZXIpO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBzY3JvbGxzcHkuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSQyID0gJ3Njcm9sbHNweSc7XFxuICBjb25zdCBEQVRBX0tFWSQyID0gJ2JzLnNjcm9sbHNweSc7XFxuICBjb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XFxuICBjb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcXG4gIGNvbnN0IEVWRU5UX0FDVElWQVRFID0gYGFjdGl2YXRlJHtFVkVOVF9LRVkkMn1gO1xcbiAgY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQyfWA7XFxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEgPSBgbG9hZCR7RVZFTlRfS0VZJDJ9JHtEQVRBX0FQSV9LRVl9YDtcXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fSVRFTSA9ICdkcm9wZG93bi1pdGVtJztcXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDEgPSAnYWN0aXZlJztcXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLWJzLXNweT1cXFwic2Nyb2xsXFxcIl0nO1xcbiAgY29uc3QgU0VMRUNUT1JfVEFSR0VUX0xJTktTID0gJ1tocmVmXSc7XFxuICBjb25zdCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCc7XFxuICBjb25zdCBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJztcXG4gIGNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xcbiAgY29uc3QgU0VMRUNUT1JfTElTVF9JVEVNUyA9ICcubGlzdC1ncm91cC1pdGVtJztcXG4gIGNvbnN0IFNFTEVDVE9SX0xJTktfSVRFTVMgPSBgJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX05BVl9JVEVNU30gPiAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gO1xcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV04gPSAnLmRyb3Bkb3duJztcXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxID0gJy5kcm9wZG93bi10b2dnbGUnO1xcbiAgY29uc3QgRGVmYXVsdCQxID0ge1xcbiAgICBvZmZzZXQ6IG51bGwsXFxuICAgIC8vIFRPRE86IHY2IEBkZXByZWNhdGVkLCBrZWVwIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSByZWFzb25zXFxuICAgIHJvb3RNYXJnaW46ICcwcHggMHB4IC0yNSUnLFxcbiAgICBzbW9vdGhTY3JvbGw6IGZhbHNlLFxcbiAgICB0YXJnZXQ6IG51bGxcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSQxID0ge1xcbiAgICBvZmZzZXQ6ICcobnVtYmVyfG51bGwpJyxcXG4gICAgLy8gVE9ETyB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xcbiAgICByb290TWFyZ2luOiAnc3RyaW5nJyxcXG4gICAgc21vb3RoU2Nyb2xsOiAnYm9vbGVhbicsXFxuICAgIHRhcmdldDogJ2VsZW1lbnQnXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIFNjcm9sbFNweSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpOyAvLyB0aGlzLl9lbGVtZW50IGlzIHRoZSBvYnNlcnZhYmxlc0NvbnRhaW5lciBhbmQgY29uZmlnLnRhcmdldCB0aGUgbWVudSBsaW5rcyB3cmFwcGVyXFxuXFxuICAgICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XFxuICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xcbiAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5vdmVyZmxvd1kgPT09ICd2aXNpYmxlJyA/IG51bGwgOiB0aGlzLl9lbGVtZW50O1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XFxuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xcbiAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YSA9IHtcXG4gICAgICAgIHZpc2libGVFbnRyeVRvcDogMCxcXG4gICAgICAgIHBhcmVudFNjcm9sbFRvcDogMFxcbiAgICAgIH07XFxuICAgICAgdGhpcy5yZWZyZXNoKCk7IC8vIGluaXRpYWxpemVcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCQxO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDE7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJDI7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIHJlZnJlc2goKSB7XFxuICAgICAgdGhpcy5faW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpO1xcblxcbiAgICAgIHRoaXMuX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCk7XFxuXFxuICAgICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XFxuICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gdGhpcy5fZ2V0TmV3T2JzZXJ2ZXIoKTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yIChjb25zdCBzZWN0aW9uIG9mIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy52YWx1ZXMoKSkge1xcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZShzZWN0aW9uKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgZGlzcG9zZSgpIHtcXG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XFxuXFxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XFxuICAgICAgLy8gVE9ETzogb24gdjYgdGFyZ2V0IHNob3VsZCBiZSBnaXZlbiBleHBsaWNpdGx5ICYgcmVtb3ZlIHRoZSB7dGFyZ2V0OiAnc3MtdGFyZ2V0J30gY2FzZVxcbiAgICAgIGNvbmZpZy50YXJnZXQgPSBnZXRFbGVtZW50KGNvbmZpZy50YXJnZXQpIHx8IGRvY3VtZW50LmJvZHk7XFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKSB7XFxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc21vb3RoU2Nyb2xsKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyB1bnJlZ2lzdGVyIGFueSBwcmV2aW91cyBsaXN0ZW5lcnNcXG5cXG5cXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLKTtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fY29uZmlnLnRhcmdldCwgRVZFTlRfQ0xJQ0ssIFNFTEVDVE9SX1RBUkdFVF9MSU5LUywgZXZlbnQgPT4ge1xcbiAgICAgICAgY29uc3Qgb2JzZXJ2YWJsZVNlY3Rpb24gPSB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuZ2V0KGV2ZW50LnRhcmdldC5oYXNoKTtcXG5cXG4gICAgICAgIGlmIChvYnNlcnZhYmxlU2VjdGlvbikge1xcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5fcm9vdEVsZW1lbnQgfHwgd2luZG93O1xcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBvYnNlcnZhYmxlU2VjdGlvbi5vZmZzZXRUb3AgLSB0aGlzLl9lbGVtZW50Lm9mZnNldFRvcDtcXG5cXG4gICAgICAgICAgaWYgKHJvb3Quc2Nyb2xsVG8pIHtcXG4gICAgICAgICAgICByb290LnNjcm9sbFRvKHtcXG4gICAgICAgICAgICAgIHRvcDogaGVpZ2h0LFxcbiAgICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9IC8vIENocm9tZSA2MCBkb2Vzbid0IHN1cHBvcnQgYHNjcm9sbFRvYFxcblxcblxcbiAgICAgICAgICByb290LnNjcm9sbFRvcCA9IGhlaWdodDtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBfZ2V0TmV3T2JzZXJ2ZXIoKSB7XFxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcXG4gICAgICAgIHJvb3Q6IHRoaXMuX3Jvb3RFbGVtZW50LFxcbiAgICAgICAgdGhyZXNob2xkOiBbMC4xLCAwLjUsIDFdLFxcbiAgICAgICAgcm9vdE1hcmdpbjogdGhpcy5fZ2V0Um9vdE1hcmdpbigpXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGVudHJpZXMgPT4gdGhpcy5fb2JzZXJ2ZXJDYWxsYmFjayhlbnRyaWVzKSwgb3B0aW9ucyk7XFxuICAgIH0gLy8gVGhlIGxvZ2ljIG9mIHNlbGVjdGlvblxcblxcblxcbiAgICBfb2JzZXJ2ZXJDYWxsYmFjayhlbnRyaWVzKSB7XFxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGVudHJ5ID0+IHRoaXMuX3RhcmdldExpbmtzLmdldChgIyR7ZW50cnkudGFyZ2V0LmlkfWApO1xcblxcbiAgICAgIGNvbnN0IGFjdGl2YXRlID0gZW50cnkgPT4ge1xcbiAgICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcCA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3A7XFxuXFxuICAgICAgICB0aGlzLl9wcm9jZXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcXG4gICAgICB9O1xcblxcbiAgICAgIGNvbnN0IHBhcmVudFNjcm9sbFRvcCA9ICh0aGlzLl9yb290RWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnNjcm9sbFRvcDtcXG4gICAgICBjb25zdCB1c2VyU2Nyb2xsc0Rvd24gPSBwYXJlbnRTY3JvbGxUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcDtcXG4gICAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEucGFyZW50U2Nyb2xsVG9wID0gcGFyZW50U2Nyb2xsVG9wO1xcblxcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xcbiAgICAgICAgaWYgKCFlbnRyeS5pc0ludGVyc2VjdGluZykge1xcbiAgICAgICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xcblxcbiAgICAgICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcXG5cXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb25zdCBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3A7IC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgZG93biwgcGljayB0aGUgYmlnZ2VyIG9mZnNldFRvcFxcblxcbiAgICAgICAgaWYgKHVzZXJTY3JvbGxzRG93biAmJiBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcXG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpOyAvLyBpZiBwYXJlbnQgaXNuJ3Qgc2Nyb2xsZWQsIGxldCdzIGtlZXAgdGhlIGZpcnN0IHZpc2libGUgaXRlbSwgYnJlYWtpbmcgdGhlIGl0ZXJhdGlvblxcblxcbiAgICAgICAgICBpZiAoIXBhcmVudFNjcm9sbFRvcCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH0gLy8gaWYgd2UgYXJlIHNjcm9sbGluZyB1cCwgcGljayB0aGUgc21hbGxlc3Qgb2Zmc2V0VG9wXFxuXFxuXFxuICAgICAgICBpZiAoIXVzZXJTY3JvbGxzRG93biAmJiAhZW50cnlJc0xvd2VyVGhhblByZXZpb3VzKSB7XFxuICAgICAgICAgIGFjdGl2YXRlKGVudHJ5KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gLy8gVE9ETzogdjYgT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gVXNlIHJvb3RNYXJnaW4gb25seVxcblxcblxcbiAgICBfZ2V0Um9vdE1hcmdpbigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLm9mZnNldCA/IGAke3RoaXMuX2NvbmZpZy5vZmZzZXR9cHggMHB4IC0zMCVgIDogdGhpcy5fY29uZmlnLnJvb3RNYXJnaW47XFxuICAgIH1cXG5cXG4gICAgX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKSB7XFxuICAgICAgdGhpcy5fdGFyZ2V0TGlua3MgPSBuZXcgTWFwKCk7XFxuICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xcbiAgICAgIGNvbnN0IHRhcmdldExpbmtzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xcblxcbiAgICAgIGZvciAoY29uc3QgYW5jaG9yIG9mIHRhcmdldExpbmtzKSB7XFxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgYW5jaG9yIGhhcyBhbiBpZCBhbmQgaXMgbm90IGRpc2FibGVkXFxuICAgICAgICBpZiAoIWFuY2hvci5oYXNoIHx8IGlzRGlzYWJsZWQoYW5jaG9yKSkge1xcbiAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShhbmNob3IuaGFzaCwgdGhpcy5fZWxlbWVudCk7IC8vIGVuc3VyZSB0aGF0IHRoZSBvYnNlcnZhYmxlU2VjdGlvbiBleGlzdHMgJiBpcyB2aXNpYmxlXFxuXFxuICAgICAgICBpZiAoaXNWaXNpYmxlKG9ic2VydmFibGVTZWN0aW9uKSkge1xcbiAgICAgICAgICB0aGlzLl90YXJnZXRMaW5rcy5zZXQoYW5jaG9yLmhhc2gsIGFuY2hvcik7XFxuXFxuICAgICAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5zZXQoYW5jaG9yLmhhc2gsIG9ic2VydmFibGVTZWN0aW9uKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX3Byb2Nlc3ModGFyZ2V0KSB7XFxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCA9PT0gdGFyZ2V0KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGhpcy5fY29uZmlnLnRhcmdldCk7XFxuXFxuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0O1xcbiAgICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xcblxcbiAgICAgIHRoaXMuX2FjdGl2YXRlUGFyZW50cyh0YXJnZXQpO1xcblxcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0FDVElWQVRFLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0YXJnZXRcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBfYWN0aXZhdGVQYXJlbnRzKHRhcmdldCkge1xcbiAgICAgIC8vIEFjdGl2YXRlIGRyb3Bkb3duIHBhcmVudHNcXG4gICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0lURU0pKSB7XFxuICAgICAgICBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSQxLCB0YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikpLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoY29uc3QgbGlzdEdyb3VwIG9mIFNlbGVjdG9yRW5naW5lLnBhcmVudHModGFyZ2V0LCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCkpIHtcXG4gICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcXG4gICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIFNlbGVjdG9yRW5naW5lLnByZXYobGlzdEdyb3VwLCBTRUxFQ1RPUl9MSU5LX0lURU1TKSkge1xcbiAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9jbGVhckFjdGl2ZUNsYXNzKHBhcmVudCkge1xcbiAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xcbiAgICAgIGNvbnN0IGFjdGl2ZU5vZGVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChgJHtTRUxFQ1RPUl9UQVJHRVRfTElOS1N9LiR7Q0xBU1NfTkFNRV9BQ1RJVkUkMX1gLCBwYXJlbnQpO1xcblxcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhY3RpdmVOb2Rlcykge1xcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDEpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMSwgKCkgPT4ge1xcbiAgICBmb3IgKGNvbnN0IHNweSBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfU1BZKSkge1xcbiAgICAgIFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHNweSk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFNjcm9sbFNweSk7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHRhYi5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJDEgPSAndGFiJztcXG4gIGNvbnN0IERBVEFfS0VZJDEgPSAnYnMudGFiJztcXG4gIGNvbnN0IEVWRU5UX0tFWSQxID0gYC4ke0RBVEFfS0VZJDF9YDtcXG4gIGNvbnN0IEVWRU5UX0hJREUkMSA9IGBoaWRlJHtFVkVOVF9LRVkkMX1gO1xcbiAgY29uc3QgRVZFTlRfSElEREVOJDEgPSBgaGlkZGVuJHtFVkVOVF9LRVkkMX1gO1xcbiAgY29uc3QgRVZFTlRfU0hPVyQxID0gYHNob3cke0VWRU5UX0tFWSQxfWA7XFxuICBjb25zdCBFVkVOVF9TSE9XTiQxID0gYHNob3duJHtFVkVOVF9LRVkkMX1gO1xcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWSQxfWA7XFxuICBjb25zdCBFVkVOVF9LRVlET1dOID0gYGtleWRvd24ke0VWRU5UX0tFWSQxfWA7XFxuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJID0gYGxvYWQke0VWRU5UX0tFWSQxfWA7XFxuICBjb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnO1xcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZID0gJ0Fycm93UmlnaHQnO1xcbiAgY29uc3QgQVJST1dfVVBfS0VZID0gJ0Fycm93VXAnO1xcbiAgY29uc3QgQVJST1dfRE9XTl9LRVkgPSAnQXJyb3dEb3duJztcXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XFxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkMSA9ICdmYWRlJztcXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQxID0gJ3Nob3cnO1xcbiAgY29uc3QgQ0xBU1NfRFJPUERPV04gPSAnZHJvcGRvd24nO1xcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnO1xcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XFxuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9JVEVNID0gJy5kcm9wZG93bi1pdGVtJztcXG4gIGNvbnN0IE5PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnOm5vdCguZHJvcGRvd24tdG9nZ2xlKSc7XFxuICBjb25zdCBTRUxFQ1RPUl9UQUJfUEFORUwgPSAnLmxpc3QtZ3JvdXAsIC5uYXYsIFtyb2xlPVxcXCJ0YWJsaXN0XFxcIl0nO1xcbiAgY29uc3QgU0VMRUNUT1JfT1VURVIgPSAnLm5hdi1pdGVtLCAubGlzdC1ncm91cC1pdGVtJztcXG4gIGNvbnN0IFNFTEVDVE9SX0lOTkVSID0gYC5uYXYtbGluayR7Tk9UX1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0sIC5saXN0LWdyb3VwLWl0ZW0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCBbcm9sZT1cXFwidGFiXFxcIl0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9YDtcXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwidGFiXFxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cXFwicGlsbFxcXCJdLCBbZGF0YS1icy10b2dnbGU9XFxcImxpc3RcXFwiXSc7IC8vIHRvZG86djY6IGNvdWxkIGJlIG9ubHkgYHRhYmBcXG5cXG4gIGNvbnN0IFNFTEVDVE9SX0lOTkVSX0VMRU0gPSBgJHtTRUxFQ1RPUl9JTk5FUn0sICR7U0VMRUNUT1JfREFUQV9UT0dHTEV9YDtcXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSA9IGAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XFxcInRhYlxcXCJdLCAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XFxcInBpbGxcXFwiXSwgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVxcXCJsaXN0XFxcIl1gO1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XFxuICAgICAgc3VwZXIoZWxlbWVudCk7XFxuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX1RBQl9QQU5FTCk7XFxuXFxuICAgICAgaWYgKCF0aGlzLl9wYXJlbnQpIHtcXG4gICAgICAgIHJldHVybjsgLy8gdG9kbzogc2hvdWxkIFRocm93IGV4Y2VwdGlvbiBvbiB2NlxcbiAgICAgICAgLy8gdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtlbGVtZW50Lm91dGVySFRNTH0gaGFzIG5vdCBhIHZhbGlkIHBhcmVudCAke1NFTEVDVE9SX0lOTkVSX0VMRU19YClcXG4gICAgICB9IC8vIFNldCB1cCBpbml0aWFsIGFyaWEgYXR0cmlidXRlc1xcblxcblxcbiAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzKHRoaXMuX3BhcmVudCwgdGhpcy5fZ2V0Q2hpbGRyZW4oKSk7XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04sIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSQxO1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBzaG93KCkge1xcbiAgICAgIC8vIFNob3dzIHRoaXMgZWxlbSBhbmQgZGVhY3RpdmF0ZSB0aGUgYWN0aXZlIHNpYmxpbmcgaWYgZXhpc3RzXFxuICAgICAgY29uc3QgaW5uZXJFbGVtID0gdGhpcy5fZWxlbWVudDtcXG5cXG4gICAgICBpZiAodGhpcy5fZWxlbUlzQWN0aXZlKGlubmVyRWxlbSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIFNlYXJjaCBmb3IgYWN0aXZlIHRhYiBvbiBzYW1lIHBhcmVudCB0byBkZWFjdGl2YXRlIGl0XFxuXFxuXFxuICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbSgpO1xcblxcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IGFjdGl2ZSA/IEV2ZW50SGFuZGxlci50cmlnZ2VyKGFjdGl2ZSwgRVZFTlRfSElERSQxLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBpbm5lckVsZW1cXG4gICAgICB9KSA6IG51bGw7XFxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIoaW5uZXJFbGVtLCBFVkVOVF9TSE9XJDEsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGFjdGl2ZVxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fCBoaWRlRXZlbnQgJiYgaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZShhY3RpdmUsIGlubmVyRWxlbSk7XFxuXFxuICAgICAgdGhpcy5fYWN0aXZhdGUoaW5uZXJFbGVtLCBhY3RpdmUpO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX2FjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XFxuICAgICAgaWYgKCFlbGVtZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSk7XFxuXFxuICAgICAgdGhpcy5fYWN0aXZhdGUoZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgYWN0aXZhdGUvc2hvdyB0aGUgcHJvcGVyIHNlY3Rpb25cXG5cXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpICE9PSAndGFiJykge1xcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDEpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XFxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XFxuXFxuICAgICAgICB0aGlzLl90b2dnbGVEcm9wRG93bihlbGVtZW50LCB0cnVlKTtcXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX1NIT1dOJDEsIHtcXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKTtcXG4gICAgfVxcblxcbiAgICBfZGVhY3RpdmF0ZShlbGVtZW50LCByZWxhdGVkRWxlbSkge1xcbiAgICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xcbiAgICAgIGVsZW1lbnQuYmx1cigpO1xcblxcbiAgICAgIHRoaXMuX2RlYWN0aXZhdGUoZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgZGVhY3RpdmF0ZSB0aGUgc2hvd24gc2VjdGlvbiB0b29cXG5cXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpICE9PSAndGFiJykge1xcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDEpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xcblxcbiAgICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgZmFsc2UpO1xcblxcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIoZWxlbWVudCwgRVZFTlRfSElEREVOJDEsIHtcXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKTtcXG4gICAgfVxcblxcbiAgICBfa2V5ZG93bihldmVudCkge1xcbiAgICAgIGlmICghW0FSUk9XX0xFRlRfS0VZLCBBUlJPV19SSUdIVF9LRVksIEFSUk9XX1VQX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IC8vIHN0b3BQcm9wYWdhdGlvbi9wcmV2ZW50RGVmYXVsdCBib3RoIGFkZGVkIHRvIHN1cHBvcnQgdXAvZG93biBrZXlzIHdpdGhvdXQgc2Nyb2xsaW5nIHRoZSBwYWdlXFxuXFxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICBjb25zdCBpc05leHQgPSBbQVJST1dfUklHSFRfS0VZLCBBUlJPV19ET1dOX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcXG4gICAgICBjb25zdCBuZXh0QWN0aXZlRWxlbWVudCA9IGdldE5leHRBY3RpdmVFbGVtZW50KHRoaXMuX2dldENoaWxkcmVuKCkuZmlsdGVyKGVsZW1lbnQgPT4gIWlzRGlzYWJsZWQoZWxlbWVudCkpLCBldmVudC50YXJnZXQsIGlzTmV4dCwgdHJ1ZSk7XFxuXFxuICAgICAgaWYgKG5leHRBY3RpdmVFbGVtZW50KSB7XFxuICAgICAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShuZXh0QWN0aXZlRWxlbWVudCkuc2hvdygpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfZ2V0Q2hpbGRyZW4oKSB7XFxuICAgICAgLy8gY29sbGVjdGlvbiBvZiBpbm5lciBlbGVtZW50c1xcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lOTkVSX0VMRU0sIHRoaXMuX3BhcmVudCk7XFxuICAgIH1cXG5cXG4gICAgX2dldEFjdGl2ZUVsZW0oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2dldENoaWxkcmVuKCkuZmluZChjaGlsZCA9PiB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpKSB8fCBudWxsO1xcbiAgICB9XFxuXFxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlcyhwYXJlbnQsIGNoaWxkcmVuKSB7XFxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMocGFyZW50LCAncm9sZScsICd0YWJsaXN0Jyk7XFxuXFxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xcbiAgICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCkge1xcbiAgICAgIGNoaWxkID0gdGhpcy5fZ2V0SW5uZXJFbGVtZW50KGNoaWxkKTtcXG5cXG4gICAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCk7XFxuXFxuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGNoaWxkKTtcXG5cXG4gICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBpc0FjdGl2ZSk7XFxuXFxuICAgICAgaWYgKG91dGVyRWxlbSAhPT0gY2hpbGQpIHtcXG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKG91dGVyRWxlbSwgJ3JvbGUnLCAncHJlc2VudGF0aW9uJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghaXNBY3RpdmUpIHtcXG4gICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoY2hpbGQsICdyb2xlJywgJ3RhYicpOyAvLyBzZXQgYXR0cmlidXRlcyB0byB0aGUgcmVsYXRlZCBwYW5lbCB0b29cXG5cXG5cXG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpO1xcbiAgICB9XFxuXFxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpIHtcXG4gICAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGNoaWxkKTtcXG5cXG4gICAgICBpZiAoIXRhcmdldCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdyb2xlJywgJ3RhYnBhbmVsJyk7XFxuXFxuICAgICAgaWYgKGNoaWxkLmlkKSB7XFxuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdhcmlhLWxhYmVsbGVkYnknLCBgIyR7Y2hpbGQuaWR9YCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF90b2dnbGVEcm9wRG93bihlbGVtZW50LCBvcGVuKSB7XFxuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGVsZW1lbnQpO1xcblxcbiAgICAgIGlmICghb3V0ZXJFbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19EUk9QRE9XTikpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgdG9nZ2xlID0gKHNlbGVjdG9yLCBjbGFzc05hbWUpID0+IHtcXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yLCBvdXRlckVsZW0pO1xcblxcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcXG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgb3Blbik7XFxuICAgICAgICB9XFxuICAgICAgfTtcXG5cXG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFLCBDTEFTU19OQU1FX0FDVElWRSk7XFxuICAgICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX01FTlUsIENMQVNTX05BTUVfU0hPVyQxKTtcXG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fSVRFTSwgQ0xBU1NfTkFNRV9BQ1RJVkUpO1xcbiAgICAgIG91dGVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvcGVuKTtcXG4gICAgfVxcblxcbiAgICBfc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoZWxlbWVudCwgYXR0cmlidXRlLCB2YWx1ZSkge1xcbiAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9lbGVtSXNBY3RpdmUoZWxlbSkge1xcbiAgICAgIHJldHVybiBlbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSk7XFxuICAgIH0gLy8gVHJ5IHRvIGdldCB0aGUgaW5uZXIgZWxlbWVudCAodXN1YWxseSB0aGUgLm5hdi1saW5rKVxcblxcblxcbiAgICBfZ2V0SW5uZXJFbGVtZW50KGVsZW0pIHtcXG4gICAgICByZXR1cm4gZWxlbS5tYXRjaGVzKFNFTEVDVE9SX0lOTkVSX0VMRU0pID8gZWxlbSA6IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ORVJfRUxFTSwgZWxlbSk7XFxuICAgIH0gLy8gVHJ5IHRvIGdldCB0aGUgb3V0ZXIgZWxlbWVudCAodXN1YWxseSB0aGUgLm5hdi1pdGVtKVxcblxcblxcbiAgICBfZ2V0T3V0ZXJFbGVtZW50KGVsZW0pIHtcXG4gICAgICByZXR1cm4gZWxlbS5jbG9zZXN0KFNFTEVDVE9SX09VVEVSKSB8fCBlbGVtO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xcbiAgfSk7XFxuICAvKipcXG4gICAqIEluaXRpYWxpemUgb24gZm9jdXNcXG4gICAqL1xcblxcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUpKSB7XFxuICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRhYik7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHRvYXN0LmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUgPSAndG9hc3QnO1xcbiAgY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnO1xcbiAgY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWA7XFxuICBjb25zdCBFVkVOVF9NT1VTRU9WRVIgPSBgbW91c2VvdmVyJHtFVkVOVF9LRVl9YDtcXG4gIGNvbnN0IEVWRU5UX01PVVNFT1VUID0gYG1vdXNlb3V0JHtFVkVOVF9LRVl9YDtcXG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4gPSBgZm9jdXNpbiR7RVZFTlRfS0VZfWA7XFxuICBjb25zdCBFVkVOVF9GT0NVU09VVCA9IGBmb2N1c291dCR7RVZFTlRfS0VZfWA7XFxuICBjb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gO1xcbiAgY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWA7XFxuICBjb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gO1xcbiAgY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9ISURFID0gJ2hpZGUnOyAvLyBAZGVwcmVjYXRlZCAtIGtlcHQgaGVyZSBvbmx5IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxcblxcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HID0gJ3Nob3dpbmcnO1xcbiAgY29uc3QgRGVmYXVsdFR5cGUgPSB7XFxuICAgIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxcbiAgICBhdXRvaGlkZTogJ2Jvb2xlYW4nLFxcbiAgICBkZWxheTogJ251bWJlcidcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0ID0ge1xcbiAgICBhbmltYXRpb246IHRydWUsXFxuICAgIGF1dG9oaWRlOiB0cnVlLFxcbiAgICBkZWxheTogNTAwMFxcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBUb2FzdCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcbiAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gZmFsc2U7XFxuXFxuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQ7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGU7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FO1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBzaG93KCkge1xcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpO1xcblxcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XFxuXFxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTik7XFxuXFxuICAgICAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfSElERSk7IC8vIEBkZXByZWNhdGVkXFxuXFxuXFxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1csIENMQVNTX05BTUVfU0hPV0lORyk7XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XFxuICAgIH1cXG5cXG4gICAgaGlkZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuaXNTaG93bigpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUpO1xcblxcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxcblxcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORywgQ0xBU1NfTkFNRV9TSE9XKTtcXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTik7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcXG4gICAgfVxcblxcbiAgICBkaXNwb3NlKCkge1xcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xcblxcbiAgICAgIGlmICh0aGlzLmlzU2hvd24oKSkge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyk7XFxuICAgICAgfVxcblxcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgfVxcblxcbiAgICBpc1Nob3duKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX21heWJlU2NoZWR1bGVIaWRlKCkge1xcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KTtcXG4gICAgfVxcblxcbiAgICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xcbiAgICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xcbiAgICAgICAgY2FzZSAnbW91c2VvdmVyJzpcXG4gICAgICAgIGNhc2UgJ21vdXNlb3V0JzpcXG4gICAgICAgICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3Rpbmc7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSAnZm9jdXNpbic6XFxuICAgICAgICBjYXNlICdmb2N1c291dCc6XFxuICAgICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzSW50ZXJhY3RpbmcpIHtcXG4gICAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBuZXh0RWxlbWVudCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XFxuXFxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IG5leHRFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMobmV4dEVsZW1lbnQpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XFxuICAgIH1cXG5cXG4gICAgX3NldExpc3RlbmVycygpIHtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVkVSLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU0lOLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xcbiAgICB9XFxuXFxuICAgIF9jbGVhclRpbWVvdXQoKSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY29uc3QgZGF0YSA9IFRvYXN0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gIH1cXG4gIC8qKlxcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cXG4gICAqL1xcblxcblxcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoVG9hc3QpO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvYXN0KTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogaW5kZXgudW1kLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIGNvbnN0IGluZGV4X3VtZCA9IHtcXG4gICAgQWxlcnQsXFxuICAgIEJ1dHRvbixcXG4gICAgQ2Fyb3VzZWwsXFxuICAgIENvbGxhcHNlLFxcbiAgICBEcm9wZG93bixcXG4gICAgTW9kYWwsXFxuICAgIE9mZmNhbnZhcyxcXG4gICAgUG9wb3ZlcixcXG4gICAgU2Nyb2xsU3B5LFxcbiAgICBUYWIsXFxuICAgIFRvYXN0LFxcbiAgICBUb29sdGlwXFxuICB9O1xcblxcbiAgcmV0dXJuIGluZGV4X3VtZDtcXG5cXG59KSk7XFxuXCIiLCJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxuICogU2VsZWN0MiA0LjAuMTNcXG4gKiBodHRwczovL3NlbGVjdDIuZ2l0aHViLmlvXFxuICpcXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc2VsZWN0Mi9zZWxlY3QyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWRcXG4gKi9cXG47KGZ1bmN0aW9uIChmYWN0b3J5KSB7XFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XFxuICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cXG4gICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xcbiAgICAvLyBOb2RlL0NvbW1vbkpTXFxuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsIGpRdWVyeSkge1xcbiAgICAgIGlmIChqUXVlcnkgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgLy8gcmVxdWlyZSgnalF1ZXJ5JykgcmV0dXJucyBhIGZhY3RvcnkgdGhhdCByZXF1aXJlcyB3aW5kb3cgdG9cXG4gICAgICAgIC8vIGJ1aWxkIGEgalF1ZXJ5IGluc3RhbmNlLCB3ZSBub3JtYWxpemUgaG93IHdlIHVzZSBtb2R1bGVzXFxuICAgICAgICAvLyB0aGF0IHJlcXVpcmUgdGhpcyBwYXR0ZXJuIGJ1dCB0aGUgd2luZG93IHByb3ZpZGVkIGlzIGEgbm9vcFxcbiAgICAgICAgLy8gaWYgaXQncyBkZWZpbmVkIChob3cganF1ZXJ5IHdvcmtzKVxcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xcbiAgICAgICAgfVxcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgIGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpKHJvb3QpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBmYWN0b3J5KGpRdWVyeSk7XFxuICAgICAgcmV0dXJuIGpRdWVyeTtcXG4gICAgfTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIEJyb3dzZXIgZ2xvYmFsc1xcbiAgICBmYWN0b3J5KGpRdWVyeSk7XFxuICB9XFxufSAoZnVuY3Rpb24gKGpRdWVyeSkge1xcbiAgLy8gVGhpcyBpcyBuZWVkZWQgc28gd2UgY2FuIGNhdGNoIHRoZSBBTUQgbG9hZGVyIGNvbmZpZ3VyYXRpb24gYW5kIHVzZSBpdFxcbiAgLy8gVGhlIGlubmVyIGZpbGUgc2hvdWxkIGJlIHdyYXBwZWQgKGJ5IGBiYW5uZXIuc3RhcnQuanNgKSBpbiBhIGZ1bmN0aW9uIHRoYXRcXG4gIC8vIHJldHVybnMgdGhlIEFNRCBsb2FkZXIgcmVmZXJlbmNlcy5cXG4gIHZhciBTMiA9KGZ1bmN0aW9uICgpIHtcXG4gIC8vIFJlc3RvcmUgdGhlIFNlbGVjdDIgQU1EIGxvYWRlciBzbyBpdCBjYW4gYmUgdXNlZFxcbiAgLy8gTmVlZGVkIG1vc3RseSBpbiB0aGUgbGFuZ3VhZ2UgZmlsZXMsIHdoZXJlIHRoZSBsb2FkZXIgaXMgbm90IGluc2VydGVkXFxuICBpZiAoalF1ZXJ5ICYmIGpRdWVyeS5mbiAmJiBqUXVlcnkuZm4uc2VsZWN0MiAmJiBqUXVlcnkuZm4uc2VsZWN0Mi5hbWQpIHtcXG4gICAgdmFyIFMyID0galF1ZXJ5LmZuLnNlbGVjdDIuYW1kO1xcbiAgfVxcbnZhciBTMjsoZnVuY3Rpb24gKCkgeyBpZiAoIVMyIHx8ICFTMi5yZXF1aXJlanMpIHtcXG5pZiAoIVMyKSB7IFMyID0ge307IH0gZWxzZSB7IHJlcXVpcmUgPSBTMjsgfVxcbi8qKlxcbiAqIEBsaWNlbnNlIGFsbW9uZCAwLjMuMyBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycy5cXG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSwgaHR0cDovL2dpdGh1Yi5jb20vcmVxdWlyZWpzL2FsbW9uZC9MSUNFTlNFXFxuICovXFxuLy9Hb2luZyBzbG9wcHkgdG8gYXZvaWQgJ3VzZSBzdHJpY3QnIHN0cmluZyBjb3N0LCBidXQgc3RyaWN0IHByYWN0aWNlcyBzaG91bGRcXG4vL2JlIGZvbGxvd2VkLlxcbi8qZ2xvYmFsIHNldFRpbWVvdXQ6IGZhbHNlICovXFxuXFxudmFyIHJlcXVpcmVqcywgcmVxdWlyZSwgZGVmaW5lO1xcbihmdW5jdGlvbiAodW5kZWYpIHtcXG4gICAgdmFyIG1haW4sIHJlcSwgbWFrZU1hcCwgaGFuZGxlcnMsXFxuICAgICAgICBkZWZpbmVkID0ge30sXFxuICAgICAgICB3YWl0aW5nID0ge30sXFxuICAgICAgICBjb25maWcgPSB7fSxcXG4gICAgICAgIGRlZmluaW5nID0ge30sXFxuICAgICAgICBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxcbiAgICAgICAgYXBzID0gW10uc2xpY2UsXFxuICAgICAgICBqc1N1ZmZpeFJlZ0V4cCA9IC9cXFxcLmpzJC87XFxuXFxuICAgIGZ1bmN0aW9uIGhhc1Byb3Aob2JqLCBwcm9wKSB7XFxuICAgICAgICByZXR1cm4gaGFzT3duLmNhbGwob2JqLCBwcm9wKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogR2l2ZW4gYSByZWxhdGl2ZSBtb2R1bGUgbmFtZSwgbGlrZSAuL3NvbWV0aGluZywgbm9ybWFsaXplIGl0IHRvXFxuICAgICAqIGEgcmVhbCBuYW1lIHRoYXQgY2FuIGJlIG1hcHBlZCB0byBhIHBhdGguXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSByZWxhdGl2ZSBuYW1lXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlTmFtZSBhIHJlYWwgbmFtZSB0aGF0IHRoZSBuYW1lIGFyZyBpcyByZWxhdGl2ZVxcbiAgICAgKiB0by5cXG4gICAgICogQHJldHVybnMge1N0cmluZ30gbm9ybWFsaXplZCBuYW1lXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBub3JtYWxpemUobmFtZSwgYmFzZU5hbWUpIHtcXG4gICAgICAgIHZhciBuYW1lUGFydHMsIG5hbWVTZWdtZW50LCBtYXBWYWx1ZSwgZm91bmRNYXAsIGxhc3RJbmRleCxcXG4gICAgICAgICAgICBmb3VuZEksIGZvdW5kU3Rhck1hcCwgc3RhckksIGksIGosIHBhcnQsIG5vcm1hbGl6ZWRCYXNlUGFydHMsXFxuICAgICAgICAgICAgYmFzZVBhcnRzID0gYmFzZU5hbWUgJiYgYmFzZU5hbWUuc3BsaXQoXFxcIi9cXFwiKSxcXG4gICAgICAgICAgICBtYXAgPSBjb25maWcubWFwLFxcbiAgICAgICAgICAgIHN0YXJNYXAgPSAobWFwICYmIG1hcFsnKiddKSB8fCB7fTtcXG5cXG4gICAgICAgIC8vQWRqdXN0IGFueSByZWxhdGl2ZSBwYXRocy5cXG4gICAgICAgIGlmIChuYW1lKSB7XFxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJy8nKTtcXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBuYW1lLmxlbmd0aCAtIDE7XFxuXFxuICAgICAgICAgICAgLy8gSWYgd2FudGluZyBub2RlIElEIGNvbXBhdGliaWxpdHksIHN0cmlwIC5qcyBmcm9tIGVuZFxcbiAgICAgICAgICAgIC8vIG9mIElEcy4gSGF2ZSB0byBkbyB0aGlzIGhlcmUsIGFuZCBub3QgaW4gbmFtZVRvVXJsXFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBub2RlIGFsbG93cyBlaXRoZXIgLmpzIG9yIG5vbiAuanMgdG8gbWFwXFxuICAgICAgICAgICAgLy8gdG8gc2FtZSBmaWxlLlxcbiAgICAgICAgICAgIGlmIChjb25maWcubm9kZUlkQ29tcGF0ICYmIGpzU3VmZml4UmVnRXhwLnRlc3QobmFtZVtsYXN0SW5kZXhdKSkge1xcbiAgICAgICAgICAgICAgICBuYW1lW2xhc3RJbmRleF0gPSBuYW1lW2xhc3RJbmRleF0ucmVwbGFjZShqc1N1ZmZpeFJlZ0V4cCwgJycpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvLyBTdGFydHMgd2l0aCBhICcuJyBzbyBuZWVkIHRoZSBiYXNlTmFtZVxcbiAgICAgICAgICAgIGlmIChuYW1lWzBdLmNoYXJBdCgwKSA9PT0gJy4nICYmIGJhc2VQYXJ0cykge1xcbiAgICAgICAgICAgICAgICAvL0NvbnZlcnQgYmFzZU5hbWUgdG8gYXJyYXksIGFuZCBsb3Agb2ZmIHRoZSBsYXN0IHBhcnQsXFxuICAgICAgICAgICAgICAgIC8vc28gdGhhdCAuIG1hdGNoZXMgdGhhdCAnZGlyZWN0b3J5JyBhbmQgbm90IG5hbWUgb2YgdGhlIGJhc2VOYW1lJ3NcXG4gICAgICAgICAgICAgICAgLy9tb2R1bGUuIEZvciBpbnN0YW5jZSwgYmFzZU5hbWUgb2YgJ29uZS90d28vdGhyZWUnLCBtYXBzIHRvXFxuICAgICAgICAgICAgICAgIC8vJ29uZS90d28vdGhyZWUuanMnLCBidXQgd2Ugd2FudCB0aGUgZGlyZWN0b3J5LCAnb25lL3R3bycgZm9yXFxuICAgICAgICAgICAgICAgIC8vdGhpcyBub3JtYWxpemF0aW9uLlxcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkQmFzZVBhcnRzID0gYmFzZVBhcnRzLnNsaWNlKDAsIGJhc2VQYXJ0cy5sZW5ndGggLSAxKTtcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZWRCYXNlUGFydHMuY29uY2F0KG5hbWUpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAvL3N0YXJ0IHRyaW1Eb3RzXFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5hbWUubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICAgICAgcGFydCA9IG5hbWVbaV07XFxuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcXG4gICAgICAgICAgICAgICAgICAgIG5hbWUuc3BsaWNlKGksIDEpO1xcbiAgICAgICAgICAgICAgICAgICAgaSAtPSAxO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGF0IHRoZSBzdGFydCwgb3IgcHJldmlvdXMgdmFsdWUgaXMgc3RpbGwgLi4sXFxuICAgICAgICAgICAgICAgICAgICAvLyBrZWVwIHRoZW0gc28gdGhhdCB3aGVuIGNvbnZlcnRlZCB0byBhIHBhdGggaXQgbWF5XFxuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCB3b3JrIHdoZW4gY29udmVydGVkIHRvIGEgcGF0aCwgZXZlbiB0aG91Z2hcXG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIGFuIElEIGl0IGlzIGxlc3MgdGhhbiBpZGVhbC4gSW4gbGFyZ2VyIHBvaW50XFxuICAgICAgICAgICAgICAgICAgICAvLyByZWxlYXNlcywgbWF5IGJlIGJldHRlciB0byBqdXN0IGtpY2sgb3V0IGFuIGVycm9yLlxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgKGkgPT09IDEgJiYgbmFtZVsyXSA9PT0gJy4uJykgfHwgbmFtZVtpIC0gMV0gPT09ICcuLicpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDApIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpIC0gMSwgMik7XFxuICAgICAgICAgICAgICAgICAgICAgICAgaSAtPSAyO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vZW5kIHRyaW1Eb3RzXFxuXFxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuam9pbignLycpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9BcHBseSBtYXAgY29uZmlnIGlmIGF2YWlsYWJsZS5cXG4gICAgICAgIGlmICgoYmFzZVBhcnRzIHx8IHN0YXJNYXApICYmIG1hcCkge1xcbiAgICAgICAgICAgIG5hbWVQYXJ0cyA9IG5hbWUuc3BsaXQoJy8nKTtcXG5cXG4gICAgICAgICAgICBmb3IgKGkgPSBuYW1lUGFydHMubGVuZ3RoOyBpID4gMDsgaSAtPSAxKSB7XFxuICAgICAgICAgICAgICAgIG5hbWVTZWdtZW50ID0gbmFtZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oXFxcIi9cXFwiKTtcXG5cXG4gICAgICAgICAgICAgICAgaWYgKGJhc2VQYXJ0cykge1xcbiAgICAgICAgICAgICAgICAgICAgLy9GaW5kIHRoZSBsb25nZXN0IGJhc2VOYW1lIHNlZ21lbnQgbWF0Y2ggaW4gdGhlIGNvbmZpZy5cXG4gICAgICAgICAgICAgICAgICAgIC8vU28sIGRvIGpvaW5zIG9uIHRoZSBiaWdnZXN0IHRvIHNtYWxsZXN0IGxlbmd0aHMgb2YgYmFzZVBhcnRzLlxcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gYmFzZVBhcnRzLmxlbmd0aDsgaiA+IDA7IGogLT0gMSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcFZhbHVlID0gbWFwW2Jhc2VQYXJ0cy5zbGljZSgwLCBqKS5qb2luKCcvJyldO1xcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFzZU5hbWUgc2VnbWVudCBoYXMgIGNvbmZpZywgZmluZCBpZiBpdCBoYXMgb25lIGZvclxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhpcyBuYW1lLlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFZhbHVlW25hbWVTZWdtZW50XTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcFZhbHVlKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL01hdGNoLCB1cGRhdGUgbmFtZSB0byB0aGUgbmV3IHZhbHVlLlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRNYXAgPSBtYXBWYWx1ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kSSA9IGk7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICBpZiAoZm91bmRNYXApIHtcXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIC8vQ2hlY2sgZm9yIGEgc3RhciBtYXAgbWF0Y2gsIGJ1dCBqdXN0IGhvbGQgb24gdG8gaXQsXFxuICAgICAgICAgICAgICAgIC8vaWYgdGhlcmUgaXMgYSBzaG9ydGVyIHNlZ21lbnQgbWF0Y2ggbGF0ZXIgaW4gYSBtYXRjaGluZ1xcbiAgICAgICAgICAgICAgICAvL2NvbmZpZywgdGhlbiBmYXZvciBvdmVyIHRoaXMgc3RhciBtYXAuXFxuICAgICAgICAgICAgICAgIGlmICghZm91bmRTdGFyTWFwICYmIHN0YXJNYXAgJiYgc3Rhck1hcFtuYW1lU2VnbWVudF0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kU3Rhck1hcCA9IHN0YXJNYXBbbmFtZVNlZ21lbnRdO1xcbiAgICAgICAgICAgICAgICAgICAgc3RhckkgPSBpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmICghZm91bmRNYXAgJiYgZm91bmRTdGFyTWFwKSB7XFxuICAgICAgICAgICAgICAgIGZvdW5kTWFwID0gZm91bmRTdGFyTWFwO1xcbiAgICAgICAgICAgICAgICBmb3VuZEkgPSBzdGFySTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XFxuICAgICAgICAgICAgICAgIG5hbWVQYXJ0cy5zcGxpY2UoMCwgZm91bmRJLCBmb3VuZE1hcCk7XFxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lUGFydHMuam9pbignLycpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiBuYW1lO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG1ha2VSZXF1aXJlKHJlbE5hbWUsIGZvcmNlU3luYykge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAvL0EgdmVyc2lvbiBvZiBhIHJlcXVpcmUgZnVuY3Rpb24gdGhhdCBwYXNzZXMgYSBtb2R1bGVOYW1lXFxuICAgICAgICAgICAgLy92YWx1ZSBmb3IgaXRlbXMgdGhhdCBtYXkgbmVlZCB0b1xcbiAgICAgICAgICAgIC8vbG9vayB1cCBwYXRocyByZWxhdGl2ZSB0byB0aGUgbW9kdWxlTmFtZVxcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXBzLmNhbGwoYXJndW1lbnRzLCAwKTtcXG5cXG4gICAgICAgICAgICAvL0lmIGZpcnN0IGFyZyBpcyBub3QgcmVxdWlyZSgnc3RyaW5nJyksIGFuZCB0aGVyZSBpcyBvbmx5XFxuICAgICAgICAgICAgLy9vbmUgYXJnLCBpdCBpcyB0aGUgYXJyYXkgZm9ybSB3aXRob3V0IGEgY2FsbGJhY2suIEluc2VydFxcbiAgICAgICAgICAgIC8vYSBudWxsIHNvIHRoYXQgdGhlIGZvbGxvd2luZyBjb25jYXQgaXMgY29ycmVjdC5cXG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaChudWxsKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIHJlcS5hcHBseSh1bmRlZiwgYXJncy5jb25jYXQoW3JlbE5hbWUsIGZvcmNlU3luY10pKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbWFrZU5vcm1hbGl6ZShyZWxOYW1lKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplKG5hbWUsIHJlbE5hbWUpO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBtYWtlTG9hZChkZXBOYW1lKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XFxuICAgICAgICAgICAgZGVmaW5lZFtkZXBOYW1lXSA9IHZhbHVlO1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBjYWxsRGVwKG5hbWUpIHtcXG4gICAgICAgIGlmIChoYXNQcm9wKHdhaXRpbmcsIG5hbWUpKSB7XFxuICAgICAgICAgICAgdmFyIGFyZ3MgPSB3YWl0aW5nW25hbWVdO1xcbiAgICAgICAgICAgIGRlbGV0ZSB3YWl0aW5nW25hbWVdO1xcbiAgICAgICAgICAgIGRlZmluaW5nW25hbWVdID0gdHJ1ZTtcXG4gICAgICAgICAgICBtYWluLmFwcGx5KHVuZGVmLCBhcmdzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcChkZWZpbmluZywgbmFtZSkpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vICcgKyBuYW1lKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBkZWZpbmVkW25hbWVdO1xcbiAgICB9XFxuXFxuICAgIC8vVHVybnMgYSBwbHVnaW4hcmVzb3VyY2UgdG8gW3BsdWdpbiwgcmVzb3VyY2VdXFxuICAgIC8vd2l0aCB0aGUgcGx1Z2luIGJlaW5nIHVuZGVmaW5lZCBpZiB0aGUgbmFtZVxcbiAgICAvL2RpZCBub3QgaGF2ZSBhIHBsdWdpbiBwcmVmaXguXFxuICAgIGZ1bmN0aW9uIHNwbGl0UHJlZml4KG5hbWUpIHtcXG4gICAgICAgIHZhciBwcmVmaXgsXFxuICAgICAgICAgICAgaW5kZXggPSBuYW1lID8gbmFtZS5pbmRleE9mKCchJykgOiAtMTtcXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XFxuICAgICAgICAgICAgcHJlZml4ID0gbmFtZS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cmluZyhpbmRleCArIDEsIG5hbWUubGVuZ3RoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBbcHJlZml4LCBuYW1lXTtcXG4gICAgfVxcblxcbiAgICAvL0NyZWF0ZXMgYSBwYXJ0cyBhcnJheSBmb3IgYSByZWxOYW1lIHdoZXJlIGZpcnN0IHBhcnQgaXMgcGx1Z2luIElELFxcbiAgICAvL3NlY29uZCBwYXJ0IGlzIHJlc291cmNlIElELiBBc3N1bWVzIHJlbE5hbWUgaGFzIGFscmVhZHkgYmVlbiBub3JtYWxpemVkLlxcbiAgICBmdW5jdGlvbiBtYWtlUmVsUGFydHMocmVsTmFtZSkge1xcbiAgICAgICAgcmV0dXJuIHJlbE5hbWUgPyBzcGxpdFByZWZpeChyZWxOYW1lKSA6IFtdO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBNYWtlcyBhIG5hbWUgbWFwLCBub3JtYWxpemluZyB0aGUgbmFtZSwgYW5kIHVzaW5nIGEgcGx1Z2luXFxuICAgICAqIGZvciBub3JtYWxpemF0aW9uIGlmIG5lY2Vzc2FyeS4gR3JhYnMgYSByZWYgdG8gcGx1Z2luXFxuICAgICAqIHRvbywgYXMgYW4gb3B0aW1pemF0aW9uLlxcbiAgICAgKi9cXG4gICAgbWFrZU1hcCA9IGZ1bmN0aW9uIChuYW1lLCByZWxQYXJ0cykge1xcbiAgICAgICAgdmFyIHBsdWdpbixcXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpLFxcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdLFxcbiAgICAgICAgICAgIHJlbFJlc291cmNlTmFtZSA9IHJlbFBhcnRzWzFdO1xcblxcbiAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xcblxcbiAgICAgICAgaWYgKHByZWZpeCkge1xcbiAgICAgICAgICAgIHByZWZpeCA9IG5vcm1hbGl6ZShwcmVmaXgsIHJlbFJlc291cmNlTmFtZSk7XFxuICAgICAgICAgICAgcGx1Z2luID0gY2FsbERlcChwcmVmaXgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9Ob3JtYWxpemUgYWNjb3JkaW5nXFxuICAgICAgICBpZiAocHJlZml4KSB7XFxuICAgICAgICAgICAgaWYgKHBsdWdpbiAmJiBwbHVnaW4ubm9ybWFsaXplKSB7XFxuICAgICAgICAgICAgICAgIG5hbWUgPSBwbHVnaW4ubm9ybWFsaXplKG5hbWUsIG1ha2VOb3JtYWxpemUocmVsUmVzb3VyY2VOYW1lKSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgbmFtZSA9IG5vcm1hbGl6ZShuYW1lLCByZWxSZXNvdXJjZU5hbWUpO1xcbiAgICAgICAgICAgIHBhcnRzID0gc3BsaXRQcmVmaXgobmFtZSk7XFxuICAgICAgICAgICAgcHJlZml4ID0gcGFydHNbMF07XFxuICAgICAgICAgICAgbmFtZSA9IHBhcnRzWzFdO1xcbiAgICAgICAgICAgIGlmIChwcmVmaXgpIHtcXG4gICAgICAgICAgICAgICAgcGx1Z2luID0gY2FsbERlcChwcmVmaXgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vVXNpbmcgcmlkaWN1bG91cyBwcm9wZXJ0eSBuYW1lcyBmb3Igc3BhY2UgcmVhc29uc1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBmOiBwcmVmaXggPyBwcmVmaXggKyAnIScgKyBuYW1lIDogbmFtZSwgLy9mdWxsTmFtZVxcbiAgICAgICAgICAgIG46IG5hbWUsXFxuICAgICAgICAgICAgcHI6IHByZWZpeCxcXG4gICAgICAgICAgICBwOiBwbHVnaW5cXG4gICAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIGZ1bmN0aW9uIG1ha2VDb25maWcobmFtZSkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gKGNvbmZpZyAmJiBjb25maWcuY29uZmlnICYmIGNvbmZpZy5jb25maWdbbmFtZV0pIHx8IHt9O1xcbiAgICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBoYW5kbGVycyA9IHtcXG4gICAgICAgIHJlcXVpcmU6IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG1ha2VSZXF1aXJlKG5hbWUpO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGV4cG9ydHM6IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgICAgICAgdmFyIGUgPSBkZWZpbmVkW25hbWVdO1xcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGU7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIChkZWZpbmVkW25hbWVdID0ge30pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBtb2R1bGU6IGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgaWQ6IG5hbWUsXFxuICAgICAgICAgICAgICAgIHVyaTogJycsXFxuICAgICAgICAgICAgICAgIGV4cG9ydHM6IGRlZmluZWRbbmFtZV0sXFxuICAgICAgICAgICAgICAgIGNvbmZpZzogbWFrZUNvbmZpZyhuYW1lKVxcbiAgICAgICAgICAgIH07XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIG1haW4gPSBmdW5jdGlvbiAobmFtZSwgZGVwcywgY2FsbGJhY2ssIHJlbE5hbWUpIHtcXG4gICAgICAgIHZhciBjanNNb2R1bGUsIGRlcE5hbWUsIHJldCwgbWFwLCBpLCByZWxQYXJ0cyxcXG4gICAgICAgICAgICBhcmdzID0gW10sXFxuICAgICAgICAgICAgY2FsbGJhY2tUeXBlID0gdHlwZW9mIGNhbGxiYWNrLFxcbiAgICAgICAgICAgIHVzaW5nRXhwb3J0cztcXG5cXG4gICAgICAgIC8vVXNlIG5hbWUgaWYgbm8gcmVsTmFtZVxcbiAgICAgICAgcmVsTmFtZSA9IHJlbE5hbWUgfHwgbmFtZTtcXG4gICAgICAgIHJlbFBhcnRzID0gbWFrZVJlbFBhcnRzKHJlbE5hbWUpO1xcblxcbiAgICAgICAgLy9DYWxsIHRoZSBjYWxsYmFjayB0byBkZWZpbmUgdGhlIG1vZHVsZSwgaWYgbmVjZXNzYXJ5LlxcbiAgICAgICAgaWYgKGNhbGxiYWNrVHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgY2FsbGJhY2tUeXBlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgLy9QdWxsIG91dCB0aGUgZGVmaW5lZCBkZXBlbmRlbmNpZXMgYW5kIHBhc3MgdGhlIG9yZGVyZWRcXG4gICAgICAgICAgICAvL3ZhbHVlcyB0byB0aGUgY2FsbGJhY2suXFxuICAgICAgICAgICAgLy9EZWZhdWx0IHRvIFtyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGVdIGlmIG5vIGRlcHNcXG4gICAgICAgICAgICBkZXBzID0gIWRlcHMubGVuZ3RoICYmIGNhbGxiYWNrLmxlbmd0aCA/IFsncmVxdWlyZScsICdleHBvcnRzJywgJ21vZHVsZSddIDogZGVwcztcXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVwcy5sZW5ndGg7IGkgKz0gMSkge1xcbiAgICAgICAgICAgICAgICBtYXAgPSBtYWtlTWFwKGRlcHNbaV0sIHJlbFBhcnRzKTtcXG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IG1hcC5mO1xcblxcbiAgICAgICAgICAgICAgICAvL0Zhc3QgcGF0aCBDb21tb25KUyBzdGFuZGFyZCBkZXBlbmRlbmNpZXMuXFxuICAgICAgICAgICAgICAgIGlmIChkZXBOYW1lID09PSBcXFwicmVxdWlyZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5yZXF1aXJlKG5hbWUpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRlcE5hbWUgPT09IFxcXCJleHBvcnRzXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgLy9Db21tb25KUyBtb2R1bGUgc3BlYyAxLjFcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBoYW5kbGVycy5leHBvcnRzKG5hbWUpO1xcbiAgICAgICAgICAgICAgICAgICAgdXNpbmdFeHBvcnRzID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXBOYW1lID09PSBcXFwibW9kdWxlXFxcIikge1xcbiAgICAgICAgICAgICAgICAgICAgLy9Db21tb25KUyBtb2R1bGUgc3BlYyAxLjFcXG4gICAgICAgICAgICAgICAgICAgIGNqc01vZHVsZSA9IGFyZ3NbaV0gPSBoYW5kbGVycy5tb2R1bGUobmFtZSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaGFzUHJvcChkZWZpbmVkLCBkZXBOYW1lKSB8fFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc1Byb3Aod2FpdGluZywgZGVwTmFtZSkgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKGRlZmluaW5nLCBkZXBOYW1lKSkge1xcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGNhbGxEZXAoZGVwTmFtZSk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWFwLnApIHtcXG4gICAgICAgICAgICAgICAgICAgIG1hcC5wLmxvYWQobWFwLm4sIG1ha2VSZXF1aXJlKHJlbE5hbWUsIHRydWUpLCBtYWtlTG9hZChkZXBOYW1lKSwge30pO1xcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tpXSA9IGRlZmluZWRbZGVwTmFtZV07XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgbWlzc2luZyAnICsgZGVwTmFtZSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0ID0gY2FsbGJhY2sgPyBjYWxsYmFjay5hcHBseShkZWZpbmVkW25hbWVdLCBhcmdzKSA6IHVuZGVmaW5lZDtcXG5cXG4gICAgICAgICAgICBpZiAobmFtZSkge1xcbiAgICAgICAgICAgICAgICAvL0lmIHNldHRpbmcgZXhwb3J0cyB2aWEgXFxcIm1vZHVsZVxcXCIgaXMgaW4gcGxheSxcXG4gICAgICAgICAgICAgICAgLy9mYXZvciB0aGF0IG92ZXIgcmV0dXJuIHZhbHVlIGFuZCBleHBvcnRzLiBBZnRlciB0aGF0LFxcbiAgICAgICAgICAgICAgICAvL2Zhdm9yIGEgbm9uLXVuZGVmaW5lZCByZXR1cm4gdmFsdWUgb3ZlciBleHBvcnRzIHVzZS5cXG4gICAgICAgICAgICAgICAgaWYgKGNqc01vZHVsZSAmJiBjanNNb2R1bGUuZXhwb3J0cyAhPT0gdW5kZWYgJiZcXG4gICAgICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUuZXhwb3J0cyAhPT0gZGVmaW5lZFtuYW1lXSkge1xcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNqc01vZHVsZS5leHBvcnRzO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJldCAhPT0gdW5kZWYgfHwgIXVzaW5nRXhwb3J0cykge1xcbiAgICAgICAgICAgICAgICAgICAgLy9Vc2UgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbi5cXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSByZXQ7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcXG4gICAgICAgICAgICAvL01heSBqdXN0IGJlIGFuIG9iamVjdCBkZWZpbml0aW9uIGZvciB0aGUgbW9kdWxlLiBPbmx5XFxuICAgICAgICAgICAgLy93b3JyeSBhYm91dCBkZWZpbmluZyBpZiBoYXZlIGEgbW9kdWxlIG5hbWUuXFxuICAgICAgICAgICAgZGVmaW5lZFtuYW1lXSA9IGNhbGxiYWNrO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICByZXF1aXJlanMgPSByZXF1aXJlID0gcmVxID0gZnVuY3Rpb24gKGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lLCBmb3JjZVN5bmMsIGFsdCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBzID09PSBcXFwic3RyaW5nXFxcIikge1xcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1tkZXBzXSkge1xcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGluIHRoaXMgY2FzZSBpcyByZWFsbHkgcmVsTmFtZVxcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlcnNbZGVwc10oY2FsbGJhY2spO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvL0p1c3QgcmV0dXJuIHRoZSBtb2R1bGUgd2FudGVkLiBJbiB0aGlzIHNjZW5hcmlvLCB0aGVcXG4gICAgICAgICAgICAvL2RlcHMgYXJnIGlzIHRoZSBtb2R1bGUgbmFtZSwgYW5kIHNlY29uZCBhcmcgKGlmIHBhc3NlZClcXG4gICAgICAgICAgICAvL2lzIGp1c3QgdGhlIHJlbE5hbWUuXFxuICAgICAgICAgICAgLy9Ob3JtYWxpemUgbW9kdWxlIG5hbWUsIGlmIGl0IGNvbnRhaW5zIC4gb3IgLi5cXG4gICAgICAgICAgICByZXR1cm4gY2FsbERlcChtYWtlTWFwKGRlcHMsIG1ha2VSZWxQYXJ0cyhjYWxsYmFjaykpLmYpO1xcbiAgICAgICAgfSBlbHNlIGlmICghZGVwcy5zcGxpY2UpIHtcXG4gICAgICAgICAgICAvL2RlcHMgaXMgYSBjb25maWcgb2JqZWN0LCBub3QgYW4gYXJyYXkuXFxuICAgICAgICAgICAgY29uZmlnID0gZGVwcztcXG4gICAgICAgICAgICBpZiAoY29uZmlnLmRlcHMpIHtcXG4gICAgICAgICAgICAgICAgcmVxKGNvbmZpZy5kZXBzLCBjb25maWcuY2FsbGJhY2spO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrLnNwbGljZSkge1xcbiAgICAgICAgICAgICAgICAvL2NhbGxiYWNrIGlzIGFuIGFycmF5LCB3aGljaCBtZWFucyBpdCBpcyBhIGRlcGVuZGVuY3kgbGlzdC5cXG4gICAgICAgICAgICAgICAgLy9BZGp1c3QgYXJncyBpZiB0aGVyZSBhcmUgZGVwZW5kZW5jaWVzXFxuICAgICAgICAgICAgICAgIGRlcHMgPSBjYWxsYmFjaztcXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSByZWxOYW1lO1xcbiAgICAgICAgICAgICAgICByZWxOYW1lID0gbnVsbDtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBkZXBzID0gdW5kZWY7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9TdXBwb3J0IHJlcXVpcmUoWydhJ10pXFxuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uICgpIHt9O1xcblxcbiAgICAgICAgLy9JZiByZWxOYW1lIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGFuIGVycmJhY2sgaGFuZGxlcixcXG4gICAgICAgIC8vc28gcmVtb3ZlIGl0LlxcbiAgICAgICAgaWYgKHR5cGVvZiByZWxOYW1lID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgcmVsTmFtZSA9IGZvcmNlU3luYztcXG4gICAgICAgICAgICBmb3JjZVN5bmMgPSBhbHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL1NpbXVsYXRlIGFzeW5jIGNhbGxiYWNrO1xcbiAgICAgICAgaWYgKGZvcmNlU3luYykge1xcbiAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgLy9Vc2luZyBhIG5vbi16ZXJvIHZhbHVlIGJlY2F1c2Ugb2YgY29uY2VybiBmb3Igd2hhdCBvbGQgYnJvd3NlcnNcXG4gICAgICAgICAgICAvL2RvLCBhbmQgbGF0ZXN0IGJyb3dzZXJzIFxcXCJ1cGdyYWRlXFxcIiB0byA0IGlmIGxvd2VyIHZhbHVlIGlzIHVzZWQ6XFxuICAgICAgICAgICAgLy9odHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aW1lcnMuaHRtbCNkb20td2luZG93dGltZXJzLXNldHRpbWVvdXQ6XFxuICAgICAgICAgICAgLy9JZiB3YW50IGEgdmFsdWUgaW1tZWRpYXRlbHksIHVzZSByZXF1aXJlKCdpZCcpIGluc3RlYWQgLS0gc29tZXRoaW5nXFxuICAgICAgICAgICAgLy90aGF0IHdvcmtzIGluIGFsbW9uZCBvbiB0aGUgZ2xvYmFsIGxldmVsLCBidXQgbm90IGd1YXJhbnRlZWQgYW5kXFxuICAgICAgICAgICAgLy91bmxpa2VseSB0byB3b3JrIGluIG90aGVyIEFNRCBpbXBsZW1lbnRhdGlvbnMuXFxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIG1haW4odW5kZWYsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKTtcXG4gICAgICAgICAgICB9LCA0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXE7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBKdXN0IGRyb3BzIHRoZSBjb25maWcgb24gdGhlIGZsb29yLCBidXQgcmV0dXJucyByZXEgaW4gY2FzZVxcbiAgICAgKiB0aGUgY29uZmlnIHJldHVybiB2YWx1ZSBpcyB1c2VkLlxcbiAgICAgKi9cXG4gICAgcmVxLmNvbmZpZyA9IGZ1bmN0aW9uIChjZmcpIHtcXG4gICAgICAgIHJldHVybiByZXEoY2ZnKTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4cG9zZSBtb2R1bGUgcmVnaXN0cnkgZm9yIGRlYnVnZ2luZyBhbmQgdG9vbGluZ1xcbiAgICAgKi9cXG4gICAgcmVxdWlyZWpzLl9kZWZpbmVkID0gZGVmaW5lZDtcXG5cXG4gICAgZGVmaW5lID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrKSB7XFxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWUgYWxtb25kIFJFQURNRTogaW5jb3JyZWN0IG1vZHVsZSBidWlsZCwgbm8gbW9kdWxlIG5hbWUnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vVGhpcyBtb2R1bGUgbWF5IG5vdCBoYXZlIGRlcGVuZGVuY2llc1xcbiAgICAgICAgaWYgKCFkZXBzLnNwbGljZSkge1xcbiAgICAgICAgICAgIC8vZGVwcyBpcyBub3QgYW4gYXJyYXksIHNvIHByb2JhYmx5IG1lYW5zXFxuICAgICAgICAgICAgLy9hbiBvYmplY3QgbGl0ZXJhbCBvciBmYWN0b3J5IGZ1bmN0aW9uIGZvclxcbiAgICAgICAgICAgIC8vdGhlIHZhbHVlLiBBZGp1c3QgYXJncy5cXG4gICAgICAgICAgICBjYWxsYmFjayA9IGRlcHM7XFxuICAgICAgICAgICAgZGVwcyA9IFtdO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFoYXNQcm9wKGRlZmluZWQsIG5hbWUpICYmICFoYXNQcm9wKHdhaXRpbmcsIG5hbWUpKSB7XFxuICAgICAgICAgICAgd2FpdGluZ1tuYW1lXSA9IFtuYW1lLCBkZXBzLCBjYWxsYmFja107XFxuICAgICAgICB9XFxuICAgIH07XFxuXFxuICAgIGRlZmluZS5hbWQgPSB7XFxuICAgICAgICBqUXVlcnk6IHRydWVcXG4gICAgfTtcXG59KCkpO1xcblxcblMyLnJlcXVpcmVqcyA9IHJlcXVpcmVqcztTMi5yZXF1aXJlID0gcmVxdWlyZTtTMi5kZWZpbmUgPSBkZWZpbmU7XFxufVxcbn0oKSk7XFxuUzIuZGVmaW5lKFxcXCJhbG1vbmRcXFwiLCBmdW5jdGlvbigpe30pO1xcblxcbi8qIGdsb2JhbCBqUXVlcnk6ZmFsc2UsICQ6ZmFsc2UgKi9cXG5TMi5kZWZpbmUoJ2pxdWVyeScsW10sZnVuY3Rpb24gKCkge1xcbiAgdmFyIF8kID0galF1ZXJ5IHx8ICQ7XFxuXFxuICBpZiAoXyQgPT0gbnVsbCAmJiBjb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcXG4gICAgY29uc29sZS5lcnJvcihcXG4gICAgICAnU2VsZWN0MjogQW4gaW5zdGFuY2Ugb2YgalF1ZXJ5IG9yIGEgalF1ZXJ5LWNvbXBhdGlibGUgbGlicmFyeSB3YXMgbm90ICcgK1xcbiAgICAgICdmb3VuZC4gTWFrZSBzdXJlIHRoYXQgeW91IGFyZSBpbmNsdWRpbmcgalF1ZXJ5IGJlZm9yZSBTZWxlY3QyIG9uIHlvdXIgJyArXFxuICAgICAgJ3dlYiBwYWdlLidcXG4gICAgKTtcXG4gIH1cXG5cXG4gIHJldHVybiBfJDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvdXRpbHMnLFtcXG4gICdqcXVlcnknXFxuXSwgZnVuY3Rpb24gKCQpIHtcXG4gIHZhciBVdGlscyA9IHt9O1xcblxcbiAgVXRpbHMuRXh0ZW5kID0gZnVuY3Rpb24gKENoaWxkQ2xhc3MsIFN1cGVyQ2xhc3MpIHtcXG4gICAgdmFyIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xcblxcbiAgICBmdW5jdGlvbiBCYXNlQ29uc3RydWN0b3IgKCkge1xcbiAgICAgIHRoaXMuY29uc3RydWN0b3IgPSBDaGlsZENsYXNzO1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGtleSBpbiBTdXBlckNsYXNzKSB7XFxuICAgICAgaWYgKF9faGFzUHJvcC5jYWxsKFN1cGVyQ2xhc3MsIGtleSkpIHtcXG4gICAgICAgIENoaWxkQ2xhc3Nba2V5XSA9IFN1cGVyQ2xhc3Nba2V5XTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgQmFzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IFN1cGVyQ2xhc3MucHJvdG90eXBlO1xcbiAgICBDaGlsZENsYXNzLnByb3RvdHlwZSA9IG5ldyBCYXNlQ29uc3RydWN0b3IoKTtcXG4gICAgQ2hpbGRDbGFzcy5fX3N1cGVyX18gPSBTdXBlckNsYXNzLnByb3RvdHlwZTtcXG5cXG4gICAgcmV0dXJuIENoaWxkQ2xhc3M7XFxuICB9O1xcblxcbiAgZnVuY3Rpb24gZ2V0TWV0aG9kcyAodGhlQ2xhc3MpIHtcXG4gICAgdmFyIHByb3RvID0gdGhlQ2xhc3MucHJvdG90eXBlO1xcblxcbiAgICB2YXIgbWV0aG9kcyA9IFtdO1xcblxcbiAgICBmb3IgKHZhciBtZXRob2ROYW1lIGluIHByb3RvKSB7XFxuICAgICAgdmFyIG0gPSBwcm90b1ttZXRob2ROYW1lXTtcXG5cXG4gICAgICBpZiAodHlwZW9mIG0gIT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobWV0aG9kTmFtZSA9PT0gJ2NvbnN0cnVjdG9yJykge1xcbiAgICAgICAgY29udGludWU7XFxuICAgICAgfVxcblxcbiAgICAgIG1ldGhvZHMucHVzaChtZXRob2ROYW1lKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbWV0aG9kcztcXG4gIH1cXG5cXG4gIFV0aWxzLkRlY29yYXRlID0gZnVuY3Rpb24gKFN1cGVyQ2xhc3MsIERlY29yYXRvckNsYXNzKSB7XFxuICAgIHZhciBkZWNvcmF0ZWRNZXRob2RzID0gZ2V0TWV0aG9kcyhEZWNvcmF0b3JDbGFzcyk7XFxuICAgIHZhciBzdXBlck1ldGhvZHMgPSBnZXRNZXRob2RzKFN1cGVyQ2xhc3MpO1xcblxcbiAgICBmdW5jdGlvbiBEZWNvcmF0ZWRDbGFzcyAoKSB7XFxuICAgICAgdmFyIHVuc2hpZnQgPSBBcnJheS5wcm90b3R5cGUudW5zaGlmdDtcXG5cXG4gICAgICB2YXIgYXJnQ291bnQgPSBEZWNvcmF0b3JDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IubGVuZ3RoO1xcblxcbiAgICAgIHZhciBjYWxsZWRDb25zdHJ1Y3RvciA9IFN1cGVyQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xcblxcbiAgICAgIGlmIChhcmdDb3VudCA+IDApIHtcXG4gICAgICAgIHVuc2hpZnQuY2FsbChhcmd1bWVudHMsIFN1cGVyQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yKTtcXG5cXG4gICAgICAgIGNhbGxlZENvbnN0cnVjdG9yID0gRGVjb3JhdG9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yO1xcbiAgICAgIH1cXG5cXG4gICAgICBjYWxsZWRDb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9XFxuXFxuICAgIERlY29yYXRvckNsYXNzLmRpc3BsYXlOYW1lID0gU3VwZXJDbGFzcy5kaXNwbGF5TmFtZTtcXG5cXG4gICAgZnVuY3Rpb24gY3RyICgpIHtcXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gRGVjb3JhdGVkQ2xhc3M7XFxuICAgIH1cXG5cXG4gICAgRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlID0gbmV3IGN0cigpO1xcblxcbiAgICBmb3IgKHZhciBtID0gMDsgbSA8IHN1cGVyTWV0aG9kcy5sZW5ndGg7IG0rKykge1xcbiAgICAgIHZhciBzdXBlck1ldGhvZCA9IHN1cGVyTWV0aG9kc1ttXTtcXG5cXG4gICAgICBEZWNvcmF0ZWRDbGFzcy5wcm90b3R5cGVbc3VwZXJNZXRob2RdID1cXG4gICAgICAgIFN1cGVyQ2xhc3MucHJvdG90eXBlW3N1cGVyTWV0aG9kXTtcXG4gICAgfVxcblxcbiAgICB2YXIgY2FsbGVkTWV0aG9kID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcXG4gICAgICAvLyBTdHViIG91dCB0aGUgb3JpZ2luYWwgbWV0aG9kIGlmIGl0J3Mgbm90IGRlY29yYXRpbmcgYW4gYWN0dWFsIG1ldGhvZFxcbiAgICAgIHZhciBvcmlnaW5hbE1ldGhvZCA9IGZ1bmN0aW9uICgpIHt9O1xcblxcbiAgICAgIGlmIChtZXRob2ROYW1lIGluIERlY29yYXRlZENsYXNzLnByb3RvdHlwZSkge1xcbiAgICAgICAgb3JpZ2luYWxNZXRob2QgPSBEZWNvcmF0ZWRDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV07XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBkZWNvcmF0ZWRNZXRob2QgPSBEZWNvcmF0b3JDbGFzcy5wcm90b3R5cGVbbWV0aG9kTmFtZV07XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciB1bnNoaWZ0ID0gQXJyYXkucHJvdG90eXBlLnVuc2hpZnQ7XFxuXFxuICAgICAgICB1bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCBvcmlnaW5hbE1ldGhvZCk7XFxuXFxuICAgICAgICByZXR1cm4gZGVjb3JhdGVkTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZWNvcmF0ZWRNZXRob2RzLmxlbmd0aDsgZCsrKSB7XFxuICAgICAgdmFyIGRlY29yYXRlZE1ldGhvZCA9IGRlY29yYXRlZE1ldGhvZHNbZF07XFxuXFxuICAgICAgRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlW2RlY29yYXRlZE1ldGhvZF0gPSBjYWxsZWRNZXRob2QoZGVjb3JhdGVkTWV0aG9kKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gRGVjb3JhdGVkQ2xhc3M7XFxuICB9O1xcblxcbiAgdmFyIE9ic2VydmFibGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMubGlzdGVuZXJzID0ge307XFxuICB9O1xcblxcbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZlbnQsIGNhbGxiYWNrKSB7XFxuICAgIHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMgfHwge307XFxuXFxuICAgIGlmIChldmVudCBpbiB0aGlzLmxpc3RlbmVycykge1xcbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0gPSBbY2FsbGJhY2tdO1xcbiAgICB9XFxuICB9O1xcblxcbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xcbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XFxuICAgIHZhciBwYXJhbXMgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuXFxuICAgIHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMgfHwge307XFxuXFxuICAgIC8vIFBhcmFtcyBzaG91bGQgYWx3YXlzIGNvbWUgaW4gYXMgYW4gYXJyYXlcXG4gICAgaWYgKHBhcmFtcyA9PSBudWxsKSB7XFxuICAgICAgcGFyYW1zID0gW107XFxuICAgIH1cXG5cXG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIGFyZ3VtZW50cyB0byB0aGUgZXZlbnQsIHVzZSBhIHRlbXBvcmFyeSBvYmplY3RcXG4gICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDApIHtcXG4gICAgICBwYXJhbXMucHVzaCh7fSk7XFxuICAgIH1cXG5cXG4gICAgLy8gU2V0IHRoZSBgX3R5cGVgIG9mIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIGV2ZW50XFxuICAgIHBhcmFtc1swXS5fdHlwZSA9IGV2ZW50O1xcblxcbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5saXN0ZW5lcnMpIHtcXG4gICAgICB0aGlzLmludm9rZSh0aGlzLmxpc3RlbmVyc1tldmVudF0sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCcqJyBpbiB0aGlzLmxpc3RlbmVycykge1xcbiAgICAgIHRoaXMuaW52b2tlKHRoaXMubGlzdGVuZXJzWycqJ10sIGFyZ3VtZW50cyk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5pbnZva2UgPSBmdW5jdGlvbiAobGlzdGVuZXJzLCBwYXJhbXMpIHtcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBwYXJhbXMpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgVXRpbHMuT2JzZXJ2YWJsZSA9IE9ic2VydmFibGU7XFxuXFxuICBVdGlscy5nZW5lcmF0ZUNoYXJzID0gZnVuY3Rpb24gKGxlbmd0aCkge1xcbiAgICB2YXIgY2hhcnMgPSAnJztcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciByYW5kb21DaGFyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMzYpO1xcbiAgICAgIGNoYXJzICs9IHJhbmRvbUNoYXIudG9TdHJpbmcoMzYpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBjaGFycztcXG4gIH07XFxuXFxuICBVdGlscy5iaW5kID0gZnVuY3Rpb24gKGZ1bmMsIGNvbnRleHQpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XFxuICAgIH07XFxuICB9O1xcblxcbiAgVXRpbHMuX2NvbnZlcnREYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgZm9yICh2YXIgb3JpZ2luYWxLZXkgaW4gZGF0YSkge1xcbiAgICAgIHZhciBrZXlzID0gb3JpZ2luYWxLZXkuc3BsaXQoJy0nKTtcXG5cXG4gICAgICB2YXIgZGF0YUxldmVsID0gZGF0YTtcXG5cXG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcXG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2tdO1xcblxcbiAgICAgICAgLy8gTG93ZXJjYXNlIHRoZSBmaXJzdCBsZXR0ZXJcXG4gICAgICAgIC8vIEJ5IGRlZmF1bHQsIGRhc2gtc2VwYXJhdGVkIGJlY29tZXMgY2FtZWxDYXNlXFxuICAgICAgICBrZXkgPSBrZXkuc3Vic3RyaW5nKDAsIDEpLnRvTG93ZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xcblxcbiAgICAgICAgaWYgKCEoa2V5IGluIGRhdGFMZXZlbCkpIHtcXG4gICAgICAgICAgZGF0YUxldmVsW2tleV0gPSB7fTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChrID09IGtleXMubGVuZ3RoIC0gMSkge1xcbiAgICAgICAgICBkYXRhTGV2ZWxba2V5XSA9IGRhdGFbb3JpZ2luYWxLZXldO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YUxldmVsID0gZGF0YUxldmVsW2tleV07XFxuICAgICAgfVxcblxcbiAgICAgIGRlbGV0ZSBkYXRhW29yaWdpbmFsS2V5XTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZGF0YTtcXG4gIH07XFxuXFxuICBVdGlscy5oYXNTY3JvbGwgPSBmdW5jdGlvbiAoaW5kZXgsIGVsKSB7XFxuICAgIC8vIEFkYXB0ZWQgZnJvbSB0aGUgZnVuY3Rpb24gY3JlYXRlZCBieSBAU2hhZG93U2NyaXB0ZXJcXG4gICAgLy8gYW5kIGFkYXB0ZWQgYnkgQEJpbGxCYXJyeSBvbiB0aGUgU3RhY2sgRXhjaGFuZ2UgQ29kZSBSZXZpZXcgd2Vic2l0ZS5cXG4gICAgLy8gVGhlIG9yaWdpbmFsIGNvZGUgY2FuIGJlIGZvdW5kIGF0XFxuICAgIC8vIGh0dHA6Ly9jb2RlcmV2aWV3LnN0YWNrZXhjaGFuZ2UuY29tL3EvMTMzMzhcXG4gICAgLy8gYW5kIHdhcyBkZXNpZ25lZCB0byBiZSB1c2VkIHdpdGggdGhlIFNpenpsZSBzZWxlY3RvciBlbmdpbmUuXFxuXFxuICAgIHZhciAkZWwgPSAkKGVsKTtcXG4gICAgdmFyIG92ZXJmbG93WCA9IGVsLnN0eWxlLm92ZXJmbG93WDtcXG4gICAgdmFyIG92ZXJmbG93WSA9IGVsLnN0eWxlLm92ZXJmbG93WTtcXG5cXG4gICAgLy9DaGVjayBib3RoIHggYW5kIHkgZGVjbGFyYXRpb25zXFxuICAgIGlmIChvdmVyZmxvd1ggPT09IG92ZXJmbG93WSAmJlxcbiAgICAgICAgKG92ZXJmbG93WSA9PT0gJ2hpZGRlbicgfHwgb3ZlcmZsb3dZID09PSAndmlzaWJsZScpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIGlmIChvdmVyZmxvd1ggPT09ICdzY3JvbGwnIHx8IG92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpIHtcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gKCRlbC5pbm5lckhlaWdodCgpIDwgZWwuc2Nyb2xsSGVpZ2h0IHx8XFxuICAgICAgJGVsLmlubmVyV2lkdGgoKSA8IGVsLnNjcm9sbFdpZHRoKTtcXG4gIH07XFxuXFxuICBVdGlscy5lc2NhcGVNYXJrdXAgPSBmdW5jdGlvbiAobWFya3VwKSB7XFxuICAgIHZhciByZXBsYWNlTWFwID0ge1xcbiAgICAgICdcXFxcXFxcXCc6ICcmIzkyOycsXFxuICAgICAgJyYnOiAnJmFtcDsnLFxcbiAgICAgICc8JzogJyZsdDsnLFxcbiAgICAgICc+JzogJyZndDsnLFxcbiAgICAgICdcXFwiJzogJyZxdW90OycsXFxuICAgICAgJ1xcXFwnJzogJyYjMzk7JyxcXG4gICAgICAnLyc6ICcmIzQ3OydcXG4gICAgfTtcXG5cXG4gICAgLy8gRG8gbm90IHRyeSB0byBlc2NhcGUgdGhlIG1hcmt1cCBpZiBpdCdzIG5vdCBhIHN0cmluZ1xcbiAgICBpZiAodHlwZW9mIG1hcmt1cCAhPT0gJ3N0cmluZycpIHtcXG4gICAgICByZXR1cm4gbWFya3VwO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBTdHJpbmcobWFya3VwKS5yZXBsYWNlKC9bJjw+XFxcIidcXFxcL1xcXFxcXFxcXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcXG4gICAgICByZXR1cm4gcmVwbGFjZU1hcFttYXRjaF07XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIC8vIEFwcGVuZCBhbiBhcnJheSBvZiBqUXVlcnkgbm9kZXMgdG8gYSBnaXZlbiBlbGVtZW50LlxcbiAgVXRpbHMuYXBwZW5kTWFueSA9IGZ1bmN0aW9uICgkZWxlbWVudCwgJG5vZGVzKSB7XFxuICAgIC8vIGpRdWVyeSAxLjcueCBkb2VzIG5vdCBzdXBwb3J0ICQuZm4uYXBwZW5kKCkgd2l0aCBhbiBhcnJheVxcbiAgICAvLyBGYWxsIGJhY2sgdG8gYSBqUXVlcnkgb2JqZWN0IGNvbGxlY3Rpb24gdXNpbmcgJC5mbi5hZGQoKVxcbiAgICBpZiAoJC5mbi5qcXVlcnkuc3Vic3RyKDAsIDMpID09PSAnMS43Jykge1xcbiAgICAgIHZhciAkanFOb2RlcyA9ICQoKTtcXG5cXG4gICAgICAkLm1hcCgkbm9kZXMsIGZ1bmN0aW9uIChub2RlKSB7XFxuICAgICAgICAkanFOb2RlcyA9ICRqcU5vZGVzLmFkZChub2RlKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICAkbm9kZXMgPSAkanFOb2RlcztcXG4gICAgfVxcblxcbiAgICAkZWxlbWVudC5hcHBlbmQoJG5vZGVzKTtcXG4gIH07XFxuXFxuICAvLyBDYWNoZSBvYmplY3RzIGluIFV0aWxzLl9fY2FjaGUgaW5zdGVhZCBvZiAkLmRhdGEgKHNlZSAjNDM0NilcXG4gIFV0aWxzLl9fY2FjaGUgPSB7fTtcXG5cXG4gIHZhciBpZCA9IDA7XFxuICBVdGlscy5HZXRVbmlxdWVFbGVtZW50SWQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAvLyBHZXQgYSB1bmlxdWUgZWxlbWVudCBJZC4gSWYgZWxlbWVudCBoYXMgbm8gaWQsXFxuICAgIC8vIGNyZWF0ZXMgYSBuZXcgdW5pcXVlIG51bWJlciwgc3RvcmVzIGl0IGluIHRoZSBpZFxcbiAgICAvLyBhdHRyaWJ1dGUgYW5kIHJldHVybnMgdGhlIG5ldyBpZC5cXG4gICAgLy8gSWYgYW4gaWQgYWxyZWFkeSBleGlzdHMsIGl0IHNpbXBseSByZXR1cm5zIGl0LlxcblxcbiAgICB2YXIgc2VsZWN0MklkID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0Mi1pZCcpO1xcbiAgICBpZiAoc2VsZWN0MklkID09IG51bGwpIHtcXG4gICAgICAvLyBJZiBlbGVtZW50IGhhcyBpZCwgdXNlIGl0LlxcbiAgICAgIGlmIChlbGVtZW50LmlkKSB7XFxuICAgICAgICBzZWxlY3QySWQgPSBlbGVtZW50LmlkO1xcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0Mi1pZCcsIHNlbGVjdDJJZCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXNlbGVjdDItaWQnLCArK2lkKTtcXG4gICAgICAgIHNlbGVjdDJJZCA9IGlkLnRvU3RyaW5nKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBzZWxlY3QySWQ7XFxuICB9O1xcblxcbiAgVXRpbHMuU3RvcmVEYXRhID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHZhbHVlKSB7XFxuICAgIC8vIFN0b3JlcyBhbiBpdGVtIGluIHRoZSBjYWNoZSBmb3IgYSBzcGVjaWZpZWQgZWxlbWVudC5cXG4gICAgLy8gbmFtZSBpcyB0aGUgY2FjaGUga2V5LlxcbiAgICB2YXIgaWQgPSBVdGlscy5HZXRVbmlxdWVFbGVtZW50SWQoZWxlbWVudCk7XFxuICAgIGlmICghVXRpbHMuX19jYWNoZVtpZF0pIHtcXG4gICAgICBVdGlscy5fX2NhY2hlW2lkXSA9IHt9O1xcbiAgICB9XFxuXFxuICAgIFV0aWxzLl9fY2FjaGVbaWRdW25hbWVdID0gdmFsdWU7XFxuICB9O1xcblxcbiAgVXRpbHMuR2V0RGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XFxuICAgIC8vIFJldHJpZXZlcyBhIHZhbHVlIGZyb20gdGhlIGNhY2hlIGJ5IGl0cyBrZXkgKG5hbWUpXFxuICAgIC8vIG5hbWUgaXMgb3B0aW9uYWwuIElmIG5vIG5hbWUgc3BlY2lmaWVkLCByZXR1cm5cXG4gICAgLy8gYWxsIGNhY2hlIGl0ZW1zIGZvciB0aGUgc3BlY2lmaWVkIGVsZW1lbnQuXFxuICAgIC8vIGFuZCBmb3IgYSBzcGVjaWZpZWQgZWxlbWVudC5cXG4gICAgdmFyIGlkID0gVXRpbHMuR2V0VW5pcXVlRWxlbWVudElkKGVsZW1lbnQpO1xcbiAgICBpZiAobmFtZSkge1xcbiAgICAgIGlmIChVdGlscy5fX2NhY2hlW2lkXSkge1xcbiAgICAgICAgaWYgKFV0aWxzLl9fY2FjaGVbaWRdW25hbWVdICE9IG51bGwpIHtcXG4gICAgICAgICAgcmV0dXJuIFV0aWxzLl9fY2FjaGVbaWRdW25hbWVdO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuICQoZWxlbWVudCkuZGF0YShuYW1lKTsgLy8gRmFsbGJhY2sgdG8gSFRNTDUgZGF0YSBhdHRyaWJzLlxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gJChlbGVtZW50KS5kYXRhKG5hbWUpOyAvLyBGYWxsYmFjayB0byBIVE1MNSBkYXRhIGF0dHJpYnMuXFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIFV0aWxzLl9fY2FjaGVbaWRdO1xcbiAgICB9XFxuICB9O1xcblxcbiAgVXRpbHMuUmVtb3ZlRGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XFxuICAgIC8vIFJlbW92ZXMgYWxsIGNhY2hlZCBpdGVtcyBmb3IgYSBzcGVjaWZpZWQgZWxlbWVudC5cXG4gICAgdmFyIGlkID0gVXRpbHMuR2V0VW5pcXVlRWxlbWVudElkKGVsZW1lbnQpO1xcbiAgICBpZiAoVXRpbHMuX19jYWNoZVtpZF0gIT0gbnVsbCkge1xcbiAgICAgIGRlbGV0ZSBVdGlscy5fX2NhY2hlW2lkXTtcXG4gICAgfVxcblxcbiAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1zZWxlY3QyLWlkJyk7XFxuICB9O1xcblxcbiAgcmV0dXJuIFV0aWxzO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9yZXN1bHRzJyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uICgkLCBVdGlscykge1xcbiAgZnVuY3Rpb24gUmVzdWx0cyAoJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKSB7XFxuICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcXG4gICAgdGhpcy5kYXRhID0gZGF0YUFkYXB0ZXI7XFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFxuICAgIFJlc3VsdHMuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XFxuICB9XFxuXFxuICBVdGlscy5FeHRlbmQoUmVzdWx0cywgVXRpbHMuT2JzZXJ2YWJsZSk7XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciAkcmVzdWx0cyA9ICQoXFxuICAgICAgJzx1bCBjbGFzcz1cXFwic2VsZWN0Mi1yZXN1bHRzX19vcHRpb25zXFxcIiByb2xlPVxcXCJsaXN0Ym94XFxcIj48L3VsPidcXG4gICAgKTtcXG5cXG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ211bHRpcGxlJykpIHtcXG4gICAgICAkcmVzdWx0cy5hdHRyKCdhcmlhLW11bHRpc2VsZWN0YWJsZScsICd0cnVlJyk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kcmVzdWx0cyA9ICRyZXN1bHRzO1xcblxcbiAgICByZXR1cm4gJHJlc3VsdHM7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuJHJlc3VsdHMuZW1wdHkoKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5kaXNwbGF5TWVzc2FnZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgdmFyIGVzY2FwZU1hcmt1cCA9IHRoaXMub3B0aW9ucy5nZXQoJ2VzY2FwZU1hcmt1cCcpO1xcblxcbiAgICB0aGlzLmNsZWFyKCk7XFxuICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcXG5cXG4gICAgdmFyICRtZXNzYWdlID0gJChcXG4gICAgICAnPGxpIHJvbGU9XFxcImFsZXJ0XFxcIiBhcmlhLWxpdmU9XFxcImFzc2VydGl2ZVxcXCInICtcXG4gICAgICAnIGNsYXNzPVxcXCJzZWxlY3QyLXJlc3VsdHNfX29wdGlvblxcXCI+PC9saT4nXFxuICAgICk7XFxuXFxuICAgIHZhciBtZXNzYWdlID0gdGhpcy5vcHRpb25zLmdldCgndHJhbnNsYXRpb25zJykuZ2V0KHBhcmFtcy5tZXNzYWdlKTtcXG5cXG4gICAgJG1lc3NhZ2UuYXBwZW5kKFxcbiAgICAgIGVzY2FwZU1hcmt1cChcXG4gICAgICAgIG1lc3NhZ2UocGFyYW1zLmFyZ3MpXFxuICAgICAgKVxcbiAgICApO1xcblxcbiAgICAkbWVzc2FnZVswXS5jbGFzc05hbWUgKz0gJyBzZWxlY3QyLXJlc3VsdHNfX21lc3NhZ2UnO1xcblxcbiAgICB0aGlzLiRyZXN1bHRzLmFwcGVuZCgkbWVzc2FnZSk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuaGlkZU1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLiRyZXN1bHRzLmZpbmQoJy5zZWxlY3QyLXJlc3VsdHNfX21lc3NhZ2UnKS5yZW1vdmUoKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XFxuXFxuICAgIHZhciAkb3B0aW9ucyA9IFtdO1xcblxcbiAgICBpZiAoZGF0YS5yZXN1bHRzID09IG51bGwgfHwgZGF0YS5yZXN1bHRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIGlmICh0aGlzLiRyZXN1bHRzLmNoaWxkcmVuKCkubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Jlc3VsdHM6bWVzc2FnZScsIHtcXG4gICAgICAgICAgbWVzc2FnZTogJ25vUmVzdWx0cydcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZGF0YS5yZXN1bHRzID0gdGhpcy5zb3J0KGRhdGEucmVzdWx0cyk7XFxuXFxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGF0YS5yZXN1bHRzLmxlbmd0aDsgZCsrKSB7XFxuICAgICAgdmFyIGl0ZW0gPSBkYXRhLnJlc3VsdHNbZF07XFxuXFxuICAgICAgdmFyICRvcHRpb24gPSB0aGlzLm9wdGlvbihpdGVtKTtcXG5cXG4gICAgICAkb3B0aW9ucy5wdXNoKCRvcHRpb24pO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuJHJlc3VsdHMuYXBwZW5kKCRvcHRpb25zKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgkcmVzdWx0cywgJGRyb3Bkb3duKSB7XFxuICAgIHZhciAkcmVzdWx0c0NvbnRhaW5lciA9ICRkcm9wZG93bi5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzJyk7XFxuICAgICRyZXN1bHRzQ29udGFpbmVyLmFwcGVuZCgkcmVzdWx0cyk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuc29ydCA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgIHZhciBzb3J0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdzb3J0ZXInKTtcXG5cXG4gICAgcmV0dXJuIHNvcnRlcihkYXRhKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5oaWdobGlnaHRGaXJzdEl0ZW0gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciAkb3B0aW9ucyA9IHRoaXMuJHJlc3VsdHNcXG4gICAgICAuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uW2FyaWEtc2VsZWN0ZWRdJyk7XFxuXFxuICAgIHZhciAkc2VsZWN0ZWQgPSAkb3B0aW9ucy5maWx0ZXIoJ1thcmlhLXNlbGVjdGVkPXRydWVdJyk7XFxuXFxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGFyZSBhbnkgc2VsZWN0ZWQgb3B0aW9uc1xcbiAgICBpZiAoJHNlbGVjdGVkLmxlbmd0aCA+IDApIHtcXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgc2VsZWN0ZWQgb3B0aW9ucywgaGlnaGxpZ2h0IHRoZSBmaXJzdFxcbiAgICAgICRzZWxlY3RlZC5maXJzdCgpLnRyaWdnZXIoJ21vdXNlZW50ZXInKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc2VsZWN0ZWQgb3B0aW9ucywgaGlnaGxpZ2h0IHRoZSBmaXJzdCBvcHRpb25cXG4gICAgICAvLyBpbiB0aGUgZHJvcGRvd25cXG4gICAgICAkb3B0aW9ucy5maXJzdCgpLnRyaWdnZXIoJ21vdXNlZW50ZXInKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLmVuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5zZXRDbGFzc2VzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuZGF0YS5jdXJyZW50KGZ1bmN0aW9uIChzZWxlY3RlZCkge1xcbiAgICAgIHZhciBzZWxlY3RlZElkcyA9ICQubWFwKHNlbGVjdGVkLCBmdW5jdGlvbiAocykge1xcbiAgICAgICAgcmV0dXJuIHMuaWQudG9TdHJpbmcoKTtcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgJG9wdGlvbnMgPSBzZWxmLiRyZXN1bHRzXFxuICAgICAgICAuZmluZCgnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uW2FyaWEtc2VsZWN0ZWRdJyk7XFxuXFxuICAgICAgJG9wdGlvbnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgJG9wdGlvbiA9ICQodGhpcyk7XFxuXFxuICAgICAgICB2YXIgaXRlbSA9IFV0aWxzLkdldERhdGEodGhpcywgJ2RhdGEnKTtcXG5cXG4gICAgICAgIC8vIGlkIG5lZWRzIHRvIGJlIGNvbnZlcnRlZCB0byBhIHN0cmluZyB3aGVuIGNvbXBhcmluZ1xcbiAgICAgICAgdmFyIGlkID0gJycgKyBpdGVtLmlkO1xcblxcbiAgICAgICAgaWYgKChpdGVtLmVsZW1lbnQgIT0gbnVsbCAmJiBpdGVtLmVsZW1lbnQuc2VsZWN0ZWQpIHx8XFxuICAgICAgICAgICAgKGl0ZW0uZWxlbWVudCA9PSBudWxsICYmICQuaW5BcnJheShpZCwgc2VsZWN0ZWRJZHMpID4gLTEpKSB7XFxuICAgICAgICAgICRvcHRpb24uYXR0cignYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAkb3B0aW9uLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAnZmFsc2UnKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgfSk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuc2hvd0xvYWRpbmcgPSBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgIHRoaXMuaGlkZUxvYWRpbmcoKTtcXG5cXG4gICAgdmFyIGxvYWRpbmdNb3JlID0gdGhpcy5vcHRpb25zLmdldCgndHJhbnNsYXRpb25zJykuZ2V0KCdzZWFyY2hpbmcnKTtcXG5cXG4gICAgdmFyIGxvYWRpbmcgPSB7XFxuICAgICAgZGlzYWJsZWQ6IHRydWUsXFxuICAgICAgbG9hZGluZzogdHJ1ZSxcXG4gICAgICB0ZXh0OiBsb2FkaW5nTW9yZShwYXJhbXMpXFxuICAgIH07XFxuICAgIHZhciAkbG9hZGluZyA9IHRoaXMub3B0aW9uKGxvYWRpbmcpO1xcbiAgICAkbG9hZGluZy5jbGFzc05hbWUgKz0gJyBsb2FkaW5nLXJlc3VsdHMnO1xcblxcbiAgICB0aGlzLiRyZXN1bHRzLnByZXBlbmQoJGxvYWRpbmcpO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLmhpZGVMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLiRyZXN1bHRzLmZpbmQoJy5sb2FkaW5nLXJlc3VsdHMnKS5yZW1vdmUoKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB2YXIgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcXG4gICAgb3B0aW9uLmNsYXNzTmFtZSA9ICdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbic7XFxuXFxuICAgIHZhciBhdHRycyA9IHtcXG4gICAgICAncm9sZSc6ICdvcHRpb24nLFxcbiAgICAgICdhcmlhLXNlbGVjdGVkJzogJ2ZhbHNlJ1xcbiAgICB9O1xcblxcbiAgICB2YXIgbWF0Y2hlcyA9IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8XFxuICAgICAgd2luZG93LkVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XFxuICAgICAgd2luZG93LkVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcXG5cXG4gICAgaWYgKChkYXRhLmVsZW1lbnQgIT0gbnVsbCAmJiBtYXRjaGVzLmNhbGwoZGF0YS5lbGVtZW50LCAnOmRpc2FibGVkJykpIHx8XFxuICAgICAgICAoZGF0YS5lbGVtZW50ID09IG51bGwgJiYgZGF0YS5kaXNhYmxlZCkpIHtcXG4gICAgICBkZWxldGUgYXR0cnNbJ2FyaWEtc2VsZWN0ZWQnXTtcXG4gICAgICBhdHRyc1snYXJpYS1kaXNhYmxlZCddID0gJ3RydWUnO1xcbiAgICB9XFxuXFxuICAgIGlmIChkYXRhLmlkID09IG51bGwpIHtcXG4gICAgICBkZWxldGUgYXR0cnNbJ2FyaWEtc2VsZWN0ZWQnXTtcXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YS5fcmVzdWx0SWQgIT0gbnVsbCkge1xcbiAgICAgIG9wdGlvbi5pZCA9IGRhdGEuX3Jlc3VsdElkO1xcbiAgICB9XFxuXFxuICAgIGlmIChkYXRhLnRpdGxlKSB7XFxuICAgICAgb3B0aW9uLnRpdGxlID0gZGF0YS50aXRsZTtcXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YS5jaGlsZHJlbikge1xcbiAgICAgIGF0dHJzLnJvbGUgPSAnZ3JvdXAnO1xcbiAgICAgIGF0dHJzWydhcmlhLWxhYmVsJ10gPSBkYXRhLnRleHQ7XFxuICAgICAgZGVsZXRlIGF0dHJzWydhcmlhLXNlbGVjdGVkJ107XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgYXR0ciBpbiBhdHRycykge1xcbiAgICAgIHZhciB2YWwgPSBhdHRyc1thdHRyXTtcXG5cXG4gICAgICBvcHRpb24uc2V0QXR0cmlidXRlKGF0dHIsIHZhbCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRhdGEuY2hpbGRyZW4pIHtcXG4gICAgICB2YXIgJG9wdGlvbiA9ICQob3B0aW9uKTtcXG5cXG4gICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHJvbmcnKTtcXG4gICAgICBsYWJlbC5jbGFzc05hbWUgPSAnc2VsZWN0Mi1yZXN1bHRzX19ncm91cCc7XFxuXFxuICAgICAgdmFyICRsYWJlbCA9ICQobGFiZWwpO1xcbiAgICAgIHRoaXMudGVtcGxhdGUoZGF0YSwgbGFiZWwpO1xcblxcbiAgICAgIHZhciAkY2hpbGRyZW4gPSBbXTtcXG5cXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGRhdGEuY2hpbGRyZW4ubGVuZ3RoOyBjKyspIHtcXG4gICAgICAgIHZhciBjaGlsZCA9IGRhdGEuY2hpbGRyZW5bY107XFxuXFxuICAgICAgICB2YXIgJGNoaWxkID0gdGhpcy5vcHRpb24oY2hpbGQpO1xcblxcbiAgICAgICAgJGNoaWxkcmVuLnB1c2goJGNoaWxkKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyICRjaGlsZHJlbkNvbnRhaW5lciA9ICQoJzx1bD48L3VsPicsIHtcXG4gICAgICAgICdjbGFzcyc6ICdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbnMgc2VsZWN0Mi1yZXN1bHRzX19vcHRpb25zLS1uZXN0ZWQnXFxuICAgICAgfSk7XFxuXFxuICAgICAgJGNoaWxkcmVuQ29udGFpbmVyLmFwcGVuZCgkY2hpbGRyZW4pO1xcblxcbiAgICAgICRvcHRpb24uYXBwZW5kKGxhYmVsKTtcXG4gICAgICAkb3B0aW9uLmFwcGVuZCgkY2hpbGRyZW5Db250YWluZXIpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMudGVtcGxhdGUoZGF0YSwgb3B0aW9uKTtcXG4gICAgfVxcblxcbiAgICBVdGlscy5TdG9yZURhdGEob3B0aW9uLCAnZGF0YScsIGRhdGEpO1xcblxcbiAgICByZXR1cm4gb3B0aW9uO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdmFyIGlkID0gY29udGFpbmVyLmlkICsgJy1yZXN1bHRzJztcXG5cXG4gICAgdGhpcy4kcmVzdWx0cy5hdHRyKCdpZCcsIGlkKTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmFsbCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLmNsZWFyKCk7XFxuICAgICAgc2VsZi5hcHBlbmQocGFyYW1zLmRhdGEpO1xcblxcbiAgICAgIGlmIChjb250YWluZXIuaXNPcGVuKCkpIHtcXG4gICAgICAgIHNlbGYuc2V0Q2xhc3NlcygpO1xcbiAgICAgICAgc2VsZi5oaWdobGlnaHRGaXJzdEl0ZW0oKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6YXBwZW5kJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHNlbGYuYXBwZW5kKHBhcmFtcy5kYXRhKTtcXG5cXG4gICAgICBpZiAoY29udGFpbmVyLmlzT3BlbigpKSB7XFxuICAgICAgICBzZWxmLnNldENsYXNzZXMoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3F1ZXJ5JywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHNlbGYuaGlkZU1lc3NhZ2VzKCk7XFxuICAgICAgc2VsZi5zaG93TG9hZGluZyhwYXJhbXMpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKCFjb250YWluZXIuaXNPcGVuKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XFxuXFxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5nZXQoJ3Njcm9sbEFmdGVyU2VsZWN0JykpIHtcXG4gICAgICAgIHNlbGYuaGlnaGxpZ2h0Rmlyc3RJdGVtKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCd1bnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBpZiAoIWNvbnRhaW5lci5pc09wZW4oKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWxmLnNldENsYXNzZXMoKTtcXG5cXG4gICAgICBpZiAoc2VsZi5vcHRpb25zLmdldCgnc2Nyb2xsQWZ0ZXJTZWxlY3QnKSkge1xcbiAgICAgICAgc2VsZi5oaWdobGlnaHRGaXJzdEl0ZW0oKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgLy8gV2hlbiB0aGUgZHJvcGRvd24gaXMgb3BlbiwgYXJpYS1leHBlbmRlZD1cXFwidHJ1ZVxcXCJcXG4gICAgICBzZWxmLiRyZXN1bHRzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xcbiAgICAgIHNlbGYuJHJlc3VsdHMuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcXG5cXG4gICAgICBzZWxmLnNldENsYXNzZXMoKTtcXG4gICAgICBzZWxmLmVuc3VyZUhpZ2hsaWdodFZpc2libGUoKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgLy8gV2hlbiB0aGUgZHJvcGRvd24gaXMgY2xvc2VkLCBhcmlhLWV4cGVuZGVkPVxcXCJmYWxzZVxcXCJcXG4gICAgICBzZWxmLiRyZXN1bHRzLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcXG4gICAgICBzZWxmLiRyZXN1bHRzLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcXG4gICAgICBzZWxmLiRyZXN1bHRzLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOnRvZ2dsZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgJGhpZ2hsaWdodGVkID0gc2VsZi5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcXG5cXG4gICAgICBpZiAoJGhpZ2hsaWdodGVkLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICAkaGlnaGxpZ2h0ZWQudHJpZ2dlcignbW91c2V1cCcpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgJGhpZ2hsaWdodGVkID0gc2VsZi5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcXG5cXG4gICAgICBpZiAoJGhpZ2hsaWdodGVkLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZGF0YSA9IFV0aWxzLkdldERhdGEoJGhpZ2hsaWdodGVkWzBdLCAnZGF0YScpO1xcblxcbiAgICAgIGlmICgkaGlnaGxpZ2h0ZWQuYXR0cignYXJpYS1zZWxlY3RlZCcpID09ICd0cnVlJykge1xcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjbG9zZScsIHt9KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3QnLCB7XFxuICAgICAgICAgIGRhdGE6IGRhdGFcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpwcmV2aW91cycsIGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgJGhpZ2hsaWdodGVkID0gc2VsZi5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcXG5cXG4gICAgICB2YXIgJG9wdGlvbnMgPSBzZWxmLiRyZXN1bHRzLmZpbmQoJ1thcmlhLXNlbGVjdGVkXScpO1xcblxcbiAgICAgIHZhciBjdXJyZW50SW5kZXggPSAkb3B0aW9ucy5pbmRleCgkaGlnaGxpZ2h0ZWQpO1xcblxcbiAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGF0IHRoZSB0b3AsIGRvbid0IG1vdmUgZnVydGhlclxcbiAgICAgIC8vIElmIG5vIG9wdGlvbnMsIGN1cnJlbnRJbmRleCB3aWxsIGJlIC0xXFxuICAgICAgaWYgKGN1cnJlbnRJbmRleCA8PSAwKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBuZXh0SW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xcblxcbiAgICAgIC8vIElmIG5vbmUgYXJlIGhpZ2hsaWdodGVkLCBoaWdobGlnaHQgdGhlIGZpcnN0XFxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIG5leHRJbmRleCA9IDA7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciAkbmV4dCA9ICRvcHRpb25zLmVxKG5leHRJbmRleCk7XFxuXFxuICAgICAgJG5leHQudHJpZ2dlcignbW91c2VlbnRlcicpO1xcblxcbiAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gc2VsZi4kcmVzdWx0cy5vZmZzZXQoKS50b3A7XFxuICAgICAgdmFyIG5leHRUb3AgPSAkbmV4dC5vZmZzZXQoKS50b3A7XFxuICAgICAgdmFyIG5leHRPZmZzZXQgPSBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgpICsgKG5leHRUb3AgLSBjdXJyZW50T2Zmc2V0KTtcXG5cXG4gICAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XFxuICAgICAgICBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgwKTtcXG4gICAgICB9IGVsc2UgaWYgKG5leHRUb3AgLSBjdXJyZW50T2Zmc2V0IDwgMCkge1xcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AobmV4dE9mZnNldCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOm5leHQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICRoaWdobGlnaHRlZCA9IHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XFxuXFxuICAgICAgdmFyICRvcHRpb25zID0gc2VsZi4kcmVzdWx0cy5maW5kKCdbYXJpYS1zZWxlY3RlZF0nKTtcXG5cXG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gJG9wdGlvbnMuaW5kZXgoJGhpZ2hsaWdodGVkKTtcXG5cXG4gICAgICB2YXIgbmV4dEluZGV4ID0gY3VycmVudEluZGV4ICsgMTtcXG5cXG4gICAgICAvLyBJZiB3ZSBhcmUgYXQgdGhlIGxhc3Qgb3B0aW9uLCBzdGF5IHRoZXJlXFxuICAgICAgaWYgKG5leHRJbmRleCA+PSAkb3B0aW9ucy5sZW5ndGgpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyICRuZXh0ID0gJG9wdGlvbnMuZXEobmV4dEluZGV4KTtcXG5cXG4gICAgICAkbmV4dC50cmlnZ2VyKCdtb3VzZWVudGVyJyk7XFxuXFxuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSBzZWxmLiRyZXN1bHRzLm9mZnNldCgpLnRvcCArXFxuICAgICAgICBzZWxmLiRyZXN1bHRzLm91dGVySGVpZ2h0KGZhbHNlKTtcXG4gICAgICB2YXIgbmV4dEJvdHRvbSA9ICRuZXh0Lm9mZnNldCgpLnRvcCArICRuZXh0Lm91dGVySGVpZ2h0KGZhbHNlKTtcXG4gICAgICB2YXIgbmV4dE9mZnNldCA9IHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKCkgKyBuZXh0Qm90dG9tIC0gY3VycmVudE9mZnNldDtcXG5cXG4gICAgICBpZiAobmV4dEluZGV4ID09PSAwKSB7XFxuICAgICAgICBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgwKTtcXG4gICAgICB9IGVsc2UgaWYgKG5leHRCb3R0b20gPiBjdXJyZW50T2Zmc2V0KSB7XFxuICAgICAgICBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcChuZXh0T2Zmc2V0KTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6Zm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgcGFyYW1zLmVsZW1lbnQuYWRkQ2xhc3MoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1oaWdobGlnaHRlZCcpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOm1lc3NhZ2UnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgc2VsZi5kaXNwbGF5TWVzc2FnZShwYXJhbXMpO1xcbiAgICB9KTtcXG5cXG4gICAgaWYgKCQuZm4ubW91c2V3aGVlbCkge1xcbiAgICAgIHRoaXMuJHJlc3VsdHMub24oJ21vdXNld2hlZWwnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgdmFyIHRvcCA9IHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKCk7XFxuXFxuICAgICAgICB2YXIgYm90dG9tID0gc2VsZi4kcmVzdWx0cy5nZXQoMCkuc2Nyb2xsSGVpZ2h0IC0gdG9wICsgZS5kZWx0YVk7XFxuXFxuICAgICAgICB2YXIgaXNBdFRvcCA9IGUuZGVsdGFZID4gMCAmJiB0b3AgLSBlLmRlbHRhWSA8PSAwO1xcbiAgICAgICAgdmFyIGlzQXRCb3R0b20gPSBlLmRlbHRhWSA8IDAgJiYgYm90dG9tIDw9IHNlbGYuJHJlc3VsdHMuaGVpZ2h0KCk7XFxuXFxuICAgICAgICBpZiAoaXNBdFRvcCkge1xcbiAgICAgICAgICBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgwKTtcXG5cXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgfSBlbHNlIGlmIChpc0F0Qm90dG9tKSB7XFxuICAgICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKFxcbiAgICAgICAgICAgIHNlbGYuJHJlc3VsdHMuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHNlbGYuJHJlc3VsdHMuaGVpZ2h0KClcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuJHJlc3VsdHMub24oJ21vdXNldXAnLCAnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uW2FyaWEtc2VsZWN0ZWRdJyxcXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgdmFyICR0aGlzID0gJCh0aGlzKTtcXG5cXG4gICAgICB2YXIgZGF0YSA9IFV0aWxzLkdldERhdGEodGhpcywgJ2RhdGEnKTtcXG5cXG4gICAgICBpZiAoJHRoaXMuYXR0cignYXJpYS1zZWxlY3RlZCcpID09PSAndHJ1ZScpIHtcXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZ2V0KCdtdWx0aXBsZScpKSB7XFxuICAgICAgICAgIHNlbGYudHJpZ2dlcigndW5zZWxlY3QnLCB7XFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0LFxcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ2Nsb3NlJywge30pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdCcsIHtcXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dCxcXG4gICAgICAgIGRhdGE6IGRhdGFcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJHJlc3VsdHMub24oJ21vdXNlZW50ZXInLCAnLnNlbGVjdDItcmVzdWx0c19fb3B0aW9uW2FyaWEtc2VsZWN0ZWRdJyxcXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKHRoaXMsICdkYXRhJyk7XFxuXFxuICAgICAgc2VsZi5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKVxcbiAgICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1oaWdobGlnaHRlZCcpO1xcblxcbiAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpmb2N1cycsIHtcXG4gICAgICAgIGRhdGE6IGRhdGEsXFxuICAgICAgICBlbGVtZW50OiAkKHRoaXMpXFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLmdldEhpZ2hsaWdodGVkUmVzdWx0cyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRoaWdobGlnaHRlZCA9IHRoaXMuJHJlc3VsdHNcXG4gICAgLmZpbmQoJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0taGlnaGxpZ2h0ZWQnKTtcXG5cXG4gICAgcmV0dXJuICRoaWdobGlnaHRlZDtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLiRyZXN1bHRzLnJlbW92ZSgpO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLmVuc3VyZUhpZ2hsaWdodFZpc2libGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciAkaGlnaGxpZ2h0ZWQgPSB0aGlzLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xcblxcbiAgICBpZiAoJGhpZ2hsaWdodGVkLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRyZXN1bHRzLmZpbmQoJ1thcmlhLXNlbGVjdGVkXScpO1xcblxcbiAgICB2YXIgY3VycmVudEluZGV4ID0gJG9wdGlvbnMuaW5kZXgoJGhpZ2hsaWdodGVkKTtcXG5cXG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB0aGlzLiRyZXN1bHRzLm9mZnNldCgpLnRvcDtcXG4gICAgdmFyIG5leHRUb3AgPSAkaGlnaGxpZ2h0ZWQub2Zmc2V0KCkudG9wO1xcbiAgICB2YXIgbmV4dE9mZnNldCA9IHRoaXMuJHJlc3VsdHMuc2Nyb2xsVG9wKCkgKyAobmV4dFRvcCAtIGN1cnJlbnRPZmZzZXQpO1xcblxcbiAgICB2YXIgb2Zmc2V0RGVsdGEgPSBuZXh0VG9wIC0gY3VycmVudE9mZnNldDtcXG4gICAgbmV4dE9mZnNldCAtPSAkaGlnaGxpZ2h0ZWQub3V0ZXJIZWlnaHQoZmFsc2UpICogMjtcXG5cXG4gICAgaWYgKGN1cnJlbnRJbmRleCA8PSAyKSB7XFxuICAgICAgdGhpcy4kcmVzdWx0cy5zY3JvbGxUb3AoMCk7XFxuICAgIH0gZWxzZSBpZiAob2Zmc2V0RGVsdGEgPiB0aGlzLiRyZXN1bHRzLm91dGVySGVpZ2h0KCkgfHwgb2Zmc2V0RGVsdGEgPCAwKSB7XFxuICAgICAgdGhpcy4kcmVzdWx0cy5zY3JvbGxUb3AobmV4dE9mZnNldCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS50ZW1wbGF0ZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGNvbnRhaW5lcikge1xcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVJlc3VsdCcpO1xcbiAgICB2YXIgZXNjYXBlTWFya3VwID0gdGhpcy5vcHRpb25zLmdldCgnZXNjYXBlTWFya3VwJyk7XFxuXFxuICAgIHZhciBjb250ZW50ID0gdGVtcGxhdGUocmVzdWx0LCBjb250YWluZXIpO1xcblxcbiAgICBpZiAoY29udGVudCA9PSBudWxsKSB7XFxuICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgY29udGFpbmVyLmlubmVySFRNTCA9IGVzY2FwZU1hcmt1cChjb250ZW50KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkKGNvbnRhaW5lcikuYXBwZW5kKGNvbnRlbnQpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgcmV0dXJuIFJlc3VsdHM7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2tleXMnLFtcXG5cXG5dLCBmdW5jdGlvbiAoKSB7XFxuICB2YXIgS0VZUyA9IHtcXG4gICAgQkFDS1NQQUNFOiA4LFxcbiAgICBUQUI6IDksXFxuICAgIEVOVEVSOiAxMyxcXG4gICAgU0hJRlQ6IDE2LFxcbiAgICBDVFJMOiAxNyxcXG4gICAgQUxUOiAxOCxcXG4gICAgRVNDOiAyNyxcXG4gICAgU1BBQ0U6IDMyLFxcbiAgICBQQUdFX1VQOiAzMyxcXG4gICAgUEFHRV9ET1dOOiAzNCxcXG4gICAgRU5EOiAzNSxcXG4gICAgSE9NRTogMzYsXFxuICAgIExFRlQ6IDM3LFxcbiAgICBVUDogMzgsXFxuICAgIFJJR0hUOiAzOSxcXG4gICAgRE9XTjogNDAsXFxuICAgIERFTEVURTogNDZcXG4gIH07XFxuXFxuICByZXR1cm4gS0VZUztcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL2Jhc2UnLFtcXG4gICdqcXVlcnknLFxcbiAgJy4uL3V0aWxzJyxcXG4gICcuLi9rZXlzJ1xcbl0sIGZ1bmN0aW9uICgkLCBVdGlscywgS0VZUykge1xcbiAgZnVuY3Rpb24gQmFzZVNlbGVjdGlvbiAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcbiAgICBCYXNlU2VsZWN0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xcbiAgfVxcblxcbiAgVXRpbHMuRXh0ZW5kKEJhc2VTZWxlY3Rpb24sIFV0aWxzLk9ic2VydmFibGUpO1xcblxcbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJHNlbGVjdGlvbiA9ICQoXFxuICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLXNlbGVjdGlvblxcXCIgcm9sZT1cXFwiY29tYm9ib3hcXFwiICcgK1xcbiAgICAgICcgYXJpYS1oYXNwb3B1cD1cXFwidHJ1ZVxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiPicgK1xcbiAgICAgICc8L3NwYW4+J1xcbiAgICApO1xcblxcbiAgICB0aGlzLl90YWJpbmRleCA9IDA7XFxuXFxuICAgIGlmIChVdGlscy5HZXREYXRhKHRoaXMuJGVsZW1lbnRbMF0sICdvbGQtdGFiaW5kZXgnKSAhPSBudWxsKSB7XFxuICAgICAgdGhpcy5fdGFiaW5kZXggPSBVdGlscy5HZXREYXRhKHRoaXMuJGVsZW1lbnRbMF0sICdvbGQtdGFiaW5kZXgnKTtcXG4gICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykgIT0gbnVsbCkge1xcbiAgICAgIHRoaXMuX3RhYmluZGV4ID0gdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpO1xcbiAgICB9XFxuXFxuICAgICRzZWxlY3Rpb24uYXR0cigndGl0bGUnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJykpO1xcbiAgICAkc2VsZWN0aW9uLmF0dHIoJ3RhYmluZGV4JywgdGhpcy5fdGFiaW5kZXgpO1xcbiAgICAkc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAnZmFsc2UnKTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uID0gJHNlbGVjdGlvbjtcXG5cXG4gICAgcmV0dXJuICRzZWxlY3Rpb247XFxuICB9O1xcblxcbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB2YXIgcmVzdWx0c0lkID0gY29udGFpbmVyLmlkICsgJy1yZXN1bHRzJztcXG5cXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2JsdXInLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgc2VsZi5faGFuZGxlQmx1cihldnQpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYudHJpZ2dlcigna2V5cHJlc3MnLCBldnQpO1xcblxcbiAgICAgIGlmIChldnQud2hpY2ggPT09IEtFWVMuU1BBQ0UpIHtcXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpmb2N1cycsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLiRzZWxlY3Rpb24uYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgcGFyYW1zLmRhdGEuX3Jlc3VsdElkKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0aW9uOnVwZGF0ZScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLnVwZGF0ZShwYXJhbXMuZGF0YSk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgLy8gV2hlbiB0aGUgZHJvcGRvd24gaXMgb3BlbiwgYXJpYS1leHBhbmRlZD1cXFwidHJ1ZVxcXCJcXG4gICAgICBzZWxmLiRzZWxlY3Rpb24uYXR0cignYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtb3ducycsIHJlc3VsdHNJZCk7XFxuXFxuICAgICAgc2VsZi5fYXR0YWNoQ2xvc2VIYW5kbGVyKGNvbnRhaW5lcik7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIC8vIFdoZW4gdGhlIGRyb3Bkb3duIGlzIGNsb3NlZCwgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiXFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcXG4gICAgICBzZWxmLiRzZWxlY3Rpb24ucmVtb3ZlQXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLnJlbW92ZUF0dHIoJ2FyaWEtb3ducycpO1xcblxcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi50cmlnZ2VyKCdmb2N1cycpO1xcblxcbiAgICAgIHNlbGYuX2RldGFjaENsb3NlSGFuZGxlcihjb250YWluZXIpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdlbmFibGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ3RhYmluZGV4Jywgc2VsZi5fdGFiaW5kZXgpO1xcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2Rpc2FibGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCAndHJ1ZScpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5faGFuZGxlQmx1ciA9IGZ1bmN0aW9uIChldnQpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYXMgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIHRoZSBib2R5IHdoZW4gdGhlIHRhYlxcbiAgICAvLyBrZXkgaXMgcHJlc3NlZCwgcG9zc2libHkgYWxvbmcgd2l0aCBvdGhlcnMuXFxuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBEb24ndCB0cmlnZ2VyIGBibHVyYCBpZiB0aGUgZm9jdXMgaXMgc3RpbGwgaW4gdGhlIHNlbGVjdGlvblxcbiAgICAgIGlmIChcXG4gICAgICAgIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHNlbGYuJHNlbGVjdGlvblswXSkgfHxcXG4gICAgICAgICgkLmNvbnRhaW5zKHNlbGYuJHNlbGVjdGlvblswXSwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXFxuICAgICAgKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHNlbGYudHJpZ2dlcignYmx1cicsIGV2dCk7XFxuICAgIH0sIDEpO1xcbiAgfTtcXG5cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLl9hdHRhY2hDbG9zZUhhbmRsZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XFxuXFxuICAgICQoZG9jdW1lbnQuYm9keSkub24oJ21vdXNlZG93bi5zZWxlY3QyLicgKyBjb250YWluZXIuaWQsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgdmFyICR0YXJnZXQgPSAkKGUudGFyZ2V0KTtcXG5cXG4gICAgICB2YXIgJHNlbGVjdCA9ICR0YXJnZXQuY2xvc2VzdCgnLnNlbGVjdDInKTtcXG5cXG4gICAgICB2YXIgJGFsbCA9ICQoJy5zZWxlY3QyLnNlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XFxuXFxuICAgICAgJGFsbC5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmICh0aGlzID09ICRzZWxlY3RbMF0pIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyICRlbGVtZW50ID0gVXRpbHMuR2V0RGF0YSh0aGlzLCAnZWxlbWVudCcpO1xcblxcbiAgICAgICAgJGVsZW1lbnQuc2VsZWN0MignY2xvc2UnKTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuX2RldGFjaENsb3NlSGFuZGxlciA9IGZ1bmN0aW9uIChjb250YWluZXIpIHtcXG4gICAgJChkb2N1bWVudC5ib2R5KS5vZmYoJ21vdXNlZG93bi5zZWxlY3QyLicgKyBjb250YWluZXIuaWQpO1xcbiAgfTtcXG5cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCRzZWxlY3Rpb24sICRjb250YWluZXIpIHtcXG4gICAgdmFyICRzZWxlY3Rpb25Db250YWluZXIgPSAkY29udGFpbmVyLmZpbmQoJy5zZWxlY3Rpb24nKTtcXG4gICAgJHNlbGVjdGlvbkNvbnRhaW5lci5hcHBlbmQoJHNlbGVjdGlvbik7XFxuICB9O1xcblxcbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5fZGV0YWNoQ2xvc2VIYW5kbGVyKHRoaXMuY29udGFpbmVyKTtcXG4gIH07XFxuXFxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgdXBkYXRlYCBtZXRob2QgbXVzdCBiZSBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXMuJyk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFic3RyYWN0IHRoZSBcXFwiZW5hYmxlZFxcXCIgKG5vdCBcXFwiZGlzYWJsZWRcXFwiKSBzdGF0ZSBvZiB0aGlzXFxuICAgKiBvYmplY3QuXFxuICAgKlxcbiAgICogQHJldHVybiB7dHJ1ZX0gaWYgdGhlIGluc3RhbmNlIGlzIG5vdCBkaXNhYmxlZC5cXG4gICAqIEByZXR1cm4ge2ZhbHNlfSBpZiB0aGUgaW5zdGFuY2UgaXMgZGlzYWJsZWQuXFxuICAgKi9cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLmlzRW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuICF0aGlzLmlzRGlzYWJsZWQoKTtcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWJzdHJhY3QgdGhlIFxcXCJkaXNhYmxlZFxcXCIgc3RhdGUgb2YgdGhpcyBvYmplY3QuXFxuICAgKlxcbiAgICogQHJldHVybiB7dHJ1ZX0gaWYgdGhlIGRpc2FibGVkIG9wdGlvbiBpcyB0cnVlLlxcbiAgICogQHJldHVybiB7ZmFsc2V9IGlmIHRoZSBkaXNhYmxlZCBvcHRpb24gaXMgZmFsc2UuXFxuICAgKi9cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLmlzRGlzYWJsZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZ2V0KCdkaXNhYmxlZCcpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBCYXNlU2VsZWN0aW9uO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vc2luZ2xlJyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuL2Jhc2UnLFxcbiAgJy4uL3V0aWxzJyxcXG4gICcuLi9rZXlzJ1xcbl0sIGZ1bmN0aW9uICgkLCBCYXNlU2VsZWN0aW9uLCBVdGlscywgS0VZUykge1xcbiAgZnVuY3Rpb24gU2luZ2xlU2VsZWN0aW9uICgpIHtcXG4gICAgU2luZ2xlU2VsZWN0aW9uLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgfVxcblxcbiAgVXRpbHMuRXh0ZW5kKFNpbmdsZVNlbGVjdGlvbiwgQmFzZVNlbGVjdGlvbik7XFxuXFxuICBTaW5nbGVTZWxlY3Rpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRzZWxlY3Rpb24gPSBTaW5nbGVTZWxlY3Rpb24uX19zdXBlcl9fLnJlbmRlci5jYWxsKHRoaXMpO1xcblxcbiAgICAkc2VsZWN0aW9uLmFkZENsYXNzKCdzZWxlY3QyLXNlbGVjdGlvbi0tc2luZ2xlJyk7XFxuXFxuICAgICRzZWxlY3Rpb24uaHRtbChcXG4gICAgICAnPHNwYW4gY2xhc3M9XFxcInNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZFxcXCI+PC9zcGFuPicgK1xcbiAgICAgICc8c3BhbiBjbGFzcz1cXFwic2VsZWN0Mi1zZWxlY3Rpb25fX2Fycm93XFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPicgK1xcbiAgICAgICAgJzxiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+PC9iPicgK1xcbiAgICAgICc8L3NwYW4+J1xcbiAgICApO1xcblxcbiAgICByZXR1cm4gJHNlbGVjdGlvbjtcXG4gIH07XFxuXFxuICBTaW5nbGVTZWxlY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgU2luZ2xlU2VsZWN0aW9uLl9fc3VwZXJfXy5iaW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFxuICAgIHZhciBpZCA9IGNvbnRhaW5lci5pZCArICctY29udGFpbmVyJztcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKVxcbiAgICAgIC5hdHRyKCdpZCcsIGlkKVxcbiAgICAgIC5hdHRyKCdyb2xlJywgJ3RleHRib3gnKVxcbiAgICAgIC5hdHRyKCdhcmlhLXJlYWRvbmx5JywgJ3RydWUnKTtcXG4gICAgdGhpcy4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtbGFiZWxsZWRieScsIGlkKTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgLy8gT25seSByZXNwb25kIHRvIGxlZnQgY2xpY2tzXFxuICAgICAgaWYgKGV2dC53aGljaCAhPT0gMSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWxmLnRyaWdnZXIoJ3RvZ2dsZScsIHtcXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdmb2N1cycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAvLyBVc2VyIGZvY3VzZXMgb24gdGhlIGNvbnRhaW5lclxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdibHVyJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIC8vIFVzZXIgZXhpdHMgdGhlIGNvbnRhaW5lclxcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdmb2N1cycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBpZiAoIWNvbnRhaW5lci5pc09wZW4oKSkge1xcbiAgICAgICAgc2VsZi4kc2VsZWN0aW9uLnRyaWdnZXIoJ2ZvY3VzJyk7XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTaW5nbGVTZWxlY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcXG4gICAgJHJlbmRlcmVkLmVtcHR5KCk7XFxuICAgICRyZW5kZXJlZC5yZW1vdmVBdHRyKCd0aXRsZScpOyAvLyBjbGVhciB0b29sdGlwIG9uIGVtcHR5XFxuICB9O1xcblxcbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5kaXNwbGF5ID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lcikge1xcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVNlbGVjdGlvbicpO1xcbiAgICB2YXIgZXNjYXBlTWFya3VwID0gdGhpcy5vcHRpb25zLmdldCgnZXNjYXBlTWFya3VwJyk7XFxuXFxuICAgIHJldHVybiBlc2NhcGVNYXJrdXAodGVtcGxhdGUoZGF0YSwgY29udGFpbmVyKSk7XFxuICB9O1xcblxcbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3Rpb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiAkKCc8c3Bhbj48L3NwYW4+Jyk7XFxuICB9O1xcblxcbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcXG4gICAgICB0aGlzLmNsZWFyKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciBzZWxlY3Rpb24gPSBkYXRhWzBdO1xcblxcbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcXG4gICAgdmFyIGZvcm1hdHRlZCA9IHRoaXMuZGlzcGxheShzZWxlY3Rpb24sICRyZW5kZXJlZCk7XFxuXFxuICAgICRyZW5kZXJlZC5lbXB0eSgpLmFwcGVuZChmb3JtYXR0ZWQpO1xcblxcbiAgICB2YXIgdGl0bGUgPSBzZWxlY3Rpb24udGl0bGUgfHwgc2VsZWN0aW9uLnRleHQ7XFxuXFxuICAgIGlmICh0aXRsZSkge1xcbiAgICAgICRyZW5kZXJlZC5hdHRyKCd0aXRsZScsIHRpdGxlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkcmVuZGVyZWQucmVtb3ZlQXR0cigndGl0bGUnKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBTaW5nbGVTZWxlY3Rpb247XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL3NlbGVjdGlvbi9tdWx0aXBsZScsW1xcbiAgJ2pxdWVyeScsXFxuICAnLi9iYXNlJyxcXG4gICcuLi91dGlscydcXG5dLCBmdW5jdGlvbiAoJCwgQmFzZVNlbGVjdGlvbiwgVXRpbHMpIHtcXG4gIGZ1bmN0aW9uIE11bHRpcGxlU2VsZWN0aW9uICgkZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICBNdWx0aXBsZVNlbGVjdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIFV0aWxzLkV4dGVuZChNdWx0aXBsZVNlbGVjdGlvbiwgQmFzZVNlbGVjdGlvbik7XFxuXFxuICBNdWx0aXBsZVNlbGVjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJHNlbGVjdGlvbiA9IE11bHRpcGxlU2VsZWN0aW9uLl9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcXG5cXG4gICAgJHNlbGVjdGlvbi5hZGRDbGFzcygnc2VsZWN0Mi1zZWxlY3Rpb24tLW11bHRpcGxlJyk7XFxuXFxuICAgICRzZWxlY3Rpb24uaHRtbChcXG4gICAgICAnPHVsIGNsYXNzPVxcXCJzZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWRcXFwiPjwvdWw+J1xcbiAgICApO1xcblxcbiAgICByZXR1cm4gJHNlbGVjdGlvbjtcXG4gIH07XFxuXFxuICBNdWx0aXBsZVNlbGVjdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICBNdWx0aXBsZVNlbGVjdGlvbi5fX3N1cGVyX18uYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYudHJpZ2dlcigndG9nZ2xlJywge1xcbiAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oXFxuICAgICAgJ2NsaWNrJyxcXG4gICAgICAnLnNlbGVjdDItc2VsZWN0aW9uX19jaG9pY2VfX3JlbW92ZScsXFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiBpdCBpcyBkaXNhYmxlZFxcbiAgICAgICAgaWYgKHNlbGYuaXNEaXNhYmxlZCgpKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciAkcmVtb3ZlID0gJCh0aGlzKTtcXG4gICAgICAgIHZhciAkc2VsZWN0aW9uID0gJHJlbW92ZS5wYXJlbnQoKTtcXG5cXG4gICAgICAgIHZhciBkYXRhID0gVXRpbHMuR2V0RGF0YSgkc2VsZWN0aW9uWzBdLCAnZGF0YScpO1xcblxcbiAgICAgICAgc2VsZi50cmlnZ2VyKCd1bnNlbGVjdCcsIHtcXG4gICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0LFxcbiAgICAgICAgICBkYXRhOiBkYXRhXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgICk7XFxuICB9O1xcblxcbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcXG4gICAgJHJlbmRlcmVkLmVtcHR5KCk7XFxuICAgICRyZW5kZXJlZC5yZW1vdmVBdHRyKCd0aXRsZScpO1xcbiAgfTtcXG5cXG4gIE11bHRpcGxlU2VsZWN0aW9uLnByb3RvdHlwZS5kaXNwbGF5ID0gZnVuY3Rpb24gKGRhdGEsIGNvbnRhaW5lcikge1xcbiAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0ZW1wbGF0ZVNlbGVjdGlvbicpO1xcbiAgICB2YXIgZXNjYXBlTWFya3VwID0gdGhpcy5vcHRpb25zLmdldCgnZXNjYXBlTWFya3VwJyk7XFxuXFxuICAgIHJldHVybiBlc2NhcGVNYXJrdXAodGVtcGxhdGUoZGF0YSwgY29udGFpbmVyKSk7XFxuICB9O1xcblxcbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLnNlbGVjdGlvbkNvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRjb250YWluZXIgPSAkKFxcbiAgICAgICc8bGkgY2xhc3M9XFxcInNlbGVjdDItc2VsZWN0aW9uX19jaG9pY2VcXFwiPicgK1xcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlX19yZW1vdmVcXFwiIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCI+JyArXFxuICAgICAgICAgICcmdGltZXM7JyArXFxuICAgICAgICAnPC9zcGFuPicgK1xcbiAgICAgICc8L2xpPidcXG4gICAgKTtcXG5cXG4gICAgcmV0dXJuICRjb250YWluZXI7XFxuICB9O1xcblxcbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgIHRoaXMuY2xlYXIoKTtcXG5cXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciAkc2VsZWN0aW9ucyA9IFtdO1xcblxcbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcXG4gICAgICB2YXIgc2VsZWN0aW9uID0gZGF0YVtkXTtcXG5cXG4gICAgICB2YXIgJHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uQ29udGFpbmVyKCk7XFxuICAgICAgdmFyIGZvcm1hdHRlZCA9IHRoaXMuZGlzcGxheShzZWxlY3Rpb24sICRzZWxlY3Rpb24pO1xcblxcbiAgICAgICRzZWxlY3Rpb24uYXBwZW5kKGZvcm1hdHRlZCk7XFxuXFxuICAgICAgdmFyIHRpdGxlID0gc2VsZWN0aW9uLnRpdGxlIHx8IHNlbGVjdGlvbi50ZXh0O1xcblxcbiAgICAgIGlmICh0aXRsZSkge1xcbiAgICAgICAgJHNlbGVjdGlvbi5hdHRyKCd0aXRsZScsIHRpdGxlKTtcXG4gICAgICB9XFxuXFxuICAgICAgVXRpbHMuU3RvcmVEYXRhKCRzZWxlY3Rpb25bMF0sICdkYXRhJywgc2VsZWN0aW9uKTtcXG5cXG4gICAgICAkc2VsZWN0aW9ucy5wdXNoKCRzZWxlY3Rpb24pO1xcbiAgICB9XFxuXFxuICAgIHZhciAkcmVuZGVyZWQgPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZCcpO1xcblxcbiAgICBVdGlscy5hcHBlbmRNYW55KCRyZW5kZXJlZCwgJHNlbGVjdGlvbnMpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBNdWx0aXBsZVNlbGVjdGlvbjtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL3BsYWNlaG9sZGVyJyxbXFxuICAnLi4vdXRpbHMnXFxuXSwgZnVuY3Rpb24gKFV0aWxzKSB7XFxuICBmdW5jdGlvbiBQbGFjZWhvbGRlciAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICB0aGlzLnBsYWNlaG9sZGVyID0gdGhpcy5ub3JtYWxpemVQbGFjZWhvbGRlcihvcHRpb25zLmdldCgncGxhY2Vob2xkZXInKSk7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcXG4gIH1cXG5cXG4gIFBsYWNlaG9sZGVyLnByb3RvdHlwZS5ub3JtYWxpemVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChfLCBwbGFjZWhvbGRlcikge1xcbiAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyID09PSAnc3RyaW5nJykge1xcbiAgICAgIHBsYWNlaG9sZGVyID0ge1xcbiAgICAgICAgaWQ6ICcnLFxcbiAgICAgICAgdGV4dDogcGxhY2Vob2xkZXJcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcXG4gIH07XFxuXFxuICBQbGFjZWhvbGRlci5wcm90b3R5cGUuY3JlYXRlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwbGFjZWhvbGRlcikge1xcbiAgICB2YXIgJHBsYWNlaG9sZGVyID0gdGhpcy5zZWxlY3Rpb25Db250YWluZXIoKTtcXG5cXG4gICAgJHBsYWNlaG9sZGVyLmh0bWwodGhpcy5kaXNwbGF5KHBsYWNlaG9sZGVyKSk7XFxuICAgICRwbGFjZWhvbGRlci5hZGRDbGFzcygnc2VsZWN0Mi1zZWxlY3Rpb25fX3BsYWNlaG9sZGVyJylcXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKCdzZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlJyk7XFxuXFxuICAgIHJldHVybiAkcGxhY2Vob2xkZXI7XFxuICB9O1xcblxcbiAgUGxhY2Vob2xkZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGRhdGEpIHtcXG4gICAgdmFyIHNpbmdsZVBsYWNlaG9sZGVyID0gKFxcbiAgICAgIGRhdGEubGVuZ3RoID09IDEgJiYgZGF0YVswXS5pZCAhPSB0aGlzLnBsYWNlaG9sZGVyLmlkXFxuICAgICk7XFxuICAgIHZhciBtdWx0aXBsZVNlbGVjdGlvbnMgPSBkYXRhLmxlbmd0aCA+IDE7XFxuXFxuICAgIGlmIChtdWx0aXBsZVNlbGVjdGlvbnMgfHwgc2luZ2xlUGxhY2Vob2xkZXIpIHtcXG4gICAgICByZXR1cm4gZGVjb3JhdGVkLmNhbGwodGhpcywgZGF0YSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5jbGVhcigpO1xcblxcbiAgICB2YXIgJHBsYWNlaG9sZGVyID0gdGhpcy5jcmVhdGVQbGFjZWhvbGRlcih0aGlzLnBsYWNlaG9sZGVyKTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKS5hcHBlbmQoJHBsYWNlaG9sZGVyKTtcXG4gIH07XFxuXFxuICByZXR1cm4gUGxhY2Vob2xkZXI7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL3NlbGVjdGlvbi9hbGxvd0NsZWFyJyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuLi9rZXlzJyxcXG4gICcuLi91dGlscydcXG5dLCBmdW5jdGlvbiAoJCwgS0VZUywgVXRpbHMpIHtcXG4gIGZ1bmN0aW9uIEFsbG93Q2xlYXIgKCkgeyB9XFxuXFxuICBBbGxvd0NsZWFyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIgPT0gbnVsbCkge1xcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUuZXJyb3IpIHtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXFxuICAgICAgICAgICdTZWxlY3QyOiBUaGUgYGFsbG93Q2xlYXJgIG9wdGlvbiBzaG91bGQgYmUgdXNlZCBpbiBjb21iaW5hdGlvbiAnICtcXG4gICAgICAgICAgJ3dpdGggdGhlIGBwbGFjZWhvbGRlcmAgb3B0aW9uLidcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignbW91c2Vkb3duJywgJy5zZWxlY3QyLXNlbGVjdGlvbl9fY2xlYXInLFxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIHNlbGYuX2hhbmRsZUNsZWFyKGV2dCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2tleXByZXNzJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYuX2hhbmRsZUtleWJvYXJkQ2xlYXIoZXZ0LCBjb250YWluZXIpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBBbGxvd0NsZWFyLnByb3RvdHlwZS5faGFuZGxlQ2xlYXIgPSBmdW5jdGlvbiAoXywgZXZ0KSB7XFxuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgaXQgaXMgZGlzYWJsZWRcXG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCgpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciAkY2xlYXIgPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19jbGVhcicpO1xcblxcbiAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIG5vdGhpbmcgaGFzIGJlZW4gc2VsZWN0ZWRcXG4gICAgaWYgKCRjbGVhci5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcbiAgICB2YXIgZGF0YSA9IFV0aWxzLkdldERhdGEoJGNsZWFyWzBdLCAnZGF0YScpO1xcblxcbiAgICB2YXIgcHJldmlvdXNWYWwgPSB0aGlzLiRlbGVtZW50LnZhbCgpO1xcbiAgICB0aGlzLiRlbGVtZW50LnZhbCh0aGlzLnBsYWNlaG9sZGVyLmlkKTtcXG5cXG4gICAgdmFyIHVuc2VsZWN0RGF0YSA9IHtcXG4gICAgICBkYXRhOiBkYXRhXFxuICAgIH07XFxuICAgIHRoaXMudHJpZ2dlcignY2xlYXInLCB1bnNlbGVjdERhdGEpO1xcbiAgICBpZiAodW5zZWxlY3REYXRhLnByZXZlbnRlZCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnQudmFsKHByZXZpb3VzVmFsKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XFxuICAgICAgdW5zZWxlY3REYXRhID0ge1xcbiAgICAgICAgZGF0YTogZGF0YVtkXVxcbiAgICAgIH07XFxuXFxuICAgICAgLy8gVHJpZ2dlciB0aGUgYHVuc2VsZWN0YCBldmVudCwgc28gcGVvcGxlIGNhbiBwcmV2ZW50IGl0IGZyb20gYmVpbmdcXG4gICAgICAvLyBjbGVhcmVkLlxcbiAgICAgIHRoaXMudHJpZ2dlcigndW5zZWxlY3QnLCB1bnNlbGVjdERhdGEpO1xcblxcbiAgICAgIC8vIElmIHRoZSBldmVudCB3YXMgcHJldmVudGVkLCBkb24ndCBjbGVhciBpdCBvdXQuXFxuICAgICAgaWYgKHVuc2VsZWN0RGF0YS5wcmV2ZW50ZWQpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudmFsKHByZXZpb3VzVmFsKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xcblxcbiAgICB0aGlzLnRyaWdnZXIoJ3RvZ2dsZScsIHt9KTtcXG4gIH07XFxuXFxuICBBbGxvd0NsZWFyLnByb3RvdHlwZS5faGFuZGxlS2V5Ym9hcmRDbGVhciA9IGZ1bmN0aW9uIChfLCBldnQsIGNvbnRhaW5lcikge1xcbiAgICBpZiAoY29udGFpbmVyLmlzT3BlbigpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmIChldnQud2hpY2ggPT0gS0VZUy5ERUxFVEUgfHwgZXZ0LndoaWNoID09IEtFWVMuQkFDS1NQQUNFKSB7XFxuICAgICAgdGhpcy5faGFuZGxlQ2xlYXIoZXZ0KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEFsbG93Q2xlYXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGRhdGEpIHtcXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgZGF0YSk7XFxuXFxuICAgIGlmICh0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19wbGFjZWhvbGRlcicpLmxlbmd0aCA+IDAgfHxcXG4gICAgICAgIGRhdGEubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciByZW1vdmVBbGwgPSB0aGlzLm9wdGlvbnMuZ2V0KCd0cmFuc2xhdGlvbnMnKS5nZXQoJ3JlbW92ZUFsbEl0ZW1zJyk7XFxuXFxuICAgIHZhciAkcmVtb3ZlID0gJChcXG4gICAgICAnPHNwYW4gY2xhc3M9XFxcInNlbGVjdDItc2VsZWN0aW9uX19jbGVhclxcXCIgdGl0bGU9XFxcIicgKyByZW1vdmVBbGwoKSArJ1xcXCI+JyArXFxuICAgICAgICAnJnRpbWVzOycgK1xcbiAgICAgICc8L3NwYW4+J1xcbiAgICApO1xcbiAgICBVdGlscy5TdG9yZURhdGEoJHJlbW92ZVswXSwgJ2RhdGEnLCBkYXRhKTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKS5wcmVwZW5kKCRyZW1vdmUpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBBbGxvd0NsZWFyO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vc2VhcmNoJyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuLi91dGlscycsXFxuICAnLi4va2V5cydcXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMsIEtFWVMpIHtcXG4gIGZ1bmN0aW9uIFNlYXJjaCAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcXG4gICAgdmFyICRzZWFyY2ggPSAkKFxcbiAgICAgICc8bGkgY2xhc3M9XFxcInNlbGVjdDItc2VhcmNoIHNlbGVjdDItc2VhcmNoLS1pbmxpbmVcXFwiPicgK1xcbiAgICAgICAgJzxpbnB1dCBjbGFzcz1cXFwic2VsZWN0Mi1zZWFyY2hfX2ZpZWxkXFxcIiB0eXBlPVxcXCJzZWFyY2hcXFwiIHRhYmluZGV4PVxcXCItMVxcXCInICtcXG4gICAgICAgICcgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIGF1dG9jYXBpdGFsaXplPVxcXCJub25lXFxcIicgK1xcbiAgICAgICAgJyBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCIgcm9sZT1cXFwic2VhcmNoYm94XFxcIiBhcmlhLWF1dG9jb21wbGV0ZT1cXFwibGlzdFxcXCIgLz4nICtcXG4gICAgICAnPC9saT4nXFxuICAgICk7XFxuXFxuICAgIHRoaXMuJHNlYXJjaENvbnRhaW5lciA9ICRzZWFyY2g7XFxuICAgIHRoaXMuJHNlYXJjaCA9ICRzZWFyY2guZmluZCgnaW5wdXQnKTtcXG5cXG4gICAgdmFyICRyZW5kZXJlZCA9IGRlY29yYXRlZC5jYWxsKHRoaXMpO1xcblxcbiAgICB0aGlzLl90cmFuc2ZlclRhYkluZGV4KCk7XFxuXFxuICAgIHJldHVybiAkcmVuZGVyZWQ7XFxuICB9O1xcblxcbiAgU2VhcmNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdmFyIHJlc3VsdHNJZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0cyc7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIGNvbnRhaW5lci5vbignb3BlbicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLiRzZWFyY2guYXR0cignYXJpYS1jb250cm9scycsIHJlc3VsdHNJZCk7XFxuICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJHNlYXJjaC52YWwoJycpO1xcbiAgICAgIHNlbGYuJHNlYXJjaC5yZW1vdmVBdHRyKCdhcmlhLWNvbnRyb2xzJyk7XFxuICAgICAgc2VsZi4kc2VhcmNoLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xcbiAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdlbmFibGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kc2VhcmNoLnByb3AoJ2Rpc2FibGVkJywgZmFsc2UpO1xcblxcbiAgICAgIHNlbGYuX3RyYW5zZmVyVGFiSW5kZXgoKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignZGlzYWJsZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLiRzZWFyY2gucHJvcCgnZGlzYWJsZWQnLCB0cnVlKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6Zm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgaWYgKHBhcmFtcy5kYXRhLl9yZXN1bHRJZCkge1xcbiAgICAgICAgc2VsZi4kc2VhcmNoLmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHBhcmFtcy5kYXRhLl9yZXN1bHRJZCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNlbGYuJHNlYXJjaC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2ZvY3VzaW4nLCAnLnNlbGVjdDItc2VhcmNoLS1pbmxpbmUnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2ZvY3Vzb3V0JywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYuX2hhbmRsZUJsdXIoZXZ0KTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbigna2V5ZG93bicsICcuc2VsZWN0Mi1zZWFyY2gtLWlubGluZScsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFxuICAgICAgc2VsZi50cmlnZ2VyKCdrZXlwcmVzcycsIGV2dCk7XFxuXFxuICAgICAgc2VsZi5fa2V5VXBQcmV2ZW50ZWQgPSBldnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XFxuXFxuICAgICAgdmFyIGtleSA9IGV2dC53aGljaDtcXG5cXG4gICAgICBpZiAoa2V5ID09PSBLRVlTLkJBQ0tTUEFDRSAmJiBzZWxmLiRzZWFyY2gudmFsKCkgPT09ICcnKSB7XFxuICAgICAgICB2YXIgJHByZXZpb3VzQ2hvaWNlID0gc2VsZi4kc2VhcmNoQ29udGFpbmVyXFxuICAgICAgICAgIC5wcmV2KCcuc2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZScpO1xcblxcbiAgICAgICAgaWYgKCRwcmV2aW91c0Nob2ljZS5sZW5ndGggPiAwKSB7XFxuICAgICAgICAgIHZhciBpdGVtID0gVXRpbHMuR2V0RGF0YSgkcHJldmlvdXNDaG9pY2VbMF0sICdkYXRhJyk7XFxuXFxuICAgICAgICAgIHNlbGYuc2VhcmNoUmVtb3ZlQ2hvaWNlKGl0ZW0pO1xcblxcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2NsaWNrJywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIGlmIChzZWxmLiRzZWFyY2gudmFsKCkpIHtcXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICAvLyBUcnkgdG8gZGV0ZWN0IHRoZSBJRSB2ZXJzaW9uIHNob3VsZCB0aGUgYGRvY3VtZW50TW9kZWAgcHJvcGVydHkgdGhhdFxcbiAgICAvLyBpcyBzdG9yZWQgb24gdGhlIGRvY3VtZW50LiBUaGlzIGlzIG9ubHkgaW1wbGVtZW50ZWQgaW4gSUUgYW5kIGlzXFxuICAgIC8vIHNsaWdodGx5IGNsZWFuZXIgdGhhbiBkb2luZyBhIHVzZXIgYWdlbnQgY2hlY2suXFxuICAgIC8vIFRoaXMgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZSBpbiBFZGdlLCBidXQgRWRnZSBhbHNvIGRvZXNuJ3QgaGF2ZVxcbiAgICAvLyB0aGlzIGJ1Zy5cXG4gICAgdmFyIG1zaWUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XFxuICAgIHZhciBkaXNhYmxlSW5wdXRFdmVudHMgPSBtc2llICYmIG1zaWUgPD0gMTE7XFxuXFxuICAgIC8vIFdvcmthcm91bmQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IHRoZSBgaW5wdXRgIGV2ZW50XFxuICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGRvdWJsZS10cmlnZ2VyaW5nIG9mIGV2ZW50cyBmb3IgYnJvd3NlcnMgd2hpY2ggc3VwcG9ydFxcbiAgICAvLyBib3RoIHRoZSBga2V5dXBgIGFuZCBgaW5wdXRgIGV2ZW50cy5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKFxcbiAgICAgICdpbnB1dC5zZWFyY2hjaGVjaycsXFxuICAgICAgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJyxcXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICAvLyBJRSB3aWxsIHRyaWdnZXIgdGhlIGBpbnB1dGAgZXZlbnQgd2hlbiBhIHBsYWNlaG9sZGVyIGlzIHVzZWQgb24gYVxcbiAgICAgICAgLy8gc2VhcmNoIGJveC4gVG8gZ2V0IGFyb3VuZCB0aGlzIGlzc3VlLCB3ZSBhcmUgZm9yY2VkIHRvIGlnbm9yZSBhbGxcXG4gICAgICAgIC8vIGBpbnB1dGAgZXZlbnRzIGluIElFIGFuZCBrZWVwIHVzaW5nIGBrZXl1cGAuXFxuICAgICAgICBpZiAoZGlzYWJsZUlucHV0RXZlbnRzKSB7XFxuICAgICAgICAgIHNlbGYuJHNlbGVjdGlvbi5vZmYoJ2lucHV0LnNlYXJjaCBpbnB1dC5zZWFyY2hjaGVjaycpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBVbmJpbmQgdGhlIGR1cGxpY2F0ZWQgYGtleXVwYCBldmVudFxcbiAgICAgICAgc2VsZi4kc2VsZWN0aW9uLm9mZigna2V5dXAuc2VhcmNoJyk7XFxuICAgICAgfVxcbiAgICApO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oXFxuICAgICAgJ2tleXVwLnNlYXJjaCBpbnB1dC5zZWFyY2gnLFxcbiAgICAgICcuc2VsZWN0Mi1zZWFyY2gtLWlubGluZScsXFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgLy8gSUUgd2lsbCB0cmlnZ2VyIHRoZSBgaW5wdXRgIGV2ZW50IHdoZW4gYSBwbGFjZWhvbGRlciBpcyB1c2VkIG9uIGFcXG4gICAgICAgIC8vIHNlYXJjaCBib3guIFRvIGdldCBhcm91bmQgdGhpcyBpc3N1ZSwgd2UgYXJlIGZvcmNlZCB0byBpZ25vcmUgYWxsXFxuICAgICAgICAvLyBgaW5wdXRgIGV2ZW50cyBpbiBJRSBhbmQga2VlcCB1c2luZyBga2V5dXBgLlxcbiAgICAgICAgaWYgKGRpc2FibGVJbnB1dEV2ZW50cyAmJiBldnQudHlwZSA9PT0gJ2lucHV0Jykge1xcbiAgICAgICAgICBzZWxmLiRzZWxlY3Rpb24ub2ZmKCdpbnB1dC5zZWFyY2ggaW5wdXQuc2VhcmNoY2hlY2snKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyIGtleSA9IGV2dC53aGljaDtcXG5cXG4gICAgICAgIC8vIFdlIGNhbiBmcmVlbHkgaWdub3JlIGV2ZW50cyBmcm9tIG1vZGlmaWVyIGtleXNcXG4gICAgICAgIGlmIChrZXkgPT0gS0VZUy5TSElGVCB8fCBrZXkgPT0gS0VZUy5DVFJMIHx8IGtleSA9PSBLRVlTLkFMVCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBUYWJiaW5nIHdpbGwgYmUgaGFuZGxlZCBkdXJpbmcgdGhlIGBrZXlkb3duYCBwaGFzZVxcbiAgICAgICAgaWYgKGtleSA9PSBLRVlTLlRBQikge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZWxmLmhhbmRsZVNlYXJjaChldnQpO1xcbiAgICAgIH1cXG4gICAgKTtcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIFRoaXMgbWV0aG9kIHdpbGwgdHJhbnNmZXIgdGhlIHRhYmluZGV4IGF0dHJpYnV0ZSBmcm9tIHRoZSByZW5kZXJlZFxcbiAgICogc2VsZWN0aW9uIHRvIHRoZSBzZWFyY2ggYm94LiBUaGlzIGFsbG93cyBmb3IgdGhlIHNlYXJjaCBib3ggdG8gYmUgdXNlZCBhc1xcbiAgICogdGhlIHByaW1hcnkgZm9jdXMgaW5zdGVhZCBvZiB0aGUgc2VsZWN0aW9uIGNvbnRhaW5lci5cXG4gICAqXFxuICAgKiBAcHJpdmF0ZVxcbiAgICovXFxuICBTZWFyY2gucHJvdG90eXBlLl90cmFuc2ZlclRhYkluZGV4ID0gZnVuY3Rpb24gKGRlY29yYXRlZCkge1xcbiAgICB0aGlzLiRzZWFyY2guYXR0cigndGFiaW5kZXgnLCB0aGlzLiRzZWxlY3Rpb24uYXR0cigndGFiaW5kZXgnKSk7XFxuICAgIHRoaXMuJHNlbGVjdGlvbi5hdHRyKCd0YWJpbmRleCcsICctMScpO1xcbiAgfTtcXG5cXG4gIFNlYXJjaC5wcm90b3R5cGUuY3JlYXRlUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwbGFjZWhvbGRlcikge1xcbiAgICB0aGlzLiRzZWFyY2guYXR0cigncGxhY2Vob2xkZXInLCBwbGFjZWhvbGRlci50ZXh0KTtcXG4gIH07XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGRhdGEpIHtcXG4gICAgdmFyIHNlYXJjaEhhZEZvY3VzID0gdGhpcy4kc2VhcmNoWzBdID09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XFxuXFxuICAgIHRoaXMuJHNlYXJjaC5hdHRyKCdwbGFjZWhvbGRlcicsICcnKTtcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgZGF0YSk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJylcXG4gICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLiRzZWFyY2hDb250YWluZXIpO1xcblxcbiAgICB0aGlzLnJlc2l6ZVNlYXJjaCgpO1xcbiAgICBpZiAoc2VhcmNoSGFkRm9jdXMpIHtcXG4gICAgICB0aGlzLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNlYXJjaC5wcm90b3R5cGUuaGFuZGxlU2VhcmNoID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLnJlc2l6ZVNlYXJjaCgpO1xcblxcbiAgICBpZiAoIXRoaXMuX2tleVVwUHJldmVudGVkKSB7XFxuICAgICAgdmFyIGlucHV0ID0gdGhpcy4kc2VhcmNoLnZhbCgpO1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7XFxuICAgICAgICB0ZXJtOiBpbnB1dFxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2tleVVwUHJldmVudGVkID0gZmFsc2U7XFxuICB9O1xcblxcbiAgU2VhcmNoLnByb3RvdHlwZS5zZWFyY2hSZW1vdmVDaG9pY2UgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBpdGVtKSB7XFxuICAgIHRoaXMudHJpZ2dlcigndW5zZWxlY3QnLCB7XFxuICAgICAgZGF0YTogaXRlbVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VhcmNoLnZhbChpdGVtLnRleHQpO1xcbiAgICB0aGlzLmhhbmRsZVNlYXJjaCgpO1xcbiAgfTtcXG5cXG4gIFNlYXJjaC5wcm90b3R5cGUucmVzaXplU2VhcmNoID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLiRzZWFyY2guY3NzKCd3aWR0aCcsICcyNXB4Jyk7XFxuXFxuICAgIHZhciB3aWR0aCA9ICcnO1xcblxcbiAgICBpZiAodGhpcy4kc2VhcmNoLmF0dHIoJ3BsYWNlaG9sZGVyJykgIT09ICcnKSB7XFxuICAgICAgd2lkdGggPSB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZCcpLndpZHRoKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIG1pbmltdW1XaWR0aCA9IHRoaXMuJHNlYXJjaC52YWwoKS5sZW5ndGggKyAxO1xcblxcbiAgICAgIHdpZHRoID0gKG1pbmltdW1XaWR0aCAqIDAuNzUpICsgJ2VtJztcXG4gICAgfVxcblxcbiAgICB0aGlzLiRzZWFyY2guY3NzKCd3aWR0aCcsIHdpZHRoKTtcXG4gIH07XFxuXFxuICByZXR1cm4gU2VhcmNoO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vZXZlbnRSZWxheScsW1xcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoJCkge1xcbiAgZnVuY3Rpb24gRXZlbnRSZWxheSAoKSB7IH1cXG5cXG4gIEV2ZW50UmVsYXkucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgcmVsYXlFdmVudHMgPSBbXFxuICAgICAgJ29wZW4nLCAnb3BlbmluZycsXFxuICAgICAgJ2Nsb3NlJywgJ2Nsb3NpbmcnLFxcbiAgICAgICdzZWxlY3QnLCAnc2VsZWN0aW5nJyxcXG4gICAgICAndW5zZWxlY3QnLCAndW5zZWxlY3RpbmcnLFxcbiAgICAgICdjbGVhcicsICdjbGVhcmluZydcXG4gICAgXTtcXG5cXG4gICAgdmFyIHByZXZlbnRhYmxlRXZlbnRzID0gW1xcbiAgICAgICdvcGVuaW5nJywgJ2Nsb3NpbmcnLCAnc2VsZWN0aW5nJywgJ3Vuc2VsZWN0aW5nJywgJ2NsZWFyaW5nJ1xcbiAgICBdO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xcblxcbiAgICBjb250YWluZXIub24oJyonLCBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XFxuICAgICAgLy8gSWdub3JlIGV2ZW50cyB0aGF0IHNob3VsZCBub3QgYmUgcmVsYXllZFxcbiAgICAgIGlmICgkLmluQXJyYXkobmFtZSwgcmVsYXlFdmVudHMpID09PSAtMSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBUaGUgcGFyYW1ldGVycyBzaG91bGQgYWx3YXlzIGJlIGFuIG9iamVjdFxcbiAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcXG5cXG4gICAgICAvLyBHZW5lcmF0ZSB0aGUgalF1ZXJ5IGV2ZW50IGZvciB0aGUgU2VsZWN0MiBldmVudFxcbiAgICAgIHZhciBldnQgPSAkLkV2ZW50KCdzZWxlY3QyOicgKyBuYW1lLCB7XFxuICAgICAgICBwYXJhbXM6IHBhcmFtc1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHNlbGYuJGVsZW1lbnQudHJpZ2dlcihldnQpO1xcblxcbiAgICAgIC8vIE9ubHkgaGFuZGxlIHByZXZlbnRhYmxlIGV2ZW50cyBpZiBpdCB3YXMgb25lXFxuICAgICAgaWYgKCQuaW5BcnJheShuYW1lLCBwcmV2ZW50YWJsZUV2ZW50cykgPT09IC0xKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHBhcmFtcy5wcmV2ZW50ZWQgPSBldnQuaXNEZWZhdWx0UHJldmVudGVkKCk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIHJldHVybiBFdmVudFJlbGF5O1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi90cmFuc2xhdGlvbicsW1xcbiAgJ2pxdWVyeScsXFxuICAncmVxdWlyZSdcXG5dLCBmdW5jdGlvbiAoJCwgcmVxdWlyZSkge1xcbiAgZnVuY3Rpb24gVHJhbnNsYXRpb24gKGRpY3QpIHtcXG4gICAgdGhpcy5kaWN0ID0gZGljdCB8fCB7fTtcXG4gIH1cXG5cXG4gIFRyYW5zbGF0aW9uLnByb3RvdHlwZS5hbGwgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzLmRpY3Q7XFxuICB9O1xcblxcbiAgVHJhbnNsYXRpb24ucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcXG4gICAgcmV0dXJuIHRoaXMuZGljdFtrZXldO1xcbiAgfTtcXG5cXG4gIFRyYW5zbGF0aW9uLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiAodHJhbnNsYXRpb24pIHtcXG4gICAgdGhpcy5kaWN0ID0gJC5leHRlbmQoe30sIHRyYW5zbGF0aW9uLmFsbCgpLCB0aGlzLmRpY3QpO1xcbiAgfTtcXG5cXG4gIC8vIFN0YXRpYyBmdW5jdGlvbnNcXG5cXG4gIFRyYW5zbGF0aW9uLl9jYWNoZSA9IHt9O1xcblxcbiAgVHJhbnNsYXRpb24ubG9hZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xcbiAgICBpZiAoIShwYXRoIGluIFRyYW5zbGF0aW9uLl9jYWNoZSkpIHtcXG4gICAgICB2YXIgdHJhbnNsYXRpb25zID0gcmVxdWlyZShwYXRoKTtcXG5cXG4gICAgICBUcmFuc2xhdGlvbi5fY2FjaGVbcGF0aF0gPSB0cmFuc2xhdGlvbnM7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG5ldyBUcmFuc2xhdGlvbihUcmFuc2xhdGlvbi5fY2FjaGVbcGF0aF0pO1xcbiAgfTtcXG5cXG4gIHJldHVybiBUcmFuc2xhdGlvbjtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGlhY3JpdGljcycsW1xcblxcbl0sIGZ1bmN0aW9uICgpIHtcXG4gIHZhciBkaWFjcml0aWNzID0ge1xcbiAgICAnXFxcXHUyNEI2JzogJ0EnLFxcbiAgICAnXFxcXHVGRjIxJzogJ0EnLFxcbiAgICAnXFxcXHUwMEMwJzogJ0EnLFxcbiAgICAnXFxcXHUwMEMxJzogJ0EnLFxcbiAgICAnXFxcXHUwMEMyJzogJ0EnLFxcbiAgICAnXFxcXHUxRUE2JzogJ0EnLFxcbiAgICAnXFxcXHUxRUE0JzogJ0EnLFxcbiAgICAnXFxcXHUxRUFBJzogJ0EnLFxcbiAgICAnXFxcXHUxRUE4JzogJ0EnLFxcbiAgICAnXFxcXHUwMEMzJzogJ0EnLFxcbiAgICAnXFxcXHUwMTAwJzogJ0EnLFxcbiAgICAnXFxcXHUwMTAyJzogJ0EnLFxcbiAgICAnXFxcXHUxRUIwJzogJ0EnLFxcbiAgICAnXFxcXHUxRUFFJzogJ0EnLFxcbiAgICAnXFxcXHUxRUI0JzogJ0EnLFxcbiAgICAnXFxcXHUxRUIyJzogJ0EnLFxcbiAgICAnXFxcXHUwMjI2JzogJ0EnLFxcbiAgICAnXFxcXHUwMUUwJzogJ0EnLFxcbiAgICAnXFxcXHUwMEM0JzogJ0EnLFxcbiAgICAnXFxcXHUwMURFJzogJ0EnLFxcbiAgICAnXFxcXHUxRUEyJzogJ0EnLFxcbiAgICAnXFxcXHUwMEM1JzogJ0EnLFxcbiAgICAnXFxcXHUwMUZBJzogJ0EnLFxcbiAgICAnXFxcXHUwMUNEJzogJ0EnLFxcbiAgICAnXFxcXHUwMjAwJzogJ0EnLFxcbiAgICAnXFxcXHUwMjAyJzogJ0EnLFxcbiAgICAnXFxcXHUxRUEwJzogJ0EnLFxcbiAgICAnXFxcXHUxRUFDJzogJ0EnLFxcbiAgICAnXFxcXHUxRUI2JzogJ0EnLFxcbiAgICAnXFxcXHUxRTAwJzogJ0EnLFxcbiAgICAnXFxcXHUwMTA0JzogJ0EnLFxcbiAgICAnXFxcXHUwMjNBJzogJ0EnLFxcbiAgICAnXFxcXHUyQzZGJzogJ0EnLFxcbiAgICAnXFxcXHVBNzMyJzogJ0FBJyxcXG4gICAgJ1xcXFx1MDBDNic6ICdBRScsXFxuICAgICdcXFxcdTAxRkMnOiAnQUUnLFxcbiAgICAnXFxcXHUwMUUyJzogJ0FFJyxcXG4gICAgJ1xcXFx1QTczNCc6ICdBTycsXFxuICAgICdcXFxcdUE3MzYnOiAnQVUnLFxcbiAgICAnXFxcXHVBNzM4JzogJ0FWJyxcXG4gICAgJ1xcXFx1QTczQSc6ICdBVicsXFxuICAgICdcXFxcdUE3M0MnOiAnQVknLFxcbiAgICAnXFxcXHUyNEI3JzogJ0InLFxcbiAgICAnXFxcXHVGRjIyJzogJ0InLFxcbiAgICAnXFxcXHUxRTAyJzogJ0InLFxcbiAgICAnXFxcXHUxRTA0JzogJ0InLFxcbiAgICAnXFxcXHUxRTA2JzogJ0InLFxcbiAgICAnXFxcXHUwMjQzJzogJ0InLFxcbiAgICAnXFxcXHUwMTgyJzogJ0InLFxcbiAgICAnXFxcXHUwMTgxJzogJ0InLFxcbiAgICAnXFxcXHUyNEI4JzogJ0MnLFxcbiAgICAnXFxcXHVGRjIzJzogJ0MnLFxcbiAgICAnXFxcXHUwMTA2JzogJ0MnLFxcbiAgICAnXFxcXHUwMTA4JzogJ0MnLFxcbiAgICAnXFxcXHUwMTBBJzogJ0MnLFxcbiAgICAnXFxcXHUwMTBDJzogJ0MnLFxcbiAgICAnXFxcXHUwMEM3JzogJ0MnLFxcbiAgICAnXFxcXHUxRTA4JzogJ0MnLFxcbiAgICAnXFxcXHUwMTg3JzogJ0MnLFxcbiAgICAnXFxcXHUwMjNCJzogJ0MnLFxcbiAgICAnXFxcXHVBNzNFJzogJ0MnLFxcbiAgICAnXFxcXHUyNEI5JzogJ0QnLFxcbiAgICAnXFxcXHVGRjI0JzogJ0QnLFxcbiAgICAnXFxcXHUxRTBBJzogJ0QnLFxcbiAgICAnXFxcXHUwMTBFJzogJ0QnLFxcbiAgICAnXFxcXHUxRTBDJzogJ0QnLFxcbiAgICAnXFxcXHUxRTEwJzogJ0QnLFxcbiAgICAnXFxcXHUxRTEyJzogJ0QnLFxcbiAgICAnXFxcXHUxRTBFJzogJ0QnLFxcbiAgICAnXFxcXHUwMTEwJzogJ0QnLFxcbiAgICAnXFxcXHUwMThCJzogJ0QnLFxcbiAgICAnXFxcXHUwMThBJzogJ0QnLFxcbiAgICAnXFxcXHUwMTg5JzogJ0QnLFxcbiAgICAnXFxcXHVBNzc5JzogJ0QnLFxcbiAgICAnXFxcXHUwMUYxJzogJ0RaJyxcXG4gICAgJ1xcXFx1MDFDNCc6ICdEWicsXFxuICAgICdcXFxcdTAxRjInOiAnRHonLFxcbiAgICAnXFxcXHUwMUM1JzogJ0R6JyxcXG4gICAgJ1xcXFx1MjRCQSc6ICdFJyxcXG4gICAgJ1xcXFx1RkYyNSc6ICdFJyxcXG4gICAgJ1xcXFx1MDBDOCc6ICdFJyxcXG4gICAgJ1xcXFx1MDBDOSc6ICdFJyxcXG4gICAgJ1xcXFx1MDBDQSc6ICdFJyxcXG4gICAgJ1xcXFx1MUVDMCc6ICdFJyxcXG4gICAgJ1xcXFx1MUVCRSc6ICdFJyxcXG4gICAgJ1xcXFx1MUVDNCc6ICdFJyxcXG4gICAgJ1xcXFx1MUVDMic6ICdFJyxcXG4gICAgJ1xcXFx1MUVCQyc6ICdFJyxcXG4gICAgJ1xcXFx1MDExMic6ICdFJyxcXG4gICAgJ1xcXFx1MUUxNCc6ICdFJyxcXG4gICAgJ1xcXFx1MUUxNic6ICdFJyxcXG4gICAgJ1xcXFx1MDExNCc6ICdFJyxcXG4gICAgJ1xcXFx1MDExNic6ICdFJyxcXG4gICAgJ1xcXFx1MDBDQic6ICdFJyxcXG4gICAgJ1xcXFx1MUVCQSc6ICdFJyxcXG4gICAgJ1xcXFx1MDExQSc6ICdFJyxcXG4gICAgJ1xcXFx1MDIwNCc6ICdFJyxcXG4gICAgJ1xcXFx1MDIwNic6ICdFJyxcXG4gICAgJ1xcXFx1MUVCOCc6ICdFJyxcXG4gICAgJ1xcXFx1MUVDNic6ICdFJyxcXG4gICAgJ1xcXFx1MDIyOCc6ICdFJyxcXG4gICAgJ1xcXFx1MUUxQyc6ICdFJyxcXG4gICAgJ1xcXFx1MDExOCc6ICdFJyxcXG4gICAgJ1xcXFx1MUUxOCc6ICdFJyxcXG4gICAgJ1xcXFx1MUUxQSc6ICdFJyxcXG4gICAgJ1xcXFx1MDE5MCc6ICdFJyxcXG4gICAgJ1xcXFx1MDE4RSc6ICdFJyxcXG4gICAgJ1xcXFx1MjRCQic6ICdGJyxcXG4gICAgJ1xcXFx1RkYyNic6ICdGJyxcXG4gICAgJ1xcXFx1MUUxRSc6ICdGJyxcXG4gICAgJ1xcXFx1MDE5MSc6ICdGJyxcXG4gICAgJ1xcXFx1QTc3Qic6ICdGJyxcXG4gICAgJ1xcXFx1MjRCQyc6ICdHJyxcXG4gICAgJ1xcXFx1RkYyNyc6ICdHJyxcXG4gICAgJ1xcXFx1MDFGNCc6ICdHJyxcXG4gICAgJ1xcXFx1MDExQyc6ICdHJyxcXG4gICAgJ1xcXFx1MUUyMCc6ICdHJyxcXG4gICAgJ1xcXFx1MDExRSc6ICdHJyxcXG4gICAgJ1xcXFx1MDEyMCc6ICdHJyxcXG4gICAgJ1xcXFx1MDFFNic6ICdHJyxcXG4gICAgJ1xcXFx1MDEyMic6ICdHJyxcXG4gICAgJ1xcXFx1MDFFNCc6ICdHJyxcXG4gICAgJ1xcXFx1MDE5Myc6ICdHJyxcXG4gICAgJ1xcXFx1QTdBMCc6ICdHJyxcXG4gICAgJ1xcXFx1QTc3RCc6ICdHJyxcXG4gICAgJ1xcXFx1QTc3RSc6ICdHJyxcXG4gICAgJ1xcXFx1MjRCRCc6ICdIJyxcXG4gICAgJ1xcXFx1RkYyOCc6ICdIJyxcXG4gICAgJ1xcXFx1MDEyNCc6ICdIJyxcXG4gICAgJ1xcXFx1MUUyMic6ICdIJyxcXG4gICAgJ1xcXFx1MUUyNic6ICdIJyxcXG4gICAgJ1xcXFx1MDIxRSc6ICdIJyxcXG4gICAgJ1xcXFx1MUUyNCc6ICdIJyxcXG4gICAgJ1xcXFx1MUUyOCc6ICdIJyxcXG4gICAgJ1xcXFx1MUUyQSc6ICdIJyxcXG4gICAgJ1xcXFx1MDEyNic6ICdIJyxcXG4gICAgJ1xcXFx1MkM2Nyc6ICdIJyxcXG4gICAgJ1xcXFx1MkM3NSc6ICdIJyxcXG4gICAgJ1xcXFx1QTc4RCc6ICdIJyxcXG4gICAgJ1xcXFx1MjRCRSc6ICdJJyxcXG4gICAgJ1xcXFx1RkYyOSc6ICdJJyxcXG4gICAgJ1xcXFx1MDBDQyc6ICdJJyxcXG4gICAgJ1xcXFx1MDBDRCc6ICdJJyxcXG4gICAgJ1xcXFx1MDBDRSc6ICdJJyxcXG4gICAgJ1xcXFx1MDEyOCc6ICdJJyxcXG4gICAgJ1xcXFx1MDEyQSc6ICdJJyxcXG4gICAgJ1xcXFx1MDEyQyc6ICdJJyxcXG4gICAgJ1xcXFx1MDEzMCc6ICdJJyxcXG4gICAgJ1xcXFx1MDBDRic6ICdJJyxcXG4gICAgJ1xcXFx1MUUyRSc6ICdJJyxcXG4gICAgJ1xcXFx1MUVDOCc6ICdJJyxcXG4gICAgJ1xcXFx1MDFDRic6ICdJJyxcXG4gICAgJ1xcXFx1MDIwOCc6ICdJJyxcXG4gICAgJ1xcXFx1MDIwQSc6ICdJJyxcXG4gICAgJ1xcXFx1MUVDQSc6ICdJJyxcXG4gICAgJ1xcXFx1MDEyRSc6ICdJJyxcXG4gICAgJ1xcXFx1MUUyQyc6ICdJJyxcXG4gICAgJ1xcXFx1MDE5Nyc6ICdJJyxcXG4gICAgJ1xcXFx1MjRCRic6ICdKJyxcXG4gICAgJ1xcXFx1RkYyQSc6ICdKJyxcXG4gICAgJ1xcXFx1MDEzNCc6ICdKJyxcXG4gICAgJ1xcXFx1MDI0OCc6ICdKJyxcXG4gICAgJ1xcXFx1MjRDMCc6ICdLJyxcXG4gICAgJ1xcXFx1RkYyQic6ICdLJyxcXG4gICAgJ1xcXFx1MUUzMCc6ICdLJyxcXG4gICAgJ1xcXFx1MDFFOCc6ICdLJyxcXG4gICAgJ1xcXFx1MUUzMic6ICdLJyxcXG4gICAgJ1xcXFx1MDEzNic6ICdLJyxcXG4gICAgJ1xcXFx1MUUzNCc6ICdLJyxcXG4gICAgJ1xcXFx1MDE5OCc6ICdLJyxcXG4gICAgJ1xcXFx1MkM2OSc6ICdLJyxcXG4gICAgJ1xcXFx1QTc0MCc6ICdLJyxcXG4gICAgJ1xcXFx1QTc0Mic6ICdLJyxcXG4gICAgJ1xcXFx1QTc0NCc6ICdLJyxcXG4gICAgJ1xcXFx1QTdBMic6ICdLJyxcXG4gICAgJ1xcXFx1MjRDMSc6ICdMJyxcXG4gICAgJ1xcXFx1RkYyQyc6ICdMJyxcXG4gICAgJ1xcXFx1MDEzRic6ICdMJyxcXG4gICAgJ1xcXFx1MDEzOSc6ICdMJyxcXG4gICAgJ1xcXFx1MDEzRCc6ICdMJyxcXG4gICAgJ1xcXFx1MUUzNic6ICdMJyxcXG4gICAgJ1xcXFx1MUUzOCc6ICdMJyxcXG4gICAgJ1xcXFx1MDEzQic6ICdMJyxcXG4gICAgJ1xcXFx1MUUzQyc6ICdMJyxcXG4gICAgJ1xcXFx1MUUzQSc6ICdMJyxcXG4gICAgJ1xcXFx1MDE0MSc6ICdMJyxcXG4gICAgJ1xcXFx1MDIzRCc6ICdMJyxcXG4gICAgJ1xcXFx1MkM2Mic6ICdMJyxcXG4gICAgJ1xcXFx1MkM2MCc6ICdMJyxcXG4gICAgJ1xcXFx1QTc0OCc6ICdMJyxcXG4gICAgJ1xcXFx1QTc0Nic6ICdMJyxcXG4gICAgJ1xcXFx1QTc4MCc6ICdMJyxcXG4gICAgJ1xcXFx1MDFDNyc6ICdMSicsXFxuICAgICdcXFxcdTAxQzgnOiAnTGonLFxcbiAgICAnXFxcXHUyNEMyJzogJ00nLFxcbiAgICAnXFxcXHVGRjJEJzogJ00nLFxcbiAgICAnXFxcXHUxRTNFJzogJ00nLFxcbiAgICAnXFxcXHUxRTQwJzogJ00nLFxcbiAgICAnXFxcXHUxRTQyJzogJ00nLFxcbiAgICAnXFxcXHUyQzZFJzogJ00nLFxcbiAgICAnXFxcXHUwMTlDJzogJ00nLFxcbiAgICAnXFxcXHUyNEMzJzogJ04nLFxcbiAgICAnXFxcXHVGRjJFJzogJ04nLFxcbiAgICAnXFxcXHUwMUY4JzogJ04nLFxcbiAgICAnXFxcXHUwMTQzJzogJ04nLFxcbiAgICAnXFxcXHUwMEQxJzogJ04nLFxcbiAgICAnXFxcXHUxRTQ0JzogJ04nLFxcbiAgICAnXFxcXHUwMTQ3JzogJ04nLFxcbiAgICAnXFxcXHUxRTQ2JzogJ04nLFxcbiAgICAnXFxcXHUwMTQ1JzogJ04nLFxcbiAgICAnXFxcXHUxRTRBJzogJ04nLFxcbiAgICAnXFxcXHUxRTQ4JzogJ04nLFxcbiAgICAnXFxcXHUwMjIwJzogJ04nLFxcbiAgICAnXFxcXHUwMTlEJzogJ04nLFxcbiAgICAnXFxcXHVBNzkwJzogJ04nLFxcbiAgICAnXFxcXHVBN0E0JzogJ04nLFxcbiAgICAnXFxcXHUwMUNBJzogJ05KJyxcXG4gICAgJ1xcXFx1MDFDQic6ICdOaicsXFxuICAgICdcXFxcdTI0QzQnOiAnTycsXFxuICAgICdcXFxcdUZGMkYnOiAnTycsXFxuICAgICdcXFxcdTAwRDInOiAnTycsXFxuICAgICdcXFxcdTAwRDMnOiAnTycsXFxuICAgICdcXFxcdTAwRDQnOiAnTycsXFxuICAgICdcXFxcdTFFRDInOiAnTycsXFxuICAgICdcXFxcdTFFRDAnOiAnTycsXFxuICAgICdcXFxcdTFFRDYnOiAnTycsXFxuICAgICdcXFxcdTFFRDQnOiAnTycsXFxuICAgICdcXFxcdTAwRDUnOiAnTycsXFxuICAgICdcXFxcdTFFNEMnOiAnTycsXFxuICAgICdcXFxcdTAyMkMnOiAnTycsXFxuICAgICdcXFxcdTFFNEUnOiAnTycsXFxuICAgICdcXFxcdTAxNEMnOiAnTycsXFxuICAgICdcXFxcdTFFNTAnOiAnTycsXFxuICAgICdcXFxcdTFFNTInOiAnTycsXFxuICAgICdcXFxcdTAxNEUnOiAnTycsXFxuICAgICdcXFxcdTAyMkUnOiAnTycsXFxuICAgICdcXFxcdTAyMzAnOiAnTycsXFxuICAgICdcXFxcdTAwRDYnOiAnTycsXFxuICAgICdcXFxcdTAyMkEnOiAnTycsXFxuICAgICdcXFxcdTFFQ0UnOiAnTycsXFxuICAgICdcXFxcdTAxNTAnOiAnTycsXFxuICAgICdcXFxcdTAxRDEnOiAnTycsXFxuICAgICdcXFxcdTAyMEMnOiAnTycsXFxuICAgICdcXFxcdTAyMEUnOiAnTycsXFxuICAgICdcXFxcdTAxQTAnOiAnTycsXFxuICAgICdcXFxcdTFFREMnOiAnTycsXFxuICAgICdcXFxcdTFFREEnOiAnTycsXFxuICAgICdcXFxcdTFFRTAnOiAnTycsXFxuICAgICdcXFxcdTFFREUnOiAnTycsXFxuICAgICdcXFxcdTFFRTInOiAnTycsXFxuICAgICdcXFxcdTFFQ0MnOiAnTycsXFxuICAgICdcXFxcdTFFRDgnOiAnTycsXFxuICAgICdcXFxcdTAxRUEnOiAnTycsXFxuICAgICdcXFxcdTAxRUMnOiAnTycsXFxuICAgICdcXFxcdTAwRDgnOiAnTycsXFxuICAgICdcXFxcdTAxRkUnOiAnTycsXFxuICAgICdcXFxcdTAxODYnOiAnTycsXFxuICAgICdcXFxcdTAxOUYnOiAnTycsXFxuICAgICdcXFxcdUE3NEEnOiAnTycsXFxuICAgICdcXFxcdUE3NEMnOiAnTycsXFxuICAgICdcXFxcdTAxNTInOiAnT0UnLFxcbiAgICAnXFxcXHUwMUEyJzogJ09JJyxcXG4gICAgJ1xcXFx1QTc0RSc6ICdPTycsXFxuICAgICdcXFxcdTAyMjInOiAnT1UnLFxcbiAgICAnXFxcXHUyNEM1JzogJ1AnLFxcbiAgICAnXFxcXHVGRjMwJzogJ1AnLFxcbiAgICAnXFxcXHUxRTU0JzogJ1AnLFxcbiAgICAnXFxcXHUxRTU2JzogJ1AnLFxcbiAgICAnXFxcXHUwMUE0JzogJ1AnLFxcbiAgICAnXFxcXHUyQzYzJzogJ1AnLFxcbiAgICAnXFxcXHVBNzUwJzogJ1AnLFxcbiAgICAnXFxcXHVBNzUyJzogJ1AnLFxcbiAgICAnXFxcXHVBNzU0JzogJ1AnLFxcbiAgICAnXFxcXHUyNEM2JzogJ1EnLFxcbiAgICAnXFxcXHVGRjMxJzogJ1EnLFxcbiAgICAnXFxcXHVBNzU2JzogJ1EnLFxcbiAgICAnXFxcXHVBNzU4JzogJ1EnLFxcbiAgICAnXFxcXHUwMjRBJzogJ1EnLFxcbiAgICAnXFxcXHUyNEM3JzogJ1InLFxcbiAgICAnXFxcXHVGRjMyJzogJ1InLFxcbiAgICAnXFxcXHUwMTU0JzogJ1InLFxcbiAgICAnXFxcXHUxRTU4JzogJ1InLFxcbiAgICAnXFxcXHUwMTU4JzogJ1InLFxcbiAgICAnXFxcXHUwMjEwJzogJ1InLFxcbiAgICAnXFxcXHUwMjEyJzogJ1InLFxcbiAgICAnXFxcXHUxRTVBJzogJ1InLFxcbiAgICAnXFxcXHUxRTVDJzogJ1InLFxcbiAgICAnXFxcXHUwMTU2JzogJ1InLFxcbiAgICAnXFxcXHUxRTVFJzogJ1InLFxcbiAgICAnXFxcXHUwMjRDJzogJ1InLFxcbiAgICAnXFxcXHUyQzY0JzogJ1InLFxcbiAgICAnXFxcXHVBNzVBJzogJ1InLFxcbiAgICAnXFxcXHVBN0E2JzogJ1InLFxcbiAgICAnXFxcXHVBNzgyJzogJ1InLFxcbiAgICAnXFxcXHUyNEM4JzogJ1MnLFxcbiAgICAnXFxcXHVGRjMzJzogJ1MnLFxcbiAgICAnXFxcXHUxRTlFJzogJ1MnLFxcbiAgICAnXFxcXHUwMTVBJzogJ1MnLFxcbiAgICAnXFxcXHUxRTY0JzogJ1MnLFxcbiAgICAnXFxcXHUwMTVDJzogJ1MnLFxcbiAgICAnXFxcXHUxRTYwJzogJ1MnLFxcbiAgICAnXFxcXHUwMTYwJzogJ1MnLFxcbiAgICAnXFxcXHUxRTY2JzogJ1MnLFxcbiAgICAnXFxcXHUxRTYyJzogJ1MnLFxcbiAgICAnXFxcXHUxRTY4JzogJ1MnLFxcbiAgICAnXFxcXHUwMjE4JzogJ1MnLFxcbiAgICAnXFxcXHUwMTVFJzogJ1MnLFxcbiAgICAnXFxcXHUyQzdFJzogJ1MnLFxcbiAgICAnXFxcXHVBN0E4JzogJ1MnLFxcbiAgICAnXFxcXHVBNzg0JzogJ1MnLFxcbiAgICAnXFxcXHUyNEM5JzogJ1QnLFxcbiAgICAnXFxcXHVGRjM0JzogJ1QnLFxcbiAgICAnXFxcXHUxRTZBJzogJ1QnLFxcbiAgICAnXFxcXHUwMTY0JzogJ1QnLFxcbiAgICAnXFxcXHUxRTZDJzogJ1QnLFxcbiAgICAnXFxcXHUwMjFBJzogJ1QnLFxcbiAgICAnXFxcXHUwMTYyJzogJ1QnLFxcbiAgICAnXFxcXHUxRTcwJzogJ1QnLFxcbiAgICAnXFxcXHUxRTZFJzogJ1QnLFxcbiAgICAnXFxcXHUwMTY2JzogJ1QnLFxcbiAgICAnXFxcXHUwMUFDJzogJ1QnLFxcbiAgICAnXFxcXHUwMUFFJzogJ1QnLFxcbiAgICAnXFxcXHUwMjNFJzogJ1QnLFxcbiAgICAnXFxcXHVBNzg2JzogJ1QnLFxcbiAgICAnXFxcXHVBNzI4JzogJ1RaJyxcXG4gICAgJ1xcXFx1MjRDQSc6ICdVJyxcXG4gICAgJ1xcXFx1RkYzNSc6ICdVJyxcXG4gICAgJ1xcXFx1MDBEOSc6ICdVJyxcXG4gICAgJ1xcXFx1MDBEQSc6ICdVJyxcXG4gICAgJ1xcXFx1MDBEQic6ICdVJyxcXG4gICAgJ1xcXFx1MDE2OCc6ICdVJyxcXG4gICAgJ1xcXFx1MUU3OCc6ICdVJyxcXG4gICAgJ1xcXFx1MDE2QSc6ICdVJyxcXG4gICAgJ1xcXFx1MUU3QSc6ICdVJyxcXG4gICAgJ1xcXFx1MDE2Qyc6ICdVJyxcXG4gICAgJ1xcXFx1MDBEQyc6ICdVJyxcXG4gICAgJ1xcXFx1MDFEQic6ICdVJyxcXG4gICAgJ1xcXFx1MDFENyc6ICdVJyxcXG4gICAgJ1xcXFx1MDFENSc6ICdVJyxcXG4gICAgJ1xcXFx1MDFEOSc6ICdVJyxcXG4gICAgJ1xcXFx1MUVFNic6ICdVJyxcXG4gICAgJ1xcXFx1MDE2RSc6ICdVJyxcXG4gICAgJ1xcXFx1MDE3MCc6ICdVJyxcXG4gICAgJ1xcXFx1MDFEMyc6ICdVJyxcXG4gICAgJ1xcXFx1MDIxNCc6ICdVJyxcXG4gICAgJ1xcXFx1MDIxNic6ICdVJyxcXG4gICAgJ1xcXFx1MDFBRic6ICdVJyxcXG4gICAgJ1xcXFx1MUVFQSc6ICdVJyxcXG4gICAgJ1xcXFx1MUVFOCc6ICdVJyxcXG4gICAgJ1xcXFx1MUVFRSc6ICdVJyxcXG4gICAgJ1xcXFx1MUVFQyc6ICdVJyxcXG4gICAgJ1xcXFx1MUVGMCc6ICdVJyxcXG4gICAgJ1xcXFx1MUVFNCc6ICdVJyxcXG4gICAgJ1xcXFx1MUU3Mic6ICdVJyxcXG4gICAgJ1xcXFx1MDE3Mic6ICdVJyxcXG4gICAgJ1xcXFx1MUU3Nic6ICdVJyxcXG4gICAgJ1xcXFx1MUU3NCc6ICdVJyxcXG4gICAgJ1xcXFx1MDI0NCc6ICdVJyxcXG4gICAgJ1xcXFx1MjRDQic6ICdWJyxcXG4gICAgJ1xcXFx1RkYzNic6ICdWJyxcXG4gICAgJ1xcXFx1MUU3Qyc6ICdWJyxcXG4gICAgJ1xcXFx1MUU3RSc6ICdWJyxcXG4gICAgJ1xcXFx1MDFCMic6ICdWJyxcXG4gICAgJ1xcXFx1QTc1RSc6ICdWJyxcXG4gICAgJ1xcXFx1MDI0NSc6ICdWJyxcXG4gICAgJ1xcXFx1QTc2MCc6ICdWWScsXFxuICAgICdcXFxcdTI0Q0MnOiAnVycsXFxuICAgICdcXFxcdUZGMzcnOiAnVycsXFxuICAgICdcXFxcdTFFODAnOiAnVycsXFxuICAgICdcXFxcdTFFODInOiAnVycsXFxuICAgICdcXFxcdTAxNzQnOiAnVycsXFxuICAgICdcXFxcdTFFODYnOiAnVycsXFxuICAgICdcXFxcdTFFODQnOiAnVycsXFxuICAgICdcXFxcdTFFODgnOiAnVycsXFxuICAgICdcXFxcdTJDNzInOiAnVycsXFxuICAgICdcXFxcdTI0Q0QnOiAnWCcsXFxuICAgICdcXFxcdUZGMzgnOiAnWCcsXFxuICAgICdcXFxcdTFFOEEnOiAnWCcsXFxuICAgICdcXFxcdTFFOEMnOiAnWCcsXFxuICAgICdcXFxcdTI0Q0UnOiAnWScsXFxuICAgICdcXFxcdUZGMzknOiAnWScsXFxuICAgICdcXFxcdTFFRjInOiAnWScsXFxuICAgICdcXFxcdTAwREQnOiAnWScsXFxuICAgICdcXFxcdTAxNzYnOiAnWScsXFxuICAgICdcXFxcdTFFRjgnOiAnWScsXFxuICAgICdcXFxcdTAyMzInOiAnWScsXFxuICAgICdcXFxcdTFFOEUnOiAnWScsXFxuICAgICdcXFxcdTAxNzgnOiAnWScsXFxuICAgICdcXFxcdTFFRjYnOiAnWScsXFxuICAgICdcXFxcdTFFRjQnOiAnWScsXFxuICAgICdcXFxcdTAxQjMnOiAnWScsXFxuICAgICdcXFxcdTAyNEUnOiAnWScsXFxuICAgICdcXFxcdTFFRkUnOiAnWScsXFxuICAgICdcXFxcdTI0Q0YnOiAnWicsXFxuICAgICdcXFxcdUZGM0EnOiAnWicsXFxuICAgICdcXFxcdTAxNzknOiAnWicsXFxuICAgICdcXFxcdTFFOTAnOiAnWicsXFxuICAgICdcXFxcdTAxN0InOiAnWicsXFxuICAgICdcXFxcdTAxN0QnOiAnWicsXFxuICAgICdcXFxcdTFFOTInOiAnWicsXFxuICAgICdcXFxcdTFFOTQnOiAnWicsXFxuICAgICdcXFxcdTAxQjUnOiAnWicsXFxuICAgICdcXFxcdTAyMjQnOiAnWicsXFxuICAgICdcXFxcdTJDN0YnOiAnWicsXFxuICAgICdcXFxcdTJDNkInOiAnWicsXFxuICAgICdcXFxcdUE3NjInOiAnWicsXFxuICAgICdcXFxcdTI0RDAnOiAnYScsXFxuICAgICdcXFxcdUZGNDEnOiAnYScsXFxuICAgICdcXFxcdTFFOUEnOiAnYScsXFxuICAgICdcXFxcdTAwRTAnOiAnYScsXFxuICAgICdcXFxcdTAwRTEnOiAnYScsXFxuICAgICdcXFxcdTAwRTInOiAnYScsXFxuICAgICdcXFxcdTFFQTcnOiAnYScsXFxuICAgICdcXFxcdTFFQTUnOiAnYScsXFxuICAgICdcXFxcdTFFQUInOiAnYScsXFxuICAgICdcXFxcdTFFQTknOiAnYScsXFxuICAgICdcXFxcdTAwRTMnOiAnYScsXFxuICAgICdcXFxcdTAxMDEnOiAnYScsXFxuICAgICdcXFxcdTAxMDMnOiAnYScsXFxuICAgICdcXFxcdTFFQjEnOiAnYScsXFxuICAgICdcXFxcdTFFQUYnOiAnYScsXFxuICAgICdcXFxcdTFFQjUnOiAnYScsXFxuICAgICdcXFxcdTFFQjMnOiAnYScsXFxuICAgICdcXFxcdTAyMjcnOiAnYScsXFxuICAgICdcXFxcdTAxRTEnOiAnYScsXFxuICAgICdcXFxcdTAwRTQnOiAnYScsXFxuICAgICdcXFxcdTAxREYnOiAnYScsXFxuICAgICdcXFxcdTFFQTMnOiAnYScsXFxuICAgICdcXFxcdTAwRTUnOiAnYScsXFxuICAgICdcXFxcdTAxRkInOiAnYScsXFxuICAgICdcXFxcdTAxQ0UnOiAnYScsXFxuICAgICdcXFxcdTAyMDEnOiAnYScsXFxuICAgICdcXFxcdTAyMDMnOiAnYScsXFxuICAgICdcXFxcdTFFQTEnOiAnYScsXFxuICAgICdcXFxcdTFFQUQnOiAnYScsXFxuICAgICdcXFxcdTFFQjcnOiAnYScsXFxuICAgICdcXFxcdTFFMDEnOiAnYScsXFxuICAgICdcXFxcdTAxMDUnOiAnYScsXFxuICAgICdcXFxcdTJDNjUnOiAnYScsXFxuICAgICdcXFxcdTAyNTAnOiAnYScsXFxuICAgICdcXFxcdUE3MzMnOiAnYWEnLFxcbiAgICAnXFxcXHUwMEU2JzogJ2FlJyxcXG4gICAgJ1xcXFx1MDFGRCc6ICdhZScsXFxuICAgICdcXFxcdTAxRTMnOiAnYWUnLFxcbiAgICAnXFxcXHVBNzM1JzogJ2FvJyxcXG4gICAgJ1xcXFx1QTczNyc6ICdhdScsXFxuICAgICdcXFxcdUE3MzknOiAnYXYnLFxcbiAgICAnXFxcXHVBNzNCJzogJ2F2JyxcXG4gICAgJ1xcXFx1QTczRCc6ICdheScsXFxuICAgICdcXFxcdTI0RDEnOiAnYicsXFxuICAgICdcXFxcdUZGNDInOiAnYicsXFxuICAgICdcXFxcdTFFMDMnOiAnYicsXFxuICAgICdcXFxcdTFFMDUnOiAnYicsXFxuICAgICdcXFxcdTFFMDcnOiAnYicsXFxuICAgICdcXFxcdTAxODAnOiAnYicsXFxuICAgICdcXFxcdTAxODMnOiAnYicsXFxuICAgICdcXFxcdTAyNTMnOiAnYicsXFxuICAgICdcXFxcdTI0RDInOiAnYycsXFxuICAgICdcXFxcdUZGNDMnOiAnYycsXFxuICAgICdcXFxcdTAxMDcnOiAnYycsXFxuICAgICdcXFxcdTAxMDknOiAnYycsXFxuICAgICdcXFxcdTAxMEInOiAnYycsXFxuICAgICdcXFxcdTAxMEQnOiAnYycsXFxuICAgICdcXFxcdTAwRTcnOiAnYycsXFxuICAgICdcXFxcdTFFMDknOiAnYycsXFxuICAgICdcXFxcdTAxODgnOiAnYycsXFxuICAgICdcXFxcdTAyM0MnOiAnYycsXFxuICAgICdcXFxcdUE3M0YnOiAnYycsXFxuICAgICdcXFxcdTIxODQnOiAnYycsXFxuICAgICdcXFxcdTI0RDMnOiAnZCcsXFxuICAgICdcXFxcdUZGNDQnOiAnZCcsXFxuICAgICdcXFxcdTFFMEInOiAnZCcsXFxuICAgICdcXFxcdTAxMEYnOiAnZCcsXFxuICAgICdcXFxcdTFFMEQnOiAnZCcsXFxuICAgICdcXFxcdTFFMTEnOiAnZCcsXFxuICAgICdcXFxcdTFFMTMnOiAnZCcsXFxuICAgICdcXFxcdTFFMEYnOiAnZCcsXFxuICAgICdcXFxcdTAxMTEnOiAnZCcsXFxuICAgICdcXFxcdTAxOEMnOiAnZCcsXFxuICAgICdcXFxcdTAyNTYnOiAnZCcsXFxuICAgICdcXFxcdTAyNTcnOiAnZCcsXFxuICAgICdcXFxcdUE3N0EnOiAnZCcsXFxuICAgICdcXFxcdTAxRjMnOiAnZHonLFxcbiAgICAnXFxcXHUwMUM2JzogJ2R6JyxcXG4gICAgJ1xcXFx1MjRENCc6ICdlJyxcXG4gICAgJ1xcXFx1RkY0NSc6ICdlJyxcXG4gICAgJ1xcXFx1MDBFOCc6ICdlJyxcXG4gICAgJ1xcXFx1MDBFOSc6ICdlJyxcXG4gICAgJ1xcXFx1MDBFQSc6ICdlJyxcXG4gICAgJ1xcXFx1MUVDMSc6ICdlJyxcXG4gICAgJ1xcXFx1MUVCRic6ICdlJyxcXG4gICAgJ1xcXFx1MUVDNSc6ICdlJyxcXG4gICAgJ1xcXFx1MUVDMyc6ICdlJyxcXG4gICAgJ1xcXFx1MUVCRCc6ICdlJyxcXG4gICAgJ1xcXFx1MDExMyc6ICdlJyxcXG4gICAgJ1xcXFx1MUUxNSc6ICdlJyxcXG4gICAgJ1xcXFx1MUUxNyc6ICdlJyxcXG4gICAgJ1xcXFx1MDExNSc6ICdlJyxcXG4gICAgJ1xcXFx1MDExNyc6ICdlJyxcXG4gICAgJ1xcXFx1MDBFQic6ICdlJyxcXG4gICAgJ1xcXFx1MUVCQic6ICdlJyxcXG4gICAgJ1xcXFx1MDExQic6ICdlJyxcXG4gICAgJ1xcXFx1MDIwNSc6ICdlJyxcXG4gICAgJ1xcXFx1MDIwNyc6ICdlJyxcXG4gICAgJ1xcXFx1MUVCOSc6ICdlJyxcXG4gICAgJ1xcXFx1MUVDNyc6ICdlJyxcXG4gICAgJ1xcXFx1MDIyOSc6ICdlJyxcXG4gICAgJ1xcXFx1MUUxRCc6ICdlJyxcXG4gICAgJ1xcXFx1MDExOSc6ICdlJyxcXG4gICAgJ1xcXFx1MUUxOSc6ICdlJyxcXG4gICAgJ1xcXFx1MUUxQic6ICdlJyxcXG4gICAgJ1xcXFx1MDI0Nyc6ICdlJyxcXG4gICAgJ1xcXFx1MDI1Qic6ICdlJyxcXG4gICAgJ1xcXFx1MDFERCc6ICdlJyxcXG4gICAgJ1xcXFx1MjRENSc6ICdmJyxcXG4gICAgJ1xcXFx1RkY0Nic6ICdmJyxcXG4gICAgJ1xcXFx1MUUxRic6ICdmJyxcXG4gICAgJ1xcXFx1MDE5Mic6ICdmJyxcXG4gICAgJ1xcXFx1QTc3Qyc6ICdmJyxcXG4gICAgJ1xcXFx1MjRENic6ICdnJyxcXG4gICAgJ1xcXFx1RkY0Nyc6ICdnJyxcXG4gICAgJ1xcXFx1MDFGNSc6ICdnJyxcXG4gICAgJ1xcXFx1MDExRCc6ICdnJyxcXG4gICAgJ1xcXFx1MUUyMSc6ICdnJyxcXG4gICAgJ1xcXFx1MDExRic6ICdnJyxcXG4gICAgJ1xcXFx1MDEyMSc6ICdnJyxcXG4gICAgJ1xcXFx1MDFFNyc6ICdnJyxcXG4gICAgJ1xcXFx1MDEyMyc6ICdnJyxcXG4gICAgJ1xcXFx1MDFFNSc6ICdnJyxcXG4gICAgJ1xcXFx1MDI2MCc6ICdnJyxcXG4gICAgJ1xcXFx1QTdBMSc6ICdnJyxcXG4gICAgJ1xcXFx1MUQ3OSc6ICdnJyxcXG4gICAgJ1xcXFx1QTc3Ric6ICdnJyxcXG4gICAgJ1xcXFx1MjRENyc6ICdoJyxcXG4gICAgJ1xcXFx1RkY0OCc6ICdoJyxcXG4gICAgJ1xcXFx1MDEyNSc6ICdoJyxcXG4gICAgJ1xcXFx1MUUyMyc6ICdoJyxcXG4gICAgJ1xcXFx1MUUyNyc6ICdoJyxcXG4gICAgJ1xcXFx1MDIxRic6ICdoJyxcXG4gICAgJ1xcXFx1MUUyNSc6ICdoJyxcXG4gICAgJ1xcXFx1MUUyOSc6ICdoJyxcXG4gICAgJ1xcXFx1MUUyQic6ICdoJyxcXG4gICAgJ1xcXFx1MUU5Nic6ICdoJyxcXG4gICAgJ1xcXFx1MDEyNyc6ICdoJyxcXG4gICAgJ1xcXFx1MkM2OCc6ICdoJyxcXG4gICAgJ1xcXFx1MkM3Nic6ICdoJyxcXG4gICAgJ1xcXFx1MDI2NSc6ICdoJyxcXG4gICAgJ1xcXFx1MDE5NSc6ICdodicsXFxuICAgICdcXFxcdTI0RDgnOiAnaScsXFxuICAgICdcXFxcdUZGNDknOiAnaScsXFxuICAgICdcXFxcdTAwRUMnOiAnaScsXFxuICAgICdcXFxcdTAwRUQnOiAnaScsXFxuICAgICdcXFxcdTAwRUUnOiAnaScsXFxuICAgICdcXFxcdTAxMjknOiAnaScsXFxuICAgICdcXFxcdTAxMkInOiAnaScsXFxuICAgICdcXFxcdTAxMkQnOiAnaScsXFxuICAgICdcXFxcdTAwRUYnOiAnaScsXFxuICAgICdcXFxcdTFFMkYnOiAnaScsXFxuICAgICdcXFxcdTFFQzknOiAnaScsXFxuICAgICdcXFxcdTAxRDAnOiAnaScsXFxuICAgICdcXFxcdTAyMDknOiAnaScsXFxuICAgICdcXFxcdTAyMEInOiAnaScsXFxuICAgICdcXFxcdTFFQ0InOiAnaScsXFxuICAgICdcXFxcdTAxMkYnOiAnaScsXFxuICAgICdcXFxcdTFFMkQnOiAnaScsXFxuICAgICdcXFxcdTAyNjgnOiAnaScsXFxuICAgICdcXFxcdTAxMzEnOiAnaScsXFxuICAgICdcXFxcdTI0RDknOiAnaicsXFxuICAgICdcXFxcdUZGNEEnOiAnaicsXFxuICAgICdcXFxcdTAxMzUnOiAnaicsXFxuICAgICdcXFxcdTAxRjAnOiAnaicsXFxuICAgICdcXFxcdTAyNDknOiAnaicsXFxuICAgICdcXFxcdTI0REEnOiAnaycsXFxuICAgICdcXFxcdUZGNEInOiAnaycsXFxuICAgICdcXFxcdTFFMzEnOiAnaycsXFxuICAgICdcXFxcdTAxRTknOiAnaycsXFxuICAgICdcXFxcdTFFMzMnOiAnaycsXFxuICAgICdcXFxcdTAxMzcnOiAnaycsXFxuICAgICdcXFxcdTFFMzUnOiAnaycsXFxuICAgICdcXFxcdTAxOTknOiAnaycsXFxuICAgICdcXFxcdTJDNkEnOiAnaycsXFxuICAgICdcXFxcdUE3NDEnOiAnaycsXFxuICAgICdcXFxcdUE3NDMnOiAnaycsXFxuICAgICdcXFxcdUE3NDUnOiAnaycsXFxuICAgICdcXFxcdUE3QTMnOiAnaycsXFxuICAgICdcXFxcdTI0REInOiAnbCcsXFxuICAgICdcXFxcdUZGNEMnOiAnbCcsXFxuICAgICdcXFxcdTAxNDAnOiAnbCcsXFxuICAgICdcXFxcdTAxM0EnOiAnbCcsXFxuICAgICdcXFxcdTAxM0UnOiAnbCcsXFxuICAgICdcXFxcdTFFMzcnOiAnbCcsXFxuICAgICdcXFxcdTFFMzknOiAnbCcsXFxuICAgICdcXFxcdTAxM0MnOiAnbCcsXFxuICAgICdcXFxcdTFFM0QnOiAnbCcsXFxuICAgICdcXFxcdTFFM0InOiAnbCcsXFxuICAgICdcXFxcdTAxN0YnOiAnbCcsXFxuICAgICdcXFxcdTAxNDInOiAnbCcsXFxuICAgICdcXFxcdTAxOUEnOiAnbCcsXFxuICAgICdcXFxcdTAyNkInOiAnbCcsXFxuICAgICdcXFxcdTJDNjEnOiAnbCcsXFxuICAgICdcXFxcdUE3NDknOiAnbCcsXFxuICAgICdcXFxcdUE3ODEnOiAnbCcsXFxuICAgICdcXFxcdUE3NDcnOiAnbCcsXFxuICAgICdcXFxcdTAxQzknOiAnbGonLFxcbiAgICAnXFxcXHUyNERDJzogJ20nLFxcbiAgICAnXFxcXHVGRjREJzogJ20nLFxcbiAgICAnXFxcXHUxRTNGJzogJ20nLFxcbiAgICAnXFxcXHUxRTQxJzogJ20nLFxcbiAgICAnXFxcXHUxRTQzJzogJ20nLFxcbiAgICAnXFxcXHUwMjcxJzogJ20nLFxcbiAgICAnXFxcXHUwMjZGJzogJ20nLFxcbiAgICAnXFxcXHUyNEREJzogJ24nLFxcbiAgICAnXFxcXHVGRjRFJzogJ24nLFxcbiAgICAnXFxcXHUwMUY5JzogJ24nLFxcbiAgICAnXFxcXHUwMTQ0JzogJ24nLFxcbiAgICAnXFxcXHUwMEYxJzogJ24nLFxcbiAgICAnXFxcXHUxRTQ1JzogJ24nLFxcbiAgICAnXFxcXHUwMTQ4JzogJ24nLFxcbiAgICAnXFxcXHUxRTQ3JzogJ24nLFxcbiAgICAnXFxcXHUwMTQ2JzogJ24nLFxcbiAgICAnXFxcXHUxRTRCJzogJ24nLFxcbiAgICAnXFxcXHUxRTQ5JzogJ24nLFxcbiAgICAnXFxcXHUwMTlFJzogJ24nLFxcbiAgICAnXFxcXHUwMjcyJzogJ24nLFxcbiAgICAnXFxcXHUwMTQ5JzogJ24nLFxcbiAgICAnXFxcXHVBNzkxJzogJ24nLFxcbiAgICAnXFxcXHVBN0E1JzogJ24nLFxcbiAgICAnXFxcXHUwMUNDJzogJ25qJyxcXG4gICAgJ1xcXFx1MjRERSc6ICdvJyxcXG4gICAgJ1xcXFx1RkY0Ric6ICdvJyxcXG4gICAgJ1xcXFx1MDBGMic6ICdvJyxcXG4gICAgJ1xcXFx1MDBGMyc6ICdvJyxcXG4gICAgJ1xcXFx1MDBGNCc6ICdvJyxcXG4gICAgJ1xcXFx1MUVEMyc6ICdvJyxcXG4gICAgJ1xcXFx1MUVEMSc6ICdvJyxcXG4gICAgJ1xcXFx1MUVENyc6ICdvJyxcXG4gICAgJ1xcXFx1MUVENSc6ICdvJyxcXG4gICAgJ1xcXFx1MDBGNSc6ICdvJyxcXG4gICAgJ1xcXFx1MUU0RCc6ICdvJyxcXG4gICAgJ1xcXFx1MDIyRCc6ICdvJyxcXG4gICAgJ1xcXFx1MUU0Ric6ICdvJyxcXG4gICAgJ1xcXFx1MDE0RCc6ICdvJyxcXG4gICAgJ1xcXFx1MUU1MSc6ICdvJyxcXG4gICAgJ1xcXFx1MUU1Myc6ICdvJyxcXG4gICAgJ1xcXFx1MDE0Ric6ICdvJyxcXG4gICAgJ1xcXFx1MDIyRic6ICdvJyxcXG4gICAgJ1xcXFx1MDIzMSc6ICdvJyxcXG4gICAgJ1xcXFx1MDBGNic6ICdvJyxcXG4gICAgJ1xcXFx1MDIyQic6ICdvJyxcXG4gICAgJ1xcXFx1MUVDRic6ICdvJyxcXG4gICAgJ1xcXFx1MDE1MSc6ICdvJyxcXG4gICAgJ1xcXFx1MDFEMic6ICdvJyxcXG4gICAgJ1xcXFx1MDIwRCc6ICdvJyxcXG4gICAgJ1xcXFx1MDIwRic6ICdvJyxcXG4gICAgJ1xcXFx1MDFBMSc6ICdvJyxcXG4gICAgJ1xcXFx1MUVERCc6ICdvJyxcXG4gICAgJ1xcXFx1MUVEQic6ICdvJyxcXG4gICAgJ1xcXFx1MUVFMSc6ICdvJyxcXG4gICAgJ1xcXFx1MUVERic6ICdvJyxcXG4gICAgJ1xcXFx1MUVFMyc6ICdvJyxcXG4gICAgJ1xcXFx1MUVDRCc6ICdvJyxcXG4gICAgJ1xcXFx1MUVEOSc6ICdvJyxcXG4gICAgJ1xcXFx1MDFFQic6ICdvJyxcXG4gICAgJ1xcXFx1MDFFRCc6ICdvJyxcXG4gICAgJ1xcXFx1MDBGOCc6ICdvJyxcXG4gICAgJ1xcXFx1MDFGRic6ICdvJyxcXG4gICAgJ1xcXFx1MDI1NCc6ICdvJyxcXG4gICAgJ1xcXFx1QTc0Qic6ICdvJyxcXG4gICAgJ1xcXFx1QTc0RCc6ICdvJyxcXG4gICAgJ1xcXFx1MDI3NSc6ICdvJyxcXG4gICAgJ1xcXFx1MDE1Myc6ICdvZScsXFxuICAgICdcXFxcdTAxQTMnOiAnb2knLFxcbiAgICAnXFxcXHUwMjIzJzogJ291JyxcXG4gICAgJ1xcXFx1QTc0Ric6ICdvbycsXFxuICAgICdcXFxcdTI0REYnOiAncCcsXFxuICAgICdcXFxcdUZGNTAnOiAncCcsXFxuICAgICdcXFxcdTFFNTUnOiAncCcsXFxuICAgICdcXFxcdTFFNTcnOiAncCcsXFxuICAgICdcXFxcdTAxQTUnOiAncCcsXFxuICAgICdcXFxcdTFEN0QnOiAncCcsXFxuICAgICdcXFxcdUE3NTEnOiAncCcsXFxuICAgICdcXFxcdUE3NTMnOiAncCcsXFxuICAgICdcXFxcdUE3NTUnOiAncCcsXFxuICAgICdcXFxcdTI0RTAnOiAncScsXFxuICAgICdcXFxcdUZGNTEnOiAncScsXFxuICAgICdcXFxcdTAyNEInOiAncScsXFxuICAgICdcXFxcdUE3NTcnOiAncScsXFxuICAgICdcXFxcdUE3NTknOiAncScsXFxuICAgICdcXFxcdTI0RTEnOiAncicsXFxuICAgICdcXFxcdUZGNTInOiAncicsXFxuICAgICdcXFxcdTAxNTUnOiAncicsXFxuICAgICdcXFxcdTFFNTknOiAncicsXFxuICAgICdcXFxcdTAxNTknOiAncicsXFxuICAgICdcXFxcdTAyMTEnOiAncicsXFxuICAgICdcXFxcdTAyMTMnOiAncicsXFxuICAgICdcXFxcdTFFNUInOiAncicsXFxuICAgICdcXFxcdTFFNUQnOiAncicsXFxuICAgICdcXFxcdTAxNTcnOiAncicsXFxuICAgICdcXFxcdTFFNUYnOiAncicsXFxuICAgICdcXFxcdTAyNEQnOiAncicsXFxuICAgICdcXFxcdTAyN0QnOiAncicsXFxuICAgICdcXFxcdUE3NUInOiAncicsXFxuICAgICdcXFxcdUE3QTcnOiAncicsXFxuICAgICdcXFxcdUE3ODMnOiAncicsXFxuICAgICdcXFxcdTI0RTInOiAncycsXFxuICAgICdcXFxcdUZGNTMnOiAncycsXFxuICAgICdcXFxcdTAwREYnOiAncycsXFxuICAgICdcXFxcdTAxNUInOiAncycsXFxuICAgICdcXFxcdTFFNjUnOiAncycsXFxuICAgICdcXFxcdTAxNUQnOiAncycsXFxuICAgICdcXFxcdTFFNjEnOiAncycsXFxuICAgICdcXFxcdTAxNjEnOiAncycsXFxuICAgICdcXFxcdTFFNjcnOiAncycsXFxuICAgICdcXFxcdTFFNjMnOiAncycsXFxuICAgICdcXFxcdTFFNjknOiAncycsXFxuICAgICdcXFxcdTAyMTknOiAncycsXFxuICAgICdcXFxcdTAxNUYnOiAncycsXFxuICAgICdcXFxcdTAyM0YnOiAncycsXFxuICAgICdcXFxcdUE3QTknOiAncycsXFxuICAgICdcXFxcdUE3ODUnOiAncycsXFxuICAgICdcXFxcdTFFOUInOiAncycsXFxuICAgICdcXFxcdTI0RTMnOiAndCcsXFxuICAgICdcXFxcdUZGNTQnOiAndCcsXFxuICAgICdcXFxcdTFFNkInOiAndCcsXFxuICAgICdcXFxcdTFFOTcnOiAndCcsXFxuICAgICdcXFxcdTAxNjUnOiAndCcsXFxuICAgICdcXFxcdTFFNkQnOiAndCcsXFxuICAgICdcXFxcdTAyMUInOiAndCcsXFxuICAgICdcXFxcdTAxNjMnOiAndCcsXFxuICAgICdcXFxcdTFFNzEnOiAndCcsXFxuICAgICdcXFxcdTFFNkYnOiAndCcsXFxuICAgICdcXFxcdTAxNjcnOiAndCcsXFxuICAgICdcXFxcdTAxQUQnOiAndCcsXFxuICAgICdcXFxcdTAyODgnOiAndCcsXFxuICAgICdcXFxcdTJDNjYnOiAndCcsXFxuICAgICdcXFxcdUE3ODcnOiAndCcsXFxuICAgICdcXFxcdUE3MjknOiAndHonLFxcbiAgICAnXFxcXHUyNEU0JzogJ3UnLFxcbiAgICAnXFxcXHVGRjU1JzogJ3UnLFxcbiAgICAnXFxcXHUwMEY5JzogJ3UnLFxcbiAgICAnXFxcXHUwMEZBJzogJ3UnLFxcbiAgICAnXFxcXHUwMEZCJzogJ3UnLFxcbiAgICAnXFxcXHUwMTY5JzogJ3UnLFxcbiAgICAnXFxcXHUxRTc5JzogJ3UnLFxcbiAgICAnXFxcXHUwMTZCJzogJ3UnLFxcbiAgICAnXFxcXHUxRTdCJzogJ3UnLFxcbiAgICAnXFxcXHUwMTZEJzogJ3UnLFxcbiAgICAnXFxcXHUwMEZDJzogJ3UnLFxcbiAgICAnXFxcXHUwMURDJzogJ3UnLFxcbiAgICAnXFxcXHUwMUQ4JzogJ3UnLFxcbiAgICAnXFxcXHUwMUQ2JzogJ3UnLFxcbiAgICAnXFxcXHUwMURBJzogJ3UnLFxcbiAgICAnXFxcXHUxRUU3JzogJ3UnLFxcbiAgICAnXFxcXHUwMTZGJzogJ3UnLFxcbiAgICAnXFxcXHUwMTcxJzogJ3UnLFxcbiAgICAnXFxcXHUwMUQ0JzogJ3UnLFxcbiAgICAnXFxcXHUwMjE1JzogJ3UnLFxcbiAgICAnXFxcXHUwMjE3JzogJ3UnLFxcbiAgICAnXFxcXHUwMUIwJzogJ3UnLFxcbiAgICAnXFxcXHUxRUVCJzogJ3UnLFxcbiAgICAnXFxcXHUxRUU5JzogJ3UnLFxcbiAgICAnXFxcXHUxRUVGJzogJ3UnLFxcbiAgICAnXFxcXHUxRUVEJzogJ3UnLFxcbiAgICAnXFxcXHUxRUYxJzogJ3UnLFxcbiAgICAnXFxcXHUxRUU1JzogJ3UnLFxcbiAgICAnXFxcXHUxRTczJzogJ3UnLFxcbiAgICAnXFxcXHUwMTczJzogJ3UnLFxcbiAgICAnXFxcXHUxRTc3JzogJ3UnLFxcbiAgICAnXFxcXHUxRTc1JzogJ3UnLFxcbiAgICAnXFxcXHUwMjg5JzogJ3UnLFxcbiAgICAnXFxcXHUyNEU1JzogJ3YnLFxcbiAgICAnXFxcXHVGRjU2JzogJ3YnLFxcbiAgICAnXFxcXHUxRTdEJzogJ3YnLFxcbiAgICAnXFxcXHUxRTdGJzogJ3YnLFxcbiAgICAnXFxcXHUwMjhCJzogJ3YnLFxcbiAgICAnXFxcXHVBNzVGJzogJ3YnLFxcbiAgICAnXFxcXHUwMjhDJzogJ3YnLFxcbiAgICAnXFxcXHVBNzYxJzogJ3Z5JyxcXG4gICAgJ1xcXFx1MjRFNic6ICd3JyxcXG4gICAgJ1xcXFx1RkY1Nyc6ICd3JyxcXG4gICAgJ1xcXFx1MUU4MSc6ICd3JyxcXG4gICAgJ1xcXFx1MUU4Myc6ICd3JyxcXG4gICAgJ1xcXFx1MDE3NSc6ICd3JyxcXG4gICAgJ1xcXFx1MUU4Nyc6ICd3JyxcXG4gICAgJ1xcXFx1MUU4NSc6ICd3JyxcXG4gICAgJ1xcXFx1MUU5OCc6ICd3JyxcXG4gICAgJ1xcXFx1MUU4OSc6ICd3JyxcXG4gICAgJ1xcXFx1MkM3Myc6ICd3JyxcXG4gICAgJ1xcXFx1MjRFNyc6ICd4JyxcXG4gICAgJ1xcXFx1RkY1OCc6ICd4JyxcXG4gICAgJ1xcXFx1MUU4Qic6ICd4JyxcXG4gICAgJ1xcXFx1MUU4RCc6ICd4JyxcXG4gICAgJ1xcXFx1MjRFOCc6ICd5JyxcXG4gICAgJ1xcXFx1RkY1OSc6ICd5JyxcXG4gICAgJ1xcXFx1MUVGMyc6ICd5JyxcXG4gICAgJ1xcXFx1MDBGRCc6ICd5JyxcXG4gICAgJ1xcXFx1MDE3Nyc6ICd5JyxcXG4gICAgJ1xcXFx1MUVGOSc6ICd5JyxcXG4gICAgJ1xcXFx1MDIzMyc6ICd5JyxcXG4gICAgJ1xcXFx1MUU4Ric6ICd5JyxcXG4gICAgJ1xcXFx1MDBGRic6ICd5JyxcXG4gICAgJ1xcXFx1MUVGNyc6ICd5JyxcXG4gICAgJ1xcXFx1MUU5OSc6ICd5JyxcXG4gICAgJ1xcXFx1MUVGNSc6ICd5JyxcXG4gICAgJ1xcXFx1MDFCNCc6ICd5JyxcXG4gICAgJ1xcXFx1MDI0Ric6ICd5JyxcXG4gICAgJ1xcXFx1MUVGRic6ICd5JyxcXG4gICAgJ1xcXFx1MjRFOSc6ICd6JyxcXG4gICAgJ1xcXFx1RkY1QSc6ICd6JyxcXG4gICAgJ1xcXFx1MDE3QSc6ICd6JyxcXG4gICAgJ1xcXFx1MUU5MSc6ICd6JyxcXG4gICAgJ1xcXFx1MDE3Qyc6ICd6JyxcXG4gICAgJ1xcXFx1MDE3RSc6ICd6JyxcXG4gICAgJ1xcXFx1MUU5Myc6ICd6JyxcXG4gICAgJ1xcXFx1MUU5NSc6ICd6JyxcXG4gICAgJ1xcXFx1MDFCNic6ICd6JyxcXG4gICAgJ1xcXFx1MDIyNSc6ICd6JyxcXG4gICAgJ1xcXFx1MDI0MCc6ICd6JyxcXG4gICAgJ1xcXFx1MkM2Qyc6ICd6JyxcXG4gICAgJ1xcXFx1QTc2Myc6ICd6JyxcXG4gICAgJ1xcXFx1MDM4Nic6ICdcXFxcdTAzOTEnLFxcbiAgICAnXFxcXHUwMzg4JzogJ1xcXFx1MDM5NScsXFxuICAgICdcXFxcdTAzODknOiAnXFxcXHUwMzk3JyxcXG4gICAgJ1xcXFx1MDM4QSc6ICdcXFxcdTAzOTknLFxcbiAgICAnXFxcXHUwM0FBJzogJ1xcXFx1MDM5OScsXFxuICAgICdcXFxcdTAzOEMnOiAnXFxcXHUwMzlGJyxcXG4gICAgJ1xcXFx1MDM4RSc6ICdcXFxcdTAzQTUnLFxcbiAgICAnXFxcXHUwM0FCJzogJ1xcXFx1MDNBNScsXFxuICAgICdcXFxcdTAzOEYnOiAnXFxcXHUwM0E5JyxcXG4gICAgJ1xcXFx1MDNBQyc6ICdcXFxcdTAzQjEnLFxcbiAgICAnXFxcXHUwM0FEJzogJ1xcXFx1MDNCNScsXFxuICAgICdcXFxcdTAzQUUnOiAnXFxcXHUwM0I3JyxcXG4gICAgJ1xcXFx1MDNBRic6ICdcXFxcdTAzQjknLFxcbiAgICAnXFxcXHUwM0NBJzogJ1xcXFx1MDNCOScsXFxuICAgICdcXFxcdTAzOTAnOiAnXFxcXHUwM0I5JyxcXG4gICAgJ1xcXFx1MDNDQyc6ICdcXFxcdTAzQkYnLFxcbiAgICAnXFxcXHUwM0NEJzogJ1xcXFx1MDNDNScsXFxuICAgICdcXFxcdTAzQ0InOiAnXFxcXHUwM0M1JyxcXG4gICAgJ1xcXFx1MDNCMCc6ICdcXFxcdTAzQzUnLFxcbiAgICAnXFxcXHUwM0NFJzogJ1xcXFx1MDNDOScsXFxuICAgICdcXFxcdTAzQzInOiAnXFxcXHUwM0MzJyxcXG4gICAgJ1xcXFx1MjAxOSc6ICdcXFxcJydcXG4gIH07XFxuXFxuICByZXR1cm4gZGlhY3JpdGljcztcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9iYXNlJyxbXFxuICAnLi4vdXRpbHMnXFxuXSwgZnVuY3Rpb24gKFV0aWxzKSB7XFxuICBmdW5jdGlvbiBCYXNlQWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgQmFzZUFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XFxuICB9XFxuXFxuICBVdGlscy5FeHRlbmQoQmFzZUFkYXB0ZXIsIFV0aWxzLk9ic2VydmFibGUpO1xcblxcbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmN1cnJlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYGN1cnJlbnRgIG1ldGhvZCBtdXN0IGJlIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlcy4nKTtcXG4gIH07XFxuXFxuICBCYXNlQWRhcHRlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgcXVlcnlgIG1ldGhvZCBtdXN0IGJlIGRlZmluZWQgaW4gY2hpbGQgY2xhc3Nlcy4nKTtcXG4gIH07XFxuXFxuICBCYXNlQWRhcHRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgLy8gQ2FuIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcXG4gIH07XFxuXFxuICBCYXNlQWRhcHRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gQ2FuIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcXG4gIH07XFxuXFxuICBCYXNlQWRhcHRlci5wcm90b3R5cGUuZ2VuZXJhdGVSZXN1bHRJZCA9IGZ1bmN0aW9uIChjb250YWluZXIsIGRhdGEpIHtcXG4gICAgdmFyIGlkID0gY29udGFpbmVyLmlkICsgJy1yZXN1bHQtJztcXG5cXG4gICAgaWQgKz0gVXRpbHMuZ2VuZXJhdGVDaGFycyg0KTtcXG5cXG4gICAgaWYgKGRhdGEuaWQgIT0gbnVsbCkge1xcbiAgICAgIGlkICs9ICctJyArIGRhdGEuaWQudG9TdHJpbmcoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZCArPSAnLScgKyBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xcbiAgICB9XFxuICAgIHJldHVybiBpZDtcXG4gIH07XFxuXFxuICByZXR1cm4gQmFzZUFkYXB0ZXI7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvc2VsZWN0JyxbXFxuICAnLi9iYXNlJyxcXG4gICcuLi91dGlscycsXFxuICAnanF1ZXJ5J1xcbl0sIGZ1bmN0aW9uIChCYXNlQWRhcHRlciwgVXRpbHMsICQpIHtcXG4gIGZ1bmN0aW9uIFNlbGVjdEFkYXB0ZXIgKCRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXG4gICAgU2VsZWN0QWRhcHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG4gIH1cXG5cXG4gIFV0aWxzLkV4dGVuZChTZWxlY3RBZGFwdGVyLCBCYXNlQWRhcHRlcik7XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XFxuICAgIHZhciBkYXRhID0gW107XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCc6c2VsZWN0ZWQnKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgJG9wdGlvbiA9ICQodGhpcyk7XFxuXFxuICAgICAgdmFyIG9wdGlvbiA9IHNlbGYuaXRlbSgkb3B0aW9uKTtcXG5cXG4gICAgICBkYXRhLnB1c2gob3B0aW9uKTtcXG4gICAgfSk7XFxuXFxuICAgIGNhbGxiYWNrKGRhdGEpO1xcbiAgfTtcXG5cXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgZGF0YS5zZWxlY3RlZCA9IHRydWU7XFxuXFxuICAgIC8vIElmIGRhdGEuZWxlbWVudCBpcyBhIERPTSBub2RlLCB1c2UgaXQgaW5zdGVhZFxcbiAgICBpZiAoJChkYXRhLmVsZW1lbnQpLmlzKCdvcHRpb24nKSkge1xcbiAgICAgIGRhdGEuZWxlbWVudC5zZWxlY3RlZCA9IHRydWU7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xcblxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy4kZWxlbWVudC5wcm9wKCdtdWx0aXBsZScpKSB7XFxuICAgICAgdGhpcy5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xcbiAgICAgICAgdmFyIHZhbCA9IFtdO1xcblxcbiAgICAgICAgZGF0YSA9IFtkYXRhXTtcXG4gICAgICAgIGRhdGEucHVzaC5hcHBseShkYXRhLCBjdXJyZW50RGF0YSk7XFxuXFxuICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcXG4gICAgICAgICAgdmFyIGlkID0gZGF0YVtkXS5pZDtcXG5cXG4gICAgICAgICAgaWYgKCQuaW5BcnJheShpZCwgdmFsKSA9PT0gLTEpIHtcXG4gICAgICAgICAgICB2YWwucHVzaChpZCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNlbGYuJGVsZW1lbnQudmFsKHZhbCk7XFxuICAgICAgICBzZWxmLiRlbGVtZW50LnRyaWdnZXIoJ2lucHV0JykudHJpZ2dlcignY2hhbmdlJyk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFyIHZhbCA9IGRhdGEuaWQ7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudC52YWwodmFsKTtcXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2lucHV0JykudHJpZ2dlcignY2hhbmdlJyk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgaWYgKCF0aGlzLiRlbGVtZW50LnByb3AoJ211bHRpcGxlJykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZGF0YS5zZWxlY3RlZCA9IGZhbHNlO1xcblxcbiAgICBpZiAoJChkYXRhLmVsZW1lbnQpLmlzKCdvcHRpb24nKSkge1xcbiAgICAgIGRhdGEuZWxlbWVudC5zZWxlY3RlZCA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaW5wdXQnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xcbiAgICAgIHZhciB2YWwgPSBbXTtcXG5cXG4gICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGN1cnJlbnREYXRhLmxlbmd0aDsgZCsrKSB7XFxuICAgICAgICB2YXIgaWQgPSBjdXJyZW50RGF0YVtkXS5pZDtcXG5cXG4gICAgICAgIGlmIChpZCAhPT0gZGF0YS5pZCAmJiAkLmluQXJyYXkoaWQsIHZhbCkgPT09IC0xKSB7XFxuICAgICAgICAgIHZhbC5wdXNoKGlkKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi4kZWxlbWVudC52YWwodmFsKTtcXG5cXG4gICAgICBzZWxmLiRlbGVtZW50LnRyaWdnZXIoJ2lucHV0JykudHJpZ2dlcignY2hhbmdlJyk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XFxuXFxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0JywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHNlbGYuc2VsZWN0KHBhcmFtcy5kYXRhKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigndW5zZWxlY3QnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgc2VsZi51bnNlbGVjdChwYXJhbXMuZGF0YSk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8vIFJlbW92ZSBhbnl0aGluZyBhZGRlZCB0byBjaGlsZCBlbGVtZW50c1xcbiAgICB0aGlzLiRlbGVtZW50LmZpbmQoJyonKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBSZW1vdmUgYW55IGN1c3RvbSBkYXRhIHNldCBieSBTZWxlY3QyXFxuICAgICAgVXRpbHMuUmVtb3ZlRGF0YSh0aGlzKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xcbiAgICB2YXIgZGF0YSA9IFtdO1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHZhciAkb3B0aW9ucyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oKTtcXG5cXG4gICAgJG9wdGlvbnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICRvcHRpb24gPSAkKHRoaXMpO1xcblxcbiAgICAgIGlmICghJG9wdGlvbi5pcygnb3B0aW9uJykgJiYgISRvcHRpb24uaXMoJ29wdGdyb3VwJykpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG9wdGlvbiA9IHNlbGYuaXRlbSgkb3B0aW9uKTtcXG5cXG4gICAgICB2YXIgbWF0Y2hlcyA9IHNlbGYubWF0Y2hlcyhwYXJhbXMsIG9wdGlvbik7XFxuXFxuICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwpIHtcXG4gICAgICAgIGRhdGEucHVzaChtYXRjaGVzKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjYWxsYmFjayh7XFxuICAgICAgcmVzdWx0czogZGF0YVxcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5hZGRPcHRpb25zID0gZnVuY3Rpb24gKCRvcHRpb25zKSB7XFxuICAgIFV0aWxzLmFwcGVuZE1hbnkodGhpcy4kZWxlbWVudCwgJG9wdGlvbnMpO1xcbiAgfTtcXG5cXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgIHZhciBvcHRpb247XFxuXFxuICAgIGlmIChkYXRhLmNoaWxkcmVuKSB7XFxuICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0Z3JvdXAnKTtcXG4gICAgICBvcHRpb24ubGFiZWwgPSBkYXRhLnRleHQ7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XFxuXFxuICAgICAgaWYgKG9wdGlvbi50ZXh0Q29udGVudCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBkYXRhLnRleHQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG9wdGlvbi5pbm5lclRleHQgPSBkYXRhLnRleHQ7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChkYXRhLmlkICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICBvcHRpb24udmFsdWUgPSBkYXRhLmlkO1xcbiAgICB9XFxuXFxuICAgIGlmIChkYXRhLmRpc2FibGVkKSB7XFxuICAgICAgb3B0aW9uLmRpc2FibGVkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YS5zZWxlY3RlZCkge1xcbiAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRhdGEudGl0bGUpIHtcXG4gICAgICBvcHRpb24udGl0bGUgPSBkYXRhLnRpdGxlO1xcbiAgICB9XFxuXFxuICAgIHZhciAkb3B0aW9uID0gJChvcHRpb24pO1xcblxcbiAgICB2YXIgbm9ybWFsaXplZERhdGEgPSB0aGlzLl9ub3JtYWxpemVJdGVtKGRhdGEpO1xcbiAgICBub3JtYWxpemVkRGF0YS5lbGVtZW50ID0gb3B0aW9uO1xcblxcbiAgICAvLyBPdmVycmlkZSB0aGUgb3B0aW9uJ3MgZGF0YSB3aXRoIHRoZSBjb21iaW5lZCBkYXRhXFxuICAgIFV0aWxzLlN0b3JlRGF0YShvcHRpb24sICdkYXRhJywgbm9ybWFsaXplZERhdGEpO1xcblxcbiAgICByZXR1cm4gJG9wdGlvbjtcXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5pdGVtID0gZnVuY3Rpb24gKCRvcHRpb24pIHtcXG4gICAgdmFyIGRhdGEgPSB7fTtcXG5cXG4gICAgZGF0YSA9IFV0aWxzLkdldERhdGEoJG9wdGlvblswXSwgJ2RhdGEnKTtcXG5cXG4gICAgaWYgKGRhdGEgIT0gbnVsbCkge1xcbiAgICAgIHJldHVybiBkYXRhO1xcbiAgICB9XFxuXFxuICAgIGlmICgkb3B0aW9uLmlzKCdvcHRpb24nKSkge1xcbiAgICAgIGRhdGEgPSB7XFxuICAgICAgICBpZDogJG9wdGlvbi52YWwoKSxcXG4gICAgICAgIHRleHQ6ICRvcHRpb24udGV4dCgpLFxcbiAgICAgICAgZGlzYWJsZWQ6ICRvcHRpb24ucHJvcCgnZGlzYWJsZWQnKSxcXG4gICAgICAgIHNlbGVjdGVkOiAkb3B0aW9uLnByb3AoJ3NlbGVjdGVkJyksXFxuICAgICAgICB0aXRsZTogJG9wdGlvbi5wcm9wKCd0aXRsZScpXFxuICAgICAgfTtcXG4gICAgfSBlbHNlIGlmICgkb3B0aW9uLmlzKCdvcHRncm91cCcpKSB7XFxuICAgICAgZGF0YSA9IHtcXG4gICAgICAgIHRleHQ6ICRvcHRpb24ucHJvcCgnbGFiZWwnKSxcXG4gICAgICAgIGNoaWxkcmVuOiBbXSxcXG4gICAgICAgIHRpdGxlOiAkb3B0aW9uLnByb3AoJ3RpdGxlJylcXG4gICAgICB9O1xcblxcbiAgICAgIHZhciAkY2hpbGRyZW4gPSAkb3B0aW9uLmNoaWxkcmVuKCdvcHRpb24nKTtcXG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcXG5cXG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8ICRjaGlsZHJlbi5sZW5ndGg7IGMrKykge1xcbiAgICAgICAgdmFyICRjaGlsZCA9ICQoJGNoaWxkcmVuW2NdKTtcXG5cXG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuaXRlbSgkY2hpbGQpO1xcblxcbiAgICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGRhdGEuY2hpbGRyZW4gPSBjaGlsZHJlbjtcXG4gICAgfVxcblxcbiAgICBkYXRhID0gdGhpcy5fbm9ybWFsaXplSXRlbShkYXRhKTtcXG4gICAgZGF0YS5lbGVtZW50ID0gJG9wdGlvblswXTtcXG5cXG4gICAgVXRpbHMuU3RvcmVEYXRhKCRvcHRpb25bMF0sICdkYXRhJywgZGF0YSk7XFxuXFxuICAgIHJldHVybiBkYXRhO1xcbiAgfTtcXG5cXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLl9ub3JtYWxpemVJdGVtID0gZnVuY3Rpb24gKGl0ZW0pIHtcXG4gICAgaWYgKGl0ZW0gIT09IE9iamVjdChpdGVtKSkge1xcbiAgICAgIGl0ZW0gPSB7XFxuICAgICAgICBpZDogaXRlbSxcXG4gICAgICAgIHRleHQ6IGl0ZW1cXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGl0ZW0gPSAkLmV4dGVuZCh7fSwge1xcbiAgICAgIHRleHQ6ICcnXFxuICAgIH0sIGl0ZW0pO1xcblxcbiAgICB2YXIgZGVmYXVsdHMgPSB7XFxuICAgICAgc2VsZWN0ZWQ6IGZhbHNlLFxcbiAgICAgIGRpc2FibGVkOiBmYWxzZVxcbiAgICB9O1xcblxcbiAgICBpZiAoaXRlbS5pZCAhPSBudWxsKSB7XFxuICAgICAgaXRlbS5pZCA9IGl0ZW0uaWQudG9TdHJpbmcoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoaXRlbS50ZXh0ICE9IG51bGwpIHtcXG4gICAgICBpdGVtLnRleHQgPSBpdGVtLnRleHQudG9TdHJpbmcoKTtcXG4gICAgfVxcblxcbiAgICBpZiAoaXRlbS5fcmVzdWx0SWQgPT0gbnVsbCAmJiBpdGVtLmlkICYmIHRoaXMuY29udGFpbmVyICE9IG51bGwpIHtcXG4gICAgICBpdGVtLl9yZXN1bHRJZCA9IHRoaXMuZ2VuZXJhdGVSZXN1bHRJZCh0aGlzLmNvbnRhaW5lciwgaXRlbSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgaXRlbSk7XFxuICB9O1xcblxcbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGRhdGEpIHtcXG4gICAgdmFyIG1hdGNoZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdtYXRjaGVyJyk7XFxuXFxuICAgIHJldHVybiBtYXRjaGVyKHBhcmFtcywgZGF0YSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIFNlbGVjdEFkYXB0ZXI7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvYXJyYXknLFtcXG4gICcuL3NlbGVjdCcsXFxuICAnLi4vdXRpbHMnLFxcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoU2VsZWN0QWRhcHRlciwgVXRpbHMsICQpIHtcXG4gIGZ1bmN0aW9uIEFycmF5QWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgdGhpcy5fZGF0YVRvQ29udmVydCA9IG9wdGlvbnMuZ2V0KCdkYXRhJykgfHwgW107XFxuXFxuICAgIEFycmF5QWRhcHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBVdGlscy5FeHRlbmQoQXJyYXlBZGFwdGVyLCBTZWxlY3RBZGFwdGVyKTtcXG5cXG4gIEFycmF5QWRhcHRlci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgQXJyYXlBZGFwdGVyLl9fc3VwZXJfXy5iaW5kLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgdGhpcy5hZGRPcHRpb25zKHRoaXMuY29udmVydFRvT3B0aW9ucyh0aGlzLl9kYXRhVG9Db252ZXJ0KSk7XFxuICB9O1xcblxcbiAgQXJyYXlBZGFwdGVyLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB2YXIgJG9wdGlvbiA9IHRoaXMuJGVsZW1lbnQuZmluZCgnb3B0aW9uJykuZmlsdGVyKGZ1bmN0aW9uIChpLCBlbG0pIHtcXG4gICAgICByZXR1cm4gZWxtLnZhbHVlID09IGRhdGEuaWQudG9TdHJpbmcoKTtcXG4gICAgfSk7XFxuXFxuICAgIGlmICgkb3B0aW9uLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICRvcHRpb24gPSB0aGlzLm9wdGlvbihkYXRhKTtcXG5cXG4gICAgICB0aGlzLmFkZE9wdGlvbnMoJG9wdGlvbik7XFxuICAgIH1cXG5cXG4gICAgQXJyYXlBZGFwdGVyLl9fc3VwZXJfXy5zZWxlY3QuY2FsbCh0aGlzLCBkYXRhKTtcXG4gIH07XFxuXFxuICBBcnJheUFkYXB0ZXIucHJvdG90eXBlLmNvbnZlcnRUb09wdGlvbnMgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHZhciAkZXhpc3RpbmcgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ29wdGlvbicpO1xcbiAgICB2YXIgZXhpc3RpbmdJZHMgPSAkZXhpc3RpbmcubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gc2VsZi5pdGVtKCQodGhpcykpLmlkO1xcbiAgICB9KS5nZXQoKTtcXG5cXG4gICAgdmFyICRvcHRpb25zID0gW107XFxuXFxuICAgIC8vIEZpbHRlciBvdXQgYWxsIGl0ZW1zIGV4Y2VwdCBmb3IgdGhlIG9uZSBwYXNzZWQgaW4gdGhlIGFyZ3VtZW50XFxuICAgIGZ1bmN0aW9uIG9ubHlJdGVtIChpdGVtKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAkKHRoaXMpLnZhbCgpID09IGl0ZW0uaWQ7XFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcXG4gICAgICB2YXIgaXRlbSA9IHRoaXMuX25vcm1hbGl6ZUl0ZW0oZGF0YVtkXSk7XFxuXFxuICAgICAgLy8gU2tpcCBpdGVtcyB3aGljaCB3ZXJlIHByZS1sb2FkZWQsIG9ubHkgbWVyZ2UgdGhlIGRhdGFcXG4gICAgICBpZiAoJC5pbkFycmF5KGl0ZW0uaWQsIGV4aXN0aW5nSWRzKSA+PSAwKSB7XFxuICAgICAgICB2YXIgJGV4aXN0aW5nT3B0aW9uID0gJGV4aXN0aW5nLmZpbHRlcihvbmx5SXRlbShpdGVtKSk7XFxuXFxuICAgICAgICB2YXIgZXhpc3RpbmdEYXRhID0gdGhpcy5pdGVtKCRleGlzdGluZ09wdGlvbik7XFxuICAgICAgICB2YXIgbmV3RGF0YSA9ICQuZXh0ZW5kKHRydWUsIHt9LCBpdGVtLCBleGlzdGluZ0RhdGEpO1xcblxcbiAgICAgICAgdmFyICRuZXdPcHRpb24gPSB0aGlzLm9wdGlvbihuZXdEYXRhKTtcXG5cXG4gICAgICAgICRleGlzdGluZ09wdGlvbi5yZXBsYWNlV2l0aCgkbmV3T3B0aW9uKTtcXG5cXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgJG9wdGlvbiA9IHRoaXMub3B0aW9uKGl0ZW0pO1xcblxcbiAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XFxuICAgICAgICB2YXIgJGNoaWxkcmVuID0gdGhpcy5jb252ZXJ0VG9PcHRpb25zKGl0ZW0uY2hpbGRyZW4pO1xcblxcbiAgICAgICAgVXRpbHMuYXBwZW5kTWFueSgkb3B0aW9uLCAkY2hpbGRyZW4pO1xcbiAgICAgIH1cXG5cXG4gICAgICAkb3B0aW9ucy5wdXNoKCRvcHRpb24pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiAkb3B0aW9ucztcXG4gIH07XFxuXFxuICByZXR1cm4gQXJyYXlBZGFwdGVyO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL2FqYXgnLFtcXG4gICcuL2FycmF5JyxcXG4gICcuLi91dGlscycsXFxuICAnanF1ZXJ5J1xcbl0sIGZ1bmN0aW9uIChBcnJheUFkYXB0ZXIsIFV0aWxzLCAkKSB7XFxuICBmdW5jdGlvbiBBamF4QWRhcHRlciAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgdGhpcy5hamF4T3B0aW9ucyA9IHRoaXMuX2FwcGx5RGVmYXVsdHMob3B0aW9ucy5nZXQoJ2FqYXgnKSk7XFxuXFxuICAgIGlmICh0aGlzLmFqYXhPcHRpb25zLnByb2Nlc3NSZXN1bHRzICE9IG51bGwpIHtcXG4gICAgICB0aGlzLnByb2Nlc3NSZXN1bHRzID0gdGhpcy5hamF4T3B0aW9ucy5wcm9jZXNzUmVzdWx0cztcXG4gICAgfVxcblxcbiAgICBBamF4QWRhcHRlci5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBVdGlscy5FeHRlbmQoQWpheEFkYXB0ZXIsIEFycmF5QWRhcHRlcik7XFxuXFxuICBBamF4QWRhcHRlci5wcm90b3R5cGUuX2FwcGx5RGVmYXVsdHMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICB2YXIgZGVmYXVsdHMgPSB7XFxuICAgICAgZGF0YTogZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBwYXJhbXMsIHtcXG4gICAgICAgICAgcTogcGFyYW1zLnRlcm1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0sXFxuICAgICAgdHJhbnNwb3J0OiBmdW5jdGlvbiAocGFyYW1zLCBzdWNjZXNzLCBmYWlsdXJlKSB7XFxuICAgICAgICB2YXIgJHJlcXVlc3QgPSAkLmFqYXgocGFyYW1zKTtcXG5cXG4gICAgICAgICRyZXF1ZXN0LnRoZW4oc3VjY2Vzcyk7XFxuICAgICAgICAkcmVxdWVzdC5mYWlsKGZhaWx1cmUpO1xcblxcbiAgICAgICAgcmV0dXJuICRyZXF1ZXN0O1xcbiAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuICQuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucywgdHJ1ZSk7XFxuICB9O1xcblxcbiAgQWpheEFkYXB0ZXIucHJvdG90eXBlLnByb2Nlc3NSZXN1bHRzID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcXG4gICAgcmV0dXJuIHJlc3VsdHM7XFxuICB9O1xcblxcbiAgQWpheEFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcXG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICBpZiAodGhpcy5fcmVxdWVzdCAhPSBudWxsKSB7XFxuICAgICAgLy8gSlNPTlAgcmVxdWVzdHMgY2Fubm90IGFsd2F5cyBiZSBhYm9ydGVkXFxuICAgICAgaWYgKCQuaXNGdW5jdGlvbih0aGlzLl9yZXF1ZXN0LmFib3J0KSkge1xcbiAgICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcXG4gICAgfVxcblxcbiAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHtcXG4gICAgICB0eXBlOiAnR0VUJ1xcbiAgICB9LCB0aGlzLmFqYXhPcHRpb25zKTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnVybCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIG9wdGlvbnMudXJsID0gb3B0aW9ucy51cmwuY2FsbCh0aGlzLiRlbGVtZW50LCBwYXJhbXMpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kYXRhID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgb3B0aW9ucy5kYXRhID0gb3B0aW9ucy5kYXRhLmNhbGwodGhpcy4kZWxlbWVudCwgcGFyYW1zKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiByZXF1ZXN0ICgpIHtcXG4gICAgICB2YXIgJHJlcXVlc3QgPSBvcHRpb25zLnRyYW5zcG9ydChvcHRpb25zLCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBzZWxmLnByb2Nlc3NSZXN1bHRzKGRhdGEsIHBhcmFtcyk7XFxuXFxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmdldCgnZGVidWcnKSAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XFxuICAgICAgICAgIC8vIENoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSByZXNwb25zZSBpbmNsdWRlZCBhIGByZXN1bHRzYCBrZXkuXFxuICAgICAgICAgIGlmICghcmVzdWx0cyB8fCAhcmVzdWx0cy5yZXN1bHRzIHx8ICEkLmlzQXJyYXkocmVzdWx0cy5yZXN1bHRzKSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXFxuICAgICAgICAgICAgICAnU2VsZWN0MjogVGhlIEFKQVggcmVzdWx0cyBkaWQgbm90IHJldHVybiBhbiBhcnJheSBpbiB0aGUgJyArXFxuICAgICAgICAgICAgICAnYHJlc3VsdHNgIGtleSBvZiB0aGUgcmVzcG9uc2UuJ1xcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGNhbGxiYWNrKHJlc3VsdHMpO1xcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZGV0ZWN0IGlmIGEgcmVxdWVzdCB3YXMgYWJvcnRlZFxcbiAgICAgICAgLy8gT25seSB3b3JrcyBpZiB0aGUgdHJhbnNwb3J0IGV4cG9zZXMgYSBzdGF0dXMgcHJvcGVydHlcXG4gICAgICAgIGlmICgnc3RhdHVzJyBpbiAkcmVxdWVzdCAmJlxcbiAgICAgICAgICAgICgkcmVxdWVzdC5zdGF0dXMgPT09IDAgfHwgJHJlcXVlc3Quc3RhdHVzID09PSAnMCcpKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czptZXNzYWdlJywge1xcbiAgICAgICAgICBtZXNzYWdlOiAnZXJyb3JMb2FkaW5nJ1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgc2VsZi5fcmVxdWVzdCA9ICRyZXF1ZXN0O1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmFqYXhPcHRpb25zLmRlbGF5ICYmIHBhcmFtcy50ZXJtICE9IG51bGwpIHtcXG4gICAgICBpZiAodGhpcy5fcXVlcnlUaW1lb3V0KSB7XFxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3F1ZXJ5VGltZW91dCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3F1ZXJ5VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHJlcXVlc3QsIHRoaXMuYWpheE9wdGlvbnMuZGVsYXkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlcXVlc3QoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBBamF4QWRhcHRlcjtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS90YWdzJyxbXFxuICAnanF1ZXJ5J1xcbl0sIGZ1bmN0aW9uICgkKSB7XFxuICBmdW5jdGlvbiBUYWdzIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHZhciB0YWdzID0gb3B0aW9ucy5nZXQoJ3RhZ3MnKTtcXG5cXG4gICAgdmFyIGNyZWF0ZVRhZyA9IG9wdGlvbnMuZ2V0KCdjcmVhdGVUYWcnKTtcXG5cXG4gICAgaWYgKGNyZWF0ZVRhZyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdGhpcy5jcmVhdGVUYWcgPSBjcmVhdGVUYWc7XFxuICAgIH1cXG5cXG4gICAgdmFyIGluc2VydFRhZyA9IG9wdGlvbnMuZ2V0KCdpbnNlcnRUYWcnKTtcXG5cXG4gICAgaWYgKGluc2VydFRhZyAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB0aGlzLmluc2VydFRhZyA9IGluc2VydFRhZztcXG4gICAgfVxcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XFxuXFxuICAgIGlmICgkLmlzQXJyYXkodGFncykpIHtcXG4gICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRhZ3MubGVuZ3RoOyB0KyspIHtcXG4gICAgICAgIHZhciB0YWcgPSB0YWdzW3RdO1xcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9ub3JtYWxpemVJdGVtKHRhZyk7XFxuXFxuICAgICAgICB2YXIgJG9wdGlvbiA9IHRoaXMub3B0aW9uKGl0ZW0pO1xcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmQoJG9wdGlvbik7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBUYWdzLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB0aGlzLl9yZW1vdmVPbGRUYWdzKCk7XFxuXFxuICAgIGlmIChwYXJhbXMudGVybSA9PSBudWxsIHx8IHBhcmFtcy5wYWdlICE9IG51bGwpIHtcXG4gICAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gd3JhcHBlciAob2JqLCBjaGlsZCkge1xcbiAgICAgIHZhciBkYXRhID0gb2JqLnJlc3VsdHM7XFxuXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICB2YXIgb3B0aW9uID0gZGF0YVtpXTtcXG5cXG4gICAgICAgIHZhciBjaGVja0NoaWxkcmVuID0gKFxcbiAgICAgICAgICBvcHRpb24uY2hpbGRyZW4gIT0gbnVsbCAmJlxcbiAgICAgICAgICAhd3JhcHBlcih7XFxuICAgICAgICAgICAgcmVzdWx0czogb3B0aW9uLmNoaWxkcmVuXFxuICAgICAgICAgIH0sIHRydWUpXFxuICAgICAgICApO1xcblxcbiAgICAgICAgdmFyIG9wdGlvblRleHQgPSAob3B0aW9uLnRleHQgfHwgJycpLnRvVXBwZXJDYXNlKCk7XFxuICAgICAgICB2YXIgcGFyYW1zVGVybSA9IChwYXJhbXMudGVybSB8fCAnJykudG9VcHBlckNhc2UoKTtcXG5cXG4gICAgICAgIHZhciBjaGVja1RleHQgPSBvcHRpb25UZXh0ID09PSBwYXJhbXNUZXJtO1xcblxcbiAgICAgICAgaWYgKGNoZWNrVGV4dCB8fCBjaGVja0NoaWxkcmVuKSB7XFxuICAgICAgICAgIGlmIChjaGlsZCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvYmouZGF0YSA9IGRhdGE7XFxuICAgICAgICAgIGNhbGxiYWNrKG9iaik7XFxuXFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGNoaWxkKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHRhZyA9IHNlbGYuY3JlYXRlVGFnKHBhcmFtcyk7XFxuXFxuICAgICAgaWYgKHRhZyAhPSBudWxsKSB7XFxuICAgICAgICB2YXIgJG9wdGlvbiA9IHNlbGYub3B0aW9uKHRhZyk7XFxuICAgICAgICAkb3B0aW9uLmF0dHIoJ2RhdGEtc2VsZWN0Mi10YWcnLCB0cnVlKTtcXG5cXG4gICAgICAgIHNlbGYuYWRkT3B0aW9ucyhbJG9wdGlvbl0pO1xcblxcbiAgICAgICAgc2VsZi5pbnNlcnRUYWcoZGF0YSwgdGFnKTtcXG4gICAgICB9XFxuXFxuICAgICAgb2JqLnJlc3VsdHMgPSBkYXRhO1xcblxcbiAgICAgIGNhbGxiYWNrKG9iaik7XFxuICAgIH1cXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgcGFyYW1zLCB3cmFwcGVyKTtcXG4gIH07XFxuXFxuICBUYWdzLnByb3RvdHlwZS5jcmVhdGVUYWcgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwYXJhbXMpIHtcXG4gICAgdmFyIHRlcm0gPSAkLnRyaW0ocGFyYW1zLnRlcm0pO1xcblxcbiAgICBpZiAodGVybSA9PT0gJycpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIGlkOiB0ZXJtLFxcbiAgICAgIHRleHQ6IHRlcm1cXG4gICAgfTtcXG4gIH07XFxuXFxuICBUYWdzLnByb3RvdHlwZS5pbnNlcnRUYWcgPSBmdW5jdGlvbiAoXywgZGF0YSwgdGFnKSB7XFxuICAgIGRhdGEudW5zaGlmdCh0YWcpO1xcbiAgfTtcXG5cXG4gIFRhZ3MucHJvdG90eXBlLl9yZW1vdmVPbGRUYWdzID0gZnVuY3Rpb24gKF8pIHtcXG4gICAgdmFyICRvcHRpb25zID0gdGhpcy4kZWxlbWVudC5maW5kKCdvcHRpb25bZGF0YS1zZWxlY3QyLXRhZ10nKTtcXG5cXG4gICAgJG9wdGlvbnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgJCh0aGlzKS5yZW1vdmUoKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIFRhZ3M7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvdG9rZW5pemVyJyxbXFxuICAnanF1ZXJ5J1xcbl0sIGZ1bmN0aW9uICgkKSB7XFxuICBmdW5jdGlvbiBUb2tlbml6ZXIgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgdmFyIHRva2VuaXplciA9IG9wdGlvbnMuZ2V0KCd0b2tlbml6ZXInKTtcXG5cXG4gICAgaWYgKHRva2VuaXplciAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgdGhpcy50b2tlbml6ZXIgPSB0b2tlbml6ZXI7XFxuICAgIH1cXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIHRoaXMuJHNlYXJjaCA9ICBjb250YWluZXIuZHJvcGRvd24uJHNlYXJjaCB8fCBjb250YWluZXIuc2VsZWN0aW9uLiRzZWFyY2ggfHxcXG4gICAgICAkY29udGFpbmVyLmZpbmQoJy5zZWxlY3QyLXNlYXJjaF9fZmllbGQnKTtcXG4gIH07XFxuXFxuICBUb2tlbml6ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zLCBjYWxsYmFjaykge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFuZFNlbGVjdCAoZGF0YSkge1xcbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgZGF0YSBvYmplY3Qgc28gd2UgY2FuIHVzZSBpdCBmb3IgY2hlY2tzXFxuICAgICAgdmFyIGl0ZW0gPSBzZWxmLl9ub3JtYWxpemVJdGVtKGRhdGEpO1xcblxcbiAgICAgIC8vIENoZWNrIGlmIHRoZSBkYXRhIG9iamVjdCBhbHJlYWR5IGV4aXN0cyBhcyBhIHRhZ1xcbiAgICAgIC8vIFNlbGVjdCBpdCBpZiBpdCBkb2Vzbid0XFxuICAgICAgdmFyICRleGlzdGluZ09wdGlvbnMgPSBzZWxmLiRlbGVtZW50LmZpbmQoJ29wdGlvbicpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gJCh0aGlzKS52YWwoKSA9PT0gaXRlbS5pZDtcXG4gICAgICB9KTtcXG5cXG4gICAgICAvLyBJZiBhbiBleGlzdGluZyBvcHRpb24gd2Fzbid0IGZvdW5kIGZvciBpdCwgY3JlYXRlIHRoZSBvcHRpb25cXG4gICAgICBpZiAoISRleGlzdGluZ09wdGlvbnMubGVuZ3RoKSB7XFxuICAgICAgICB2YXIgJG9wdGlvbiA9IHNlbGYub3B0aW9uKGl0ZW0pO1xcbiAgICAgICAgJG9wdGlvbi5hdHRyKCdkYXRhLXNlbGVjdDItdGFnJywgdHJ1ZSk7XFxuXFxuICAgICAgICBzZWxmLl9yZW1vdmVPbGRUYWdzKCk7XFxuICAgICAgICBzZWxmLmFkZE9wdGlvbnMoWyRvcHRpb25dKTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gU2VsZWN0IHRoZSBpdGVtLCBub3cgdGhhdCB3ZSBrbm93IHRoZXJlIGlzIGFuIG9wdGlvbiBmb3IgaXRcXG4gICAgICBzZWxlY3QoaXRlbSk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gc2VsZWN0IChkYXRhKSB7XFxuICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3QnLCB7XFxuICAgICAgICBkYXRhOiBkYXRhXFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgcGFyYW1zLnRlcm0gPSBwYXJhbXMudGVybSB8fCAnJztcXG5cXG4gICAgdmFyIHRva2VuRGF0YSA9IHRoaXMudG9rZW5pemVyKHBhcmFtcywgdGhpcy5vcHRpb25zLCBjcmVhdGVBbmRTZWxlY3QpO1xcblxcbiAgICBpZiAodG9rZW5EYXRhLnRlcm0gIT09IHBhcmFtcy50ZXJtKSB7XFxuICAgICAgLy8gUmVwbGFjZSB0aGUgc2VhcmNoIHRlcm0gaWYgd2UgaGF2ZSB0aGUgc2VhcmNoIGJveFxcbiAgICAgIGlmICh0aGlzLiRzZWFyY2gubGVuZ3RoKSB7XFxuICAgICAgICB0aGlzLiRzZWFyY2gudmFsKHRva2VuRGF0YS50ZXJtKTtcXG4gICAgICAgIHRoaXMuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYXJhbXMudGVybSA9IHRva2VuRGF0YS50ZXJtO1xcbiAgICB9XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xcbiAgfTtcXG5cXG4gIFRva2VuaXplci5wcm90b3R5cGUudG9rZW5pemVyID0gZnVuY3Rpb24gKF8sIHBhcmFtcywgb3B0aW9ucywgY2FsbGJhY2spIHtcXG4gICAgdmFyIHNlcGFyYXRvcnMgPSBvcHRpb25zLmdldCgndG9rZW5TZXBhcmF0b3JzJykgfHwgW107XFxuICAgIHZhciB0ZXJtID0gcGFyYW1zLnRlcm07XFxuICAgIHZhciBpID0gMDtcXG5cXG4gICAgdmFyIGNyZWF0ZVRhZyA9IHRoaXMuY3JlYXRlVGFnIHx8IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgaWQ6IHBhcmFtcy50ZXJtLFxcbiAgICAgICAgdGV4dDogcGFyYW1zLnRlcm1cXG4gICAgICB9O1xcbiAgICB9O1xcblxcbiAgICB3aGlsZSAoaSA8IHRlcm0ubGVuZ3RoKSB7XFxuICAgICAgdmFyIHRlcm1DaGFyID0gdGVybVtpXTtcXG5cXG4gICAgICBpZiAoJC5pbkFycmF5KHRlcm1DaGFyLCBzZXBhcmF0b3JzKSA9PT0gLTEpIHtcXG4gICAgICAgIGkrKztcXG5cXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgcGFydCA9IHRlcm0uc3Vic3RyKDAsIGkpO1xcbiAgICAgIHZhciBwYXJ0UGFyYW1zID0gJC5leHRlbmQoe30sIHBhcmFtcywge1xcbiAgICAgICAgdGVybTogcGFydFxcbiAgICAgIH0pO1xcblxcbiAgICAgIHZhciBkYXRhID0gY3JlYXRlVGFnKHBhcnRQYXJhbXMpO1xcblxcbiAgICAgIGlmIChkYXRhID09IG51bGwpIHtcXG4gICAgICAgIGkrKztcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBjYWxsYmFjayhkYXRhKTtcXG5cXG4gICAgICAvLyBSZXNldCB0aGUgdGVybSB0byBub3QgaW5jbHVkZSB0aGUgdG9rZW5pemVkIHBvcnRpb25cXG4gICAgICB0ZXJtID0gdGVybS5zdWJzdHIoaSArIDEpIHx8ICcnO1xcbiAgICAgIGkgPSAwO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgdGVybTogdGVybVxcbiAgICB9O1xcbiAgfTtcXG5cXG4gIHJldHVybiBUb2tlbml6ZXI7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvbWluaW11bUlucHV0TGVuZ3RoJyxbXFxuXFxuXSwgZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gTWluaW11bUlucHV0TGVuZ3RoIChkZWNvcmF0ZWQsICRlLCBvcHRpb25zKSB7XFxuICAgIHRoaXMubWluaW11bUlucHV0TGVuZ3RoID0gb3B0aW9ucy5nZXQoJ21pbmltdW1JbnB1dExlbmd0aCcpO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZSwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBNaW5pbXVtSW5wdXRMZW5ndGgucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zLCBjYWxsYmFjaykge1xcbiAgICBwYXJhbXMudGVybSA9IHBhcmFtcy50ZXJtIHx8ICcnO1xcblxcbiAgICBpZiAocGFyYW1zLnRlcm0ubGVuZ3RoIDwgdGhpcy5taW5pbXVtSW5wdXRMZW5ndGgpIHtcXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Jlc3VsdHM6bWVzc2FnZScsIHtcXG4gICAgICAgIG1lc3NhZ2U6ICdpbnB1dFRvb1Nob3J0JyxcXG4gICAgICAgIGFyZ3M6IHtcXG4gICAgICAgICAgbWluaW11bTogdGhpcy5taW5pbXVtSW5wdXRMZW5ndGgsXFxuICAgICAgICAgIGlucHV0OiBwYXJhbXMudGVybSxcXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXNcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XFxuICB9O1xcblxcbiAgcmV0dXJuIE1pbmltdW1JbnB1dExlbmd0aDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9tYXhpbXVtSW5wdXRMZW5ndGgnLFtcXG5cXG5dLCBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBNYXhpbXVtSW5wdXRMZW5ndGggKGRlY29yYXRlZCwgJGUsIG9wdGlvbnMpIHtcXG4gICAgdGhpcy5tYXhpbXVtSW5wdXRMZW5ndGggPSBvcHRpb25zLmdldCgnbWF4aW11bUlucHV0TGVuZ3RoJyk7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlLCBvcHRpb25zKTtcXG4gIH1cXG5cXG4gIE1heGltdW1JbnB1dExlbmd0aC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XFxuICAgIHBhcmFtcy50ZXJtID0gcGFyYW1zLnRlcm0gfHwgJyc7XFxuXFxuICAgIGlmICh0aGlzLm1heGltdW1JbnB1dExlbmd0aCA+IDAgJiZcXG4gICAgICAgIHBhcmFtcy50ZXJtLmxlbmd0aCA+IHRoaXMubWF4aW11bUlucHV0TGVuZ3RoKSB7XFxuICAgICAgdGhpcy50cmlnZ2VyKCdyZXN1bHRzOm1lc3NhZ2UnLCB7XFxuICAgICAgICBtZXNzYWdlOiAnaW5wdXRUb29Mb25nJyxcXG4gICAgICAgIGFyZ3M6IHtcXG4gICAgICAgICAgbWF4aW11bTogdGhpcy5tYXhpbXVtSW5wdXRMZW5ndGgsXFxuICAgICAgICAgIGlucHV0OiBwYXJhbXMudGVybSxcXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXNcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XFxuICB9O1xcblxcbiAgcmV0dXJuIE1heGltdW1JbnB1dExlbmd0aDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoJyxbXFxuXFxuXSwgZnVuY3Rpb24gKCl7XFxuICBmdW5jdGlvbiBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoIChkZWNvcmF0ZWQsICRlLCBvcHRpb25zKSB7XFxuICAgIHRoaXMubWF4aW11bVNlbGVjdGlvbkxlbmd0aCA9IG9wdGlvbnMuZ2V0KCdtYXhpbXVtU2VsZWN0aW9uTGVuZ3RoJyk7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlLCBvcHRpb25zKTtcXG4gIH1cXG5cXG4gIE1heGltdW1TZWxlY3Rpb25MZW5ndGgucHJvdG90eXBlLmJpbmQgPVxcbiAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgICBjb250YWluZXIub24oJ3NlbGVjdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNlbGYuX2NoZWNrSWZNYXhpbXVtU2VsZWN0ZWQoKTtcXG4gICAgICB9KTtcXG4gIH07XFxuXFxuICBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoLnByb3RvdHlwZS5xdWVyeSA9XFxuICAgIGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5fY2hlY2tJZk1heGltdW1TZWxlY3RlZChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBkZWNvcmF0ZWQuY2FsbChzZWxmLCBwYXJhbXMsIGNhbGxiYWNrKTtcXG4gICAgICB9KTtcXG4gIH07XFxuXFxuICBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoLnByb3RvdHlwZS5fY2hlY2tJZk1heGltdW1TZWxlY3RlZCA9XFxuICAgIGZ1bmN0aW9uIChfLCBzdWNjZXNzQ2FsbGJhY2spIHtcXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgICAgdGhpcy5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xcbiAgICAgICAgdmFyIGNvdW50ID0gY3VycmVudERhdGEgIT0gbnVsbCA/IGN1cnJlbnREYXRhLmxlbmd0aCA6IDA7XFxuICAgICAgICBpZiAoc2VsZi5tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoID4gMCAmJlxcbiAgICAgICAgICBjb3VudCA+PSBzZWxmLm1heGltdW1TZWxlY3Rpb25MZW5ndGgpIHtcXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOm1lc3NhZ2UnLCB7XFxuICAgICAgICAgICAgbWVzc2FnZTogJ21heGltdW1TZWxlY3RlZCcsXFxuICAgICAgICAgICAgYXJnczoge1xcbiAgICAgICAgICAgICAgbWF4aW11bTogc2VsZi5tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xcbiAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gIH07XFxuXFxuICByZXR1cm4gTWF4aW11bVNlbGVjdGlvbkxlbmd0aDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24nLFtcXG4gICdqcXVlcnknLFxcbiAgJy4vdXRpbHMnXFxuXSwgZnVuY3Rpb24gKCQsIFV0aWxzKSB7XFxuICBmdW5jdGlvbiBEcm9wZG93biAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgdGhpcy4kZWxlbWVudCA9ICRlbGVtZW50O1xcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcbiAgICBEcm9wZG93bi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG4gIH1cXG5cXG4gIFV0aWxzLkV4dGVuZChEcm9wZG93biwgVXRpbHMuT2JzZXJ2YWJsZSk7XFxuXFxuICBEcm9wZG93bi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJGRyb3Bkb3duID0gJChcXG4gICAgICAnPHNwYW4gY2xhc3M9XFxcInNlbGVjdDItZHJvcGRvd25cXFwiPicgK1xcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLXJlc3VsdHNcXFwiPjwvc3Bhbj4nICtcXG4gICAgICAnPC9zcGFuPidcXG4gICAgKTtcXG5cXG4gICAgJGRyb3Bkb3duLmF0dHIoJ2RpcicsIHRoaXMub3B0aW9ucy5nZXQoJ2RpcicpKTtcXG5cXG4gICAgdGhpcy4kZHJvcGRvd24gPSAkZHJvcGRvd247XFxuXFxuICAgIHJldHVybiAkZHJvcGRvd247XFxuICB9O1xcblxcbiAgRHJvcGRvd24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8vIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXFxuICB9O1xcblxcbiAgRHJvcGRvd24ucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKCRkcm9wZG93biwgJGNvbnRhaW5lcikge1xcbiAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xcbiAgfTtcXG5cXG4gIERyb3Bkb3duLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcbiAgICAvLyBSZW1vdmUgdGhlIGRyb3Bkb3duIGZyb20gdGhlIERPTVxcbiAgICB0aGlzLiRkcm9wZG93bi5yZW1vdmUoKTtcXG4gIH07XFxuXFxuICByZXR1cm4gRHJvcGRvd247XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL3NlYXJjaCcsW1xcbiAgJ2pxdWVyeScsXFxuICAnLi4vdXRpbHMnXFxuXSwgZnVuY3Rpb24gKCQsIFV0aWxzKSB7XFxuICBmdW5jdGlvbiBTZWFyY2ggKCkgeyB9XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcXG4gICAgdmFyICRyZW5kZXJlZCA9IGRlY29yYXRlZC5jYWxsKHRoaXMpO1xcblxcbiAgICB2YXIgJHNlYXJjaCA9ICQoXFxuICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLXNlYXJjaCBzZWxlY3QyLXNlYXJjaC0tZHJvcGRvd25cXFwiPicgK1xcbiAgICAgICAgJzxpbnB1dCBjbGFzcz1cXFwic2VsZWN0Mi1zZWFyY2hfX2ZpZWxkXFxcIiB0eXBlPVxcXCJzZWFyY2hcXFwiIHRhYmluZGV4PVxcXCItMVxcXCInICtcXG4gICAgICAgICcgYXV0b2NvbXBsZXRlPVxcXCJvZmZcXFwiIGF1dG9jb3JyZWN0PVxcXCJvZmZcXFwiIGF1dG9jYXBpdGFsaXplPVxcXCJub25lXFxcIicgK1xcbiAgICAgICAgJyBzcGVsbGNoZWNrPVxcXCJmYWxzZVxcXCIgcm9sZT1cXFwic2VhcmNoYm94XFxcIiBhcmlhLWF1dG9jb21wbGV0ZT1cXFwibGlzdFxcXCIgLz4nICtcXG4gICAgICAnPC9zcGFuPidcXG4gICAgKTtcXG5cXG4gICAgdGhpcy4kc2VhcmNoQ29udGFpbmVyID0gJHNlYXJjaDtcXG4gICAgdGhpcy4kc2VhcmNoID0gJHNlYXJjaC5maW5kKCdpbnB1dCcpO1xcblxcbiAgICAkcmVuZGVyZWQucHJlcGVuZCgkc2VhcmNoKTtcXG5cXG4gICAgcmV0dXJuICRyZW5kZXJlZDtcXG4gIH07XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB2YXIgcmVzdWx0c0lkID0gY29udGFpbmVyLmlkICsgJy1yZXN1bHRzJztcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgdGhpcy4kc2VhcmNoLm9uKCdrZXlkb3duJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYudHJpZ2dlcigna2V5cHJlc3MnLCBldnQpO1xcblxcbiAgICAgIHNlbGYuX2tleVVwUHJldmVudGVkID0gZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xcbiAgICB9KTtcXG5cXG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgYnJvd3NlcnMgd2hpY2ggZG8gbm90IHN1cHBvcnQgdGhlIGBpbnB1dGAgZXZlbnRcXG4gICAgLy8gVGhpcyB3aWxsIHByZXZlbnQgZG91YmxlLXRyaWdnZXJpbmcgb2YgZXZlbnRzIGZvciBicm93c2VycyB3aGljaCBzdXBwb3J0XFxuICAgIC8vIGJvdGggdGhlIGBrZXl1cGAgYW5kIGBpbnB1dGAgZXZlbnRzLlxcbiAgICB0aGlzLiRzZWFyY2gub24oJ2lucHV0JywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIC8vIFVuYmluZCB0aGUgZHVwbGljYXRlZCBga2V5dXBgIGV2ZW50XFxuICAgICAgJCh0aGlzKS5vZmYoJ2tleXVwJyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRzZWFyY2gub24oJ2tleXVwIGlucHV0JywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYuaGFuZGxlU2VhcmNoKGV2dCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kc2VhcmNoLmF0dHIoJ3RhYmluZGV4JywgMCk7XFxuICAgICAgc2VsZi4kc2VhcmNoLmF0dHIoJ2FyaWEtY29udHJvbHMnLCByZXN1bHRzSWQpO1xcblxcbiAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xcblxcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xcbiAgICAgIH0sIDApO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLiRzZWFyY2guYXR0cigndGFiaW5kZXgnLCAtMSk7XFxuICAgICAgc2VsZi4kc2VhcmNoLnJlbW92ZUF0dHIoJ2FyaWEtY29udHJvbHMnKTtcXG4gICAgICBzZWxmLiRzZWFyY2gucmVtb3ZlQXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XFxuXFxuICAgICAgc2VsZi4kc2VhcmNoLnZhbCgnJyk7XFxuICAgICAgc2VsZi4kc2VhcmNoLnRyaWdnZXIoJ2JsdXInKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignZm9jdXMnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKCFjb250YWluZXIuaXNPcGVuKCkpIHtcXG4gICAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czphbGwnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgaWYgKHBhcmFtcy5xdWVyeS50ZXJtID09IG51bGwgfHwgcGFyYW1zLnF1ZXJ5LnRlcm0gPT09ICcnKSB7XFxuICAgICAgICB2YXIgc2hvd1NlYXJjaCA9IHNlbGYuc2hvd1NlYXJjaChwYXJhbXMpO1xcblxcbiAgICAgICAgaWYgKHNob3dTZWFyY2gpIHtcXG4gICAgICAgICAgc2VsZi4kc2VhcmNoQ29udGFpbmVyLnJlbW92ZUNsYXNzKCdzZWxlY3QyLXNlYXJjaC0taGlkZScpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2VsZi4kc2VhcmNoQ29udGFpbmVyLmFkZENsYXNzKCdzZWxlY3QyLXNlYXJjaC0taGlkZScpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpmb2N1cycsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBpZiAocGFyYW1zLmRhdGEuX3Jlc3VsdElkKSB7XFxuICAgICAgICBzZWxmLiRzZWFyY2guYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgcGFyYW1zLmRhdGEuX3Jlc3VsdElkKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2VsZi4kc2VhcmNoLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcblxcbiAgU2VhcmNoLnByb3RvdHlwZS5oYW5kbGVTZWFyY2ggPSBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgIGlmICghdGhpcy5fa2V5VXBQcmV2ZW50ZWQpIHtcXG4gICAgICB2YXIgaW5wdXQgPSB0aGlzLiRzZWFyY2gudmFsKCk7XFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdxdWVyeScsIHtcXG4gICAgICAgIHRlcm06IGlucHV0XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5fa2V5VXBQcmV2ZW50ZWQgPSBmYWxzZTtcXG4gIH07XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLnNob3dTZWFyY2ggPSBmdW5jdGlvbiAoXywgcGFyYW1zKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfTtcXG5cXG4gIHJldHVybiBTZWFyY2g7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL2hpZGVQbGFjZWhvbGRlcicsW1xcblxcbl0sIGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIEhpZGVQbGFjZWhvbGRlciAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpIHtcXG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IHRoaXMubm9ybWFsaXplUGxhY2Vob2xkZXIob3B0aW9ucy5nZXQoJ3BsYWNlaG9sZGVyJykpO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpO1xcbiAgfVxcblxcbiAgSGlkZVBsYWNlaG9sZGVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XFxuICAgIGRhdGEucmVzdWx0cyA9IHRoaXMucmVtb3ZlUGxhY2Vob2xkZXIoZGF0YS5yZXN1bHRzKTtcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgZGF0YSk7XFxuICB9O1xcblxcbiAgSGlkZVBsYWNlaG9sZGVyLnByb3RvdHlwZS5ub3JtYWxpemVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChfLCBwbGFjZWhvbGRlcikge1xcbiAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyID09PSAnc3RyaW5nJykge1xcbiAgICAgIHBsYWNlaG9sZGVyID0ge1xcbiAgICAgICAgaWQ6ICcnLFxcbiAgICAgICAgdGV4dDogcGxhY2Vob2xkZXJcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwbGFjZWhvbGRlcjtcXG4gIH07XFxuXFxuICBIaWRlUGxhY2Vob2xkZXIucHJvdG90eXBlLnJlbW92ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKF8sIGRhdGEpIHtcXG4gICAgdmFyIG1vZGlmaWVkRGF0YSA9IGRhdGEuc2xpY2UoMCk7XFxuXFxuICAgIGZvciAodmFyIGQgPSBkYXRhLmxlbmd0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XFxuICAgICAgdmFyIGl0ZW0gPSBkYXRhW2RdO1xcblxcbiAgICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyLmlkID09PSBpdGVtLmlkKSB7XFxuICAgICAgICBtb2RpZmllZERhdGEuc3BsaWNlKGQsIDEpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gbW9kaWZpZWREYXRhO1xcbiAgfTtcXG5cXG4gIHJldHVybiBIaWRlUGxhY2Vob2xkZXI7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL2luZmluaXRlU2Nyb2xsJyxbXFxuICAnanF1ZXJ5J1xcbl0sIGZ1bmN0aW9uICgkKSB7XFxuICBmdW5jdGlvbiBJbmZpbml0ZVNjcm9sbCAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpIHtcXG4gICAgdGhpcy5sYXN0UGFyYW1zID0ge307XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcik7XFxuXFxuICAgIHRoaXMuJGxvYWRpbmdNb3JlID0gdGhpcy5jcmVhdGVMb2FkaW5nTW9yZSgpO1xcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XFxuICAgIHRoaXMuJGxvYWRpbmdNb3JlLnJlbW92ZSgpO1xcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgZGF0YSk7XFxuXFxuICAgIGlmICh0aGlzLnNob3dMb2FkaW5nTW9yZShkYXRhKSkge1xcbiAgICAgIHRoaXMuJHJlc3VsdHMuYXBwZW5kKHRoaXMuJGxvYWRpbmdNb3JlKTtcXG4gICAgICB0aGlzLmxvYWRNb3JlSWZOZWVkZWQoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdxdWVyeScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLmxhc3RQYXJhbXMgPSBwYXJhbXM7XFxuICAgICAgc2VsZi5sb2FkaW5nID0gdHJ1ZTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncXVlcnk6YXBwZW5kJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHNlbGYubGFzdFBhcmFtcyA9IHBhcmFtcztcXG4gICAgICBzZWxmLmxvYWRpbmcgPSB0cnVlO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kcmVzdWx0cy5vbignc2Nyb2xsJywgdGhpcy5sb2FkTW9yZUlmTmVlZGVkLmJpbmQodGhpcykpO1xcbiAgfTtcXG5cXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5sb2FkTW9yZUlmTmVlZGVkID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgaXNMb2FkTW9yZVZpc2libGUgPSAkLmNvbnRhaW5zKFxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcXG4gICAgICB0aGlzLiRsb2FkaW5nTW9yZVswXVxcbiAgICApO1xcblxcbiAgICBpZiAodGhpcy5sb2FkaW5nIHx8ICFpc0xvYWRNb3JlVmlzaWJsZSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgY3VycmVudE9mZnNldCA9IHRoaXMuJHJlc3VsdHMub2Zmc2V0KCkudG9wICtcXG4gICAgICB0aGlzLiRyZXN1bHRzLm91dGVySGVpZ2h0KGZhbHNlKTtcXG4gICAgdmFyIGxvYWRpbmdNb3JlT2Zmc2V0ID0gdGhpcy4kbG9hZGluZ01vcmUub2Zmc2V0KCkudG9wICtcXG4gICAgICB0aGlzLiRsb2FkaW5nTW9yZS5vdXRlckhlaWdodChmYWxzZSk7XFxuXFxuICAgIGlmIChjdXJyZW50T2Zmc2V0ICsgNTAgPj0gbG9hZGluZ01vcmVPZmZzZXQpIHtcXG4gICAgICB0aGlzLmxvYWRNb3JlKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUubG9hZE1vcmUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMubG9hZGluZyA9IHRydWU7XFxuXFxuICAgIHZhciBwYXJhbXMgPSAkLmV4dGVuZCh7fSwge3BhZ2U6IDF9LCB0aGlzLmxhc3RQYXJhbXMpO1xcblxcbiAgICBwYXJhbXMucGFnZSsrO1xcblxcbiAgICB0aGlzLnRyaWdnZXIoJ3F1ZXJ5OmFwcGVuZCcsIHBhcmFtcyk7XFxuICB9O1xcblxcbiAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLnNob3dMb2FkaW5nTW9yZSA9IGZ1bmN0aW9uIChfLCBkYXRhKSB7XFxuICAgIHJldHVybiBkYXRhLnBhZ2luYXRpb24gJiYgZGF0YS5wYWdpbmF0aW9uLm1vcmU7XFxuICB9O1xcblxcbiAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmNyZWF0ZUxvYWRpbmdNb3JlID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJG9wdGlvbiA9ICQoXFxuICAgICAgJzxsaSAnICtcXG4gICAgICAnY2xhc3M9XFxcInNlbGVjdDItcmVzdWx0c19fb3B0aW9uIHNlbGVjdDItcmVzdWx0c19fb3B0aW9uLS1sb2FkLW1vcmVcXFwiJyArXFxuICAgICAgJ3JvbGU9XFxcIm9wdGlvblxcXCIgYXJpYS1kaXNhYmxlZD1cXFwidHJ1ZVxcXCI+PC9saT4nXFxuICAgICk7XFxuXFxuICAgIHZhciBtZXNzYWdlID0gdGhpcy5vcHRpb25zLmdldCgndHJhbnNsYXRpb25zJykuZ2V0KCdsb2FkaW5nTW9yZScpO1xcblxcbiAgICAkb3B0aW9uLmh0bWwobWVzc2FnZSh0aGlzLmxhc3RQYXJhbXMpKTtcXG5cXG4gICAgcmV0dXJuICRvcHRpb247XFxuICB9O1xcblxcbiAgcmV0dXJuIEluZmluaXRlU2Nyb2xsO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9hdHRhY2hCb2R5JyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuLi91dGlscydcXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMpIHtcXG4gIGZ1bmN0aW9uIEF0dGFjaEJvZHkgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgdGhpcy4kZHJvcGRvd25QYXJlbnQgPSAkKG9wdGlvbnMuZ2V0KCdkcm9wZG93blBhcmVudCcpIHx8IGRvY3VtZW50LmJvZHkpO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuX3Nob3dEcm9wZG93bigpO1xcbiAgICAgIHNlbGYuX2F0dGFjaFBvc2l0aW9uaW5nSGFuZGxlcihjb250YWluZXIpO1xcblxcbiAgICAgIC8vIE11c3QgYmluZCBhZnRlciB0aGUgcmVzdWx0cyBoYW5kbGVycyB0byBlbnN1cmUgY29ycmVjdCBzaXppbmdcXG4gICAgICBzZWxmLl9iaW5kQ29udGFpbmVyUmVzdWx0SGFuZGxlcnMoY29udGFpbmVyKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi5faGlkZURyb3Bkb3duKCk7XFxuICAgICAgc2VsZi5fZGV0YWNoUG9zaXRpb25pbmdIYW5kbGVyKGNvbnRhaW5lcik7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRkcm9wZG93bkNvbnRhaW5lci5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcyk7XFxuXFxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyLnJlbW92ZSgpO1xcbiAgfTtcXG5cXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLnBvc2l0aW9uID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgJGRyb3Bkb3duLCAkY29udGFpbmVyKSB7XFxuICAgIC8vIENsb25lIGFsbCBvZiB0aGUgY29udGFpbmVyIGNsYXNzZXNcXG4gICAgJGRyb3Bkb3duLmF0dHIoJ2NsYXNzJywgJGNvbnRhaW5lci5hdHRyKCdjbGFzcycpKTtcXG5cXG4gICAgJGRyb3Bkb3duLnJlbW92ZUNsYXNzKCdzZWxlY3QyJyk7XFxuICAgICRkcm9wZG93bi5hZGRDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLW9wZW4nKTtcXG5cXG4gICAgJGRyb3Bkb3duLmNzcyh7XFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXFxuICAgICAgdG9wOiAtOTk5OTk5XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRjb250YWluZXIgPSAkY29udGFpbmVyO1xcbiAgfTtcXG5cXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcXG4gICAgdmFyICRjb250YWluZXIgPSAkKCc8c3Bhbj48L3NwYW4+Jyk7XFxuXFxuICAgIHZhciAkZHJvcGRvd24gPSBkZWNvcmF0ZWQuY2FsbCh0aGlzKTtcXG4gICAgJGNvbnRhaW5lci5hcHBlbmQoJGRyb3Bkb3duKTtcXG5cXG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIgPSAkY29udGFpbmVyO1xcblxcbiAgICByZXR1cm4gJGNvbnRhaW5lcjtcXG4gIH07XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5faGlkZURyb3Bkb3duID0gZnVuY3Rpb24gKGRlY29yYXRlZCkge1xcbiAgICB0aGlzLiRkcm9wZG93bkNvbnRhaW5lci5kZXRhY2goKTtcXG4gIH07XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fYmluZENvbnRhaW5lclJlc3VsdEhhbmRsZXJzID1cXG4gICAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIpIHtcXG5cXG4gICAgLy8gVGhlc2Ugc2hvdWxkIG9ubHkgYmUgYm91bmQgb25jZVxcbiAgICBpZiAodGhpcy5fY29udGFpbmVyUmVzdWx0c0hhbmRsZXJzQm91bmQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6YWxsJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuX3Bvc2l0aW9uRHJvcGRvd24oKTtcXG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmFwcGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XFxuICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czptZXNzYWdlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuX3Bvc2l0aW9uRHJvcGRvd24oKTtcXG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi5fcG9zaXRpb25Ecm9wZG93bigpO1xcbiAgICAgIHNlbGYuX3Jlc2l6ZURyb3Bkb3duKCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Vuc2VsZWN0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuX3Bvc2l0aW9uRHJvcGRvd24oKTtcXG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5fY29udGFpbmVyUmVzdWx0c0hhbmRsZXJzQm91bmQgPSB0cnVlO1xcbiAgfTtcXG5cXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9hdHRhY2hQb3NpdGlvbmluZ0hhbmRsZXIgPVxcbiAgICAgIGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHZhciBzY3JvbGxFdmVudCA9ICdzY3JvbGwuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xcbiAgICB2YXIgcmVzaXplRXZlbnQgPSAncmVzaXplLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcXG4gICAgdmFyIG9yaWVudGF0aW9uRXZlbnQgPSAnb3JpZW50YXRpb25jaGFuZ2Uuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xcblxcbiAgICB2YXIgJHdhdGNoZXJzID0gdGhpcy4kY29udGFpbmVyLnBhcmVudHMoKS5maWx0ZXIoVXRpbHMuaGFzU2Nyb2xsKTtcXG4gICAgJHdhdGNoZXJzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIFV0aWxzLlN0b3JlRGF0YSh0aGlzLCAnc2VsZWN0Mi1zY3JvbGwtcG9zaXRpb24nLCB7XFxuICAgICAgICB4OiAkKHRoaXMpLnNjcm9sbExlZnQoKSxcXG4gICAgICAgIHk6ICQodGhpcykuc2Nyb2xsVG9wKClcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgICR3YXRjaGVycy5vbihzY3JvbGxFdmVudCwgZnVuY3Rpb24gKGV2KSB7XFxuICAgICAgdmFyIHBvc2l0aW9uID0gVXRpbHMuR2V0RGF0YSh0aGlzLCAnc2VsZWN0Mi1zY3JvbGwtcG9zaXRpb24nKTtcXG4gICAgICAkKHRoaXMpLnNjcm9sbFRvcChwb3NpdGlvbi55KTtcXG4gICAgfSk7XFxuXFxuICAgICQod2luZG93KS5vbihzY3JvbGxFdmVudCArICcgJyArIHJlc2l6ZUV2ZW50ICsgJyAnICsgb3JpZW50YXRpb25FdmVudCxcXG4gICAgICBmdW5jdGlvbiAoZSkge1xcbiAgICAgIHNlbGYuX3Bvc2l0aW9uRHJvcGRvd24oKTtcXG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fZGV0YWNoUG9zaXRpb25pbmdIYW5kbGVyID1cXG4gICAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIpIHtcXG4gICAgdmFyIHNjcm9sbEV2ZW50ID0gJ3Njcm9sbC5zZWxlY3QyLicgKyBjb250YWluZXIuaWQ7XFxuICAgIHZhciByZXNpemVFdmVudCA9ICdyZXNpemUuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xcbiAgICB2YXIgb3JpZW50YXRpb25FdmVudCA9ICdvcmllbnRhdGlvbmNoYW5nZS5zZWxlY3QyLicgKyBjb250YWluZXIuaWQ7XFxuXFxuICAgIHZhciAkd2F0Y2hlcnMgPSB0aGlzLiRjb250YWluZXIucGFyZW50cygpLmZpbHRlcihVdGlscy5oYXNTY3JvbGwpO1xcbiAgICAkd2F0Y2hlcnMub2ZmKHNjcm9sbEV2ZW50KTtcXG5cXG4gICAgJCh3aW5kb3cpLm9mZihzY3JvbGxFdmVudCArICcgJyArIHJlc2l6ZUV2ZW50ICsgJyAnICsgb3JpZW50YXRpb25FdmVudCk7XFxuICB9O1xcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX3Bvc2l0aW9uRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciAkd2luZG93ID0gJCh3aW5kb3cpO1xcblxcbiAgICB2YXIgaXNDdXJyZW50bHlBYm92ZSA9IHRoaXMuJGRyb3Bkb3duLmhhc0NsYXNzKCdzZWxlY3QyLWRyb3Bkb3duLS1hYm92ZScpO1xcbiAgICB2YXIgaXNDdXJyZW50bHlCZWxvdyA9IHRoaXMuJGRyb3Bkb3duLmhhc0NsYXNzKCdzZWxlY3QyLWRyb3Bkb3duLS1iZWxvdycpO1xcblxcbiAgICB2YXIgbmV3RGlyZWN0aW9uID0gbnVsbDtcXG5cXG4gICAgdmFyIG9mZnNldCA9IHRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKTtcXG5cXG4gICAgb2Zmc2V0LmJvdHRvbSA9IG9mZnNldC50b3AgKyB0aGlzLiRjb250YWluZXIub3V0ZXJIZWlnaHQoZmFsc2UpO1xcblxcbiAgICB2YXIgY29udGFpbmVyID0ge1xcbiAgICAgIGhlaWdodDogdGhpcy4kY29udGFpbmVyLm91dGVySGVpZ2h0KGZhbHNlKVxcbiAgICB9O1xcblxcbiAgICBjb250YWluZXIudG9wID0gb2Zmc2V0LnRvcDtcXG4gICAgY29udGFpbmVyLmJvdHRvbSA9IG9mZnNldC50b3AgKyBjb250YWluZXIuaGVpZ2h0O1xcblxcbiAgICB2YXIgZHJvcGRvd24gPSB7XFxuICAgICAgaGVpZ2h0OiB0aGlzLiRkcm9wZG93bi5vdXRlckhlaWdodChmYWxzZSlcXG4gICAgfTtcXG5cXG4gICAgdmFyIHZpZXdwb3J0ID0ge1xcbiAgICAgIHRvcDogJHdpbmRvdy5zY3JvbGxUb3AoKSxcXG4gICAgICBib3R0b206ICR3aW5kb3cuc2Nyb2xsVG9wKCkgKyAkd2luZG93LmhlaWdodCgpXFxuICAgIH07XFxuXFxuICAgIHZhciBlbm91Z2hSb29tQWJvdmUgPSB2aWV3cG9ydC50b3AgPCAob2Zmc2V0LnRvcCAtIGRyb3Bkb3duLmhlaWdodCk7XFxuICAgIHZhciBlbm91Z2hSb29tQmVsb3cgPSB2aWV3cG9ydC5ib3R0b20gPiAob2Zmc2V0LmJvdHRvbSArIGRyb3Bkb3duLmhlaWdodCk7XFxuXFxuICAgIHZhciBjc3MgPSB7XFxuICAgICAgbGVmdDogb2Zmc2V0LmxlZnQsXFxuICAgICAgdG9wOiBjb250YWluZXIuYm90dG9tXFxuICAgIH07XFxuXFxuICAgIC8vIERldGVybWluZSB3aGF0IHRoZSBwYXJlbnQgZWxlbWVudCBpcyB0byB1c2UgZm9yIGNhbGN1bGF0aW5nIHRoZSBvZmZzZXRcXG4gICAgdmFyICRvZmZzZXRQYXJlbnQgPSB0aGlzLiRkcm9wZG93blBhcmVudDtcXG5cXG4gICAgLy8gRm9yIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50cywgd2UgbmVlZCB0byBnZXQgdGhlIGVsZW1lbnRcXG4gICAgLy8gdGhhdCBpcyBkZXRlcm1pbmluZyB0aGUgb2Zmc2V0XFxuICAgIGlmICgkb2Zmc2V0UGFyZW50LmNzcygncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcXG4gICAgICAkb2Zmc2V0UGFyZW50ID0gJG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQoKTtcXG4gICAgfVxcblxcbiAgICB2YXIgcGFyZW50T2Zmc2V0ID0ge1xcbiAgICAgIHRvcDogMCxcXG4gICAgICBsZWZ0OiAwXFxuICAgIH07XFxuXFxuICAgIGlmIChcXG4gICAgICAkLmNvbnRhaW5zKGRvY3VtZW50LmJvZHksICRvZmZzZXRQYXJlbnRbMF0pIHx8XFxuICAgICAgJG9mZnNldFBhcmVudFswXS5pc0Nvbm5lY3RlZFxcbiAgICAgICkge1xcbiAgICAgIHBhcmVudE9mZnNldCA9ICRvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XFxuICAgIH1cXG5cXG4gICAgY3NzLnRvcCAtPSBwYXJlbnRPZmZzZXQudG9wO1xcbiAgICBjc3MubGVmdCAtPSBwYXJlbnRPZmZzZXQubGVmdDtcXG5cXG4gICAgaWYgKCFpc0N1cnJlbnRseUFib3ZlICYmICFpc0N1cnJlbnRseUJlbG93KSB7XFxuICAgICAgbmV3RGlyZWN0aW9uID0gJ2JlbG93JztcXG4gICAgfVxcblxcbiAgICBpZiAoIWVub3VnaFJvb21CZWxvdyAmJiBlbm91Z2hSb29tQWJvdmUgJiYgIWlzQ3VycmVudGx5QWJvdmUpIHtcXG4gICAgICBuZXdEaXJlY3Rpb24gPSAnYWJvdmUnO1xcbiAgICB9IGVsc2UgaWYgKCFlbm91Z2hSb29tQWJvdmUgJiYgZW5vdWdoUm9vbUJlbG93ICYmIGlzQ3VycmVudGx5QWJvdmUpIHtcXG4gICAgICBuZXdEaXJlY3Rpb24gPSAnYmVsb3cnO1xcbiAgICB9XFxuXFxuICAgIGlmIChuZXdEaXJlY3Rpb24gPT0gJ2Fib3ZlJyB8fFxcbiAgICAgIChpc0N1cnJlbnRseUFib3ZlICYmIG5ld0RpcmVjdGlvbiAhPT0gJ2JlbG93JykpIHtcXG4gICAgICBjc3MudG9wID0gY29udGFpbmVyLnRvcCAtIHBhcmVudE9mZnNldC50b3AgLSBkcm9wZG93bi5oZWlnaHQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKG5ld0RpcmVjdGlvbiAhPSBudWxsKSB7XFxuICAgICAgdGhpcy4kZHJvcGRvd25cXG4gICAgICAgIC5yZW1vdmVDbGFzcygnc2VsZWN0Mi1kcm9wZG93bi0tYmVsb3cgc2VsZWN0Mi1kcm9wZG93bi0tYWJvdmUnKVxcbiAgICAgICAgLmFkZENsYXNzKCdzZWxlY3QyLWRyb3Bkb3duLS0nICsgbmV3RGlyZWN0aW9uKTtcXG4gICAgICB0aGlzLiRjb250YWluZXJcXG4gICAgICAgIC5yZW1vdmVDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWJlbG93IHNlbGVjdDItY29udGFpbmVyLS1hYm92ZScpXFxuICAgICAgICAuYWRkQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS0nICsgbmV3RGlyZWN0aW9uKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLiRkcm9wZG93bkNvbnRhaW5lci5jc3MoY3NzKTtcXG4gIH07XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fcmVzaXplRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBjc3MgPSB7XFxuICAgICAgd2lkdGg6IHRoaXMuJGNvbnRhaW5lci5vdXRlcldpZHRoKGZhbHNlKSArICdweCdcXG4gICAgfTtcXG5cXG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ2Ryb3Bkb3duQXV0b1dpZHRoJykpIHtcXG4gICAgICBjc3MubWluV2lkdGggPSBjc3Mud2lkdGg7XFxuICAgICAgY3NzLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcXG4gICAgICBjc3Mud2lkdGggPSAnYXV0byc7XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kZHJvcGRvd24uY3NzKGNzcyk7XFxuICB9O1xcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX3Nob3dEcm9wZG93biA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcXG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIuYXBwZW5kVG8odGhpcy4kZHJvcGRvd25QYXJlbnQpO1xcblxcbiAgICB0aGlzLl9wb3NpdGlvbkRyb3Bkb3duKCk7XFxuICAgIHRoaXMuX3Jlc2l6ZURyb3Bkb3duKCk7XFxuICB9O1xcblxcbiAgcmV0dXJuIEF0dGFjaEJvZHk7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL21pbmltdW1SZXN1bHRzRm9yU2VhcmNoJyxbXFxuXFxuXSwgZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gY291bnRSZXN1bHRzIChkYXRhKSB7XFxuICAgIHZhciBjb3VudCA9IDA7XFxuXFxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xcbiAgICAgIHZhciBpdGVtID0gZGF0YVtkXTtcXG5cXG4gICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xcbiAgICAgICAgY291bnQgKz0gY291bnRSZXN1bHRzKGl0ZW0uY2hpbGRyZW4pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBjb3VudCsrO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gY291bnQ7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaCAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpIHtcXG4gICAgdGhpcy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA9IG9wdGlvbnMuZ2V0KCdtaW5pbXVtUmVzdWx0c0ZvclNlYXJjaCcpO1xcblxcbiAgICBpZiAodGhpcy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA8IDApIHtcXG4gICAgICB0aGlzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoID0gSW5maW5pdHk7XFxuICAgIH1cXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKTtcXG4gIH1cXG5cXG4gIE1pbmltdW1SZXN1bHRzRm9yU2VhcmNoLnByb3RvdHlwZS5zaG93U2VhcmNoID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zKSB7XFxuICAgIGlmIChjb3VudFJlc3VsdHMocGFyYW1zLmRhdGEucmVzdWx0cykgPCB0aGlzLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vc2VsZWN0T25DbG9zZScsW1xcbiAgJy4uL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uIChVdGlscykge1xcbiAgZnVuY3Rpb24gU2VsZWN0T25DbG9zZSAoKSB7IH1cXG5cXG4gIFNlbGVjdE9uQ2xvc2UucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIsICRjb250YWluZXIpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xcblxcbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHNlbGYuX2hhbmRsZVNlbGVjdE9uQ2xvc2UocGFyYW1zKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgU2VsZWN0T25DbG9zZS5wcm90b3R5cGUuX2hhbmRsZVNlbGVjdE9uQ2xvc2UgPSBmdW5jdGlvbiAoXywgcGFyYW1zKSB7XFxuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zLm9yaWdpbmFsU2VsZWN0MkV2ZW50ICE9IG51bGwpIHtcXG4gICAgICB2YXIgZXZlbnQgPSBwYXJhbXMub3JpZ2luYWxTZWxlY3QyRXZlbnQ7XFxuXFxuICAgICAgLy8gRG9uJ3Qgc2VsZWN0IGFuIGl0ZW0gaWYgdGhlIGNsb3NlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgZnJvbSBhIHNlbGVjdCBvclxcbiAgICAgIC8vIHVuc2VsZWN0IGV2ZW50XFxuICAgICAgaWYgKGV2ZW50Ll90eXBlID09PSAnc2VsZWN0JyB8fCBldmVudC5fdHlwZSA9PT0gJ3Vuc2VsZWN0Jykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB2YXIgJGhpZ2hsaWdodGVkUmVzdWx0cyA9IHRoaXMuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XFxuXFxuICAgIC8vIE9ubHkgc2VsZWN0IGhpZ2hsaWdodGVkIHJlc3VsdHNcXG4gICAgaWYgKCRoaWdobGlnaHRlZFJlc3VsdHMubGVuZ3RoIDwgMSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgZGF0YSA9IFV0aWxzLkdldERhdGEoJGhpZ2hsaWdodGVkUmVzdWx0c1swXSwgJ2RhdGEnKTtcXG5cXG4gICAgLy8gRG9uJ3QgcmUtc2VsZWN0IGFscmVhZHkgc2VsZWN0ZWQgcmVzdWx0ZVxcbiAgICBpZiAoXFxuICAgICAgKGRhdGEuZWxlbWVudCAhPSBudWxsICYmIGRhdGEuZWxlbWVudC5zZWxlY3RlZCkgfHxcXG4gICAgICAoZGF0YS5lbGVtZW50ID09IG51bGwgJiYgZGF0YS5zZWxlY3RlZClcXG4gICAgKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudHJpZ2dlcignc2VsZWN0Jywge1xcbiAgICAgICAgZGF0YTogZGF0YVxcbiAgICB9KTtcXG4gIH07XFxuXFxuICByZXR1cm4gU2VsZWN0T25DbG9zZTtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vY2xvc2VPblNlbGVjdCcsW1xcblxcbl0sIGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIENsb3NlT25TZWxlY3QgKCkgeyB9XFxuXFxuICBDbG9zZU9uU2VsZWN0LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgc2VsZi5fc2VsZWN0VHJpZ2dlcmVkKGV2dCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Vuc2VsZWN0JywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYuX3NlbGVjdFRyaWdnZXJlZChldnQpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBDbG9zZU9uU2VsZWN0LnByb3RvdHlwZS5fc2VsZWN0VHJpZ2dlcmVkID0gZnVuY3Rpb24gKF8sIGV2dCkge1xcbiAgICB2YXIgb3JpZ2luYWxFdmVudCA9IGV2dC5vcmlnaW5hbEV2ZW50O1xcblxcbiAgICAvLyBEb24ndCBjbG9zZSBpZiB0aGUgY29udHJvbCBrZXkgaXMgYmVpbmcgaGVsZFxcbiAgICBpZiAob3JpZ2luYWxFdmVudCAmJiAob3JpZ2luYWxFdmVudC5jdHJsS2V5IHx8IG9yaWdpbmFsRXZlbnQubWV0YUtleSkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy50cmlnZ2VyKCdjbG9zZScsIHtcXG4gICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxcbiAgICAgIG9yaWdpbmFsU2VsZWN0MkV2ZW50OiBldnRcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIENsb3NlT25TZWxlY3Q7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2kxOG4vZW4nLFtdLGZ1bmN0aW9uICgpIHtcXG4gIC8vIEVuZ2xpc2hcXG4gIHJldHVybiB7XFxuICAgIGVycm9yTG9hZGluZzogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiAnVGhlIHJlc3VsdHMgY291bGQgbm90IGJlIGxvYWRlZC4nO1xcbiAgICB9LFxcbiAgICBpbnB1dFRvb0xvbmc6IGZ1bmN0aW9uIChhcmdzKSB7XFxuICAgICAgdmFyIG92ZXJDaGFycyA9IGFyZ3MuaW5wdXQubGVuZ3RoIC0gYXJncy5tYXhpbXVtO1xcblxcbiAgICAgIHZhciBtZXNzYWdlID0gJ1BsZWFzZSBkZWxldGUgJyArIG92ZXJDaGFycyArICcgY2hhcmFjdGVyJztcXG5cXG4gICAgICBpZiAob3ZlckNoYXJzICE9IDEpIHtcXG4gICAgICAgIG1lc3NhZ2UgKz0gJ3MnO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbWVzc2FnZTtcXG4gICAgfSxcXG4gICAgaW5wdXRUb29TaG9ydDogZnVuY3Rpb24gKGFyZ3MpIHtcXG4gICAgICB2YXIgcmVtYWluaW5nQ2hhcnMgPSBhcmdzLm1pbmltdW0gLSBhcmdzLmlucHV0Lmxlbmd0aDtcXG5cXG4gICAgICB2YXIgbWVzc2FnZSA9ICdQbGVhc2UgZW50ZXIgJyArIHJlbWFpbmluZ0NoYXJzICsgJyBvciBtb3JlIGNoYXJhY3RlcnMnO1xcblxcbiAgICAgIHJldHVybiBtZXNzYWdlO1xcbiAgICB9LFxcbiAgICBsb2FkaW5nTW9yZTogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiAnTG9hZGluZyBtb3JlIHJlc3VsdHPigKYnO1xcbiAgICB9LFxcbiAgICBtYXhpbXVtU2VsZWN0ZWQ6IGZ1bmN0aW9uIChhcmdzKSB7XFxuICAgICAgdmFyIG1lc3NhZ2UgPSAnWW91IGNhbiBvbmx5IHNlbGVjdCAnICsgYXJncy5tYXhpbXVtICsgJyBpdGVtJztcXG5cXG4gICAgICBpZiAoYXJncy5tYXhpbXVtICE9IDEpIHtcXG4gICAgICAgIG1lc3NhZ2UgKz0gJ3MnO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbWVzc2FnZTtcXG4gICAgfSxcXG4gICAgbm9SZXN1bHRzOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuICdObyByZXN1bHRzIGZvdW5kJztcXG4gICAgfSxcXG4gICAgc2VhcmNoaW5nOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuICdTZWFyY2hpbmfigKYnO1xcbiAgICB9LFxcbiAgICByZW1vdmVBbGxJdGVtczogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiAnUmVtb3ZlIGFsbCBpdGVtcyc7XFxuICAgIH1cXG4gIH07XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RlZmF1bHRzJyxbXFxuICAnanF1ZXJ5JyxcXG4gICdyZXF1aXJlJyxcXG5cXG4gICcuL3Jlc3VsdHMnLFxcblxcbiAgJy4vc2VsZWN0aW9uL3NpbmdsZScsXFxuICAnLi9zZWxlY3Rpb24vbXVsdGlwbGUnLFxcbiAgJy4vc2VsZWN0aW9uL3BsYWNlaG9sZGVyJyxcXG4gICcuL3NlbGVjdGlvbi9hbGxvd0NsZWFyJyxcXG4gICcuL3NlbGVjdGlvbi9zZWFyY2gnLFxcbiAgJy4vc2VsZWN0aW9uL2V2ZW50UmVsYXknLFxcblxcbiAgJy4vdXRpbHMnLFxcbiAgJy4vdHJhbnNsYXRpb24nLFxcbiAgJy4vZGlhY3JpdGljcycsXFxuXFxuICAnLi9kYXRhL3NlbGVjdCcsXFxuICAnLi9kYXRhL2FycmF5JyxcXG4gICcuL2RhdGEvYWpheCcsXFxuICAnLi9kYXRhL3RhZ3MnLFxcbiAgJy4vZGF0YS90b2tlbml6ZXInLFxcbiAgJy4vZGF0YS9taW5pbXVtSW5wdXRMZW5ndGgnLFxcbiAgJy4vZGF0YS9tYXhpbXVtSW5wdXRMZW5ndGgnLFxcbiAgJy4vZGF0YS9tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoJyxcXG5cXG4gICcuL2Ryb3Bkb3duJyxcXG4gICcuL2Ryb3Bkb3duL3NlYXJjaCcsXFxuICAnLi9kcm9wZG93bi9oaWRlUGxhY2Vob2xkZXInLFxcbiAgJy4vZHJvcGRvd24vaW5maW5pdGVTY3JvbGwnLFxcbiAgJy4vZHJvcGRvd24vYXR0YWNoQm9keScsXFxuICAnLi9kcm9wZG93bi9taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCcsXFxuICAnLi9kcm9wZG93bi9zZWxlY3RPbkNsb3NlJyxcXG4gICcuL2Ryb3Bkb3duL2Nsb3NlT25TZWxlY3QnLFxcblxcbiAgJy4vaTE4bi9lbidcXG5dLCBmdW5jdGlvbiAoJCwgcmVxdWlyZSxcXG5cXG4gICAgICAgICAgICAgUmVzdWx0c0xpc3QsXFxuXFxuICAgICAgICAgICAgIFNpbmdsZVNlbGVjdGlvbiwgTXVsdGlwbGVTZWxlY3Rpb24sIFBsYWNlaG9sZGVyLCBBbGxvd0NsZWFyLFxcbiAgICAgICAgICAgICBTZWxlY3Rpb25TZWFyY2gsIEV2ZW50UmVsYXksXFxuXFxuICAgICAgICAgICAgIFV0aWxzLCBUcmFuc2xhdGlvbiwgRElBQ1JJVElDUyxcXG5cXG4gICAgICAgICAgICAgU2VsZWN0RGF0YSwgQXJyYXlEYXRhLCBBamF4RGF0YSwgVGFncywgVG9rZW5pemVyLFxcbiAgICAgICAgICAgICBNaW5pbXVtSW5wdXRMZW5ndGgsIE1heGltdW1JbnB1dExlbmd0aCwgTWF4aW11bVNlbGVjdGlvbkxlbmd0aCxcXG5cXG4gICAgICAgICAgICAgRHJvcGRvd24sIERyb3Bkb3duU2VhcmNoLCBIaWRlUGxhY2Vob2xkZXIsIEluZmluaXRlU2Nyb2xsLFxcbiAgICAgICAgICAgICBBdHRhY2hCb2R5LCBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaCwgU2VsZWN0T25DbG9zZSwgQ2xvc2VPblNlbGVjdCxcXG5cXG4gICAgICAgICAgICAgRW5nbGlzaFRyYW5zbGF0aW9uKSB7XFxuICBmdW5jdGlvbiBEZWZhdWx0cyAoKSB7XFxuICAgIHRoaXMucmVzZXQoKTtcXG4gIH1cXG5cXG4gIERlZmF1bHRzLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XFxuICAgIG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyk7XFxuXFxuICAgIGlmIChvcHRpb25zLmRhdGFBZGFwdGVyID09IG51bGwpIHtcXG4gICAgICBpZiAob3B0aW9ucy5hamF4ICE9IG51bGwpIHtcXG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBBamF4RGF0YTtcXG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZGF0YSAhPSBudWxsKSB7XFxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gQXJyYXlEYXRhO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gU2VsZWN0RGF0YTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMubWluaW11bUlucHV0TGVuZ3RoID4gMCkge1xcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyLFxcbiAgICAgICAgICBNaW5pbXVtSW5wdXRMZW5ndGhcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLm1heGltdW1JbnB1dExlbmd0aCA+IDApIHtcXG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcXG4gICAgICAgICAgTWF4aW11bUlucHV0TGVuZ3RoXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoID4gMCkge1xcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyLFxcbiAgICAgICAgICBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy50YWdzKSB7XFxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUob3B0aW9ucy5kYXRhQWRhcHRlciwgVGFncyk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLnRva2VuU2VwYXJhdG9ycyAhPSBudWxsIHx8IG9wdGlvbnMudG9rZW5pemVyICE9IG51bGwpIHtcXG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcXG4gICAgICAgICAgVG9rZW5pemVyXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5xdWVyeSAhPSBudWxsKSB7XFxuICAgICAgICB2YXIgUXVlcnkgPSByZXF1aXJlKG9wdGlvbnMuYW1kQmFzZSArICdjb21wYXQvcXVlcnknKTtcXG5cXG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcXG4gICAgICAgICAgUXVlcnlcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLmluaXRTZWxlY3Rpb24gIT0gbnVsbCkge1xcbiAgICAgICAgdmFyIEluaXRTZWxlY3Rpb24gPSByZXF1aXJlKG9wdGlvbnMuYW1kQmFzZSArICdjb21wYXQvaW5pdFNlbGVjdGlvbicpO1xcblxcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyLFxcbiAgICAgICAgICBJbml0U2VsZWN0aW9uXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAob3B0aW9ucy5yZXN1bHRzQWRhcHRlciA9PSBudWxsKSB7XFxuICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlciA9IFJlc3VsdHNMaXN0O1xcblxcbiAgICAgIGlmIChvcHRpb25zLmFqYXggIT0gbnVsbCkge1xcbiAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyLFxcbiAgICAgICAgICBJbmZpbml0ZVNjcm9sbFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIgIT0gbnVsbCkge1xcbiAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyLFxcbiAgICAgICAgICBIaWRlUGxhY2Vob2xkZXJcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLnNlbGVjdE9uQ2xvc2UpIHtcXG4gICAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlcixcXG4gICAgICAgICAgU2VsZWN0T25DbG9zZVxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID09IG51bGwpIHtcXG4gICAgICBpZiAob3B0aW9ucy5tdWx0aXBsZSkge1xcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBEcm9wZG93bjtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIFNlYXJjaGFibGVEcm9wZG93biA9IFV0aWxzLkRlY29yYXRlKERyb3Bkb3duLCBEcm9wZG93blNlYXJjaCk7XFxuXFxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9IFNlYXJjaGFibGVEcm9wZG93bjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggIT09IDApIHtcXG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyLFxcbiAgICAgICAgICBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMuY2xvc2VPblNlbGVjdCkge1xcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIsXFxuICAgICAgICAgIENsb3NlT25TZWxlY3RcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChcXG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25Dc3NDbGFzcyAhPSBudWxsIHx8XFxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQ3NzICE9IG51bGwgfHxcXG4gICAgICAgIG9wdGlvbnMuYWRhcHREcm9wZG93bkNzc0NsYXNzICE9IG51bGxcXG4gICAgICApIHtcXG4gICAgICAgIHZhciBEcm9wZG93bkNTUyA9IHJlcXVpcmUob3B0aW9ucy5hbWRCYXNlICsgJ2NvbXBhdC9kcm9wZG93bkNzcycpO1xcblxcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIsXFxuICAgICAgICAgIERyb3Bkb3duQ1NTXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIsXFxuICAgICAgICBBdHRhY2hCb2R5XFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICBpZiAob3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID09IG51bGwpIHtcXG4gICAgICBpZiAob3B0aW9ucy5tdWx0aXBsZSkge1xcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gTXVsdGlwbGVTZWxlY3Rpb247XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IFNpbmdsZVNlbGVjdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gQWRkIHRoZSBwbGFjZWhvbGRlciBtaXhpbiBpZiBhIHBsYWNlaG9sZGVyIHdhcyBzcGVjaWZpZWRcXG4gICAgICBpZiAob3B0aW9ucy5wbGFjZWhvbGRlciAhPSBudWxsKSB7XFxuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyLFxcbiAgICAgICAgICBQbGFjZWhvbGRlclxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMuYWxsb3dDbGVhcikge1xcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlcixcXG4gICAgICAgICAgQWxsb3dDbGVhclxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMubXVsdGlwbGUpIHtcXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXFxuICAgICAgICAgIFNlbGVjdGlvblNlYXJjaFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKFxcbiAgICAgICAgb3B0aW9ucy5jb250YWluZXJDc3NDbGFzcyAhPSBudWxsIHx8XFxuICAgICAgICBvcHRpb25zLmNvbnRhaW5lckNzcyAhPSBudWxsIHx8XFxuICAgICAgICBvcHRpb25zLmFkYXB0Q29udGFpbmVyQ3NzQ2xhc3MgIT0gbnVsbFxcbiAgICAgICkge1xcbiAgICAgICAgdmFyIENvbnRhaW5lckNTUyA9IHJlcXVpcmUob3B0aW9ucy5hbWRCYXNlICsgJ2NvbXBhdC9jb250YWluZXJDc3MnKTtcXG5cXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXFxuICAgICAgICAgIENvbnRhaW5lckNTU1xcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXFxuICAgICAgICBFdmVudFJlbGF5XFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICAvLyBJZiB0aGUgZGVmYXVsdHMgd2VyZSBub3QgcHJldmlvdXNseSBhcHBsaWVkIGZyb20gYW4gZWxlbWVudCwgaXQgaXNcXG4gICAgLy8gcG9zc2libGUgZm9yIHRoZSBsYW5ndWFnZSBvcHRpb24gdG8gaGF2ZSBub3QgYmVlbiByZXNvbHZlZFxcbiAgICBvcHRpb25zLmxhbmd1YWdlID0gdGhpcy5fcmVzb2x2ZUxhbmd1YWdlKG9wdGlvbnMubGFuZ3VhZ2UpO1xcblxcbiAgICAvLyBBbHdheXMgZmFsbCBiYWNrIHRvIEVuZ2xpc2ggc2luY2UgaXQgd2lsbCBhbHdheXMgYmUgY29tcGxldGVcXG4gICAgb3B0aW9ucy5sYW5ndWFnZS5wdXNoKCdlbicpO1xcblxcbiAgICB2YXIgdW5pcXVlTGFuZ3VhZ2VzID0gW107XFxuXFxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgb3B0aW9ucy5sYW5ndWFnZS5sZW5ndGg7IGwrKykge1xcbiAgICAgIHZhciBsYW5ndWFnZSA9IG9wdGlvbnMubGFuZ3VhZ2VbbF07XFxuXFxuICAgICAgaWYgKHVuaXF1ZUxhbmd1YWdlcy5pbmRleE9mKGxhbmd1YWdlKSA9PT0gLTEpIHtcXG4gICAgICAgIHVuaXF1ZUxhbmd1YWdlcy5wdXNoKGxhbmd1YWdlKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IHVuaXF1ZUxhbmd1YWdlcztcXG5cXG4gICAgb3B0aW9ucy50cmFuc2xhdGlvbnMgPSB0aGlzLl9wcm9jZXNzVHJhbnNsYXRpb25zKFxcbiAgICAgIG9wdGlvbnMubGFuZ3VhZ2UsXFxuICAgICAgb3B0aW9ucy5kZWJ1Z1xcbiAgICApO1xcblxcbiAgICByZXR1cm4gb3B0aW9ucztcXG4gIH07XFxuXFxuICBEZWZhdWx0cy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIHN0cmlwRGlhY3JpdGljcyAodGV4dCkge1xcbiAgICAgIC8vIFVzZWQgJ3VuaSByYW5nZSArIG5hbWVkIGZ1bmN0aW9uJyBmcm9tIGh0dHA6Ly9qc3BlcmYuY29tL2RpYWNyaXRpY3MvMThcXG4gICAgICBmdW5jdGlvbiBtYXRjaChhKSB7XFxuICAgICAgICByZXR1cm4gRElBQ1JJVElDU1thXSB8fCBhO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bXlxcXFx1MDAwMC1cXFxcdTAwN0VdL2csIG1hdGNoKTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBtYXRjaGVyIChwYXJhbXMsIGRhdGEpIHtcXG4gICAgICAvLyBBbHdheXMgcmV0dXJuIHRoZSBvYmplY3QgaWYgdGhlcmUgaXMgbm90aGluZyB0byBjb21wYXJlXFxuICAgICAgaWYgKCQudHJpbShwYXJhbXMudGVybSkgPT09ICcnKSB7XFxuICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gRG8gYSByZWN1cnNpdmUgY2hlY2sgZm9yIG9wdGlvbnMgd2l0aCBjaGlsZHJlblxcbiAgICAgIGlmIChkYXRhLmNoaWxkcmVuICYmIGRhdGEuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xcbiAgICAgICAgLy8gQ2xvbmUgdGhlIGRhdGEgb2JqZWN0IGlmIHRoZXJlIGFyZSBjaGlsZHJlblxcbiAgICAgICAgLy8gVGhpcyBpcyByZXF1aXJlZCBhcyB3ZSBtb2RpZnkgdGhlIG9iamVjdCB0byByZW1vdmUgYW55IG5vbi1tYXRjaGVzXFxuICAgICAgICB2YXIgbWF0Y2ggPSAkLmV4dGVuZCh0cnVlLCB7fSwgZGF0YSk7XFxuXFxuICAgICAgICAvLyBDaGVjayBlYWNoIGNoaWxkIG9mIHRoZSBvcHRpb25cXG4gICAgICAgIGZvciAodmFyIGMgPSBkYXRhLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGMgPj0gMDsgYy0tKSB7XFxuICAgICAgICAgIHZhciBjaGlsZCA9IGRhdGEuY2hpbGRyZW5bY107XFxuXFxuICAgICAgICAgIHZhciBtYXRjaGVzID0gbWF0Y2hlcihwYXJhbXMsIGNoaWxkKTtcXG5cXG4gICAgICAgICAgLy8gSWYgdGhlcmUgd2Fzbid0IGEgbWF0Y2gsIHJlbW92ZSB0aGUgb2JqZWN0IGluIHRoZSBhcnJheVxcbiAgICAgICAgICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XFxuICAgICAgICAgICAgbWF0Y2guY2hpbGRyZW4uc3BsaWNlKGMsIDEpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBhbnkgY2hpbGRyZW4gbWF0Y2hlZCwgcmV0dXJuIHRoZSBuZXcgb2JqZWN0XFxuICAgICAgICBpZiAobWF0Y2guY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiB0aGVyZSB3ZXJlIG5vIG1hdGNoaW5nIGNoaWxkcmVuLCBjaGVjayBqdXN0IHRoZSBwbGFpbiBvYmplY3RcXG4gICAgICAgIHJldHVybiBtYXRjaGVyKHBhcmFtcywgbWF0Y2gpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgb3JpZ2luYWwgPSBzdHJpcERpYWNyaXRpY3MoZGF0YS50ZXh0KS50b1VwcGVyQ2FzZSgpO1xcbiAgICAgIHZhciB0ZXJtID0gc3RyaXBEaWFjcml0aWNzKHBhcmFtcy50ZXJtKS50b1VwcGVyQ2FzZSgpO1xcblxcbiAgICAgIC8vIENoZWNrIGlmIHRoZSB0ZXh0IGNvbnRhaW5zIHRoZSB0ZXJtXFxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YodGVybSkgPiAtMSkge1xcbiAgICAgICAgcmV0dXJuIGRhdGE7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIElmIGl0IGRvZXNuJ3QgY29udGFpbiB0aGUgdGVybSwgZG9uJ3QgcmV0dXJuIGFueXRoaW5nXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5kZWZhdWx0cyA9IHtcXG4gICAgICBhbWRCYXNlOiAnLi8nLFxcbiAgICAgIGFtZExhbmd1YWdlQmFzZTogJy4vaTE4bi8nLFxcbiAgICAgIGNsb3NlT25TZWxlY3Q6IHRydWUsXFxuICAgICAgZGVidWc6IGZhbHNlLFxcbiAgICAgIGRyb3Bkb3duQXV0b1dpZHRoOiBmYWxzZSxcXG4gICAgICBlc2NhcGVNYXJrdXA6IFV0aWxzLmVzY2FwZU1hcmt1cCxcXG4gICAgICBsYW5ndWFnZToge30sXFxuICAgICAgbWF0Y2hlcjogbWF0Y2hlcixcXG4gICAgICBtaW5pbXVtSW5wdXRMZW5ndGg6IDAsXFxuICAgICAgbWF4aW11bUlucHV0TGVuZ3RoOiAwLFxcbiAgICAgIG1heGltdW1TZWxlY3Rpb25MZW5ndGg6IDAsXFxuICAgICAgbWluaW11bVJlc3VsdHNGb3JTZWFyY2g6IDAsXFxuICAgICAgc2VsZWN0T25DbG9zZTogZmFsc2UsXFxuICAgICAgc2Nyb2xsQWZ0ZXJTZWxlY3Q6IGZhbHNlLFxcbiAgICAgIHNvcnRlcjogZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgIH0sXFxuICAgICAgdGVtcGxhdGVSZXN1bHQ6IGZ1bmN0aW9uIChyZXN1bHQpIHtcXG4gICAgICAgIHJldHVybiByZXN1bHQudGV4dDtcXG4gICAgICB9LFxcbiAgICAgIHRlbXBsYXRlU2VsZWN0aW9uOiBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm4gc2VsZWN0aW9uLnRleHQ7XFxuICAgICAgfSxcXG4gICAgICB0aGVtZTogJ2RlZmF1bHQnLFxcbiAgICAgIHdpZHRoOiAncmVzb2x2ZSdcXG4gICAgfTtcXG4gIH07XFxuXFxuICBEZWZhdWx0cy5wcm90b3R5cGUuYXBwbHlGcm9tRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRpb25zLCAkZWxlbWVudCkge1xcbiAgICB2YXIgb3B0aW9uTGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlO1xcbiAgICB2YXIgZGVmYXVsdExhbmd1YWdlID0gdGhpcy5kZWZhdWx0cy5sYW5ndWFnZTtcXG4gICAgdmFyIGVsZW1lbnRMYW5ndWFnZSA9ICRlbGVtZW50LnByb3AoJ2xhbmcnKTtcXG4gICAgdmFyIHBhcmVudExhbmd1YWdlID0gJGVsZW1lbnQuY2xvc2VzdCgnW2xhbmddJykucHJvcCgnbGFuZycpO1xcblxcbiAgICB2YXIgbGFuZ3VhZ2VzID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5jYWxsKFxcbiAgICAgIHRoaXMuX3Jlc29sdmVMYW5ndWFnZShlbGVtZW50TGFuZ3VhZ2UpLFxcbiAgICAgIHRoaXMuX3Jlc29sdmVMYW5ndWFnZShvcHRpb25MYW5ndWFnZSksXFxuICAgICAgdGhpcy5fcmVzb2x2ZUxhbmd1YWdlKGRlZmF1bHRMYW5ndWFnZSksXFxuICAgICAgdGhpcy5fcmVzb2x2ZUxhbmd1YWdlKHBhcmVudExhbmd1YWdlKVxcbiAgICApO1xcblxcbiAgICBvcHRpb25zLmxhbmd1YWdlID0gbGFuZ3VhZ2VzO1xcblxcbiAgICByZXR1cm4gb3B0aW9ucztcXG4gIH07XFxuXFxuICBEZWZhdWx0cy5wcm90b3R5cGUuX3Jlc29sdmVMYW5ndWFnZSA9IGZ1bmN0aW9uIChsYW5ndWFnZSkge1xcbiAgICBpZiAoIWxhbmd1YWdlKSB7XFxuICAgICAgcmV0dXJuIFtdO1xcbiAgICB9XFxuXFxuICAgIGlmICgkLmlzRW1wdHlPYmplY3QobGFuZ3VhZ2UpKSB7XFxuICAgICAgcmV0dXJuIFtdO1xcbiAgICB9XFxuXFxuICAgIGlmICgkLmlzUGxhaW5PYmplY3QobGFuZ3VhZ2UpKSB7XFxuICAgICAgcmV0dXJuIFtsYW5ndWFnZV07XFxuICAgIH1cXG5cXG4gICAgdmFyIGxhbmd1YWdlcztcXG5cXG4gICAgaWYgKCEkLmlzQXJyYXkobGFuZ3VhZ2UpKSB7XFxuICAgICAgbGFuZ3VhZ2VzID0gW2xhbmd1YWdlXTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBsYW5ndWFnZXMgPSBsYW5ndWFnZTtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVzb2x2ZWRMYW5ndWFnZXMgPSBbXTtcXG5cXG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsYW5ndWFnZXMubGVuZ3RoOyBsKyspIHtcXG4gICAgICByZXNvbHZlZExhbmd1YWdlcy5wdXNoKGxhbmd1YWdlc1tsXSk7XFxuXFxuICAgICAgaWYgKHR5cGVvZiBsYW5ndWFnZXNbbF0gPT09ICdzdHJpbmcnICYmIGxhbmd1YWdlc1tsXS5pbmRleE9mKCctJykgPiAwKSB7XFxuICAgICAgICAvLyBFeHRyYWN0IHRoZSByZWdpb24gaW5mb3JtYXRpb24gaWYgaXQgaXMgaW5jbHVkZWRcXG4gICAgICAgIHZhciBsYW5ndWFnZVBhcnRzID0gbGFuZ3VhZ2VzW2xdLnNwbGl0KCctJyk7XFxuICAgICAgICB2YXIgYmFzZUxhbmd1YWdlID0gbGFuZ3VhZ2VQYXJ0c1swXTtcXG5cXG4gICAgICAgIHJlc29sdmVkTGFuZ3VhZ2VzLnB1c2goYmFzZUxhbmd1YWdlKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHJlc29sdmVkTGFuZ3VhZ2VzO1xcbiAgfTtcXG5cXG4gIERlZmF1bHRzLnByb3RvdHlwZS5fcHJvY2Vzc1RyYW5zbGF0aW9ucyA9IGZ1bmN0aW9uIChsYW5ndWFnZXMsIGRlYnVnKSB7XFxuICAgIHZhciB0cmFuc2xhdGlvbnMgPSBuZXcgVHJhbnNsYXRpb24oKTtcXG5cXG4gICAgZm9yICh2YXIgbCA9IDA7IGwgPCBsYW5ndWFnZXMubGVuZ3RoOyBsKyspIHtcXG4gICAgICB2YXIgbGFuZ3VhZ2VEYXRhID0gbmV3IFRyYW5zbGF0aW9uKCk7XFxuXFxuICAgICAgdmFyIGxhbmd1YWdlID0gbGFuZ3VhZ2VzW2xdO1xcblxcbiAgICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAvLyBUcnkgdG8gbG9hZCBpdCB3aXRoIHRoZSBvcmlnaW5hbCBuYW1lXFxuICAgICAgICAgIGxhbmd1YWdlRGF0YSA9IFRyYW5zbGF0aW9uLmxvYWRQYXRoKGxhbmd1YWdlKTtcXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBsb2FkIGl0LCBjaGVjayBpZiBpdCB3YXNuJ3QgdGhlIGZ1bGwgcGF0aFxcbiAgICAgICAgICAgIGxhbmd1YWdlID0gdGhpcy5kZWZhdWx0cy5hbWRMYW5ndWFnZUJhc2UgKyBsYW5ndWFnZTtcXG4gICAgICAgICAgICBsYW5ndWFnZURhdGEgPSBUcmFuc2xhdGlvbi5sb2FkUGF0aChsYW5ndWFnZSk7XFxuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XFxuICAgICAgICAgICAgLy8gVGhlIHRyYW5zbGF0aW9uIGNvdWxkIG5vdCBiZSBsb2FkZWQgYXQgYWxsLiBTb21ldGltZXMgdGhpcyBpc1xcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugb2YgYSBjb25maWd1cmF0aW9uIHByb2JsZW0sIG90aGVyIHRpbWVzIHRoaXMgY2FuIGJlXFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBob3cgU2VsZWN0MiBoZWxwcyBsb2FkIGFsbCBwb3NzaWJsZSB0cmFuc2xhdGlvbiBmaWxlc1xcbiAgICAgICAgICAgIGlmIChkZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcXG4gICAgICAgICAgICAgICAgJ1NlbGVjdDI6IFRoZSBsYW5ndWFnZSBmaWxlIGZvciBcXFwiJyArIGxhbmd1YWdlICsgJ1xcXCIgY291bGQgJyArXFxuICAgICAgICAgICAgICAgICdub3QgYmUgYXV0b21hdGljYWxseSBsb2FkZWQuIEEgZmFsbGJhY2sgd2lsbCBiZSB1c2VkIGluc3RlYWQuJ1xcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgaWYgKCQuaXNQbGFpbk9iamVjdChsYW5ndWFnZSkpIHtcXG4gICAgICAgIGxhbmd1YWdlRGF0YSA9IG5ldyBUcmFuc2xhdGlvbihsYW5ndWFnZSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxhbmd1YWdlRGF0YSA9IGxhbmd1YWdlO1xcbiAgICAgIH1cXG5cXG4gICAgICB0cmFuc2xhdGlvbnMuZXh0ZW5kKGxhbmd1YWdlRGF0YSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRyYW5zbGF0aW9ucztcXG4gIH07XFxuXFxuICBEZWZhdWx0cy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgdmFyIGNhbWVsS2V5ID0gJC5jYW1lbENhc2Uoa2V5KTtcXG5cXG4gICAgdmFyIGRhdGEgPSB7fTtcXG4gICAgZGF0YVtjYW1lbEtleV0gPSB2YWx1ZTtcXG5cXG4gICAgdmFyIGNvbnZlcnRlZERhdGEgPSBVdGlscy5fY29udmVydERhdGEoZGF0YSk7XFxuXFxuICAgICQuZXh0ZW5kKHRydWUsIHRoaXMuZGVmYXVsdHMsIGNvbnZlcnRlZERhdGEpO1xcbiAgfTtcXG5cXG4gIHZhciBkZWZhdWx0cyA9IG5ldyBEZWZhdWx0cygpO1xcblxcbiAgcmV0dXJuIGRlZmF1bHRzO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9vcHRpb25zJyxbXFxuICAncmVxdWlyZScsXFxuICAnanF1ZXJ5JyxcXG4gICcuL2RlZmF1bHRzJyxcXG4gICcuL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uIChyZXF1aXJlLCAkLCBEZWZhdWx0cywgVXRpbHMpIHtcXG4gIGZ1bmN0aW9uIE9wdGlvbnMgKG9wdGlvbnMsICRlbGVtZW50KSB7XFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFxuICAgIGlmICgkZWxlbWVudCAhPSBudWxsKSB7XFxuICAgICAgdGhpcy5mcm9tRWxlbWVudCgkZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKCRlbGVtZW50ICE9IG51bGwpIHtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSBEZWZhdWx0cy5hcHBseUZyb21FbGVtZW50KHRoaXMub3B0aW9ucywgJGVsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMub3B0aW9ucyA9IERlZmF1bHRzLmFwcGx5KHRoaXMub3B0aW9ucyk7XFxuXFxuICAgIGlmICgkZWxlbWVudCAmJiAkZWxlbWVudC5pcygnaW5wdXQnKSkge1xcbiAgICAgIHZhciBJbnB1dENvbXBhdCA9IHJlcXVpcmUodGhpcy5nZXQoJ2FtZEJhc2UnKSArICdjb21wYXQvaW5wdXREYXRhJyk7XFxuXFxuICAgICAgdGhpcy5vcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGF0YUFkYXB0ZXIsXFxuICAgICAgICBJbnB1dENvbXBhdFxcbiAgICAgICk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIE9wdGlvbnMucHJvdG90eXBlLmZyb21FbGVtZW50ID0gZnVuY3Rpb24gKCRlKSB7XFxuICAgIHZhciBleGNsdWRlZERhdGEgPSBbJ3NlbGVjdDInXTtcXG5cXG4gICAgaWYgKHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9PSBudWxsKSB7XFxuICAgICAgdGhpcy5vcHRpb25zLm11bHRpcGxlID0gJGUucHJvcCgnbXVsdGlwbGUnKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkID09IG51bGwpIHtcXG4gICAgICB0aGlzLm9wdGlvbnMuZGlzYWJsZWQgPSAkZS5wcm9wKCdkaXNhYmxlZCcpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZGlyID09IG51bGwpIHtcXG4gICAgICBpZiAoJGUucHJvcCgnZGlyJykpIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5kaXIgPSAkZS5wcm9wKCdkaXInKTtcXG4gICAgICB9IGVsc2UgaWYgKCRlLmNsb3Nlc3QoJ1tkaXJdJykucHJvcCgnZGlyJykpIHtcXG4gICAgICAgIHRoaXMub3B0aW9ucy5kaXIgPSAkZS5jbG9zZXN0KCdbZGlyXScpLnByb3AoJ2RpcicpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGlyID0gJ2x0cic7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgICRlLnByb3AoJ2Rpc2FibGVkJywgdGhpcy5vcHRpb25zLmRpc2FibGVkKTtcXG4gICAgJGUucHJvcCgnbXVsdGlwbGUnLCB0aGlzLm9wdGlvbnMubXVsdGlwbGUpO1xcblxcbiAgICBpZiAoVXRpbHMuR2V0RGF0YSgkZVswXSwgJ3NlbGVjdDJUYWdzJykpIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xcbiAgICAgICAgY29uc29sZS53YXJuKFxcbiAgICAgICAgICAnU2VsZWN0MjogVGhlIGBkYXRhLXNlbGVjdDItdGFnc2AgYXR0cmlidXRlIGhhcyBiZWVuIGNoYW5nZWQgdG8gJyArXFxuICAgICAgICAgICd1c2UgdGhlIGBkYXRhLWRhdGFgIGFuZCBgZGF0YS10YWdzPVxcXCJ0cnVlXFxcImAgYXR0cmlidXRlcyBhbmQgd2lsbCBiZSAnICtcXG4gICAgICAgICAgJ3JlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFNlbGVjdDIuJ1xcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgVXRpbHMuU3RvcmVEYXRhKCRlWzBdLCAnZGF0YScsIFV0aWxzLkdldERhdGEoJGVbMF0sICdzZWxlY3QyVGFncycpKTtcXG4gICAgICBVdGlscy5TdG9yZURhdGEoJGVbMF0sICd0YWdzJywgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKFV0aWxzLkdldERhdGEoJGVbMF0sICdhamF4VXJsJykpIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xcbiAgICAgICAgY29uc29sZS53YXJuKFxcbiAgICAgICAgICAnU2VsZWN0MjogVGhlIGBkYXRhLWFqYXgtdXJsYCBhdHRyaWJ1dGUgaGFzIGJlZW4gY2hhbmdlZCB0byAnICtcXG4gICAgICAgICAgJ2BkYXRhLWFqYXgtLXVybGAgYW5kIHN1cHBvcnQgZm9yIHRoZSBvbGQgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCcgK1xcbiAgICAgICAgICAnIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBTZWxlY3QyLidcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgICRlLmF0dHIoJ2FqYXgtLXVybCcsIFV0aWxzLkdldERhdGEoJGVbMF0sICdhamF4VXJsJykpO1xcbiAgICAgIFV0aWxzLlN0b3JlRGF0YSgkZVswXSwgJ2FqYXgtVXJsJywgVXRpbHMuR2V0RGF0YSgkZVswXSwgJ2FqYXhVcmwnKSk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGRhdGFzZXQgPSB7fTtcXG5cXG4gICAgZnVuY3Rpb24gdXBwZXJDYXNlTGV0dGVyKF8sIGxldHRlcikge1xcbiAgICAgIHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcXG4gICAgfVxcblxcbiAgICAvLyBQcmUtbG9hZCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgd2hpY2ggYXJlIHByZWZpeGVkIHdpdGggYGRhdGEtYFxcbiAgICBmb3IgKHZhciBhdHRyID0gMDsgYXR0ciA8ICRlWzBdLmF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyKyspIHtcXG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9ICRlWzBdLmF0dHJpYnV0ZXNbYXR0cl0ubmFtZTtcXG4gICAgICB2YXIgcHJlZml4ID0gJ2RhdGEtJztcXG5cXG4gICAgICBpZiAoYXR0cmlidXRlTmFtZS5zdWJzdHIoMCwgcHJlZml4Lmxlbmd0aCkgPT0gcHJlZml4KSB7XFxuICAgICAgICAvLyBHZXQgdGhlIGNvbnRlbnRzIG9mIHRoZSBhdHRyaWJ1dGUgYWZ0ZXIgYGRhdGEtYFxcbiAgICAgICAgdmFyIGRhdGFOYW1lID0gYXR0cmlidXRlTmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCk7XFxuXFxuICAgICAgICAvLyBHZXQgdGhlIGRhdGEgY29udGVudHMgZnJvbSB0aGUgY29uc2lzdGVudCBzb3VyY2VcXG4gICAgICAgIC8vIFRoaXMgaXMgbW9yZSB0aGFuIGxpa2VseSB0aGUgalF1ZXJ5IGRhdGEgaGVscGVyXFxuICAgICAgICB2YXIgZGF0YVZhbHVlID0gVXRpbHMuR2V0RGF0YSgkZVswXSwgZGF0YU5hbWUpO1xcblxcbiAgICAgICAgLy8gY2FtZWxDYXNlIHRoZSBhdHRyaWJ1dGUgbmFtZSB0byBtYXRjaCB0aGUgc3BlY1xcbiAgICAgICAgdmFyIGNhbWVsRGF0YU5hbWUgPSBkYXRhTmFtZS5yZXBsYWNlKC8tKFthLXpdKS9nLCB1cHBlckNhc2VMZXR0ZXIpO1xcblxcbiAgICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgYXR0cmlidXRlIGNvbnRlbnRzIGludG8gdGhlIGRhdGFzZXQgc2luY2VcXG4gICAgICAgIGRhdGFzZXRbY2FtZWxEYXRhTmFtZV0gPSBkYXRhVmFsdWU7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIC8vIFByZWZlciB0aGUgZWxlbWVudCdzIGBkYXRhc2V0YCBhdHRyaWJ1dGUgaWYgaXQgZXhpc3RzXFxuICAgIC8vIGpRdWVyeSAxLnggZG9lcyBub3QgY29ycmVjdGx5IGhhbmRsZSBkYXRhIGF0dHJpYnV0ZXMgd2l0aCBtdWx0aXBsZSBkYXNoZXNcXG4gICAgaWYgKCQuZm4uanF1ZXJ5ICYmICQuZm4uanF1ZXJ5LnN1YnN0cigwLCAyKSA9PSAnMS4nICYmICRlWzBdLmRhdGFzZXQpIHtcXG4gICAgICBkYXRhc2V0ID0gJC5leHRlbmQodHJ1ZSwge30sICRlWzBdLmRhdGFzZXQsIGRhdGFzZXQpO1xcbiAgICB9XFxuXFxuICAgIC8vIFByZWZlciBvdXIgaW50ZXJuYWwgZGF0YSBjYWNoZSBpZiBpdCBleGlzdHNcXG4gICAgdmFyIGRhdGEgPSAkLmV4dGVuZCh0cnVlLCB7fSwgVXRpbHMuR2V0RGF0YSgkZVswXSksIGRhdGFzZXQpO1xcblxcbiAgICBkYXRhID0gVXRpbHMuX2NvbnZlcnREYXRhKGRhdGEpO1xcblxcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xcbiAgICAgIGlmICgkLmluQXJyYXkoa2V5LCBleGNsdWRlZERhdGEpID4gLTEpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHRoaXMub3B0aW9uc1trZXldKSkge1xcbiAgICAgICAgJC5leHRlbmQodGhpcy5vcHRpb25zW2tleV0sIGRhdGFba2V5XSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMub3B0aW9uc1trZXldID0gZGF0YVtrZXldO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICBPcHRpb25zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcXG4gIH07XFxuXFxuICBPcHRpb25zLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcXG4gICAgdGhpcy5vcHRpb25zW2tleV0gPSB2YWw7XFxuICB9O1xcblxcbiAgcmV0dXJuIE9wdGlvbnM7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2NvcmUnLFtcXG4gICdqcXVlcnknLFxcbiAgJy4vb3B0aW9ucycsXFxuICAnLi91dGlscycsXFxuICAnLi9rZXlzJ1xcbl0sIGZ1bmN0aW9uICgkLCBPcHRpb25zLCBVdGlscywgS0VZUykge1xcbiAgdmFyIFNlbGVjdDIgPSBmdW5jdGlvbiAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgaWYgKFV0aWxzLkdldERhdGEoJGVsZW1lbnRbMF0sICdzZWxlY3QyJykgIT0gbnVsbCkge1xcbiAgICAgIFV0aWxzLkdldERhdGEoJGVsZW1lbnRbMF0sICdzZWxlY3QyJykuZGVzdHJveSgpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcXG5cXG4gICAgdGhpcy5pZCA9IHRoaXMuX2dlbmVyYXRlSWQoJGVsZW1lbnQpO1xcblxcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgdGhpcy5vcHRpb25zID0gbmV3IE9wdGlvbnMob3B0aW9ucywgJGVsZW1lbnQpO1xcblxcbiAgICBTZWxlY3QyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xcblxcbiAgICAvLyBTZXQgdXAgdGhlIHRhYmluZGV4XFxuXFxuICAgIHZhciB0YWJpbmRleCA9ICRlbGVtZW50LmF0dHIoJ3RhYmluZGV4JykgfHwgMDtcXG4gICAgVXRpbHMuU3RvcmVEYXRhKCRlbGVtZW50WzBdLCAnb2xkLXRhYmluZGV4JywgdGFiaW5kZXgpO1xcbiAgICAkZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsICctMScpO1xcblxcbiAgICAvLyBTZXQgdXAgY29udGFpbmVycyBhbmQgYWRhcHRlcnNcXG5cXG4gICAgdmFyIERhdGFBZGFwdGVyID0gdGhpcy5vcHRpb25zLmdldCgnZGF0YUFkYXB0ZXInKTtcXG4gICAgdGhpcy5kYXRhQWRhcHRlciA9IG5ldyBEYXRhQWRhcHRlcigkZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcXG5cXG4gICAgdmFyICRjb250YWluZXIgPSB0aGlzLnJlbmRlcigpO1xcblxcbiAgICB0aGlzLl9wbGFjZUNvbnRhaW5lcigkY29udGFpbmVyKTtcXG5cXG4gICAgdmFyIFNlbGVjdGlvbkFkYXB0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdzZWxlY3Rpb25BZGFwdGVyJyk7XFxuICAgIHRoaXMuc2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbkFkYXB0ZXIoJGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XFxuICAgIHRoaXMuJHNlbGVjdGlvbiA9IHRoaXMuc2VsZWN0aW9uLnJlbmRlcigpO1xcblxcbiAgICB0aGlzLnNlbGVjdGlvbi5wb3NpdGlvbih0aGlzLiRzZWxlY3Rpb24sICRjb250YWluZXIpO1xcblxcbiAgICB2YXIgRHJvcGRvd25BZGFwdGVyID0gdGhpcy5vcHRpb25zLmdldCgnZHJvcGRvd25BZGFwdGVyJyk7XFxuICAgIHRoaXMuZHJvcGRvd24gPSBuZXcgRHJvcGRvd25BZGFwdGVyKCRlbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xcbiAgICB0aGlzLiRkcm9wZG93biA9IHRoaXMuZHJvcGRvd24ucmVuZGVyKCk7XFxuXFxuICAgIHRoaXMuZHJvcGRvd24ucG9zaXRpb24odGhpcy4kZHJvcGRvd24sICRjb250YWluZXIpO1xcblxcbiAgICB2YXIgUmVzdWx0c0FkYXB0ZXIgPSB0aGlzLm9wdGlvbnMuZ2V0KCdyZXN1bHRzQWRhcHRlcicpO1xcbiAgICB0aGlzLnJlc3VsdHMgPSBuZXcgUmVzdWx0c0FkYXB0ZXIoJGVsZW1lbnQsIHRoaXMub3B0aW9ucywgdGhpcy5kYXRhQWRhcHRlcik7XFxuICAgIHRoaXMuJHJlc3VsdHMgPSB0aGlzLnJlc3VsdHMucmVuZGVyKCk7XFxuXFxuICAgIHRoaXMucmVzdWx0cy5wb3NpdGlvbih0aGlzLiRyZXN1bHRzLCB0aGlzLiRkcm9wZG93bik7XFxuXFxuICAgIC8vIEJpbmQgZXZlbnRzXFxuXFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgLy8gQmluZCB0aGUgY29udGFpbmVyIHRvIGFsbCBvZiB0aGUgYWRhcHRlcnNcXG4gICAgdGhpcy5fYmluZEFkYXB0ZXJzKCk7XFxuXFxuICAgIC8vIFJlZ2lzdGVyIGFueSBET00gZXZlbnQgaGFuZGxlcnNcXG4gICAgdGhpcy5fcmVnaXN0ZXJEb21FdmVudHMoKTtcXG5cXG4gICAgLy8gUmVnaXN0ZXIgYW55IGludGVybmFsIGV2ZW50IGhhbmRsZXJzXFxuICAgIHRoaXMuX3JlZ2lzdGVyRGF0YUV2ZW50cygpO1xcbiAgICB0aGlzLl9yZWdpc3RlclNlbGVjdGlvbkV2ZW50cygpO1xcbiAgICB0aGlzLl9yZWdpc3RlckRyb3Bkb3duRXZlbnRzKCk7XFxuICAgIHRoaXMuX3JlZ2lzdGVyUmVzdWx0c0V2ZW50cygpO1xcbiAgICB0aGlzLl9yZWdpc3RlckV2ZW50cygpO1xcblxcbiAgICAvLyBTZXQgdGhlIGluaXRpYWwgc3RhdGVcXG4gICAgdGhpcy5kYXRhQWRhcHRlci5jdXJyZW50KGZ1bmN0aW9uIChpbml0aWFsRGF0YSkge1xcbiAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0aW9uOnVwZGF0ZScsIHtcXG4gICAgICAgIGRhdGE6IGluaXRpYWxEYXRhXFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICAvLyBIaWRlIHRoZSBvcmlnaW5hbCBzZWxlY3RcXG4gICAgJGVsZW1lbnQuYWRkQ2xhc3MoJ3NlbGVjdDItaGlkZGVuLWFjY2Vzc2libGUnKTtcXG4gICAgJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xcblxcbiAgICAvLyBTeW5jaHJvbml6ZSBhbnkgbW9uaXRvcmVkIGF0dHJpYnV0ZXNcXG4gICAgdGhpcy5fc3luY0F0dHJpYnV0ZXMoKTtcXG5cXG4gICAgVXRpbHMuU3RvcmVEYXRhKCRlbGVtZW50WzBdLCAnc2VsZWN0MicsIHRoaXMpO1xcblxcbiAgICAvLyBFbnN1cmUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgd2l0aCAkZWxlbWVudC5kYXRhKCdzZWxlY3QyJykuXFxuICAgICRlbGVtZW50LmRhdGEoJ3NlbGVjdDInLCB0aGlzKTtcXG4gIH07XFxuXFxuICBVdGlscy5FeHRlbmQoU2VsZWN0MiwgVXRpbHMuT2JzZXJ2YWJsZSk7XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uICgkZWxlbWVudCkge1xcbiAgICB2YXIgaWQgPSAnJztcXG5cXG4gICAgaWYgKCRlbGVtZW50LmF0dHIoJ2lkJykgIT0gbnVsbCkge1xcbiAgICAgIGlkID0gJGVsZW1lbnQuYXR0cignaWQnKTtcXG4gICAgfSBlbHNlIGlmICgkZWxlbWVudC5hdHRyKCduYW1lJykgIT0gbnVsbCkge1xcbiAgICAgIGlkID0gJGVsZW1lbnQuYXR0cignbmFtZScpICsgJy0nICsgVXRpbHMuZ2VuZXJhdGVDaGFycygyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBpZCA9IFV0aWxzLmdlbmVyYXRlQ2hhcnMoNCk7XFxuICAgIH1cXG5cXG4gICAgaWQgPSBpZC5yZXBsYWNlKC8oOnxcXFxcLnxcXFxcW3xcXFxcXXwsKS9nLCAnJyk7XFxuICAgIGlkID0gJ3NlbGVjdDItJyArIGlkO1xcblxcbiAgICByZXR1cm4gaWQ7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3BsYWNlQ29udGFpbmVyID0gZnVuY3Rpb24gKCRjb250YWluZXIpIHtcXG4gICAgJGNvbnRhaW5lci5pbnNlcnRBZnRlcih0aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgdmFyIHdpZHRoID0gdGhpcy5fcmVzb2x2ZVdpZHRoKHRoaXMuJGVsZW1lbnQsIHRoaXMub3B0aW9ucy5nZXQoJ3dpZHRoJykpO1xcblxcbiAgICBpZiAod2lkdGggIT0gbnVsbCkge1xcbiAgICAgICRjb250YWluZXIuY3NzKCd3aWR0aCcsIHdpZHRoKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZXNvbHZlV2lkdGggPSBmdW5jdGlvbiAoJGVsZW1lbnQsIG1ldGhvZCkge1xcbiAgICB2YXIgV0lEVEggPSAvXndpZHRoOigoWy0rXT8oWzAtOV0qXFxcXC4pP1swLTldKykocHh8ZW18ZXh8JXxpbnxjbXxtbXxwdHxwYykpL2k7XFxuXFxuICAgIGlmIChtZXRob2QgPT0gJ3Jlc29sdmUnKSB7XFxuICAgICAgdmFyIHN0eWxlV2lkdGggPSB0aGlzLl9yZXNvbHZlV2lkdGgoJGVsZW1lbnQsICdzdHlsZScpO1xcblxcbiAgICAgIGlmIChzdHlsZVdpZHRoICE9IG51bGwpIHtcXG4gICAgICAgIHJldHVybiBzdHlsZVdpZHRoO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVdpZHRoKCRlbGVtZW50LCAnZWxlbWVudCcpO1xcbiAgICB9XFxuXFxuICAgIGlmIChtZXRob2QgPT0gJ2VsZW1lbnQnKSB7XFxuICAgICAgdmFyIGVsZW1lbnRXaWR0aCA9ICRlbGVtZW50Lm91dGVyV2lkdGgoZmFsc2UpO1xcblxcbiAgICAgIGlmIChlbGVtZW50V2lkdGggPD0gMCkge1xcbiAgICAgICAgcmV0dXJuICdhdXRvJztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGVsZW1lbnRXaWR0aCArICdweCc7XFxuICAgIH1cXG5cXG4gICAgaWYgKG1ldGhvZCA9PSAnc3R5bGUnKSB7XFxuICAgICAgdmFyIHN0eWxlID0gJGVsZW1lbnQuYXR0cignc3R5bGUnKTtcXG5cXG4gICAgICBpZiAodHlwZW9mKHN0eWxlKSAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgYXR0cnMgPSBzdHlsZS5zcGxpdCgnOycpO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXR0cnMubGVuZ3RoOyBpIDwgbDsgaSA9IGkgKyAxKSB7XFxuICAgICAgICB2YXIgYXR0ciA9IGF0dHJzW2ldLnJlcGxhY2UoL1xcXFxzL2csICcnKTtcXG4gICAgICAgIHZhciBtYXRjaGVzID0gYXR0ci5tYXRjaChXSURUSCk7XFxuXFxuICAgICAgICBpZiAobWF0Y2hlcyAhPT0gbnVsbCAmJiBtYXRjaGVzLmxlbmd0aCA+PSAxKSB7XFxuICAgICAgICAgIHJldHVybiBtYXRjaGVzWzFdO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcblxcbiAgICBpZiAobWV0aG9kID09ICdjb21wdXRlZHN0eWxlJykge1xcbiAgICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoJGVsZW1lbnRbMF0pO1xcblxcbiAgICAgIHJldHVybiBjb21wdXRlZFN0eWxlLndpZHRoO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBtZXRob2Q7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX2JpbmRBZGFwdGVycyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5kYXRhQWRhcHRlci5iaW5kKHRoaXMsIHRoaXMuJGNvbnRhaW5lcik7XFxuICAgIHRoaXMuc2VsZWN0aW9uLmJpbmQodGhpcywgdGhpcy4kY29udGFpbmVyKTtcXG5cXG4gICAgdGhpcy5kcm9wZG93bi5iaW5kKHRoaXMsIHRoaXMuJGNvbnRhaW5lcik7XFxuICAgIHRoaXMucmVzdWx0cy5iaW5kKHRoaXMsIHRoaXMuJGNvbnRhaW5lcik7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3JlZ2lzdGVyRG9tRXZlbnRzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2NoYW5nZS5zZWxlY3QyJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuZGF0YUFkYXB0ZXIuY3VycmVudChmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3Rpb246dXBkYXRlJywge1xcbiAgICAgICAgICBkYXRhOiBkYXRhXFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJGVsZW1lbnQub24oJ2ZvY3VzLnNlbGVjdDInLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgc2VsZi50cmlnZ2VyKCdmb2N1cycsIGV2dCk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLl9zeW5jQSA9IFV0aWxzLmJpbmQodGhpcy5fc3luY0F0dHJpYnV0ZXMsIHRoaXMpO1xcbiAgICB0aGlzLl9zeW5jUyA9IFV0aWxzLmJpbmQodGhpcy5fc3luY1N1YnRyZWUsIHRoaXMpO1xcblxcbiAgICBpZiAodGhpcy4kZWxlbWVudFswXS5hdHRhY2hFdmVudCkge1xcbiAgICAgIHRoaXMuJGVsZW1lbnRbMF0uYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCB0aGlzLl9zeW5jQSk7XFxuICAgIH1cXG5cXG4gICAgdmFyIG9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHxcXG4gICAgICB3aW5kb3cuV2ViS2l0TXV0YXRpb25PYnNlcnZlciB8fFxcbiAgICAgIHdpbmRvdy5Nb3pNdXRhdGlvbk9ic2VydmVyXFxuICAgIDtcXG5cXG4gICAgaWYgKG9ic2VydmVyICE9IG51bGwpIHtcXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBvYnNlcnZlcihmdW5jdGlvbiAobXV0YXRpb25zKSB7XFxuICAgICAgICBzZWxmLl9zeW5jQSgpO1xcbiAgICAgICAgc2VsZi5fc3luY1MobnVsbCwgbXV0YXRpb25zKTtcXG4gICAgICB9KTtcXG4gICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuJGVsZW1lbnRbMF0sIHtcXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXFxuICAgICAgICBzdWJ0cmVlOiBmYWxzZVxcbiAgICAgIH0pO1xcbiAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICAgIHRoaXMuJGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcihcXG4gICAgICAgICdET01BdHRyTW9kaWZpZWQnLFxcbiAgICAgICAgc2VsZi5fc3luY0EsXFxuICAgICAgICBmYWxzZVxcbiAgICAgICk7XFxuICAgICAgdGhpcy4kZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFxcbiAgICAgICAgJ0RPTU5vZGVJbnNlcnRlZCcsXFxuICAgICAgICBzZWxmLl9zeW5jUyxcXG4gICAgICAgIGZhbHNlXFxuICAgICAgKTtcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXFxuICAgICAgICAnRE9NTm9kZVJlbW92ZWQnLFxcbiAgICAgICAgc2VsZi5fc3luY1MsXFxuICAgICAgICBmYWxzZVxcbiAgICAgICk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVnaXN0ZXJEYXRhRXZlbnRzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuZGF0YUFkYXB0ZXIub24oJyonLCBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XFxuICAgICAgc2VsZi50cmlnZ2VyKG5hbWUsIHBhcmFtcyk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlclNlbGVjdGlvbkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICB2YXIgbm9uUmVsYXlFdmVudHMgPSBbJ3RvZ2dsZScsICdmb2N1cyddO1xcblxcbiAgICB0aGlzLnNlbGVjdGlvbi5vbigndG9nZ2xlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYudG9nZ2xlRHJvcGRvd24oKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuc2VsZWN0aW9uLm9uKCdmb2N1cycsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLmZvY3VzKHBhcmFtcyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLnNlbGVjdGlvbi5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcXG4gICAgICBpZiAoJC5pbkFycmF5KG5hbWUsIG5vblJlbGF5RXZlbnRzKSAhPT0gLTEpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi50cmlnZ2VyKG5hbWUsIHBhcmFtcyk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckRyb3Bkb3duRXZlbnRzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuZHJvcGRvd24ub24oJyonLCBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XFxuICAgICAgc2VsZi50cmlnZ2VyKG5hbWUsIHBhcmFtcyk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlclJlc3VsdHNFdmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdGhpcy5yZXN1bHRzLm9uKCcqJywgZnVuY3Rpb24gKG5hbWUsIHBhcmFtcykge1xcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVnaXN0ZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdGhpcy5vbignb3BlbicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLiRjb250YWluZXIuYWRkQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLiRjb250YWluZXIucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLm9uKCdlbmFibGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tZGlzYWJsZWQnKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMub24oJ2Rpc2FibGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kY29udGFpbmVyLmFkZENsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tZGlzYWJsZWQnKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMub24oJ2JsdXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tZm9jdXMnKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMub24oJ3F1ZXJ5JywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIGlmICghc2VsZi5pc09wZW4oKSkge1xcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdvcGVuJywge30pO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLmRhdGFBZGFwdGVyLnF1ZXJ5KHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czphbGwnLCB7XFxuICAgICAgICAgIGRhdGE6IGRhdGEsXFxuICAgICAgICAgIHF1ZXJ5OiBwYXJhbXNcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5vbigncXVlcnk6YXBwZW5kJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHRoaXMuZGF0YUFkYXB0ZXIucXVlcnkocGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOmFwcGVuZCcsIHtcXG4gICAgICAgICAgZGF0YTogZGF0YSxcXG4gICAgICAgICAgcXVlcnk6IHBhcmFtc1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICB2YXIga2V5ID0gZXZ0LndoaWNoO1xcblxcbiAgICAgIGlmIChzZWxmLmlzT3BlbigpKSB7XFxuICAgICAgICBpZiAoa2V5ID09PSBLRVlTLkVTQyB8fCBrZXkgPT09IEtFWVMuVEFCIHx8XFxuICAgICAgICAgICAgKGtleSA9PT0gS0VZUy5VUCAmJiBldnQuYWx0S2V5KSkge1xcbiAgICAgICAgICBzZWxmLmNsb3NlKGV2dCk7XFxuXFxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtFWVMuRU5URVIpIHtcXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOnNlbGVjdCcsIHt9KTtcXG5cXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9IGVsc2UgaWYgKChrZXkgPT09IEtFWVMuU1BBQ0UgJiYgZXZ0LmN0cmxLZXkpKSB7XFxuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czp0b2dnbGUnLCB7fSk7XFxuXFxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IEtFWVMuVVApIHtcXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOnByZXZpb3VzJywge30pO1xcblxcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLRVlTLkRPV04pIHtcXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdyZXN1bHRzOm5leHQnLCB7fSk7XFxuXFxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoa2V5ID09PSBLRVlTLkVOVEVSIHx8IGtleSA9PT0gS0VZUy5TUEFDRSB8fFxcbiAgICAgICAgICAgIChrZXkgPT09IEtFWVMuRE9XTiAmJiBldnQuYWx0S2V5KSkge1xcbiAgICAgICAgICBzZWxmLm9wZW4oKTtcXG5cXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fc3luY0F0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMub3B0aW9ucy5zZXQoJ2Rpc2FibGVkJywgdGhpcy4kZWxlbWVudC5wcm9wKCdkaXNhYmxlZCcpKTtcXG5cXG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCgpKSB7XFxuICAgICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy50cmlnZ2VyKCdkaXNhYmxlJywge30pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMudHJpZ2dlcignZW5hYmxlJywge30pO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX2lzQ2hhbmdlTXV0YXRpb24gPSBmdW5jdGlvbiAoZXZ0LCBtdXRhdGlvbnMpIHtcXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAvLyBJZ25vcmUgYW55IG11dGF0aW9uIGV2ZW50cyByYWlzZWQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlbid0IG9wdGlvbnMgb3JcXG4gICAgLy8gb3B0Z3JvdXBzLiBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugd2hlbiB0aGUgc2VsZWN0IGVsZW1lbnQgaXMgZGVzdHJveWVkXFxuICAgIGlmIChcXG4gICAgICBldnQgJiYgZXZ0LnRhcmdldCAmJiAoXFxuICAgICAgICBldnQudGFyZ2V0Lm5vZGVOYW1lICE9PSAnT1BUSU9OJyAmJiBldnQudGFyZ2V0Lm5vZGVOYW1lICE9PSAnT1BUR1JPVVAnXFxuICAgICAgKVxcbiAgICApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKCFtdXRhdGlvbnMpIHtcXG4gICAgICAvLyBJZiBtdXRhdGlvbiBldmVudHMgYXJlbid0IHN1cHBvcnRlZCwgdGhlbiB3ZSBjYW4gb25seSBhc3N1bWUgdGhhdCB0aGVcXG4gICAgICAvLyBjaGFuZ2UgYWZmZWN0ZWQgdGhlIHNlbGVjdGlvbnNcXG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcXG4gICAgfSBlbHNlIGlmIChtdXRhdGlvbnMuYWRkZWROb2RlcyAmJiBtdXRhdGlvbnMuYWRkZWROb2Rlcy5sZW5ndGggPiAwKSB7XFxuICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBtdXRhdGlvbnMuYWRkZWROb2Rlcy5sZW5ndGg7IG4rKykge1xcbiAgICAgICAgdmFyIG5vZGUgPSBtdXRhdGlvbnMuYWRkZWROb2Rlc1tuXTtcXG5cXG4gICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7XFxuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChtdXRhdGlvbnMucmVtb3ZlZE5vZGVzICYmIG11dGF0aW9ucy5yZW1vdmVkTm9kZXMubGVuZ3RoID4gMCkge1xcbiAgICAgIGNoYW5nZWQgPSB0cnVlO1xcbiAgICB9IGVsc2UgaWYgKCQuaXNBcnJheShtdXRhdGlvbnMpKSB7XFxuICAgICAgJC5lYWNoKG11dGF0aW9ucywgZnVuY3Rpb24oZXZ0LCBtdXRhdGlvbikge1xcbiAgICAgICAgaWYgKHNlbGYuX2lzQ2hhbmdlTXV0YXRpb24oZXZ0LCBtdXRhdGlvbikpIHtcXG4gICAgICAgICAgLy8gV2UndmUgZm91bmQgYSBjaGFuZ2UgbXV0YXRpb24uXFxuICAgICAgICAgIC8vIExldCdzIGVzY2FwZSBmcm9tIHRoZSBsb29wIGFuZCBjb250aW51ZVxcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiBjaGFuZ2VkO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9zeW5jU3VidHJlZSA9IGZ1bmN0aW9uIChldnQsIG11dGF0aW9ucykge1xcbiAgICB2YXIgY2hhbmdlZCA9IHRoaXMuX2lzQ2hhbmdlTXV0YXRpb24oZXZ0LCBtdXRhdGlvbnMpO1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIC8vIE9ubHkgcmUtcHVsbCB0aGUgZGF0YSBpZiB3ZSB0aGluayB0aGVyZSBpcyBhIGNoYW5nZVxcbiAgICBpZiAoY2hhbmdlZCkge1xcbiAgICAgIHRoaXMuZGF0YUFkYXB0ZXIuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcXG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0aW9uOnVwZGF0ZScsIHtcXG4gICAgICAgICAgZGF0YTogY3VycmVudERhdGFcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBPdmVycmlkZSB0aGUgdHJpZ2dlciBtZXRob2QgdG8gYXV0b21hdGljYWxseSB0cmlnZ2VyIHByZS1ldmVudHMgd2hlblxcbiAgICogdGhlcmUgYXJlIGV2ZW50cyB0aGF0IGNhbiBiZSBwcmV2ZW50ZWQuXFxuICAgKi9cXG4gIFNlbGVjdDIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgYXJncykge1xcbiAgICB2YXIgYWN0dWFsVHJpZ2dlciA9IFNlbGVjdDIuX19zdXBlcl9fLnRyaWdnZXI7XFxuICAgIHZhciBwcmVUcmlnZ2VyTWFwID0ge1xcbiAgICAgICdvcGVuJzogJ29wZW5pbmcnLFxcbiAgICAgICdjbG9zZSc6ICdjbG9zaW5nJyxcXG4gICAgICAnc2VsZWN0JzogJ3NlbGVjdGluZycsXFxuICAgICAgJ3Vuc2VsZWN0JzogJ3Vuc2VsZWN0aW5nJyxcXG4gICAgICAnY2xlYXInOiAnY2xlYXJpbmcnXFxuICAgIH07XFxuXFxuICAgIGlmIChhcmdzID09PSB1bmRlZmluZWQpIHtcXG4gICAgICBhcmdzID0ge307XFxuICAgIH1cXG5cXG4gICAgaWYgKG5hbWUgaW4gcHJlVHJpZ2dlck1hcCkge1xcbiAgICAgIHZhciBwcmVUcmlnZ2VyTmFtZSA9IHByZVRyaWdnZXJNYXBbbmFtZV07XFxuICAgICAgdmFyIHByZVRyaWdnZXJBcmdzID0ge1xcbiAgICAgICAgcHJldmVudGVkOiBmYWxzZSxcXG4gICAgICAgIG5hbWU6IG5hbWUsXFxuICAgICAgICBhcmdzOiBhcmdzXFxuICAgICAgfTtcXG5cXG4gICAgICBhY3R1YWxUcmlnZ2VyLmNhbGwodGhpcywgcHJlVHJpZ2dlck5hbWUsIHByZVRyaWdnZXJBcmdzKTtcXG5cXG4gICAgICBpZiAocHJlVHJpZ2dlckFyZ3MucHJldmVudGVkKSB7XFxuICAgICAgICBhcmdzLnByZXZlbnRlZCA9IHRydWU7XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGFjdHVhbFRyaWdnZXIuY2FsbCh0aGlzLCBuYW1lLCBhcmdzKTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS50b2dnbGVEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCgpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XFxuICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHRoaXMub3BlbigpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKHRoaXMuaXNPcGVuKCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuaXNEaXNhYmxlZCgpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7fSk7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgIGlmICghdGhpcy5pc09wZW4oKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLnRyaWdnZXIoJ2Nsb3NlJywgeyBvcmlnaW5hbEV2ZW50IDogZXZ0IH0pO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogSGVscGVyIG1ldGhvZCB0byBhYnN0cmFjdCB0aGUgXFxcImVuYWJsZWRcXFwiIChub3QgXFxcImRpc2FibGVkXFxcIikgc3RhdGUgb2YgdGhpc1xcbiAgICogb2JqZWN0LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge3RydWV9IGlmIHRoZSBpbnN0YW5jZSBpcyBub3QgZGlzYWJsZWQuXFxuICAgKiBAcmV0dXJuIHtmYWxzZX0gaWYgdGhlIGluc3RhbmNlIGlzIGRpc2FibGVkLlxcbiAgICovXFxuICBTZWxlY3QyLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiAhdGhpcy5pc0Rpc2FibGVkKCk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFic3RyYWN0IHRoZSBcXFwiZGlzYWJsZWRcXFwiIHN0YXRlIG9mIHRoaXMgb2JqZWN0LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge3RydWV9IGlmIHRoZSBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZS5cXG4gICAqIEByZXR1cm4ge2ZhbHNlfSBpZiB0aGUgZGlzYWJsZWQgb3B0aW9uIGlzIGZhbHNlLlxcbiAgICovXFxuICBTZWxlY3QyLnByb3RvdHlwZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmdldCgnZGlzYWJsZWQnKTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5pc09wZW4gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzLiRjb250YWluZXIuaGFzQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuaGFzRm9jdXMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiB0aGlzLiRjb250YWluZXIuaGFzQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1mb2N1cycpO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgLy8gTm8gbmVlZCB0byByZS10cmlnZ2VyIGZvY3VzIGV2ZW50cyBpZiB3ZSBhcmUgYWxyZWFkeSBmb2N1c2VkXFxuICAgIGlmICh0aGlzLmhhc0ZvY3VzKCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tZm9jdXMnKTtcXG4gICAgdGhpcy50cmlnZ2VyKCdmb2N1cycsIHt9KTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoYXJncykge1xcbiAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnZGVidWcnKSAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcXG4gICAgICBjb25zb2xlLndhcm4oXFxuICAgICAgICAnU2VsZWN0MjogVGhlIGBzZWxlY3QyKFxcXCJlbmFibGVcXFwiKWAgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwnICtcXG4gICAgICAgICcgYmUgcmVtb3ZlZCBpbiBsYXRlciBTZWxlY3QyIHZlcnNpb25zLiBVc2UgJGVsZW1lbnQucHJvcChcXFwiZGlzYWJsZWRcXFwiKScgK1xcbiAgICAgICAgJyBpbnN0ZWFkLidcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIGlmIChhcmdzID09IG51bGwgfHwgYXJncy5sZW5ndGggPT09IDApIHtcXG4gICAgICBhcmdzID0gW3RydWVdO1xcbiAgICB9XFxuXFxuICAgIHZhciBkaXNhYmxlZCA9ICFhcmdzWzBdO1xcblxcbiAgICB0aGlzLiRlbGVtZW50LnByb3AoJ2Rpc2FibGVkJywgZGlzYWJsZWQpO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmXFxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcXG4gICAgICBjb25zb2xlLndhcm4oXFxuICAgICAgICAnU2VsZWN0MjogRGF0YSBjYW4gbm8gbG9uZ2VyIGJlIHNldCB1c2luZyBgc2VsZWN0MihcXFwiZGF0YVxcXCIpYC4gWW91ICcgK1xcbiAgICAgICAgJ3Nob3VsZCBjb25zaWRlciBzZXR0aW5nIHRoZSB2YWx1ZSBpbnN0ZWFkIHVzaW5nIGAkZWxlbWVudC52YWwoKWAuJ1xcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGRhdGEgPSBbXTtcXG5cXG4gICAgdGhpcy5kYXRhQWRhcHRlci5jdXJyZW50KGZ1bmN0aW9uIChjdXJyZW50RGF0YSkge1xcbiAgICAgIGRhdGEgPSBjdXJyZW50RGF0YTtcXG4gICAgfSk7XFxuXFxuICAgIHJldHVybiBkYXRhO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLnZhbCA9IGZ1bmN0aW9uIChhcmdzKSB7XFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkZWJ1ZycpICYmIHdpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xcbiAgICAgIGNvbnNvbGUud2FybihcXG4gICAgICAgICdTZWxlY3QyOiBUaGUgYHNlbGVjdDIoXFxcInZhbFxcXCIpYCBtZXRob2QgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgd2lsbCBiZScgK1xcbiAgICAgICAgJyByZW1vdmVkIGluIGxhdGVyIFNlbGVjdDIgdmVyc2lvbnMuIFVzZSAkZWxlbWVudC52YWwoKSBpbnN0ZWFkLidcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIGlmIChhcmdzID09IG51bGwgfHwgYXJncy5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC52YWwoKTtcXG4gICAgfVxcblxcbiAgICB2YXIgbmV3VmFsID0gYXJnc1swXTtcXG5cXG4gICAgaWYgKCQuaXNBcnJheShuZXdWYWwpKSB7XFxuICAgICAgbmV3VmFsID0gJC5tYXAobmV3VmFsLCBmdW5jdGlvbiAob2JqKSB7XFxuICAgICAgICByZXR1cm4gb2JqLnRvU3RyaW5nKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kZWxlbWVudC52YWwobmV3VmFsKS50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmUoKTtcXG5cXG4gICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0uZGV0YWNoRXZlbnQpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdLmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgdGhpcy5fc3luY0EpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9vYnNlcnZlciAhPSBudWxsKSB7XFxuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcXG4gICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50WzBdLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdXFxuICAgICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQXR0ck1vZGlmaWVkJywgdGhpcy5fc3luY0EsIGZhbHNlKTtcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdXFxuICAgICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgdGhpcy5fc3luY1MsIGZhbHNlKTtcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdXFxuICAgICAgICAucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWQnLCB0aGlzLl9zeW5jUywgZmFsc2UpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX3N5bmNBID0gbnVsbDtcXG4gICAgdGhpcy5fc3luY1MgPSBudWxsO1xcblxcbiAgICB0aGlzLiRlbGVtZW50Lm9mZignLnNlbGVjdDInKTtcXG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsXFxuICAgIFV0aWxzLkdldERhdGEodGhpcy4kZWxlbWVudFswXSwgJ29sZC10YWJpbmRleCcpKTtcXG5cXG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnc2VsZWN0Mi1oaWRkZW4tYWNjZXNzaWJsZScpO1xcbiAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XFxuICAgIFV0aWxzLlJlbW92ZURhdGEodGhpcy4kZWxlbWVudFswXSk7XFxuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnc2VsZWN0MicpO1xcblxcbiAgICB0aGlzLmRhdGFBZGFwdGVyLmRlc3Ryb3koKTtcXG4gICAgdGhpcy5zZWxlY3Rpb24uZGVzdHJveSgpO1xcbiAgICB0aGlzLmRyb3Bkb3duLmRlc3Ryb3koKTtcXG4gICAgdGhpcy5yZXN1bHRzLmRlc3Ryb3koKTtcXG5cXG4gICAgdGhpcy5kYXRhQWRhcHRlciA9IG51bGw7XFxuICAgIHRoaXMuc2VsZWN0aW9uID0gbnVsbDtcXG4gICAgdGhpcy5kcm9wZG93biA9IG51bGw7XFxuICAgIHRoaXMucmVzdWx0cyA9IG51bGw7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJGNvbnRhaW5lciA9ICQoXFxuICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyIHNlbGVjdDItY29udGFpbmVyXFxcIj4nICtcXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwic2VsZWN0aW9uXFxcIj48L3NwYW4+JyArXFxuICAgICAgICAnPHNwYW4gY2xhc3M9XFxcImRyb3Bkb3duLXdyYXBwZXJcXFwiIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIj48L3NwYW4+JyArXFxuICAgICAgJzwvc3Bhbj4nXFxuICAgICk7XFxuXFxuICAgICRjb250YWluZXIuYXR0cignZGlyJywgdGhpcy5vcHRpb25zLmdldCgnZGlyJykpO1xcblxcbiAgICB0aGlzLiRjb250YWluZXIgPSAkY29udGFpbmVyO1xcblxcbiAgICB0aGlzLiRjb250YWluZXIuYWRkQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS0nICsgdGhpcy5vcHRpb25zLmdldCgndGhlbWUnKSk7XFxuXFxuICAgIFV0aWxzLlN0b3JlRGF0YSgkY29udGFpbmVyWzBdLCAnZWxlbWVudCcsIHRoaXMuJGVsZW1lbnQpO1xcblxcbiAgICByZXR1cm4gJGNvbnRhaW5lcjtcXG4gIH07XFxuXFxuICByZXR1cm4gU2VsZWN0MjtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ2pxdWVyeS1tb3VzZXdoZWVsJyxbXFxuICAnanF1ZXJ5J1xcbl0sIGZ1bmN0aW9uICgkKSB7XFxuICAvLyBVc2VkIHRvIHNoaW0galF1ZXJ5Lm1vdXNld2hlZWwgZm9yIG5vbi1mdWxsIGJ1aWxkcy5cXG4gIHJldHVybiAkO1xcbn0pO1xcblxcblMyLmRlZmluZSgnanF1ZXJ5LnNlbGVjdDInLFtcXG4gICdqcXVlcnknLFxcbiAgJ2pxdWVyeS1tb3VzZXdoZWVsJyxcXG5cXG4gICcuL3NlbGVjdDIvY29yZScsXFxuICAnLi9zZWxlY3QyL2RlZmF1bHRzJyxcXG4gICcuL3NlbGVjdDIvdXRpbHMnXFxuXSwgZnVuY3Rpb24gKCQsIF8sIFNlbGVjdDIsIERlZmF1bHRzLCBVdGlscykge1xcbiAgaWYgKCQuZm4uc2VsZWN0MiA9PSBudWxsKSB7XFxuICAgIC8vIEFsbCBtZXRob2RzIHRoYXQgc2hvdWxkIHJldHVybiB0aGUgZWxlbWVudFxcbiAgICB2YXIgdGhpc01ldGhvZHMgPSBbJ29wZW4nLCAnY2xvc2UnLCAnZGVzdHJveSddO1xcblxcbiAgICAkLmZuLnNlbGVjdDIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBpbnN0YW5jZU9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgb3B0aW9ucyk7XFxuXFxuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBTZWxlY3QyKCQodGhpcyksIGluc3RhbmNlT3B0aW9ucyk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICB2YXIgcmV0O1xcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcblxcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gVXRpbHMuR2V0RGF0YSh0aGlzLCAnc2VsZWN0MicpO1xcblxcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT0gbnVsbCAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcXG4gICAgICAgICAgICAgICdUaGUgc2VsZWN0MihcXFxcJycgKyBvcHRpb25zICsgJ1xcXFwnKSBtZXRob2Qgd2FzIGNhbGxlZCBvbiBhbiAnICtcXG4gICAgICAgICAgICAgICdlbGVtZW50IHRoYXQgaXMgbm90IHVzaW5nIFNlbGVjdDIuJ1xcbiAgICAgICAgICAgICk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0ID0gaW5zdGFuY2Vbb3B0aW9uc10uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBzaG91bGQgYmUgcmV0dXJuaW5nIGB0aGlzYFxcbiAgICAgICAgaWYgKCQuaW5BcnJheShvcHRpb25zLCB0aGlzTWV0aG9kcykgPiAtMSkge1xcbiAgICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiByZXQ7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMgZm9yIFNlbGVjdDI6ICcgKyBvcHRpb25zKTtcXG4gICAgICB9XFxuICAgIH07XFxuICB9XFxuXFxuICBpZiAoJC5mbi5zZWxlY3QyLmRlZmF1bHRzID09IG51bGwpIHtcXG4gICAgJC5mbi5zZWxlY3QyLmRlZmF1bHRzID0gRGVmYXVsdHM7XFxuICB9XFxuXFxuICByZXR1cm4gU2VsZWN0MjtcXG59KTtcXG5cXG4gIC8vIFJldHVybiB0aGUgQU1EIGxvYWRlciBjb25maWd1cmF0aW9uIHNvIGl0IGNhbiBiZSB1c2VkIG91dHNpZGUgb2YgdGhpcyBmaWxlXFxuICByZXR1cm4ge1xcbiAgICBkZWZpbmU6IFMyLmRlZmluZSxcXG4gICAgcmVxdWlyZTogUzIucmVxdWlyZVxcbiAgfTtcXG59KCkpO1xcblxcbiAgLy8gQXV0b2xvYWQgdGhlIGpRdWVyeSBiaW5kaW5nc1xcbiAgLy8gV2Uga25vdyB0aGF0IGFsbCBvZiB0aGUgbW9kdWxlcyBleGlzdCBhYm92ZSB0aGlzLCBzbyB3ZSdyZSBzYWZlXFxuICB2YXIgc2VsZWN0MiA9IFMyLnJlcXVpcmUoJ2pxdWVyeS5zZWxlY3QyJyk7XFxuXFxuICAvLyBIb2xkIHRoZSBBTUQgbW9kdWxlIHJlZmVyZW5jZXMgb24gdGhlIGpRdWVyeSBmdW5jdGlvbiB0aGF0IHdhcyBqdXN0IGxvYWRlZFxcbiAgLy8gVGhpcyBhbGxvd3MgU2VsZWN0MiB0byB1c2UgdGhlIGludGVybmFsIGxvYWRlciBvdXRzaWRlIG9mIHRoaXMgZmlsZSwgc3VjaFxcbiAgLy8gYXMgaW4gdGhlIGxhbmd1YWdlIGZpbGVzLlxcbiAgalF1ZXJ5LmZuLnNlbGVjdDIuYW1kID0gUzI7XFxuXFxuICAvLyBSZXR1cm4gdGhlIFNlbGVjdDIgaW5zdGFuY2UgZm9yIGFueW9uZSB3aG8gaXMgaW1wb3J0aW5nIGl0LlxcbiAgcmV0dXJuIHNlbGVjdDI7XFxufSkpO1xcblwiIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cbiIsInJlcXVpcmUoXCIhIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXNlbGVjdC9kaXN0L2pzL2Jvb3RzdHJhcC1zZWxlY3QuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXNlbGVjdC9kaXN0L2pzL2Jvb3RzdHJhcC1zZWxlY3QuanNcIikiLCJyZXF1aXJlKFwiISEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlci9pbmRleC5qcyEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuanNcIikiLCJyZXF1aXJlKFwiISEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NlbGVjdDIvZGlzdC9qcy9zZWxlY3QyLmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NlbGVjdDIvZGlzdC9qcy9zZWxlY3QyLmpzXCIpIiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcbn07XG5cbnZhciBnZXRFbGVtZW50ID0gKGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbyA9IHt9O1xuXG5cdHJldHVybiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBwYXNzaW5nIGZ1bmN0aW9uIGluIG9wdGlvbnMsIHRoZW4gdXNlIGl0IGZvciByZXNvbHZlIFwiaGVhZFwiIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gVXNlZnVsIGZvciBTaGFkb3cgUm9vdCBzdHlsZSBpLmVcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBpbnNlcnRJbnRvOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvb1wiKS5zaGFkb3dSb290IH1cbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZW1vW3RhcmdldF0gPT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdHZhciBzdHlsZVRhcmdldCA9IGdldFRhcmdldC5jYWxsKHRoaXMsIHRhcmdldCk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG5cdFx0XHRcdFx0Ly8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuXHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRzdHlsZVRhcmdldCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuXHRcdH1cblx0XHRyZXR1cm4gbWVtb1t0YXJnZXRdXG5cdH07XG59KSgpO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuICAgICAgICBpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRpZihvcHRpb25zLmF0dHJzLnR5cGUgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wdGlvbnMuYXR0cnMudHlwZSA9IFwidGV4dC9jc3NcIjtcblx0fVxuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0aWYob3B0aW9ucy5hdHRycy50eXBlID09PSB1bmRlZmluZWQpIHtcblx0XHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdH1cblx0b3B0aW9ucy5hdHRycy5yZWwgPSBcInN0eWxlc2hlZXRcIjtcblxuXHRhZGRBdHRycyhsaW5rLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIGxpbmspO1xuXG5cdHJldHVybiBsaW5rO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRycyAoZWwsIGF0dHJzKSB7XG5cdE9iamVjdC5rZXlzKGF0dHJzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyc1trZXldKTtcblx0fSk7XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmosIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlLCB1cGRhdGUsIHJlbW92ZSwgcmVzdWx0O1xuXG5cdC8vIElmIGEgdHJhbnNmb3JtIGZ1bmN0aW9uIHdhcyBkZWZpbmVkLCBydW4gaXQgb24gdGhlIGNzc1xuXHRpZiAob3B0aW9ucy50cmFuc2Zvcm0gJiYgb2JqLmNzcykge1xuXHQgICAgcmVzdWx0ID0gb3B0aW9ucy50cmFuc2Zvcm0ob2JqLmNzcyk7XG5cblx0ICAgIGlmIChyZXN1bHQpIHtcblx0ICAgIFx0Ly8gSWYgdHJhbnNmb3JtIHJldHVybnMgYSB2YWx1ZSwgdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgb3JpZ2luYWwgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBydW5uaW5nIHJ1bnRpbWUgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBjc3MuXG5cdCAgICBcdG9iai5jc3MgPSByZXN1bHQ7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgXHQvLyBJZiB0aGUgdHJhbnNmb3JtIGZ1bmN0aW9uIHJldHVybnMgYSBmYWxzeSB2YWx1ZSwgZG9uJ3QgYWRkIHRoaXMgY3NzLlxuXHQgICAgXHQvLyBUaGlzIGFsbG93cyBjb25kaXRpb25hbCBsb2FkaW5nIG9mIGNzc1xuXHQgICAgXHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdCAgICBcdFx0Ly8gbm9vcFxuXHQgICAgXHR9O1xuXHQgICAgfVxuXHR9XG5cblx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG5cblx0XHRzdHlsZSA9IHNpbmdsZXRvbiB8fCAoc2luZ2xldG9uID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcblxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgZmFsc2UpO1xuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZSwgc3R5bGVJbmRleCwgdHJ1ZSk7XG5cblx0fSBlbHNlIGlmIChcblx0XHRvYmouc291cmNlTWFwICYmXG5cdFx0dHlwZW9mIFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIlxuXHQpIHtcblx0XHRzdHlsZSA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IHVwZGF0ZUxpbmsuYmluZChudWxsLCBzdHlsZSwgb3B0aW9ucyk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblxuXHRcdFx0aWYoc3R5bGUuaHJlZikgVVJMLnJldm9rZU9iamVjdFVSTChzdHlsZS5ocmVmKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZSk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChuZXdPYmopIHtcblx0XHRpZiAobmV3T2JqKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdG5ld09iai5jc3MgPT09IG9iai5jc3MgJiZcblx0XHRcdFx0bmV3T2JqLm1lZGlhID09PSBvYmoubWVkaWEgJiZcblx0XHRcdFx0bmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcFxuXHRcdFx0KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dXBkYXRlKG9iaiA9IG5ld09iaik7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlbW92ZSgpO1xuXHRcdH1cblx0fTtcbn1cblxudmFyIHJlcGxhY2VUZXh0ID0gKGZ1bmN0aW9uICgpIHtcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xuXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZSwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xuXHR9IGVsc2Uge1xuXHRcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlLmNoaWxkTm9kZXM7XG5cblx0XHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcblxuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGUuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3R5bGUuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcblxuXHRpZihtZWRpYSkge1xuXHRcdHN0eWxlLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIG1lZGlhKVxuXHR9XG5cblx0aWYoc3R5bGUuc3R5bGVTaGVldCkge1xuXHRcdHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0fSBlbHNlIHtcblx0XHR3aGlsZShzdHlsZS5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcblx0XHR9XG5cblx0XHRzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcblx0fVxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaW5rIChsaW5rLCBvcHRpb25zLCBvYmopIHtcblx0dmFyIGNzcyA9IG9iai5jc3M7XG5cdHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG5cdC8qXG5cdFx0SWYgY29udmVydFRvQWJzb2x1dGVVcmxzIGlzbid0IGRlZmluZWQsIGJ1dCBzb3VyY2VtYXBzIGFyZSBlbmFibGVkXG5cdFx0YW5kIHRoZXJlIGlzIG5vIHB1YmxpY1BhdGggZGVmaW5lZCB0aGVuIGxldHMgdHVybiBjb252ZXJ0VG9BYnNvbHV0ZVVybHNcblx0XHRvbiBieSBkZWZhdWx0LiAgT3RoZXJ3aXNlIGRlZmF1bHQgdG8gdGhlIGNvbnZlcnRUb0Fic29sdXRlVXJscyBvcHRpb25cblx0XHRkaXJlY3RseVxuXHQqL1xuXHR2YXIgYXV0b0ZpeFVybHMgPSBvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyA9PT0gdW5kZWZpbmVkICYmIHNvdXJjZU1hcDtcblxuXHRpZiAob3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgfHwgYXV0b0ZpeFVybHMpIHtcblx0XHRjc3MgPSBmaXhVcmxzKGNzcyk7XG5cdH1cblxuXHRpZiAoc291cmNlTWFwKSB7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFwidGV4dC9jc3NcIiB9KTtcblxuXHR2YXIgb2xkU3JjID0gbGluay5ocmVmO1xuXG5cdGxpbmsuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cblx0aWYob2xkU3JjKSBVUkwucmV2b2tlT2JqZWN0VVJMKG9sZFNyYyk7XG59XG4iLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcL3xcXHMqJCkvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcbiIsIlxudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanMhLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMl0udXNlWzJdIS4uLy4uL25vZGVfbW9kdWxlcy9zYXNzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbM10hLi90dXRvbXZjLnNjc3NcIik7XG5cbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuXG52YXIgdHJhbnNmb3JtO1xudmFyIGluc2VydEludG87XG5cblxuXG52YXIgb3B0aW9ucyA9IHtcImhtclwiOnRydWV9XG5cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG5vcHRpb25zLmluc2VydEludG8gPSB1bmRlZmluZWQ7XG5cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG5cbmlmKG1vZHVsZS5ob3QpIHtcblx0bW9kdWxlLmhvdC5hY2NlcHQoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLnVzZVszXSEuL3R1dG9tdmMuc2Nzc1wiLCBmdW5jdGlvbigpIHtcblx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcyEuLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1syXS51c2VbMl0hLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzJdLnVzZVszXSEuL3R1dG9tdmMuc2Nzc1wiKTtcblxuXHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXG5cdFx0dmFyIGxvY2FscyA9IChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHR2YXIga2V5LCBpZHggPSAwO1xuXG5cdFx0XHRmb3Ioa2V5IGluIGEpIHtcblx0XHRcdFx0aWYoIWIgfHwgYVtrZXldICE9PSBiW2tleV0pIHJldHVybiBmYWxzZTtcblx0XHRcdFx0aWR4Kys7XG5cdFx0XHR9XG5cblx0XHRcdGZvcihrZXkgaW4gYikgaWR4LS07XG5cblx0XHRcdHJldHVybiBpZHggPT09IDA7XG5cdFx0fShjb250ZW50LmxvY2FscywgbmV3Q29udGVudC5sb2NhbHMpKTtcblxuXHRcdGlmKCFsb2NhbHMpIHRocm93IG5ldyBFcnJvcignQWJvcnRpbmcgQ1NTIEhNUiBkdWUgdG8gY2hhbmdlZCBjc3MtbW9kdWxlcyBsb2NhbHMuJyk7XG5cblx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdH0pO1xuXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufSIsImltcG9ydCB7V1BBdHRhY2htZW50Rm9ybUlucHV0fSBmcm9tIFwiLi4vd3AvZm9ybS9pbnB1dHMvV1BBdHRhY2htZW50Rm9ybUlucHV0XCI7XG5qUXVlcnkoIGRvY3VtZW50ICkucmVhZHkoIGZ1bmN0aW9uICgpXG57XG5cdGpRdWVyeSggXCIud3BhdHRhY2htZW50Zm9ybWlucHV0XCIgKS5lYWNoKCBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0bmV3IFdQQXR0YWNobWVudEZvcm1JbnB1dCggalF1ZXJ5KCB0aGlzICksIGpRdWVyeSggdGhpcyApLmRhdGEoKSApO1xuXHR9ICk7XG4vL1x0alF1ZXJ5KCBcIi53cGF0dGFjaG1lbnRmb3JtaW5wdXQgLmJ0bi1yZW1vdmVcIiApLmNsaWNrKCBmdW5jdGlvbiAoIGUgKVxuLy9cdHtcbi8vXHRcdGUucHJldmVudERlZmF1bHQoKTtcbi8vXHRcdHZhciAkZWwgPSAkKCB0aGlzICk7XG4vL1x0XHQkZWwuY2xvc2VzdCggXCIubGlzdC1ncm91cC1pdGVtXCIgKS5yZW1vdmUoKTtcbi8vXG4vL1x0XHRuZXcgV1BBdHRhY2htZW50Rm9ybUlucHV0KCAkKCAkKCB0aGlzICkuZGF0YSggXCJ0YXJnZXRcIiApICksIFwicmVuZGVyXCIgKTtcbi8vXHR9ICk7XG4vL1x0alF1ZXJ5KCBcIi53cGF0dGFjaG1lbnRmb3JtaW5wdXQgLmJ0bi1hZGRcIiApLmNsaWNrKCBmdW5jdGlvbiAoIGUgKVxuLy9cdHtcbi8vXHRcdG5ldyBXUEF0dGFjaG1lbnRGb3JtSW5wdXQoICQoICQoIHRoaXMgKS5kYXRhKCBcInRhcmdldFwiICkgKSwgXCJvcGVuXCIgKTtcbi8vXHR9ICk7XG59ICk7IiwialF1ZXJ5KCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5KCBcImJvZHlcIiApLm9uKCBcImNsaWNrXCIsIFwiLndwZWRpdG9yLXBsYWNlaG9sZGVyLW92ZXJsYXlcIiwgKCBlICkgPT4ge1xuXHRcdGxldCAkY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcblx0XHRsZXQgJGVsICAgICAgICAgICAgPSBqUXVlcnkoICRjdXJyZW50VGFyZ2V0LmNsb3Nlc3QoIFwiLndwZWRpdG9yLXBsYWNlaG9sZGVyXCIgKSApO1xuXHRcdGxldCBjb250ZW50ICAgICAgICA9ICRlbC5maW5kKCBcInRleHRhcmVhXCIgKS52YWwoKTtcblx0XHRjb25zb2xlLmxvZyggY29udGVudCApO1xuXHRcdGpRdWVyeS5hamF4KCAkZWwuZGF0YSggXCJhamF4LXVybFwiICksIHtcblx0XHRcdGRhdGE6ICAge1xuXHRcdFx0XHRjb250ZW50OmNvbnRlbnQsXG5cdFx0XHRcdFwiaWRcIjogICAkZWwuZGF0YSggXCJpZFwiICksXG5cdFx0XHR9LFxuXHRcdFx0c3VjY2VzczooIHJlc3VsdCApID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coIHJlc3VsdCApO1xuXHRcdFx0XHQkZWwuaHRtbCggcmVzdWx0Lmh0bWwgKTtcblx0XHRcdFx0dGlueW1jZS5pbml0KCByZXN1bHQuc2V0dGluZ3MgKTtcblx0XHRcdFx0cXVpY2t0YWdzKCB7aWQ6JGVsLmRhdGEoIFwiaWRcIiApfSApO1xuXHRcdFx0XHR3aW5kb3cud3BBY3RpdmVFZGl0b3IgPSAkZWwuZGF0YSggXCJpZFwiICk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6ICBlcnJvciA9PiBjb25zb2xlLmVycm9yKCBlcnJvciApXG5cdFx0fSApO1xuXHR9ICk7XG59ICk7IiwiaW1wb3J0IHtNZXRhQm94fSBmcm9tIFwiLi4vd3AvZm9ybS9ncm91cHMvTWV0YUJveFwiO1xuXG5qUXVlcnkoIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkoIFwiLnR1dG9tdmMtc2V0dGluZ3MsLnR1dG9tdmMtbWV0YWJveCwudHV0b212Yy11c2VyX21ldGFib3hcIiApLmVhY2goIGZ1bmN0aW9uKCBpLCBlbCApIHtcblx0XHRuZXcgTWV0YUJveCggalF1ZXJ5KCBlbCApICk7XG5cdH0gKTtcbn0gKTsiLCJpbXBvcnQge1dQQXR0YWNobWVudEZvcm1JbnB1dH0gZnJvbSBcIi4uL2lucHV0cy9XUEF0dGFjaG1lbnRGb3JtSW5wdXRcIjtcblxuZXhwb3J0IGNsYXNzIE1ldGFCb3hcbntcblx0cHJpdmF0ZSBfJGVsOiBKUXVlcnk7XG5cblx0Y29uc3RydWN0b3IoICRlbDogSlF1ZXJ5IClcblx0e1xuXHRcdHRoaXMuXyRlbCA9ICRlbDtcblxuXHRcdHRoaXMuXyRlbC5vbiggXCJjaGFuZ2VcIiwgXCIuZmlzc2lsZS1mb3JtLWdyb3VwLW51a2VcIiwgKCBlICkgPT4gdGhpcy5wYXJzZSgpICk7XG5cdFx0Y29uc29sZS5sb2coIFwiTWV0YUJveFwiICk7XG5cdFx0Y29uc29sZS5sb2coIFR1dG9NVkMgKTtcblx0fVxuXG5cdHByaXZhdGUgcmVuZGVyKCBodG1sIClcblx0e1xuXHRcdHRoaXMuXyRlbC5odG1sKCBodG1sICk7XG5cdFx0dGhpcy5fJGVsLmZpbmQoIFwiLmZvcm0taW5wdXQtZWxlbWVudC5zZWxlY3QyXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnNlbGVjdDIoIGpRdWVyeSggdGhpcyApLmRhdGEoKSApO1xuXHRcdH0gKTtcblx0XHR0aGlzLl8kZWwuZmluZCggXCIuc2VsZWN0cGlja2VyXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnNlbGVjdHBpY2tlciggalF1ZXJ5KCB0aGlzICkuZGF0YSgpICk7XG5cdFx0fSApO1xuXHRcdHRoaXMuXyRlbC5maW5kKCBcIi53cGF0dGFjaG1lbnRmb3JtaW5wdXRcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0bmV3IFdQQXR0YWNobWVudEZvcm1JbnB1dCggalF1ZXJ5KCB0aGlzICksIGpRdWVyeSggdGhpcyApLmRhdGEoKSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHByaXZhdGUgZGVzdHJveSgpXG5cdHtcblx0XHR0aGlzLl8kZWwuZmluZCggXCJ0ZXh0YXJlYS53cC1lZGl0b3ItYXJlYVwiICkuZWFjaCggKCBpLCBlbCApID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCBcIkRFU09UUlk6XCIsIGpRdWVyeSggZWwgKS5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0dGlueW1jZS5yZW1vdmUoIFwiI1wiICsgalF1ZXJ5KCBlbCApLmF0dHIoIFwiaWRcIiApICk7XG4vL1x0XHRcdHRpbnltY2UuZXhlY0NvbW1hbmQoICdtY2VSZW1vdmVDb250cm9sJywgdHJ1ZSwgalF1ZXJ5KCBlbCApLmF0dHIoIFwiaWRcIiApICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cHJpdmF0ZSBwYXJzZSgpXG5cdHtcblx0XHRpZiggdGhpcy4kZm9ybS5sZW5ndGggKVxuXHRcdHtcblx0XHRcdGlmKCB0eXBlb2YgdGlueW1jZSAhPT0gJ3VuZGVmaW5lZCcgKVxuXHRcdFx0e1xuXHRcdFx0XHR0aW55bWNlLnRyaWdnZXJTYXZlKCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgZGF0YSA9IG5ldyBGb3JtRGF0YSggdGhpcy4kZm9ybVsgMCBdICk7XG5cdFx0XHRkYXRhLmFwcGVuZCggXCJhY3Rpb25cIiwgVHV0b01WQy5wYXJzZUFjdGlvbiApO1xuXHRcdFx0ZGF0YS5hcHBlbmQoIFwibm9uY2VcIiwgVHV0b01WQy5wYXJzZU5vbmNlICk7XG5cdFx0XHRsZXQgdXJsICAgICAgICAgPSBUdXRvTVZDLnBhcnNlVVJMICsgXCImaWQ9XCIgKyB0aGlzLmlkICsgXCImdHlwZT1cIiArIHRoaXMudHlwZTtcblx0XHRcdGNvbnNvbGUubG9nKHVybCk7XG5cdFx0XHR2YXIgYWpheFJlcXVlc3QgPSBqUXVlcnkuYWpheCggdXJsLCB7XG5cdFx0XHRcdGRhdGE6ICAgICAgIGRhdGEsXG5cdFx0XHRcdG1ldGhvZDogICAgIFwiUE9TVFwiLFxuXHRcdFx0XHRjb250ZW50VHlwZTpmYWxzZSxcblx0XHRcdFx0cHJvY2Vzc0RhdGE6ZmFsc2UsXG5cdFx0XHRcdHN1Y2Nlc3M6ICAgICggcmVzdWx0ICkgPT4ge1xuXHRcdFx0XHRcdGlmKCByZXN1bHQgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRsZXQgJG1ldGFib3ggPSBqUXVlcnkoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlciggJG1ldGFib3guaHRtbCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogICAgICByZXN1bHQgPT4gY29uc29sZS5lcnJvciggcmVzdWx0IClcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblxuXHQvKiBTRVQgQU5EIEdFVCAqL1xuXHRnZXQgaWQoKTogc3RyaW5nXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fJGVsLmF0dHIoIFwiaWRcIiApO1xuXHR9XG5cblx0Z2V0ICRmb3JtKCk6IEpRdWVyeVxuXHR7XG5cdFx0cmV0dXJuIGpRdWVyeSggdGhpcy5fJGVsLmNsb3Nlc3QoIFwiZm9ybVwiICkgKTtcblx0fVxuXG5cdGdldCB0eXBlKCk6IHN0cmluZ1xuXHR7XG5cdFx0aWYoIHRoaXMuXyRlbC5oYXNDbGFzcyggXCJ0dXRvbXZjLW1ldGFib3hcIiApICkgcmV0dXJuIFwibWV0YWJveFwiO1xuXHRcdGlmKCB0aGlzLl8kZWwuaGFzQ2xhc3MoIFwidHV0b212Yy11c2VyX21ldGFib3hcIiApICkgcmV0dXJuIFwidXNlcl9tZXRhYm94XCI7XG5cdFx0aWYoIHRoaXMuXyRlbC5oYXNDbGFzcyggXCJ0dXRvbXZjLXNldHRpbmdzXCIgKSApIHJldHVybiBcInNldHRpbmdzXCI7XG5cdH1cbn0iLCJleHBvcnQgY2xhc3MgV1BBdHRhY2htZW50Rm9ybUlucHV0XG57XG5cdHB1YmxpYyAkZWw6IEpRdWVyeTtcblx0cHVibGljIG9wdGlvbnM6IElXUEF0dGFjaG1lbnRGb3JtSW5wdXRPcHRpb25zID0ge1xuXHRcdG1heDogICAgICAgLTEsXG5cdFx0dGl0bGU6ICAgICBcIlwiLFxuXHRcdGJ1dHRvblRleHQ6XCJcIixcblx0XHR0eXBlOiAgICAgIG51bGwsXG5cdFx0ZnJhbWU6ICAgICBcInNlbGVjdFwiXG5cdH07XG5cdHB1YmxpYyB3cE1lZGlhOiBhbnk7XG5cdHB1YmxpYyB0ZW1wbGF0ZTogYW55O1xuXG5cdGNvbnN0cnVjdG9yKCAkZWw6IEpRdWVyeSwgb3B0aW9uczogT2JqZWN0IClcblx0e1xuXHRcdHRoaXMuJGVsICAgICAgPSAkZWw7XG5cdFx0Ly8gTW9kZWxcblx0XHR0aGlzLm9wdGlvbnMgID0galF1ZXJ5LmV4dGVuZCgge30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyApO1xuXHRcdC8vIFZpZXdcblx0XHR0aGlzLnRlbXBsYXRlID0gXy50ZW1wbGF0ZSggPHN0cmluZz50aGlzLiRlbC5maW5kKCBcInRleHRhcmVhLnVuZGVyc2NvcmUtdGVtcGxhdGVcIiApLnZhbCgpICk7XG5cdFx0dGhpcy53cE1lZGlhICA9IHdwLm1lZGlhKCB7XG5cdFx0XHR0aXRsZTogICB0aGlzLm9wdGlvbnMudGl0bGUsXG5cdFx0XHRtdWx0aXBsZTp0aGlzLm9wdGlvbnMubWF4IDwgMCB8fCB0aGlzLm9wdGlvbnMubWF4ID4gMSA/IHRydWUgOiBmYWxzZSxcblx0XHRcdGxpYnJhcnk6IHRoaXMub3B0aW9ucy50eXBlID8ge3R5cGU6dGhpcy5vcHRpb25zLnR5cGV9IDogdW5kZWZpbmVkLFxuXHRcdFx0YnV0dG9uOiAge3RleHQ6dGhpcy5vcHRpb25zLmJ1dHRvblRleHR9LFxuXHRcdFx0ZnJhbWU6ICAgdGhpcy5vcHRpb25zLmZyYW1lXG5cdFx0fSApO1xuXHRcdC8vIENvbnRyb2xsZXJcblx0XHR0aGlzLndwTWVkaWEub24oIFwic2VsZWN0XCIsICgpID0+IHRoaXMub25XUE1lZGlhU2VsZWN0KCkgKTtcblx0XHR0aGlzLiRlbC5vbiggXCJjbGlja1wiLCBcIi5idG4tYWRkXCIsICgpID0+IHRoaXMub3BlbigpICk7XG5cdFx0dGhpcy4kZWwub24oIFwiY2xpY2tcIiwgXCIuYnRuLXJlbW92ZVwiLCAoIGUgKSA9PiB0aGlzLm9uUmVtb3ZlQ2xpY2soIGUgKSApO1xuXG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fVxuXG5cdHB1YmxpYyByZW5kZXIoKVxuXHR7XG5cdFx0aWYoIHRoaXMuY291bnQgPj0gdGhpcy5vcHRpb25zLm1heCAmJiB0aGlzLm9wdGlvbnMubWF4ID49IDAgKSB0aGlzLiRlbC5maW5kKCBcIi5idG4tYWRkXCIgKS5wcm9wKCBcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIiApO1xuXHRcdGVsc2UgdGhpcy4kZWwuZmluZCggXCIuYnRuLWFkZFwiICkucHJvcCggXCJkaXNhYmxlZFwiLCBudWxsICk7XG5cdH1cblxuXHRwdWJsaWMgb3BlbigpXG5cdHtcblx0XHR0aGlzLndwTWVkaWEub3BlbigpO1xuXHR9O1xuXG5cdHB1YmxpYyBhZGQoIGF0dGFjaG1lbnRNb2RlbDogV1BNZWRpYUF0dGFjaG1lbnRNb2RlbCApXG5cdHtcblx0XHRhdHRhY2htZW50TW9kZWwuc3JjID0gYXR0YWNobWVudE1vZGVsLmljb247XG5cdFx0aWYoICFhdHRhY2htZW50TW9kZWwud2lkdGggKSBhdHRhY2htZW50TW9kZWwud2lkdGggPSBcIlwiO1xuXHRcdGlmKCAhYXR0YWNobWVudE1vZGVsLmhlaWdodCApIGF0dGFjaG1lbnRNb2RlbC5oZWlnaHQgPSBcIlwiO1xuXHRcdGlmKCBhdHRhY2htZW50TW9kZWwuc2l6ZXMgKVxuXHRcdHtcblx0XHRcdGlmKCBhdHRhY2htZW50TW9kZWwuc2l6ZXMudGh1bWJuYWlsICYmIGF0dGFjaG1lbnRNb2RlbC5zaXplcy50aHVtYm5haWwudXJsIClcblx0XHRcdHtcblx0XHRcdFx0YXR0YWNobWVudE1vZGVsLnNyYyA9IGF0dGFjaG1lbnRNb2RlbC5zaXplcy50aHVtYm5haWwudXJsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiggYXR0YWNobWVudE1vZGVsLnNpemVzLmZ1bGwgJiYgYXR0YWNobWVudE1vZGVsLnNpemVzLmZ1bGwudXJsIClcblx0XHRcdHtcblx0XHRcdFx0YXR0YWNobWVudE1vZGVsLnNyYyA9IGF0dGFjaG1lbnRNb2RlbC5zaXplcy5mdWxsLnVybDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyICRlbCA9IGpRdWVyeSggdGhpcy50ZW1wbGF0ZSggYXR0YWNobWVudE1vZGVsICkgKTtcblx0XHR0aGlzLiRlbC5maW5kKCBcIi5saXN0LWdyb3VwXCIgKS5hcHBlbmQoICRlbCApO1xuXHR9O1xuXG5cdC8qIFNFVCBBTkQgR0VUICovXG5cdHB1YmxpYyBnZXQgY291bnQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuJGVsLmZpbmQoIFwiLmxpc3QtZ3JvdXAtaXRlbVwiICkubGVuZ3RoO1xuXHR9XG5cblx0LyogRVZFTlQgSEFORExFUlMgKi9cblx0cHJpdmF0ZSBvbldQTWVkaWFTZWxlY3QoKVxuXHR7XG5cdFx0dmFyIHNlbGVjdGlvbiA9IHRoaXMud3BNZWRpYS5zdGF0ZSgpLmdldCggJ3NlbGVjdGlvbicgKTtcblx0XHR2YXIgX190aGlzICAgID0gdGhpcztcblx0XHRzZWxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGF0dGFjaG1lbnQgKVxuXHRcdHtcblx0XHRcdGlmKCBfX3RoaXMub3B0aW9ucy5tYXggPCAwIHx8IF9fdGhpcy5jb3VudCA8IF9fdGhpcy5vcHRpb25zLm1heCApXG5cdFx0XHR7XG5cdFx0XHRcdF9fdGhpcy5hZGQoIGF0dGFjaG1lbnQudG9KU09OKCkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlbmRlcigpO1xuXHR9O1xuXG5cdHByaXZhdGUgb25SZW1vdmVDbGljayggZSApXG5cdHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dmFyICRlbCA9IGpRdWVyeSggZS5jdXJyZW50VGFyZ2V0ICk7XG5cdFx0JGVsLmNsb3Nlc3QoIFwiLmxpc3QtZ3JvdXAtaXRlbVwiICkucmVtb3ZlKCk7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElXUEF0dGFjaG1lbnRGb3JtSW5wdXRPcHRpb25zXG57XG5cdG1heDogbnVtYmVyO1xuXHR0aXRsZTogc3RyaW5nO1xuXHRidXR0b25UZXh0OiBzdHJpbmc7XG5cdHR5cGU6IHN0cmluZztcblx0ZnJhbWU6IHN0cmluZztcbn1cbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0aWQ6IG1vZHVsZUlkLFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJpbXBvcnQgXCIuLi9zY3NzL3R1dG9tdmMuc2Nzc1wiO1xuaW1wb3J0IFwic2NyaXB0LWxvYWRlciFib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuanNcIjtcbmltcG9ydCBcInNjcmlwdC1sb2FkZXIhc2VsZWN0Mi9kaXN0L2pzL3NlbGVjdDIuanNcIjtcbmltcG9ydCBcInNjcmlwdC1sb2FkZXIhYm9vdHN0cmFwLXNlbGVjdC9kaXN0L2pzL2Jvb3RzdHJhcC1zZWxlY3QuanNcIjtcbmltcG9ydCBcIi4vcGx1Z2lucy9qUXVlcnlXUEF0dGFjaG1lbnRGb3JtSW5wdXRcIjtcbmltcG9ydCBcIi4vcGx1Z2lucy9qUXVlcnlXUEVkaXRvckZvcm1JbnB1dFwiO1xuaW1wb3J0IFwiLi9wbHVnaW5zL2pRdWVyeVdQTWV0YUJveFwiO1xuXG4oZnVuY3Rpb24oICQgKVxue1xuXHQkKCBkb2N1bWVudCApLnJlYWR5KCBmdW5jdGlvbigpXG5cdHtcblx0XHQvLyBTZWxlY3QyRm9ybUlucHV0XG5cdFx0JCggXCIuZm9ybS1pbnB1dC1lbGVtZW50LnNlbGVjdDJcIiApLmVhY2goIGZ1bmN0aW9uKClcblx0XHR7XG5cdFx0XHQkKCB0aGlzICkuc2VsZWN0MiggJCggdGhpcyApLmRhdGEoKSApO1xuXHRcdH0gKTtcblx0fSApO1xufSkoIGpRdWVyeSApO1xuXG5jb25zb2xlLmxvZyhcIkhFTExPIFdPUkxEXCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9