/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js ***!
  \************************************************************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\r\n * Bootstrap-select v1.13.18 (https://developer.snapappointments.com/bootstrap-select)\r\n *\r\n * Copyright 2012-2020 SnapAppointments, LLC\r\n * Licensed under MIT (https://github.com/snapappointments/bootstrap-select/blob/master/LICENSE)\r\n */\r\n\r\n(function (root, factory) {\r\n  if (root === undefined && window !== undefined) root = window;\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module unless amdModuleId is set\r\n    define([\"jquery\"], function (a0) {\r\n      return (factory(a0));\r\n    });\r\n  } else if (typeof module === 'object' && module.exports) {\r\n    // Node. Does not work with strict CommonJS, but\r\n    // only CommonJS-like environments that support module.exports,\r\n    // like Node.\r\n    module.exports = factory(require(\"jquery\"));\r\n  } else {\r\n    factory(root[\"jQuery\"]);\r\n  }\r\n}(this, function (jQuery) {\r\n\r\n(function ($) {\r\n  'use strict';\r\n\r\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\r\n\r\n  var uriAttrs = [\r\n    'background',\r\n    'cite',\r\n    'href',\r\n    'itemtype',\r\n    'longdesc',\r\n    'poster',\r\n    'src',\r\n    'xlink:href'\r\n  ];\r\n\r\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\r\n\r\n  var DefaultWhitelist = {\r\n    // Global attributes allowed on any supplied element below.\r\n    '*': ['class', 'dir', 'id', 'lang', 'role', 'tabindex', 'style', ARIA_ATTRIBUTE_PATTERN],\r\n    a: ['target', 'href', 'title', 'rel'],\r\n    area: [],\r\n    b: [],\r\n    br: [],\r\n    col: [],\r\n    code: [],\r\n    div: [],\r\n    em: [],\r\n    hr: [],\r\n    h1: [],\r\n    h2: [],\r\n    h3: [],\r\n    h4: [],\r\n    h5: [],\r\n    h6: [],\r\n    i: [],\r\n    img: ['src', 'alt', 'title', 'width', 'height'],\r\n    li: [],\r\n    ol: [],\r\n    p: [],\r\n    pre: [],\r\n    s: [],\r\n    small: [],\r\n    span: [],\r\n    sub: [],\r\n    sup: [],\r\n    strong: [],\r\n    u: [],\r\n    ul: []\r\n  }\r\n\r\n  /**\r\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\r\n   *\r\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\r\n   */\r\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\r\n\r\n  /**\r\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\r\n   *\r\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\r\n   */\r\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;\r\n\r\n  function allowedAttribute (attr, allowedAttributeList) {\r\n    var attrName = attr.nodeName.toLowerCase()\r\n\r\n    if ($.inArray(attrName, allowedAttributeList) !== -1) {\r\n      if ($.inArray(attrName, uriAttrs) !== -1) {\r\n        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN))\r\n      }\r\n\r\n      return true\r\n    }\r\n\r\n    var regExp = $(allowedAttributeList).filter(function (index, value) {\r\n      return value instanceof RegExp\r\n    })\r\n\r\n    // Check if a regular expression validates the attribute.\r\n    for (var i = 0, l = regExp.length; i < l; i++) {\r\n      if (attrName.match(regExp[i])) {\r\n        return true\r\n      }\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  function sanitizeHtml (unsafeElements, whiteList, sanitizeFn) {\r\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\r\n      return sanitizeFn(unsafeElements);\r\n    }\r\n\r\n    var whitelistKeys = Object.keys(whiteList);\r\n\r\n    for (var i = 0, len = unsafeElements.length; i < len; i++) {\r\n      var elements = unsafeElements[i].querySelectorAll('*');\r\n\r\n      for (var j = 0, len2 = elements.length; j < len2; j++) {\r\n        var el = elements[j];\r\n        var elName = el.nodeName.toLowerCase();\r\n\r\n        if (whitelistKeys.indexOf(elName) === -1) {\r\n          el.parentNode.removeChild(el);\r\n\r\n          continue;\r\n        }\r\n\r\n        var attributeList = [].slice.call(el.attributes);\r\n        var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\r\n\r\n        for (var k = 0, len3 = attributeList.length; k < len3; k++) {\r\n          var attr = attributeList[k];\r\n\r\n          if (!allowedAttribute(attr, whitelistedAttributes)) {\r\n            el.removeAttribute(attr.nodeName);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Polyfill for browsers with no classList support\r\n  // Remove in v2\r\n  if (!('classList' in document.createElement('_'))) {\r\n    (function (view) {\r\n      if (!('Element' in view)) return;\r\n\r\n      var classListProp = 'classList',\r\n          protoProp = 'prototype',\r\n          elemCtrProto = view.Element[protoProp],\r\n          objCtr = Object,\r\n          classListGetter = function () {\r\n            var $elem = $(this);\r\n\r\n            return {\r\n              add: function (classes) {\r\n                classes = Array.prototype.slice.call(arguments).join(' ');\r\n                return $elem.addClass(classes);\r\n              },\r\n              remove: function (classes) {\r\n                classes = Array.prototype.slice.call(arguments).join(' ');\r\n                return $elem.removeClass(classes);\r\n              },\r\n              toggle: function (classes, force) {\r\n                return $elem.toggleClass(classes, force);\r\n              },\r\n              contains: function (classes) {\r\n                return $elem.hasClass(classes);\r\n              }\r\n            }\r\n          };\r\n\r\n      if (objCtr.defineProperty) {\r\n        var classListPropDesc = {\r\n          get: classListGetter,\r\n          enumerable: true,\r\n          configurable: true\r\n        };\r\n        try {\r\n          objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\r\n        } catch (ex) { // IE 8 doesn't support enumerable:true\r\n          // adding undefined to fight this issue https://github.com/eligrey/classList.js/issues/36\r\n          // modernie IE8-MSW7 machine has IE8 8.0.6001.18702 and is affected\r\n          if (ex.number === undefined || ex.number === -0x7FF5EC54) {\r\n            classListPropDesc.enumerable = false;\r\n            objCtr.defineProperty(elemCtrProto, classListProp, classListPropDesc);\r\n          }\r\n        }\r\n      } else if (objCtr[protoProp].__defineGetter__) {\r\n        elemCtrProto.__defineGetter__(classListProp, classListGetter);\r\n      }\r\n    }(window));\r\n  }\r\n\r\n  var testElement = document.createElement('_');\r\n\r\n  testElement.classList.add('c1', 'c2');\r\n\r\n  if (!testElement.classList.contains('c2')) {\r\n    var _add = DOMTokenList.prototype.add,\r\n        _remove = DOMTokenList.prototype.remove;\r\n\r\n    DOMTokenList.prototype.add = function () {\r\n      Array.prototype.forEach.call(arguments, _add.bind(this));\r\n    }\r\n\r\n    DOMTokenList.prototype.remove = function () {\r\n      Array.prototype.forEach.call(arguments, _remove.bind(this));\r\n    }\r\n  }\r\n\r\n  testElement.classList.toggle('c3', false);\r\n\r\n  // Polyfill for IE 10 and Firefox <24, where classList.toggle does not\r\n  // support the second argument.\r\n  if (testElement.classList.contains('c3')) {\r\n    var _toggle = DOMTokenList.prototype.toggle;\r\n\r\n    DOMTokenList.prototype.toggle = function (token, force) {\r\n      if (1 in arguments && !this.contains(token) === !force) {\r\n        return force;\r\n      } else {\r\n        return _toggle.call(this, token);\r\n      }\r\n    };\r\n  }\r\n\r\n  testElement = null;\r\n\r\n  // shallow array comparison\r\n  function isEqual (array1, array2) {\r\n    return array1.length === array2.length && array1.every(function (element, index) {\r\n      return element === array2[index];\r\n    });\r\n  };\r\n\r\n  // <editor-fold desc=\"Shims\">\r\n  if (!String.prototype.startsWith) {\r\n    (function () {\r\n      'use strict'; // needed to support `apply`/`call` with `undefined`/`null`\r\n      var defineProperty = (function () {\r\n        // IE 8 only supports `Object.defineProperty` on DOM elements\r\n        try {\r\n          var object = {};\r\n          var $defineProperty = Object.defineProperty;\r\n          var result = $defineProperty(object, object, object) && $defineProperty;\r\n        } catch (error) {\r\n        }\r\n        return result;\r\n      }());\r\n      var toString = {}.toString;\r\n      var startsWith = function (search) {\r\n        if (this == null) {\r\n          throw new TypeError();\r\n        }\r\n        var string = String(this);\r\n        if (search && toString.call(search) == '[object RegExp]') {\r\n          throw new TypeError();\r\n        }\r\n        var stringLength = string.length;\r\n        var searchString = String(search);\r\n        var searchLength = searchString.length;\r\n        var position = arguments.length > 1 ? arguments[1] : undefined;\r\n        // `ToInteger`\r\n        var pos = position ? Number(position) : 0;\r\n        if (pos != pos) { // better `isNaN`\r\n          pos = 0;\r\n        }\r\n        var start = Math.min(Math.max(pos, 0), stringLength);\r\n        // Avoid the `indexOf` call if no match is possible\r\n        if (searchLength + start > stringLength) {\r\n          return false;\r\n        }\r\n        var index = -1;\r\n        while (++index < searchLength) {\r\n          if (string.charCodeAt(start + index) != searchString.charCodeAt(index)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      };\r\n      if (defineProperty) {\r\n        defineProperty(String.prototype, 'startsWith', {\r\n          'value': startsWith,\r\n          'configurable': true,\r\n          'writable': true\r\n        });\r\n      } else {\r\n        String.prototype.startsWith = startsWith;\r\n      }\r\n    }());\r\n  }\r\n\r\n  if (!Object.keys) {\r\n    Object.keys = function (\r\n      o, // object\r\n      k, // key\r\n      r  // result array\r\n    ) {\r\n      // initialize object and result\r\n      r = [];\r\n      // iterate over object keys\r\n      for (k in o) {\r\n        // fill result array with non-prototypical keys\r\n        r.hasOwnProperty.call(o, k) && r.push(k);\r\n      }\r\n      // return result\r\n      return r;\r\n    };\r\n  }\r\n\r\n  if (HTMLSelectElement && !HTMLSelectElement.prototype.hasOwnProperty('selectedOptions')) {\r\n    Object.defineProperty(HTMLSelectElement.prototype, 'selectedOptions', {\r\n      get: function () {\r\n        return this.querySelectorAll(':checked');\r\n      }\r\n    });\r\n  }\r\n\r\n  function getSelectedOptions (select, ignoreDisabled) {\r\n    var selectedOptions = select.selectedOptions,\r\n        options = [],\r\n        opt;\r\n\r\n    if (ignoreDisabled) {\r\n      for (var i = 0, len = selectedOptions.length; i < len; i++) {\r\n        opt = selectedOptions[i];\r\n\r\n        if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {\r\n          options.push(opt);\r\n        }\r\n      }\r\n\r\n      return options;\r\n    }\r\n\r\n    return selectedOptions;\r\n  }\r\n\r\n  // much faster than $.val()\r\n  function getSelectValues (select, selectedOptions) {\r\n    var value = [],\r\n        options = selectedOptions || select.selectedOptions,\r\n        opt;\r\n\r\n    for (var i = 0, len = options.length; i < len; i++) {\r\n      opt = options[i];\r\n\r\n      if (!(opt.disabled || opt.parentNode.tagName === 'OPTGROUP' && opt.parentNode.disabled)) {\r\n        value.push(opt.value);\r\n      }\r\n    }\r\n\r\n    if (!select.multiple) {\r\n      return !value.length ? null : value[0];\r\n    }\r\n\r\n    return value;\r\n  }\r\n\r\n  // set data-selected on select element if the value has been programmatically selected\r\n  // prior to initialization of bootstrap-select\r\n  // * consider removing or replacing an alternative method *\r\n  var valHooks = {\r\n    useDefault: false,\r\n    _set: $.valHooks.select.set\r\n  };\r\n\r\n  $.valHooks.select.set = function (elem, value) {\r\n    if (value && !valHooks.useDefault) $(elem).data('selected', true);\r\n\r\n    return valHooks._set.apply(this, arguments);\r\n  };\r\n\r\n  var changedArguments = null;\r\n\r\n  var EventIsSupported = (function () {\r\n    try {\r\n      new Event('change');\r\n      return true;\r\n    } catch (e) {\r\n      return false;\r\n    }\r\n  })();\r\n\r\n  $.fn.triggerNative = function (eventName) {\r\n    var el = this[0],\r\n        event;\r\n\r\n    if (el.dispatchEvent) { // for modern browsers & IE9+\r\n      if (EventIsSupported) {\r\n        // For modern browsers\r\n        event = new Event(eventName, {\r\n          bubbles: true\r\n        });\r\n      } else {\r\n        // For IE since it doesn't support Event constructor\r\n        event = document.createEvent('Event');\r\n        event.initEvent(eventName, true, false);\r\n      }\r\n\r\n      el.dispatchEvent(event);\r\n    } else if (el.fireEvent) { // for IE8\r\n      event = document.createEventObject();\r\n      event.eventType = eventName;\r\n      el.fireEvent('on' + eventName, event);\r\n    } else {\r\n      // fall back to jQuery.trigger\r\n      this.trigger(eventName);\r\n    }\r\n  };\r\n  // </editor-fold>\r\n\r\n  function stringSearch (li, searchString, method, normalize) {\r\n    var stringTypes = [\r\n          'display',\r\n          'subtext',\r\n          'tokens'\r\n        ],\r\n        searchSuccess = false;\r\n\r\n    for (var i = 0; i < stringTypes.length; i++) {\r\n      var stringType = stringTypes[i],\r\n          string = li[stringType];\r\n\r\n      if (string) {\r\n        string = string.toString();\r\n\r\n        // Strip HTML tags. This isn't perfect, but it's much faster than any other method\r\n        if (stringType === 'display') {\r\n          string = string.replace(/<[^>]+>/g, '');\r\n        }\r\n\r\n        if (normalize) string = normalizeToBase(string);\r\n        string = string.toUpperCase();\r\n\r\n        if (method === 'contains') {\r\n          searchSuccess = string.indexOf(searchString) >= 0;\r\n        } else {\r\n          searchSuccess = string.startsWith(searchString);\r\n        }\r\n\r\n        if (searchSuccess) break;\r\n      }\r\n    }\r\n\r\n    return searchSuccess;\r\n  }\r\n\r\n  function toInteger (value) {\r\n    return parseInt(value, 10) || 0;\r\n  }\r\n\r\n  // Borrowed from Lodash (_.deburr)\r\n  /** Used to map Latin Unicode letters to basic Latin letters. */\r\n  var deburredLetters = {\r\n    // Latin-1 Supplement block.\r\n    '\\xc0': 'A',  '\\xc1': 'A', '\\xc2': 'A', '\\xc3': 'A', '\\xc4': 'A', '\\xc5': 'A',\r\n    '\\xe0': 'a',  '\\xe1': 'a', '\\xe2': 'a', '\\xe3': 'a', '\\xe4': 'a', '\\xe5': 'a',\r\n    '\\xc7': 'C',  '\\xe7': 'c',\r\n    '\\xd0': 'D',  '\\xf0': 'd',\r\n    '\\xc8': 'E',  '\\xc9': 'E', '\\xca': 'E', '\\xcb': 'E',\r\n    '\\xe8': 'e',  '\\xe9': 'e', '\\xea': 'e', '\\xeb': 'e',\r\n    '\\xcc': 'I',  '\\xcd': 'I', '\\xce': 'I', '\\xcf': 'I',\r\n    '\\xec': 'i',  '\\xed': 'i', '\\xee': 'i', '\\xef': 'i',\r\n    '\\xd1': 'N',  '\\xf1': 'n',\r\n    '\\xd2': 'O',  '\\xd3': 'O', '\\xd4': 'O', '\\xd5': 'O', '\\xd6': 'O', '\\xd8': 'O',\r\n    '\\xf2': 'o',  '\\xf3': 'o', '\\xf4': 'o', '\\xf5': 'o', '\\xf6': 'o', '\\xf8': 'o',\r\n    '\\xd9': 'U',  '\\xda': 'U', '\\xdb': 'U', '\\xdc': 'U',\r\n    '\\xf9': 'u',  '\\xfa': 'u', '\\xfb': 'u', '\\xfc': 'u',\r\n    '\\xdd': 'Y',  '\\xfd': 'y', '\\xff': 'y',\r\n    '\\xc6': 'Ae', '\\xe6': 'ae',\r\n    '\\xde': 'Th', '\\xfe': 'th',\r\n    '\\xdf': 'ss',\r\n    // Latin Extended-A block.\r\n    '\\u0100': 'A',  '\\u0102': 'A', '\\u0104': 'A',\r\n    '\\u0101': 'a',  '\\u0103': 'a', '\\u0105': 'a',\r\n    '\\u0106': 'C',  '\\u0108': 'C', '\\u010a': 'C', '\\u010c': 'C',\r\n    '\\u0107': 'c',  '\\u0109': 'c', '\\u010b': 'c', '\\u010d': 'c',\r\n    '\\u010e': 'D',  '\\u0110': 'D', '\\u010f': 'd', '\\u0111': 'd',\r\n    '\\u0112': 'E',  '\\u0114': 'E', '\\u0116': 'E', '\\u0118': 'E', '\\u011a': 'E',\r\n    '\\u0113': 'e',  '\\u0115': 'e', '\\u0117': 'e', '\\u0119': 'e', '\\u011b': 'e',\r\n    '\\u011c': 'G',  '\\u011e': 'G', '\\u0120': 'G', '\\u0122': 'G',\r\n    '\\u011d': 'g',  '\\u011f': 'g', '\\u0121': 'g', '\\u0123': 'g',\r\n    '\\u0124': 'H',  '\\u0126': 'H', '\\u0125': 'h', '\\u0127': 'h',\r\n    '\\u0128': 'I',  '\\u012a': 'I', '\\u012c': 'I', '\\u012e': 'I', '\\u0130': 'I',\r\n    '\\u0129': 'i',  '\\u012b': 'i', '\\u012d': 'i', '\\u012f': 'i', '\\u0131': 'i',\r\n    '\\u0134': 'J',  '\\u0135': 'j',\r\n    '\\u0136': 'K',  '\\u0137': 'k', '\\u0138': 'k',\r\n    '\\u0139': 'L',  '\\u013b': 'L', '\\u013d': 'L', '\\u013f': 'L', '\\u0141': 'L',\r\n    '\\u013a': 'l',  '\\u013c': 'l', '\\u013e': 'l', '\\u0140': 'l', '\\u0142': 'l',\r\n    '\\u0143': 'N',  '\\u0145': 'N', '\\u0147': 'N', '\\u014a': 'N',\r\n    '\\u0144': 'n',  '\\u0146': 'n', '\\u0148': 'n', '\\u014b': 'n',\r\n    '\\u014c': 'O',  '\\u014e': 'O', '\\u0150': 'O',\r\n    '\\u014d': 'o',  '\\u014f': 'o', '\\u0151': 'o',\r\n    '\\u0154': 'R',  '\\u0156': 'R', '\\u0158': 'R',\r\n    '\\u0155': 'r',  '\\u0157': 'r', '\\u0159': 'r',\r\n    '\\u015a': 'S',  '\\u015c': 'S', '\\u015e': 'S', '\\u0160': 'S',\r\n    '\\u015b': 's',  '\\u015d': 's', '\\u015f': 's', '\\u0161': 's',\r\n    '\\u0162': 'T',  '\\u0164': 'T', '\\u0166': 'T',\r\n    '\\u0163': 't',  '\\u0165': 't', '\\u0167': 't',\r\n    '\\u0168': 'U',  '\\u016a': 'U', '\\u016c': 'U', '\\u016e': 'U', '\\u0170': 'U', '\\u0172': 'U',\r\n    '\\u0169': 'u',  '\\u016b': 'u', '\\u016d': 'u', '\\u016f': 'u', '\\u0171': 'u', '\\u0173': 'u',\r\n    '\\u0174': 'W',  '\\u0175': 'w',\r\n    '\\u0176': 'Y',  '\\u0177': 'y', '\\u0178': 'Y',\r\n    '\\u0179': 'Z',  '\\u017b': 'Z', '\\u017d': 'Z',\r\n    '\\u017a': 'z',  '\\u017c': 'z', '\\u017e': 'z',\r\n    '\\u0132': 'IJ', '\\u0133': 'ij',\r\n    '\\u0152': 'Oe', '\\u0153': 'oe',\r\n    '\\u0149': \"'n\", '\\u017f': 's'\r\n  };\r\n\r\n  /** Used to match Latin Unicode letters (excluding mathematical operators). */\r\n  var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\r\n\r\n  /** Used to compose unicode character classes. */\r\n  var rsComboMarksRange = '\\\\u0300-\\\\u036f',\r\n      reComboHalfMarksRange = '\\\\ufe20-\\\\ufe2f',\r\n      rsComboSymbolsRange = '\\\\u20d0-\\\\u20ff',\r\n      rsComboMarksExtendedRange = '\\\\u1ab0-\\\\u1aff',\r\n      rsComboMarksSupplementRange = '\\\\u1dc0-\\\\u1dff',\r\n      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange + rsComboMarksExtendedRange + rsComboMarksSupplementRange;\r\n\r\n  /** Used to compose unicode capture groups. */\r\n  var rsCombo = '[' + rsComboRange + ']';\r\n\r\n  /**\r\n   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and\r\n   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).\r\n   */\r\n  var reComboMark = RegExp(rsCombo, 'g');\r\n\r\n  function deburrLetter (key) {\r\n    return deburredLetters[key];\r\n  };\r\n\r\n  function normalizeToBase (string) {\r\n    string = string.toString();\r\n    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');\r\n  }\r\n\r\n  // List of HTML entities for escaping.\r\n  var escapeMap = {\r\n    '&': '&amp;',\r\n    '<': '&lt;',\r\n    '>': '&gt;',\r\n    '\"': '&quot;',\r\n    \"'\": '&#x27;',\r\n    '`': '&#x60;'\r\n  };\r\n\r\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\r\n  var createEscaper = function (map) {\r\n    var escaper = function (match) {\r\n      return map[match];\r\n    };\r\n    // Regexes for identifying a key that needs to be escaped.\r\n    var source = '(?:' + Object.keys(map).join('|') + ')';\r\n    var testRegexp = RegExp(source);\r\n    var replaceRegexp = RegExp(source, 'g');\r\n    return function (string) {\r\n      string = string == null ? '' : '' + string;\r\n      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;\r\n    };\r\n  };\r\n\r\n  var htmlEscape = createEscaper(escapeMap);\r\n\r\n  /**\r\n   * ------------------------------------------------------------------------\r\n   * Constants\r\n   * ------------------------------------------------------------------------\r\n   */\r\n\r\n  var keyCodeMap = {\r\n    32: ' ',\r\n    48: '0',\r\n    49: '1',\r\n    50: '2',\r\n    51: '3',\r\n    52: '4',\r\n    53: '5',\r\n    54: '6',\r\n    55: '7',\r\n    56: '8',\r\n    57: '9',\r\n    59: ';',\r\n    65: 'A',\r\n    66: 'B',\r\n    67: 'C',\r\n    68: 'D',\r\n    69: 'E',\r\n    70: 'F',\r\n    71: 'G',\r\n    72: 'H',\r\n    73: 'I',\r\n    74: 'J',\r\n    75: 'K',\r\n    76: 'L',\r\n    77: 'M',\r\n    78: 'N',\r\n    79: 'O',\r\n    80: 'P',\r\n    81: 'Q',\r\n    82: 'R',\r\n    83: 'S',\r\n    84: 'T',\r\n    85: 'U',\r\n    86: 'V',\r\n    87: 'W',\r\n    88: 'X',\r\n    89: 'Y',\r\n    90: 'Z',\r\n    96: '0',\r\n    97: '1',\r\n    98: '2',\r\n    99: '3',\r\n    100: '4',\r\n    101: '5',\r\n    102: '6',\r\n    103: '7',\r\n    104: '8',\r\n    105: '9'\r\n  };\r\n\r\n  var keyCodes = {\r\n    ESCAPE: 27, // KeyboardEvent.which value for Escape (Esc) key\r\n    ENTER: 13, // KeyboardEvent.which value for Enter key\r\n    SPACE: 32, // KeyboardEvent.which value for space key\r\n    TAB: 9, // KeyboardEvent.which value for tab key\r\n    ARROW_UP: 38, // KeyboardEvent.which value for up arrow key\r\n    ARROW_DOWN: 40 // KeyboardEvent.which value for down arrow key\r\n  }\r\n\r\n  var version = {\r\n    success: false,\r\n    major: '3'\r\n  };\r\n\r\n  try {\r\n    version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');\r\n    version.major = version.full[0];\r\n    version.success = true;\r\n  } catch (err) {\r\n    // do nothing\r\n  }\r\n\r\n  var selectId = 0;\r\n\r\n  var EVENT_KEY = '.bs.select';\r\n\r\n  var classNames = {\r\n    DISABLED: 'disabled',\r\n    DIVIDER: 'divider',\r\n    SHOW: 'open',\r\n    DROPUP: 'dropup',\r\n    MENU: 'dropdown-menu',\r\n    MENURIGHT: 'dropdown-menu-right',\r\n    MENULEFT: 'dropdown-menu-left',\r\n    // to-do: replace with more advanced template/customization options\r\n    BUTTONCLASS: 'btn-default',\r\n    POPOVERHEADER: 'popover-title',\r\n    ICONBASE: 'glyphicon',\r\n    TICKICON: 'glyphicon-ok'\r\n  }\r\n\r\n  var Selector = {\r\n    MENU: '.' + classNames.MENU\r\n  }\r\n\r\n  var elementTemplates = {\r\n    div: document.createElement('div'),\r\n    span: document.createElement('span'),\r\n    i: document.createElement('i'),\r\n    subtext: document.createElement('small'),\r\n    a: document.createElement('a'),\r\n    li: document.createElement('li'),\r\n    whitespace: document.createTextNode('\\u00A0'),\r\n    fragment: document.createDocumentFragment()\r\n  }\r\n\r\n  elementTemplates.noResults = elementTemplates.li.cloneNode(false);\r\n  elementTemplates.noResults.className = 'no-results';\r\n\r\n  elementTemplates.a.setAttribute('role', 'option');\r\n  elementTemplates.a.className = 'dropdown-item';\r\n\r\n  elementTemplates.subtext.className = 'text-muted';\r\n\r\n  elementTemplates.text = elementTemplates.span.cloneNode(false);\r\n  elementTemplates.text.className = 'text';\r\n\r\n  elementTemplates.checkMark = elementTemplates.span.cloneNode(false);\r\n\r\n  var REGEXP_ARROW = new RegExp(keyCodes.ARROW_UP + '|' + keyCodes.ARROW_DOWN);\r\n  var REGEXP_TAB_OR_ESCAPE = new RegExp('^' + keyCodes.TAB + '$|' + keyCodes.ESCAPE);\r\n\r\n  var generateOption = {\r\n    li: function (content, classes, optgroup) {\r\n      var li = elementTemplates.li.cloneNode(false);\r\n\r\n      if (content) {\r\n        if (content.nodeType === 1 || content.nodeType === 11) {\r\n          li.appendChild(content);\r\n        } else {\r\n          li.innerHTML = content;\r\n        }\r\n      }\r\n\r\n      if (typeof classes !== 'undefined' && classes !== '') li.className = classes;\r\n      if (typeof optgroup !== 'undefined' && optgroup !== null) li.classList.add('optgroup-' + optgroup);\r\n\r\n      return li;\r\n    },\r\n\r\n    a: function (text, classes, inline) {\r\n      var a = elementTemplates.a.cloneNode(true);\r\n\r\n      if (text) {\r\n        if (text.nodeType === 11) {\r\n          a.appendChild(text);\r\n        } else {\r\n          a.insertAdjacentHTML('beforeend', text);\r\n        }\r\n      }\r\n\r\n      if (typeof classes !== 'undefined' && classes !== '') a.classList.add.apply(a.classList, classes.split(/\\s+/));\r\n      if (inline) a.setAttribute('style', inline);\r\n\r\n      return a;\r\n    },\r\n\r\n    text: function (options, useFragment) {\r\n      var textElement = elementTemplates.text.cloneNode(false),\r\n          subtextElement,\r\n          iconElement;\r\n\r\n      if (options.content) {\r\n        textElement.innerHTML = options.content;\r\n      } else {\r\n        textElement.textContent = options.text;\r\n\r\n        if (options.icon) {\r\n          var whitespace = elementTemplates.whitespace.cloneNode(false);\r\n\r\n          // need to use <i> for icons in the button to prevent a breaking change\r\n          // note: switch to span in next major release\r\n          iconElement = (useFragment === true ? elementTemplates.i : elementTemplates.span).cloneNode(false);\r\n          iconElement.className = this.options.iconBase + ' ' + options.icon;\r\n\r\n          elementTemplates.fragment.appendChild(iconElement);\r\n          elementTemplates.fragment.appendChild(whitespace);\r\n        }\r\n\r\n        if (options.subtext) {\r\n          subtextElement = elementTemplates.subtext.cloneNode(false);\r\n          subtextElement.textContent = options.subtext;\r\n          textElement.appendChild(subtextElement);\r\n        }\r\n      }\r\n\r\n      if (useFragment === true) {\r\n        while (textElement.childNodes.length > 0) {\r\n          elementTemplates.fragment.appendChild(textElement.childNodes[0]);\r\n        }\r\n      } else {\r\n        elementTemplates.fragment.appendChild(textElement);\r\n      }\r\n\r\n      return elementTemplates.fragment;\r\n    },\r\n\r\n    label: function (options) {\r\n      var textElement = elementTemplates.text.cloneNode(false),\r\n          subtextElement,\r\n          iconElement;\r\n\r\n      textElement.innerHTML = options.display;\r\n\r\n      if (options.icon) {\r\n        var whitespace = elementTemplates.whitespace.cloneNode(false);\r\n\r\n        iconElement = elementTemplates.span.cloneNode(false);\r\n        iconElement.className = this.options.iconBase + ' ' + options.icon;\r\n\r\n        elementTemplates.fragment.appendChild(iconElement);\r\n        elementTemplates.fragment.appendChild(whitespace);\r\n      }\r\n\r\n      if (options.subtext) {\r\n        subtextElement = elementTemplates.subtext.cloneNode(false);\r\n        subtextElement.textContent = options.subtext;\r\n        textElement.appendChild(subtextElement);\r\n      }\r\n\r\n      elementTemplates.fragment.appendChild(textElement);\r\n\r\n      return elementTemplates.fragment;\r\n    }\r\n  }\r\n\r\n  function showNoResults (searchMatch, searchValue) {\r\n    if (!searchMatch.length) {\r\n      elementTemplates.noResults.innerHTML = this.options.noneResultsText.replace('{0}', '\"' + htmlEscape(searchValue) + '\"');\r\n      this.$menuInner[0].firstChild.appendChild(elementTemplates.noResults);\r\n    }\r\n  }\r\n\r\n  var Selectpicker = function (element, options) {\r\n    var that = this;\r\n\r\n    // bootstrap-select has been initialized - revert valHooks.select.set back to its original function\r\n    if (!valHooks.useDefault) {\r\n      $.valHooks.select.set = valHooks._set;\r\n      valHooks.useDefault = true;\r\n    }\r\n\r\n    this.$element = $(element);\r\n    this.$newElement = null;\r\n    this.$button = null;\r\n    this.$menu = null;\r\n    this.options = options;\r\n    this.selectpicker = {\r\n      main: {},\r\n      search: {},\r\n      current: {}, // current changes if a search is in progress\r\n      view: {},\r\n      isSearching: false,\r\n      keydown: {\r\n        keyHistory: '',\r\n        resetKeyHistory: {\r\n          start: function () {\r\n            return setTimeout(function () {\r\n              that.selectpicker.keydown.keyHistory = '';\r\n            }, 800);\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.sizeInfo = {};\r\n\r\n    // If we have no title yet, try to pull it from the html title attribute (jQuery doesnt' pick it up as it's not a\r\n    // data-attribute)\r\n    if (this.options.title === null) {\r\n      this.options.title = this.$element.attr('title');\r\n    }\r\n\r\n    // Format window padding\r\n    var winPad = this.options.windowPadding;\r\n    if (typeof winPad === 'number') {\r\n      this.options.windowPadding = [winPad, winPad, winPad, winPad];\r\n    }\r\n\r\n    // Expose public methods\r\n    this.val = Selectpicker.prototype.val;\r\n    this.render = Selectpicker.prototype.render;\r\n    this.refresh = Selectpicker.prototype.refresh;\r\n    this.setStyle = Selectpicker.prototype.setStyle;\r\n    this.selectAll = Selectpicker.prototype.selectAll;\r\n    this.deselectAll = Selectpicker.prototype.deselectAll;\r\n    this.destroy = Selectpicker.prototype.destroy;\r\n    this.remove = Selectpicker.prototype.remove;\r\n    this.show = Selectpicker.prototype.show;\r\n    this.hide = Selectpicker.prototype.hide;\r\n\r\n    this.init();\r\n  };\r\n\r\n  Selectpicker.VERSION = '1.13.18';\r\n\r\n  // part of this is duplicated in i18n/defaults-en_US.js. Make sure to update both.\r\n  Selectpicker.DEFAULTS = {\r\n    noneSelectedText: 'Nothing selected',\r\n    noneResultsText: 'No results matched {0}',\r\n    countSelectedText: function (numSelected, numTotal) {\r\n      return (numSelected == 1) ? '{0} item selected' : '{0} items selected';\r\n    },\r\n    maxOptionsText: function (numAll, numGroup) {\r\n      return [\r\n        (numAll == 1) ? 'Limit reached ({n} item max)' : 'Limit reached ({n} items max)',\r\n        (numGroup == 1) ? 'Group limit reached ({n} item max)' : 'Group limit reached ({n} items max)'\r\n      ];\r\n    },\r\n    selectAllText: 'Select All',\r\n    deselectAllText: 'Deselect All',\r\n    doneButton: false,\r\n    doneButtonText: 'Close',\r\n    multipleSeparator: ', ',\r\n    styleBase: 'btn',\r\n    style: classNames.BUTTONCLASS,\r\n    size: 'auto',\r\n    title: null,\r\n    selectedTextFormat: 'values',\r\n    width: false,\r\n    container: false,\r\n    hideDisabled: false,\r\n    showSubtext: false,\r\n    showIcon: true,\r\n    showContent: true,\r\n    dropupAuto: true,\r\n    header: false,\r\n    liveSearch: false,\r\n    liveSearchPlaceholder: null,\r\n    liveSearchNormalize: false,\r\n    liveSearchStyle: 'contains',\r\n    actionsBox: false,\r\n    iconBase: classNames.ICONBASE,\r\n    tickIcon: classNames.TICKICON,\r\n    showTick: false,\r\n    template: {\r\n      caret: '<span class=\"caret\"></span>'\r\n    },\r\n    maxOptions: false,\r\n    mobile: false,\r\n    selectOnTab: false,\r\n    dropdownAlignRight: false,\r\n    windowPadding: 0,\r\n    virtualScroll: 600,\r\n    display: false,\r\n    sanitize: true,\r\n    sanitizeFn: null,\r\n    whiteList: DefaultWhitelist\r\n  };\r\n\r\n  Selectpicker.prototype = {\r\n\r\n    constructor: Selectpicker,\r\n\r\n    init: function () {\r\n      var that = this,\r\n          id = this.$element.attr('id'),\r\n          element = this.$element[0],\r\n          form = element.form;\r\n\r\n      selectId++;\r\n      this.selectId = 'bs-select-' + selectId;\r\n\r\n      element.classList.add('bs-select-hidden');\r\n\r\n      this.multiple = this.$element.prop('multiple');\r\n      this.autofocus = this.$element.prop('autofocus');\r\n\r\n      if (element.classList.contains('show-tick')) {\r\n        this.options.showTick = true;\r\n      }\r\n\r\n      this.$newElement = this.createDropdown();\r\n      this.buildData();\r\n      this.$element\r\n        .after(this.$newElement)\r\n        .prependTo(this.$newElement);\r\n\r\n      // ensure select is associated with form element if it got unlinked after moving it inside newElement\r\n      if (form && element.form === null) {\r\n        if (!form.id) form.id = 'form-' + this.selectId;\r\n        element.setAttribute('form', form.id);\r\n      }\r\n\r\n      this.$button = this.$newElement.children('button');\r\n      this.$menu = this.$newElement.children(Selector.MENU);\r\n      this.$menuInner = this.$menu.children('.inner');\r\n      this.$searchbox = this.$menu.find('input');\r\n\r\n      element.classList.remove('bs-select-hidden');\r\n\r\n      if (this.options.dropdownAlignRight === true) this.$menu[0].classList.add(classNames.MENURIGHT);\r\n\r\n      if (typeof id !== 'undefined') {\r\n        this.$button.attr('data-id', id);\r\n      }\r\n\r\n      this.checkDisabled();\r\n      this.clickListener();\r\n\r\n      if (this.options.liveSearch) {\r\n        this.liveSearchListener();\r\n        this.focusedParent = this.$searchbox[0];\r\n      } else {\r\n        this.focusedParent = this.$menuInner[0];\r\n      }\r\n\r\n      this.setStyle();\r\n      this.render();\r\n      this.setWidth();\r\n      if (this.options.container) {\r\n        this.selectPosition();\r\n      } else {\r\n        this.$element.on('hide' + EVENT_KEY, function () {\r\n          if (that.isVirtual()) {\r\n            // empty menu on close\r\n            var menuInner = that.$menuInner[0],\r\n                emptyMenu = menuInner.firstChild.cloneNode(false);\r\n\r\n            // replace the existing UL with an empty one - this is faster than $.empty() or innerHTML = ''\r\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\r\n            menuInner.scrollTop = 0;\r\n          }\r\n        });\r\n      }\r\n      this.$menu.data('this', this);\r\n      this.$newElement.data('this', this);\r\n      if (this.options.mobile) this.mobile();\r\n\r\n      this.$newElement.on({\r\n        'hide.bs.dropdown': function (e) {\r\n          that.$element.trigger('hide' + EVENT_KEY, e);\r\n        },\r\n        'hidden.bs.dropdown': function (e) {\r\n          that.$element.trigger('hidden' + EVENT_KEY, e);\r\n        },\r\n        'show.bs.dropdown': function (e) {\r\n          that.$element.trigger('show' + EVENT_KEY, e);\r\n        },\r\n        'shown.bs.dropdown': function (e) {\r\n          that.$element.trigger('shown' + EVENT_KEY, e);\r\n        }\r\n      });\r\n\r\n      if (element.hasAttribute('required')) {\r\n        this.$element.on('invalid' + EVENT_KEY, function () {\r\n          that.$button[0].classList.add('bs-invalid');\r\n\r\n          that.$element\r\n            .on('shown' + EVENT_KEY + '.invalid', function () {\r\n              that.$element\r\n                .val(that.$element.val()) // set the value to hide the validation message in Chrome when menu is opened\r\n                .off('shown' + EVENT_KEY + '.invalid');\r\n            })\r\n            .on('rendered' + EVENT_KEY, function () {\r\n              // if select is no longer invalid, remove the bs-invalid class\r\n              if (this.validity.valid) that.$button[0].classList.remove('bs-invalid');\r\n              that.$element.off('rendered' + EVENT_KEY);\r\n            });\r\n\r\n          that.$button.on('blur' + EVENT_KEY, function () {\r\n            that.$element.trigger('focus').trigger('blur');\r\n            that.$button.off('blur' + EVENT_KEY);\r\n          });\r\n        });\r\n      }\r\n\r\n      setTimeout(function () {\r\n        that.buildList();\r\n        that.$element.trigger('loaded' + EVENT_KEY);\r\n      });\r\n    },\r\n\r\n    createDropdown: function () {\r\n      // Options\r\n      // If we are multiple or showTick option is set, then add the show-tick class\r\n      var showTick = (this.multiple || this.options.showTick) ? ' show-tick' : '',\r\n          multiselectable = this.multiple ? ' aria-multiselectable=\"true\"' : '',\r\n          inputGroup = '',\r\n          autofocus = this.autofocus ? ' autofocus' : '';\r\n\r\n      if (version.major < 4 && this.$element.parent().hasClass('input-group')) {\r\n        inputGroup = ' input-group-btn';\r\n      }\r\n\r\n      // Elements\r\n      var drop,\r\n          header = '',\r\n          searchbox = '',\r\n          actionsbox = '',\r\n          donebutton = '';\r\n\r\n      if (this.options.header) {\r\n        header =\r\n          '<div class=\"' + classNames.POPOVERHEADER + '\">' +\r\n            '<button type=\"button\" class=\"close\" aria-hidden=\"true\">&times;</button>' +\r\n              this.options.header +\r\n          '</div>';\r\n      }\r\n\r\n      if (this.options.liveSearch) {\r\n        searchbox =\r\n          '<div class=\"bs-searchbox\">' +\r\n            '<input type=\"search\" class=\"form-control\" autocomplete=\"off\"' +\r\n              (\r\n                this.options.liveSearchPlaceholder === null ? ''\r\n                :\r\n                ' placeholder=\"' + htmlEscape(this.options.liveSearchPlaceholder) + '\"'\r\n              ) +\r\n              ' role=\"combobox\" aria-label=\"Search\" aria-controls=\"' + this.selectId + '\" aria-autocomplete=\"list\">' +\r\n          '</div>';\r\n      }\r\n\r\n      if (this.multiple && this.options.actionsBox) {\r\n        actionsbox =\r\n          '<div class=\"bs-actionsbox\">' +\r\n            '<div class=\"btn-group btn-group-sm btn-block\">' +\r\n              '<button type=\"button\" class=\"actions-btn bs-select-all btn ' + classNames.BUTTONCLASS + '\">' +\r\n                this.options.selectAllText +\r\n              '</button>' +\r\n              '<button type=\"button\" class=\"actions-btn bs-deselect-all btn ' + classNames.BUTTONCLASS + '\">' +\r\n                this.options.deselectAllText +\r\n              '</button>' +\r\n            '</div>' +\r\n          '</div>';\r\n      }\r\n\r\n      if (this.multiple && this.options.doneButton) {\r\n        donebutton =\r\n          '<div class=\"bs-donebutton\">' +\r\n            '<div class=\"btn-group btn-block\">' +\r\n              '<button type=\"button\" class=\"btn btn-sm ' + classNames.BUTTONCLASS + '\">' +\r\n                this.options.doneButtonText +\r\n              '</button>' +\r\n            '</div>' +\r\n          '</div>';\r\n      }\r\n\r\n      drop =\r\n        '<div class=\"dropdown bootstrap-select' + showTick + inputGroup + '\">' +\r\n          '<button type=\"button\" tabindex=\"-1\" class=\"' + this.options.styleBase + ' dropdown-toggle\" ' + (this.options.display === 'static' ? 'data-display=\"static\"' : '') + 'data-toggle=\"dropdown\"' + autofocus + ' role=\"combobox\" aria-owns=\"' + this.selectId + '\" aria-haspopup=\"listbox\" aria-expanded=\"false\">' +\r\n            '<div class=\"filter-option\">' +\r\n              '<div class=\"filter-option-inner\">' +\r\n                '<div class=\"filter-option-inner-inner\"></div>' +\r\n              '</div> ' +\r\n            '</div>' +\r\n            (\r\n              version.major === '4' ? ''\r\n              :\r\n              '<span class=\"bs-caret\">' +\r\n                this.options.template.caret +\r\n              '</span>'\r\n            ) +\r\n          '</button>' +\r\n          '<div class=\"' + classNames.MENU + ' ' + (version.major === '4' ? '' : classNames.SHOW) + '\">' +\r\n            header +\r\n            searchbox +\r\n            actionsbox +\r\n            '<div class=\"inner ' + classNames.SHOW + '\" role=\"listbox\" id=\"' + this.selectId + '\" tabindex=\"-1\" ' + multiselectable + '>' +\r\n                '<ul class=\"' + classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '') + '\" role=\"presentation\">' +\r\n                '</ul>' +\r\n            '</div>' +\r\n            donebutton +\r\n          '</div>' +\r\n        '</div>';\r\n\r\n      return $(drop);\r\n    },\r\n\r\n    setPositionData: function () {\r\n      this.selectpicker.view.canHighlight = [];\r\n      this.selectpicker.view.size = 0;\r\n      this.selectpicker.view.firstHighlightIndex = false;\r\n\r\n      for (var i = 0; i < this.selectpicker.current.data.length; i++) {\r\n        var li = this.selectpicker.current.data[i],\r\n            canHighlight = true;\r\n\r\n        if (li.type === 'divider') {\r\n          canHighlight = false;\r\n          li.height = this.sizeInfo.dividerHeight;\r\n        } else if (li.type === 'optgroup-label') {\r\n          canHighlight = false;\r\n          li.height = this.sizeInfo.dropdownHeaderHeight;\r\n        } else {\r\n          li.height = this.sizeInfo.liHeight;\r\n        }\r\n\r\n        if (li.disabled) canHighlight = false;\r\n\r\n        this.selectpicker.view.canHighlight.push(canHighlight);\r\n\r\n        if (canHighlight) {\r\n          this.selectpicker.view.size++;\r\n          li.posinset = this.selectpicker.view.size;\r\n          if (this.selectpicker.view.firstHighlightIndex === false) this.selectpicker.view.firstHighlightIndex = i;\r\n        }\r\n\r\n        li.position = (i === 0 ? 0 : this.selectpicker.current.data[i - 1].position) + li.height;\r\n      }\r\n    },\r\n\r\n    isVirtual: function () {\r\n      return (this.options.virtualScroll !== false) && (this.selectpicker.main.elements.length >= this.options.virtualScroll) || this.options.virtualScroll === true;\r\n    },\r\n\r\n    createView: function (isSearching, setSize, refresh) {\r\n      var that = this,\r\n          scrollTop = 0,\r\n          active = [],\r\n          selected,\r\n          prevActive;\r\n\r\n      this.selectpicker.isSearching = isSearching;\r\n      this.selectpicker.current = isSearching ? this.selectpicker.search : this.selectpicker.main;\r\n\r\n      this.setPositionData();\r\n\r\n      if (setSize) {\r\n        if (refresh) {\r\n          scrollTop = this.$menuInner[0].scrollTop;\r\n        } else if (!that.multiple) {\r\n          var element = that.$element[0],\r\n              selectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\r\n\r\n          if (typeof selectedIndex === 'number' && that.options.size !== false) {\r\n            var selectedData = that.selectpicker.main.data[selectedIndex],\r\n                position = selectedData && selectedData.position;\r\n\r\n            if (position) {\r\n              scrollTop = position - ((that.sizeInfo.menuInnerHeight + that.sizeInfo.liHeight) / 2);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      scroll(scrollTop, true);\r\n\r\n      this.$menuInner.off('scroll.createView').on('scroll.createView', function (e, updateValue) {\r\n        if (!that.noScroll) scroll(this.scrollTop, updateValue);\r\n        that.noScroll = false;\r\n      });\r\n\r\n      function scroll (scrollTop, init) {\r\n        var size = that.selectpicker.current.elements.length,\r\n            chunks = [],\r\n            chunkSize,\r\n            chunkCount,\r\n            firstChunk,\r\n            lastChunk,\r\n            currentChunk,\r\n            prevPositions,\r\n            positionIsDifferent,\r\n            previousElements,\r\n            menuIsDifferent = true,\r\n            isVirtual = that.isVirtual();\r\n\r\n        that.selectpicker.view.scrollTop = scrollTop;\r\n\r\n        chunkSize = Math.ceil(that.sizeInfo.menuInnerHeight / that.sizeInfo.liHeight * 1.5); // number of options in a chunk\r\n        chunkCount = Math.round(size / chunkSize) || 1; // number of chunks\r\n\r\n        for (var i = 0; i < chunkCount; i++) {\r\n          var endOfChunk = (i + 1) * chunkSize;\r\n\r\n          if (i === chunkCount - 1) {\r\n            endOfChunk = size;\r\n          }\r\n\r\n          chunks[i] = [\r\n            (i) * chunkSize + (!i ? 0 : 1),\r\n            endOfChunk\r\n          ];\r\n\r\n          if (!size) break;\r\n\r\n          if (currentChunk === undefined && scrollTop - 1 <= that.selectpicker.current.data[endOfChunk - 1].position - that.sizeInfo.menuInnerHeight) {\r\n            currentChunk = i;\r\n          }\r\n        }\r\n\r\n        if (currentChunk === undefined) currentChunk = 0;\r\n\r\n        prevPositions = [that.selectpicker.view.position0, that.selectpicker.view.position1];\r\n\r\n        // always display previous, current, and next chunks\r\n        firstChunk = Math.max(0, currentChunk - 1);\r\n        lastChunk = Math.min(chunkCount - 1, currentChunk + 1);\r\n\r\n        that.selectpicker.view.position0 = isVirtual === false ? 0 : (Math.max(0, chunks[firstChunk][0]) || 0);\r\n        that.selectpicker.view.position1 = isVirtual === false ? size : (Math.min(size, chunks[lastChunk][1]) || 0);\r\n\r\n        positionIsDifferent = prevPositions[0] !== that.selectpicker.view.position0 || prevPositions[1] !== that.selectpicker.view.position1;\r\n\r\n        if (that.activeIndex !== undefined) {\r\n          prevActive = that.selectpicker.main.elements[that.prevActiveIndex];\r\n          active = that.selectpicker.main.elements[that.activeIndex];\r\n          selected = that.selectpicker.main.elements[that.selectedIndex];\r\n\r\n          if (init) {\r\n            if (that.activeIndex !== that.selectedIndex) {\r\n              that.defocusItem(active);\r\n            }\r\n            that.activeIndex = undefined;\r\n          }\r\n\r\n          if (that.activeIndex && that.activeIndex !== that.selectedIndex) {\r\n            that.defocusItem(selected);\r\n          }\r\n        }\r\n\r\n        if (that.prevActiveIndex !== undefined && that.prevActiveIndex !== that.activeIndex && that.prevActiveIndex !== that.selectedIndex) {\r\n          that.defocusItem(prevActive);\r\n        }\r\n\r\n        if (init || positionIsDifferent) {\r\n          previousElements = that.selectpicker.view.visibleElements ? that.selectpicker.view.visibleElements.slice() : [];\r\n\r\n          if (isVirtual === false) {\r\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements;\r\n          } else {\r\n            that.selectpicker.view.visibleElements = that.selectpicker.current.elements.slice(that.selectpicker.view.position0, that.selectpicker.view.position1);\r\n          }\r\n\r\n          that.setOptionStatus();\r\n\r\n          // if searching, check to make sure the list has actually been updated before updating DOM\r\n          // this prevents unnecessary repaints\r\n          if (isSearching || (isVirtual === false && init)) menuIsDifferent = !isEqual(previousElements, that.selectpicker.view.visibleElements);\r\n\r\n          // if virtual scroll is disabled and not searching,\r\n          // menu should never need to be updated more than once\r\n          if ((init || isVirtual === true) && menuIsDifferent) {\r\n            var menuInner = that.$menuInner[0],\r\n                menuFragment = document.createDocumentFragment(),\r\n                emptyMenu = menuInner.firstChild.cloneNode(false),\r\n                marginTop,\r\n                marginBottom,\r\n                elements = that.selectpicker.view.visibleElements,\r\n                toSanitize = [];\r\n\r\n            // replace the existing UL with an empty one - this is faster than $.empty()\r\n            menuInner.replaceChild(emptyMenu, menuInner.firstChild);\r\n\r\n            for (var i = 0, visibleElementsLen = elements.length; i < visibleElementsLen; i++) {\r\n              var element = elements[i],\r\n                  elText,\r\n                  elementData;\r\n\r\n              if (that.options.sanitize) {\r\n                elText = element.lastChild;\r\n\r\n                if (elText) {\r\n                  elementData = that.selectpicker.current.data[i + that.selectpicker.view.position0];\r\n\r\n                  if (elementData && elementData.content && !elementData.sanitized) {\r\n                    toSanitize.push(elText);\r\n                    elementData.sanitized = true;\r\n                  }\r\n                }\r\n              }\r\n\r\n              menuFragment.appendChild(element);\r\n            }\r\n\r\n            if (that.options.sanitize && toSanitize.length) {\r\n              sanitizeHtml(toSanitize, that.options.whiteList, that.options.sanitizeFn);\r\n            }\r\n\r\n            if (isVirtual === true) {\r\n              marginTop = (that.selectpicker.view.position0 === 0 ? 0 : that.selectpicker.current.data[that.selectpicker.view.position0 - 1].position);\r\n              marginBottom = (that.selectpicker.view.position1 > size - 1 ? 0 : that.selectpicker.current.data[size - 1].position - that.selectpicker.current.data[that.selectpicker.view.position1 - 1].position);\r\n\r\n              menuInner.firstChild.style.marginTop = marginTop + 'px';\r\n              menuInner.firstChild.style.marginBottom = marginBottom + 'px';\r\n            } else {\r\n              menuInner.firstChild.style.marginTop = 0;\r\n              menuInner.firstChild.style.marginBottom = 0;\r\n            }\r\n\r\n            menuInner.firstChild.appendChild(menuFragment);\r\n\r\n            // if an option is encountered that is wider than the current menu width, update the menu width accordingly\r\n            // switch to ResizeObserver with increased browser support\r\n            if (isVirtual === true && that.sizeInfo.hasScrollBar) {\r\n              var menuInnerInnerWidth = menuInner.firstChild.offsetWidth;\r\n\r\n              if (init && menuInnerInnerWidth < that.sizeInfo.menuInnerInnerWidth && that.sizeInfo.totalMenuWidth > that.sizeInfo.selectWidth) {\r\n                menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\r\n              } else if (menuInnerInnerWidth > that.sizeInfo.menuInnerInnerWidth) {\r\n                // set to 0 to get actual width of menu\r\n                that.$menu[0].style.minWidth = 0;\r\n\r\n                var actualMenuWidth = menuInner.firstChild.offsetWidth;\r\n\r\n                if (actualMenuWidth > that.sizeInfo.menuInnerInnerWidth) {\r\n                  that.sizeInfo.menuInnerInnerWidth = actualMenuWidth;\r\n                  menuInner.firstChild.style.minWidth = that.sizeInfo.menuInnerInnerWidth + 'px';\r\n                }\r\n\r\n                // reset to default CSS styling\r\n                that.$menu[0].style.minWidth = '';\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n        that.prevActiveIndex = that.activeIndex;\r\n\r\n        if (!that.options.liveSearch) {\r\n          that.$menuInner.trigger('focus');\r\n        } else if (isSearching && init) {\r\n          var index = 0,\r\n              newActive;\r\n\r\n          if (!that.selectpicker.view.canHighlight[index]) {\r\n            index = 1 + that.selectpicker.view.canHighlight.slice(1).indexOf(true);\r\n          }\r\n\r\n          newActive = that.selectpicker.view.visibleElements[index];\r\n\r\n          that.defocusItem(that.selectpicker.view.currentActive);\r\n\r\n          that.activeIndex = (that.selectpicker.current.data[index] || {}).index;\r\n\r\n          that.focusItem(newActive);\r\n        }\r\n      }\r\n\r\n      $(window)\r\n        .off('resize' + EVENT_KEY + '.' + this.selectId + '.createView')\r\n        .on('resize' + EVENT_KEY + '.' + this.selectId + '.createView', function () {\r\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\r\n\r\n          if (isActive) scroll(that.$menuInner[0].scrollTop);\r\n        });\r\n    },\r\n\r\n    focusItem: function (li, liData, noStyle) {\r\n      if (li) {\r\n        liData = liData || this.selectpicker.main.data[this.activeIndex];\r\n        var a = li.firstChild;\r\n\r\n        if (a) {\r\n          a.setAttribute('aria-setsize', this.selectpicker.view.size);\r\n          a.setAttribute('aria-posinset', liData.posinset);\r\n\r\n          if (noStyle !== true) {\r\n            this.focusedParent.setAttribute('aria-activedescendant', a.id);\r\n            li.classList.add('active');\r\n            a.classList.add('active');\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    defocusItem: function (li) {\r\n      if (li) {\r\n        li.classList.remove('active');\r\n        if (li.firstChild) li.firstChild.classList.remove('active');\r\n      }\r\n    },\r\n\r\n    setPlaceholder: function () {\r\n      var that = this,\r\n          updateIndex = false;\r\n\r\n      if (this.options.title && !this.multiple) {\r\n        if (!this.selectpicker.view.titleOption) this.selectpicker.view.titleOption = document.createElement('option');\r\n\r\n        // this option doesn't create a new <li> element, but does add a new option at the start,\r\n        // so startIndex should increase to prevent having to check every option for the bs-title-option class\r\n        updateIndex = true;\r\n\r\n        var element = this.$element[0],\r\n            selectTitleOption = false,\r\n            titleNotAppended = !this.selectpicker.view.titleOption.parentNode,\r\n            selectedIndex = element.selectedIndex,\r\n            selectedOption = element.options[selectedIndex],\r\n            navigation = window.performance && window.performance.getEntriesByType('navigation'),\r\n            // Safari doesn't support getEntriesByType('navigation') - fall back to performance.navigation\r\n            isNotBackForward = (navigation && navigation.length) ? navigation[0].type !== 'back_forward' : window.performance.navigation.type !== 2;\r\n\r\n        if (titleNotAppended) {\r\n          // Use native JS to prepend option (faster)\r\n          this.selectpicker.view.titleOption.className = 'bs-title-option';\r\n          this.selectpicker.view.titleOption.value = '';\r\n\r\n          // Check if selected or data-selected attribute is already set on an option. If not, select the titleOption option.\r\n          // the selected item may have been changed by user or programmatically before the bootstrap select plugin runs,\r\n          // if so, the select will have the data-selected attribute\r\n          selectTitleOption = !selectedOption || (selectedIndex === 0 && selectedOption.defaultSelected === false && this.$element.data('selected') === undefined);\r\n        }\r\n\r\n        if (titleNotAppended || this.selectpicker.view.titleOption.index !== 0) {\r\n          element.insertBefore(this.selectpicker.view.titleOption, element.firstChild);\r\n        }\r\n\r\n        // Set selected *after* appending to select,\r\n        // otherwise the option doesn't get selected in IE\r\n        // set using selectedIndex, as setting the selected attr to true here doesn't work in IE11\r\n        if (selectTitleOption && isNotBackForward) {\r\n          element.selectedIndex = 0;\r\n        } else if (document.readyState !== 'complete') {\r\n          // if navigation type is back_forward, there's a chance the select will have its value set by BFCache\r\n          // wait for that value to be set, then run render again\r\n          window.addEventListener('pageshow', function () {\r\n            if (that.selectpicker.view.displayedValue !== element.value) that.render();\r\n          });\r\n        }\r\n      }\r\n\r\n      return updateIndex;\r\n    },\r\n\r\n    buildData: function () {\r\n      var optionSelector = ':not([hidden]):not([data-hidden=\"true\"])',\r\n          mainData = [],\r\n          optID = 0,\r\n          startIndex = this.setPlaceholder() ? 1 : 0; // append the titleOption if necessary and skip the first option in the loop\r\n\r\n      if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\r\n\r\n      var selectOptions = this.$element[0].querySelectorAll('select > *' + optionSelector);\r\n\r\n      function addDivider (config) {\r\n        var previousData = mainData[mainData.length - 1];\r\n\r\n        // ensure optgroup doesn't create back-to-back dividers\r\n        if (\r\n          previousData &&\r\n          previousData.type === 'divider' &&\r\n          (previousData.optID || config.optID)\r\n        ) {\r\n          return;\r\n        }\r\n\r\n        config = config || {};\r\n        config.type = 'divider';\r\n\r\n        mainData.push(config);\r\n      }\r\n\r\n      function addOption (option, config) {\r\n        config = config || {};\r\n\r\n        config.divider = option.getAttribute('data-divider') === 'true';\r\n\r\n        if (config.divider) {\r\n          addDivider({\r\n            optID: config.optID\r\n          });\r\n        } else {\r\n          var liIndex = mainData.length,\r\n              cssText = option.style.cssText,\r\n              inlineStyle = cssText ? htmlEscape(cssText) : '',\r\n              optionClass = (option.className || '') + (config.optgroupClass || '');\r\n\r\n          if (config.optID) optionClass = 'opt ' + optionClass;\r\n\r\n          config.optionClass = optionClass.trim();\r\n          config.inlineStyle = inlineStyle;\r\n          config.text = option.textContent;\r\n\r\n          config.content = option.getAttribute('data-content');\r\n          config.tokens = option.getAttribute('data-tokens');\r\n          config.subtext = option.getAttribute('data-subtext');\r\n          config.icon = option.getAttribute('data-icon');\r\n\r\n          option.liIndex = liIndex;\r\n\r\n          config.display = config.content || config.text;\r\n          config.type = 'option';\r\n          config.index = liIndex;\r\n          config.option = option;\r\n          config.selected = !!option.selected;\r\n          config.disabled = config.disabled || !!option.disabled;\r\n\r\n          mainData.push(config);\r\n        }\r\n      }\r\n\r\n      function addOptgroup (index, selectOptions) {\r\n        var optgroup = selectOptions[index],\r\n            // skip placeholder option\r\n            previous = index - 1 < startIndex ? false : selectOptions[index - 1],\r\n            next = selectOptions[index + 1],\r\n            options = optgroup.querySelectorAll('option' + optionSelector);\r\n\r\n        if (!options.length) return;\r\n\r\n        var config = {\r\n              display: htmlEscape(optgroup.label),\r\n              subtext: optgroup.getAttribute('data-subtext'),\r\n              icon: optgroup.getAttribute('data-icon'),\r\n              type: 'optgroup-label',\r\n              optgroupClass: ' ' + (optgroup.className || '')\r\n            },\r\n            headerIndex,\r\n            lastIndex;\r\n\r\n        optID++;\r\n\r\n        if (previous) {\r\n          addDivider({ optID: optID });\r\n        }\r\n\r\n        config.optID = optID;\r\n\r\n        mainData.push(config);\r\n\r\n        for (var j = 0, len = options.length; j < len; j++) {\r\n          var option = options[j];\r\n\r\n          if (j === 0) {\r\n            headerIndex = mainData.length - 1;\r\n            lastIndex = headerIndex + len;\r\n          }\r\n\r\n          addOption(option, {\r\n            headerIndex: headerIndex,\r\n            lastIndex: lastIndex,\r\n            optID: config.optID,\r\n            optgroupClass: config.optgroupClass,\r\n            disabled: optgroup.disabled\r\n          });\r\n        }\r\n\r\n        if (next) {\r\n          addDivider({ optID: optID });\r\n        }\r\n      }\r\n\r\n      for (var len = selectOptions.length, i = startIndex; i < len; i++) {\r\n        var item = selectOptions[i];\r\n\r\n        if (item.tagName !== 'OPTGROUP') {\r\n          addOption(item, {});\r\n        } else {\r\n          addOptgroup(i, selectOptions);\r\n        }\r\n      }\r\n\r\n      this.selectpicker.main.data = this.selectpicker.current.data = mainData;\r\n    },\r\n\r\n    buildList: function () {\r\n      var that = this,\r\n          selectData = this.selectpicker.main.data,\r\n          mainElements = [],\r\n          widestOptionLength = 0;\r\n\r\n      if ((that.options.showTick || that.multiple) && !elementTemplates.checkMark.parentNode) {\r\n        elementTemplates.checkMark.className = this.options.iconBase + ' ' + that.options.tickIcon + ' check-mark';\r\n        elementTemplates.a.appendChild(elementTemplates.checkMark);\r\n      }\r\n\r\n      function buildElement (item) {\r\n        var liElement,\r\n            combinedLength = 0;\r\n\r\n        switch (item.type) {\r\n          case 'divider':\r\n            liElement = generateOption.li(\r\n              false,\r\n              classNames.DIVIDER,\r\n              (item.optID ? item.optID + 'div' : undefined)\r\n            );\r\n\r\n            break;\r\n\r\n          case 'option':\r\n            liElement = generateOption.li(\r\n              generateOption.a(\r\n                generateOption.text.call(that, item),\r\n                item.optionClass,\r\n                item.inlineStyle\r\n              ),\r\n              '',\r\n              item.optID\r\n            );\r\n\r\n            if (liElement.firstChild) {\r\n              liElement.firstChild.id = that.selectId + '-' + item.index;\r\n            }\r\n\r\n            break;\r\n\r\n          case 'optgroup-label':\r\n            liElement = generateOption.li(\r\n              generateOption.label.call(that, item),\r\n              'dropdown-header' + item.optgroupClass,\r\n              item.optID\r\n            );\r\n\r\n            break;\r\n        }\r\n\r\n        item.element = liElement;\r\n        mainElements.push(liElement);\r\n\r\n        // count the number of characters in the option - not perfect, but should work in most cases\r\n        if (item.display) combinedLength += item.display.length;\r\n        if (item.subtext) combinedLength += item.subtext.length;\r\n        // if there is an icon, ensure this option's width is checked\r\n        if (item.icon) combinedLength += 1;\r\n\r\n        if (combinedLength > widestOptionLength) {\r\n          widestOptionLength = combinedLength;\r\n\r\n          // guess which option is the widest\r\n          // use this when calculating menu width\r\n          // not perfect, but it's fast, and the width will be updating accordingly when scrolling\r\n          that.selectpicker.view.widestOption = mainElements[mainElements.length - 1];\r\n        }\r\n      }\r\n\r\n      for (var len = selectData.length, i = 0; i < len; i++) {\r\n        var item = selectData[i];\r\n\r\n        buildElement(item);\r\n      }\r\n\r\n      this.selectpicker.main.elements = this.selectpicker.current.elements = mainElements;\r\n    },\r\n\r\n    findLis: function () {\r\n      return this.$menuInner.find('.inner > li');\r\n    },\r\n\r\n    render: function () {\r\n      var that = this,\r\n          element = this.$element[0],\r\n          // ensure titleOption is appended and selected (if necessary) before getting selectedOptions\r\n          placeholderSelected = this.setPlaceholder() && element.selectedIndex === 0,\r\n          selectedOptions = getSelectedOptions(element, this.options.hideDisabled),\r\n          selectedCount = selectedOptions.length,\r\n          button = this.$button[0],\r\n          buttonInner = button.querySelector('.filter-option-inner-inner'),\r\n          multipleSeparator = document.createTextNode(this.options.multipleSeparator),\r\n          titleFragment = elementTemplates.fragment.cloneNode(false),\r\n          showCount,\r\n          countMax,\r\n          hasContent = false;\r\n\r\n      button.classList.toggle('bs-placeholder', that.multiple ? !selectedCount : !getSelectValues(element, selectedOptions));\r\n\r\n      if (!that.multiple && selectedOptions.length === 1) {\r\n        that.selectpicker.view.displayedValue = getSelectValues(element, selectedOptions);\r\n      }\r\n\r\n      if (this.options.selectedTextFormat === 'static') {\r\n        titleFragment = generateOption.text.call(this, { text: this.options.title }, true);\r\n      } else {\r\n        showCount = this.multiple && this.options.selectedTextFormat.indexOf('count') !== -1 && selectedCount > 1;\r\n\r\n        // determine if the number of selected options will be shown (showCount === true)\r\n        if (showCount) {\r\n          countMax = this.options.selectedTextFormat.split('>');\r\n          showCount = (countMax.length > 1 && selectedCount > countMax[1]) || (countMax.length === 1 && selectedCount >= 2);\r\n        }\r\n\r\n        // only loop through all selected options if the count won't be shown\r\n        if (showCount === false) {\r\n          if (!placeholderSelected) {\r\n            for (var selectedIndex = 0; selectedIndex < selectedCount; selectedIndex++) {\r\n              if (selectedIndex < 50) {\r\n                var option = selectedOptions[selectedIndex],\r\n                    thisData = this.selectpicker.main.data[option.liIndex],\r\n                    titleOptions = {};\r\n\r\n                if (this.multiple && selectedIndex > 0) {\r\n                  titleFragment.appendChild(multipleSeparator.cloneNode(false));\r\n                }\r\n\r\n                if (option.title) {\r\n                  titleOptions.text = option.title;\r\n                } else if (thisData) {\r\n                  if (thisData.content && that.options.showContent) {\r\n                    titleOptions.content = thisData.content.toString();\r\n                    hasContent = true;\r\n                  } else {\r\n                    if (that.options.showIcon) {\r\n                      titleOptions.icon = thisData.icon;\r\n                    }\r\n                    if (that.options.showSubtext && !that.multiple && thisData.subtext) titleOptions.subtext = ' ' + thisData.subtext;\r\n                    titleOptions.text = option.textContent.trim();\r\n                  }\r\n                }\r\n\r\n                titleFragment.appendChild(generateOption.text.call(this, titleOptions, true));\r\n              } else {\r\n                break;\r\n              }\r\n            }\r\n\r\n            // add ellipsis\r\n            if (selectedCount > 49) {\r\n              titleFragment.appendChild(document.createTextNode('...'));\r\n            }\r\n          }\r\n        } else {\r\n          var optionSelector = ':not([hidden]):not([data-hidden=\"true\"]):not([data-divider=\"true\"])';\r\n          if (this.options.hideDisabled) optionSelector += ':not(:disabled)';\r\n\r\n          // If this is a multiselect, and selectedTextFormat is count, then show 1 of 2 selected, etc.\r\n          var totalCount = this.$element[0].querySelectorAll('select > option' + optionSelector + ', optgroup' + optionSelector + ' option' + optionSelector).length,\r\n              tr8nText = (typeof this.options.countSelectedText === 'function') ? this.options.countSelectedText(selectedCount, totalCount) : this.options.countSelectedText;\r\n\r\n          titleFragment = generateOption.text.call(this, {\r\n            text: tr8nText.replace('{0}', selectedCount.toString()).replace('{1}', totalCount.toString())\r\n          }, true);\r\n        }\r\n      }\r\n\r\n      if (this.options.title == undefined) {\r\n        // use .attr to ensure undefined is returned if title attribute is not set\r\n        this.options.title = this.$element.attr('title');\r\n      }\r\n\r\n      // If the select doesn't have a title, then use the default, or if nothing is set at all, use noneSelectedText\r\n      if (!titleFragment.childNodes.length) {\r\n        titleFragment = generateOption.text.call(this, {\r\n          text: typeof this.options.title !== 'undefined' ? this.options.title : this.options.noneSelectedText\r\n        }, true);\r\n      }\r\n\r\n      // strip all HTML tags and trim the result, then unescape any escaped tags\r\n      button.title = titleFragment.textContent.replace(/<[^>]*>?/g, '').trim();\r\n\r\n      if (this.options.sanitize && hasContent) {\r\n        sanitizeHtml([titleFragment], that.options.whiteList, that.options.sanitizeFn);\r\n      }\r\n\r\n      buttonInner.innerHTML = '';\r\n      buttonInner.appendChild(titleFragment);\r\n\r\n      if (version.major < 4 && this.$newElement[0].classList.contains('bs3-has-addon')) {\r\n        var filterExpand = button.querySelector('.filter-expand'),\r\n            clone = buttonInner.cloneNode(true);\r\n\r\n        clone.className = 'filter-expand';\r\n\r\n        if (filterExpand) {\r\n          button.replaceChild(clone, filterExpand);\r\n        } else {\r\n          button.appendChild(clone);\r\n        }\r\n      }\r\n\r\n      this.$element.trigger('rendered' + EVENT_KEY);\r\n    },\r\n\r\n    /**\r\n     * @param [style]\r\n     * @param [status]\r\n     */\r\n    setStyle: function (newStyle, status) {\r\n      var button = this.$button[0],\r\n          newElement = this.$newElement[0],\r\n          style = this.options.style.trim(),\r\n          buttonClass;\r\n\r\n      if (this.$element.attr('class')) {\r\n        this.$newElement.addClass(this.$element.attr('class').replace(/selectpicker|mobile-device|bs-select-hidden|validate\\[.*\\]/gi, ''));\r\n      }\r\n\r\n      if (version.major < 4) {\r\n        newElement.classList.add('bs3');\r\n\r\n        if (newElement.parentNode.classList && newElement.parentNode.classList.contains('input-group') &&\r\n            (newElement.previousElementSibling || newElement.nextElementSibling) &&\r\n            (newElement.previousElementSibling || newElement.nextElementSibling).classList.contains('input-group-addon')\r\n        ) {\r\n          newElement.classList.add('bs3-has-addon');\r\n        }\r\n      }\r\n\r\n      if (newStyle) {\r\n        buttonClass = newStyle.trim();\r\n      } else {\r\n        buttonClass = style;\r\n      }\r\n\r\n      if (status == 'add') {\r\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\r\n      } else if (status == 'remove') {\r\n        if (buttonClass) button.classList.remove.apply(button.classList, buttonClass.split(' '));\r\n      } else {\r\n        if (style) button.classList.remove.apply(button.classList, style.split(' '));\r\n        if (buttonClass) button.classList.add.apply(button.classList, buttonClass.split(' '));\r\n      }\r\n    },\r\n\r\n    liHeight: function (refresh) {\r\n      if (!refresh && (this.options.size === false || Object.keys(this.sizeInfo).length)) return;\r\n\r\n      var newElement = elementTemplates.div.cloneNode(false),\r\n          menu = elementTemplates.div.cloneNode(false),\r\n          menuInner = elementTemplates.div.cloneNode(false),\r\n          menuInnerInner = document.createElement('ul'),\r\n          divider = elementTemplates.li.cloneNode(false),\r\n          dropdownHeader = elementTemplates.li.cloneNode(false),\r\n          li,\r\n          a = elementTemplates.a.cloneNode(false),\r\n          text = elementTemplates.span.cloneNode(false),\r\n          header = this.options.header && this.$menu.find('.' + classNames.POPOVERHEADER).length > 0 ? this.$menu.find('.' + classNames.POPOVERHEADER)[0].cloneNode(true) : null,\r\n          search = this.options.liveSearch ? elementTemplates.div.cloneNode(false) : null,\r\n          actions = this.options.actionsBox && this.multiple && this.$menu.find('.bs-actionsbox').length > 0 ? this.$menu.find('.bs-actionsbox')[0].cloneNode(true) : null,\r\n          doneButton = this.options.doneButton && this.multiple && this.$menu.find('.bs-donebutton').length > 0 ? this.$menu.find('.bs-donebutton')[0].cloneNode(true) : null,\r\n          firstOption = this.$element.find('option')[0];\r\n\r\n      this.sizeInfo.selectWidth = this.$newElement[0].offsetWidth;\r\n\r\n      text.className = 'text';\r\n      a.className = 'dropdown-item ' + (firstOption ? firstOption.className : '');\r\n      newElement.className = this.$menu[0].parentNode.className + ' ' + classNames.SHOW;\r\n      newElement.style.width = 0; // ensure button width doesn't affect natural width of menu when calculating\r\n      if (this.options.width === 'auto') menu.style.minWidth = 0;\r\n      menu.className = classNames.MENU + ' ' + classNames.SHOW;\r\n      menuInner.className = 'inner ' + classNames.SHOW;\r\n      menuInnerInner.className = classNames.MENU + ' inner ' + (version.major === '4' ? classNames.SHOW : '');\r\n      divider.className = classNames.DIVIDER;\r\n      dropdownHeader.className = 'dropdown-header';\r\n\r\n      text.appendChild(document.createTextNode('\\u200b'));\r\n\r\n      if (this.selectpicker.current.data.length) {\r\n        for (var i = 0; i < this.selectpicker.current.data.length; i++) {\r\n          var data = this.selectpicker.current.data[i];\r\n          if (data.type === 'option') {\r\n            li = data.element;\r\n            break;\r\n          }\r\n        }\r\n      } else {\r\n        li = elementTemplates.li.cloneNode(false);\r\n        a.appendChild(text);\r\n        li.appendChild(a);\r\n      }\r\n\r\n      dropdownHeader.appendChild(text.cloneNode(true));\r\n\r\n      if (this.selectpicker.view.widestOption) {\r\n        menuInnerInner.appendChild(this.selectpicker.view.widestOption.cloneNode(true));\r\n      }\r\n\r\n      menuInnerInner.appendChild(li);\r\n      menuInnerInner.appendChild(divider);\r\n      menuInnerInner.appendChild(dropdownHeader);\r\n      if (header) menu.appendChild(header);\r\n      if (search) {\r\n        var input = document.createElement('input');\r\n        search.className = 'bs-searchbox';\r\n        input.className = 'form-control';\r\n        search.appendChild(input);\r\n        menu.appendChild(search);\r\n      }\r\n      if (actions) menu.appendChild(actions);\r\n      menuInner.appendChild(menuInnerInner);\r\n      menu.appendChild(menuInner);\r\n      if (doneButton) menu.appendChild(doneButton);\r\n      newElement.appendChild(menu);\r\n\r\n      document.body.appendChild(newElement);\r\n\r\n      var liHeight = li.offsetHeight,\r\n          dropdownHeaderHeight = dropdownHeader ? dropdownHeader.offsetHeight : 0,\r\n          headerHeight = header ? header.offsetHeight : 0,\r\n          searchHeight = search ? search.offsetHeight : 0,\r\n          actionsHeight = actions ? actions.offsetHeight : 0,\r\n          doneButtonHeight = doneButton ? doneButton.offsetHeight : 0,\r\n          dividerHeight = $(divider).outerHeight(true),\r\n          // fall back to jQuery if getComputedStyle is not supported\r\n          menuStyle = window.getComputedStyle ? window.getComputedStyle(menu) : false,\r\n          menuWidth = menu.offsetWidth,\r\n          $menu = menuStyle ? null : $(menu),\r\n          menuPadding = {\r\n            vert: toInteger(menuStyle ? menuStyle.paddingTop : $menu.css('paddingTop')) +\r\n                  toInteger(menuStyle ? menuStyle.paddingBottom : $menu.css('paddingBottom')) +\r\n                  toInteger(menuStyle ? menuStyle.borderTopWidth : $menu.css('borderTopWidth')) +\r\n                  toInteger(menuStyle ? menuStyle.borderBottomWidth : $menu.css('borderBottomWidth')),\r\n            horiz: toInteger(menuStyle ? menuStyle.paddingLeft : $menu.css('paddingLeft')) +\r\n                  toInteger(menuStyle ? menuStyle.paddingRight : $menu.css('paddingRight')) +\r\n                  toInteger(menuStyle ? menuStyle.borderLeftWidth : $menu.css('borderLeftWidth')) +\r\n                  toInteger(menuStyle ? menuStyle.borderRightWidth : $menu.css('borderRightWidth'))\r\n          },\r\n          menuExtras = {\r\n            vert: menuPadding.vert +\r\n                  toInteger(menuStyle ? menuStyle.marginTop : $menu.css('marginTop')) +\r\n                  toInteger(menuStyle ? menuStyle.marginBottom : $menu.css('marginBottom')) + 2,\r\n            horiz: menuPadding.horiz +\r\n                  toInteger(menuStyle ? menuStyle.marginLeft : $menu.css('marginLeft')) +\r\n                  toInteger(menuStyle ? menuStyle.marginRight : $menu.css('marginRight')) + 2\r\n          },\r\n          scrollBarWidth;\r\n\r\n      menuInner.style.overflowY = 'scroll';\r\n\r\n      scrollBarWidth = menu.offsetWidth - menuWidth;\r\n\r\n      document.body.removeChild(newElement);\r\n\r\n      this.sizeInfo.liHeight = liHeight;\r\n      this.sizeInfo.dropdownHeaderHeight = dropdownHeaderHeight;\r\n      this.sizeInfo.headerHeight = headerHeight;\r\n      this.sizeInfo.searchHeight = searchHeight;\r\n      this.sizeInfo.actionsHeight = actionsHeight;\r\n      this.sizeInfo.doneButtonHeight = doneButtonHeight;\r\n      this.sizeInfo.dividerHeight = dividerHeight;\r\n      this.sizeInfo.menuPadding = menuPadding;\r\n      this.sizeInfo.menuExtras = menuExtras;\r\n      this.sizeInfo.menuWidth = menuWidth;\r\n      this.sizeInfo.menuInnerInnerWidth = menuWidth - menuPadding.horiz;\r\n      this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth;\r\n      this.sizeInfo.scrollBarWidth = scrollBarWidth;\r\n      this.sizeInfo.selectHeight = this.$newElement[0].offsetHeight;\r\n\r\n      this.setPositionData();\r\n    },\r\n\r\n    getSelectPosition: function () {\r\n      var that = this,\r\n          $window = $(window),\r\n          pos = that.$newElement.offset(),\r\n          $container = $(that.options.container),\r\n          containerPos;\r\n\r\n      if (that.options.container && $container.length && !$container.is('body')) {\r\n        containerPos = $container.offset();\r\n        containerPos.top += parseInt($container.css('borderTopWidth'));\r\n        containerPos.left += parseInt($container.css('borderLeftWidth'));\r\n      } else {\r\n        containerPos = { top: 0, left: 0 };\r\n      }\r\n\r\n      var winPad = that.options.windowPadding;\r\n\r\n      this.sizeInfo.selectOffsetTop = pos.top - containerPos.top - $window.scrollTop();\r\n      this.sizeInfo.selectOffsetBot = $window.height() - this.sizeInfo.selectOffsetTop - this.sizeInfo.selectHeight - containerPos.top - winPad[2];\r\n      this.sizeInfo.selectOffsetLeft = pos.left - containerPos.left - $window.scrollLeft();\r\n      this.sizeInfo.selectOffsetRight = $window.width() - this.sizeInfo.selectOffsetLeft - this.sizeInfo.selectWidth - containerPos.left - winPad[1];\r\n      this.sizeInfo.selectOffsetTop -= winPad[0];\r\n      this.sizeInfo.selectOffsetLeft -= winPad[3];\r\n    },\r\n\r\n    setMenuSize: function (isAuto) {\r\n      this.getSelectPosition();\r\n\r\n      var selectWidth = this.sizeInfo.selectWidth,\r\n          liHeight = this.sizeInfo.liHeight,\r\n          headerHeight = this.sizeInfo.headerHeight,\r\n          searchHeight = this.sizeInfo.searchHeight,\r\n          actionsHeight = this.sizeInfo.actionsHeight,\r\n          doneButtonHeight = this.sizeInfo.doneButtonHeight,\r\n          divHeight = this.sizeInfo.dividerHeight,\r\n          menuPadding = this.sizeInfo.menuPadding,\r\n          menuInnerHeight,\r\n          menuHeight,\r\n          divLength = 0,\r\n          minHeight,\r\n          _minHeight,\r\n          maxHeight,\r\n          menuInnerMinHeight,\r\n          estimate,\r\n          isDropup;\r\n\r\n      if (this.options.dropupAuto) {\r\n        // Get the estimated height of the menu without scrollbars.\r\n        // This is useful for smaller menus, where there might be plenty of room\r\n        // below the button without setting dropup, but we can't know\r\n        // the exact height of the menu until createView is called later\r\n        estimate = liHeight * this.selectpicker.current.elements.length + menuPadding.vert;\r\n\r\n        isDropup = this.sizeInfo.selectOffsetTop - this.sizeInfo.selectOffsetBot > this.sizeInfo.menuExtras.vert && estimate + this.sizeInfo.menuExtras.vert + 50 > this.sizeInfo.selectOffsetBot;\r\n\r\n        // ensure dropup doesn't change while searching (so menu doesn't bounce back and forth)\r\n        if (this.selectpicker.isSearching === true) {\r\n          isDropup = this.selectpicker.dropup;\r\n        }\r\n\r\n        this.$newElement.toggleClass(classNames.DROPUP, isDropup);\r\n        this.selectpicker.dropup = isDropup;\r\n      }\r\n\r\n      if (this.options.size === 'auto') {\r\n        _minHeight = this.selectpicker.current.elements.length > 3 ? this.sizeInfo.liHeight * 3 + this.sizeInfo.menuExtras.vert - 2 : 0;\r\n        menuHeight = this.sizeInfo.selectOffsetBot - this.sizeInfo.menuExtras.vert;\r\n        minHeight = _minHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\r\n        menuInnerMinHeight = Math.max(_minHeight - menuPadding.vert, 0);\r\n\r\n        if (this.$newElement.hasClass(classNames.DROPUP)) {\r\n          menuHeight = this.sizeInfo.selectOffsetTop - this.sizeInfo.menuExtras.vert;\r\n        }\r\n\r\n        maxHeight = menuHeight;\r\n        menuInnerHeight = menuHeight - headerHeight - searchHeight - actionsHeight - doneButtonHeight - menuPadding.vert;\r\n      } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\r\n        for (var i = 0; i < this.options.size; i++) {\r\n          if (this.selectpicker.current.data[i].type === 'divider') divLength++;\r\n        }\r\n\r\n        menuHeight = liHeight * this.options.size + divLength * divHeight + menuPadding.vert;\r\n        menuInnerHeight = menuHeight - menuPadding.vert;\r\n        maxHeight = menuHeight + headerHeight + searchHeight + actionsHeight + doneButtonHeight;\r\n        minHeight = menuInnerMinHeight = '';\r\n      }\r\n\r\n      this.$menu.css({\r\n        'max-height': maxHeight + 'px',\r\n        'overflow': 'hidden',\r\n        'min-height': minHeight + 'px'\r\n      });\r\n\r\n      this.$menuInner.css({\r\n        'max-height': menuInnerHeight + 'px',\r\n        'overflow-y': 'auto',\r\n        'min-height': menuInnerMinHeight + 'px'\r\n      });\r\n\r\n      // ensure menuInnerHeight is always a positive number to prevent issues calculating chunkSize in createView\r\n      this.sizeInfo.menuInnerHeight = Math.max(menuInnerHeight, 1);\r\n\r\n      if (this.selectpicker.current.data.length && this.selectpicker.current.data[this.selectpicker.current.data.length - 1].position > this.sizeInfo.menuInnerHeight) {\r\n        this.sizeInfo.hasScrollBar = true;\r\n        this.sizeInfo.totalMenuWidth = this.sizeInfo.menuWidth + this.sizeInfo.scrollBarWidth;\r\n      }\r\n\r\n      if (this.options.dropdownAlignRight === 'auto') {\r\n        this.$menu.toggleClass(classNames.MENURIGHT, this.sizeInfo.selectOffsetLeft > this.sizeInfo.selectOffsetRight && this.sizeInfo.selectOffsetRight < (this.sizeInfo.totalMenuWidth - selectWidth));\r\n      }\r\n\r\n      if (this.dropdown && this.dropdown._popper) this.dropdown._popper.update();\r\n    },\r\n\r\n    setSize: function (refresh) {\r\n      this.liHeight(refresh);\r\n\r\n      if (this.options.header) this.$menu.css('padding-top', 0);\r\n\r\n      if (this.options.size !== false) {\r\n        var that = this,\r\n            $window = $(window);\r\n\r\n        this.setMenuSize();\r\n\r\n        if (this.options.liveSearch) {\r\n          this.$searchbox\r\n            .off('input.setMenuSize propertychange.setMenuSize')\r\n            .on('input.setMenuSize propertychange.setMenuSize', function () {\r\n              return that.setMenuSize();\r\n            });\r\n        }\r\n\r\n        if (this.options.size === 'auto') {\r\n          $window\r\n            .off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize')\r\n            .on('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize', function () {\r\n              return that.setMenuSize();\r\n            });\r\n        } else if (this.options.size && this.options.size != 'auto' && this.selectpicker.current.elements.length > this.options.size) {\r\n          $window.off('resize' + EVENT_KEY + '.' + this.selectId + '.setMenuSize' + ' scroll' + EVENT_KEY + '.' + this.selectId + '.setMenuSize');\r\n        }\r\n      }\r\n\r\n      this.createView(false, true, refresh);\r\n    },\r\n\r\n    setWidth: function () {\r\n      var that = this;\r\n\r\n      if (this.options.width === 'auto') {\r\n        requestAnimationFrame(function () {\r\n          that.$menu.css('min-width', '0');\r\n\r\n          that.$element.on('loaded' + EVENT_KEY, function () {\r\n            that.liHeight();\r\n            that.setMenuSize();\r\n\r\n            // Get correct width if element is hidden\r\n            var $selectClone = that.$newElement.clone().appendTo('body'),\r\n                btnWidth = $selectClone.css('width', 'auto').children('button').outerWidth();\r\n\r\n            $selectClone.remove();\r\n\r\n            // Set width to whatever's larger, button title or longest option\r\n            that.sizeInfo.selectWidth = Math.max(that.sizeInfo.totalMenuWidth, btnWidth);\r\n            that.$newElement.css('width', that.sizeInfo.selectWidth + 'px');\r\n          });\r\n        });\r\n      } else if (this.options.width === 'fit') {\r\n        // Remove inline min-width so width can be changed from 'auto'\r\n        this.$menu.css('min-width', '');\r\n        this.$newElement.css('width', '').addClass('fit-width');\r\n      } else if (this.options.width) {\r\n        // Remove inline min-width so width can be changed from 'auto'\r\n        this.$menu.css('min-width', '');\r\n        this.$newElement.css('width', this.options.width);\r\n      } else {\r\n        // Remove inline min-width/width so width can be changed\r\n        this.$menu.css('min-width', '');\r\n        this.$newElement.css('width', '');\r\n      }\r\n      // Remove fit-width class if width is changed programmatically\r\n      if (this.$newElement.hasClass('fit-width') && this.options.width !== 'fit') {\r\n        this.$newElement[0].classList.remove('fit-width');\r\n      }\r\n    },\r\n\r\n    selectPosition: function () {\r\n      this.$bsContainer = $('<div class=\"bs-container\" />');\r\n\r\n      var that = this,\r\n          $container = $(this.options.container),\r\n          pos,\r\n          containerPos,\r\n          actualHeight,\r\n          getPlacement = function ($element) {\r\n            var containerPosition = {},\r\n                // fall back to dropdown's default display setting if display is not manually set\r\n                display = that.options.display || (\r\n                  // Bootstrap 3 doesn't have $.fn.dropdown.Constructor.Default\r\n                  $.fn.dropdown.Constructor.Default ? $.fn.dropdown.Constructor.Default.display\r\n                  : false\r\n                );\r\n\r\n            that.$bsContainer.addClass($element.attr('class').replace(/form-control|fit-width/gi, '')).toggleClass(classNames.DROPUP, $element.hasClass(classNames.DROPUP));\r\n            pos = $element.offset();\r\n\r\n            if (!$container.is('body')) {\r\n              containerPos = $container.offset();\r\n              containerPos.top += parseInt($container.css('borderTopWidth')) - $container.scrollTop();\r\n              containerPos.left += parseInt($container.css('borderLeftWidth')) - $container.scrollLeft();\r\n            } else {\r\n              containerPos = { top: 0, left: 0 };\r\n            }\r\n\r\n            actualHeight = $element.hasClass(classNames.DROPUP) ? 0 : $element[0].offsetHeight;\r\n\r\n            // Bootstrap 4+ uses Popper for menu positioning\r\n            if (version.major < 4 || display === 'static') {\r\n              containerPosition.top = pos.top - containerPos.top + actualHeight;\r\n              containerPosition.left = pos.left - containerPos.left;\r\n            }\r\n\r\n            containerPosition.width = $element[0].offsetWidth;\r\n\r\n            that.$bsContainer.css(containerPosition);\r\n          };\r\n\r\n      this.$button.on('click.bs.dropdown.data-api', function () {\r\n        if (that.isDisabled()) {\r\n          return;\r\n        }\r\n\r\n        getPlacement(that.$newElement);\r\n\r\n        that.$bsContainer\r\n          .appendTo(that.options.container)\r\n          .toggleClass(classNames.SHOW, !that.$button.hasClass(classNames.SHOW))\r\n          .append(that.$menu);\r\n      });\r\n\r\n      $(window)\r\n        .off('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId)\r\n        .on('resize' + EVENT_KEY + '.' + this.selectId + ' scroll' + EVENT_KEY + '.' + this.selectId, function () {\r\n          var isActive = that.$newElement.hasClass(classNames.SHOW);\r\n\r\n          if (isActive) getPlacement(that.$newElement);\r\n        });\r\n\r\n      this.$element.on('hide' + EVENT_KEY, function () {\r\n        that.$menu.data('height', that.$menu.height());\r\n        that.$bsContainer.detach();\r\n      });\r\n    },\r\n\r\n    setOptionStatus: function (selectedOnly) {\r\n      var that = this;\r\n\r\n      that.noScroll = false;\r\n\r\n      if (that.selectpicker.view.visibleElements && that.selectpicker.view.visibleElements.length) {\r\n        for (var i = 0; i < that.selectpicker.view.visibleElements.length; i++) {\r\n          var liData = that.selectpicker.current.data[i + that.selectpicker.view.position0],\r\n              option = liData.option;\r\n\r\n          if (option) {\r\n            if (selectedOnly !== true) {\r\n              that.setDisabled(\r\n                liData.index,\r\n                liData.disabled\r\n              );\r\n            }\r\n\r\n            that.setSelected(\r\n              liData.index,\r\n              option.selected\r\n            );\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {number} index - the index of the option that is being changed\r\n     * @param {boolean} selected - true if the option is being selected, false if being deselected\r\n     */\r\n    setSelected: function (index, selected) {\r\n      var li = this.selectpicker.main.elements[index],\r\n          liData = this.selectpicker.main.data[index],\r\n          activeIndexIsSet = this.activeIndex !== undefined,\r\n          thisIsActive = this.activeIndex === index,\r\n          prevActive,\r\n          a,\r\n          // if current option is already active\r\n          // OR\r\n          // if the current option is being selected, it's NOT multiple, and\r\n          // activeIndex is undefined:\r\n          //  - when the menu is first being opened, OR\r\n          //  - after a search has been performed, OR\r\n          //  - when retainActive is false when selecting a new option (i.e. index of the newly selected option is not the same as the current activeIndex)\r\n          keepActive = thisIsActive || (selected && !this.multiple && !activeIndexIsSet);\r\n\r\n      liData.selected = selected;\r\n\r\n      a = li.firstChild;\r\n\r\n      if (selected) {\r\n        this.selectedIndex = index;\r\n      }\r\n\r\n      li.classList.toggle('selected', selected);\r\n\r\n      if (keepActive) {\r\n        this.focusItem(li, liData);\r\n        this.selectpicker.view.currentActive = li;\r\n        this.activeIndex = index;\r\n      } else {\r\n        this.defocusItem(li);\r\n      }\r\n\r\n      if (a) {\r\n        a.classList.toggle('selected', selected);\r\n\r\n        if (selected) {\r\n          a.setAttribute('aria-selected', true);\r\n        } else {\r\n          if (this.multiple) {\r\n            a.setAttribute('aria-selected', false);\r\n          } else {\r\n            a.removeAttribute('aria-selected');\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!keepActive && !activeIndexIsSet && selected && this.prevActiveIndex !== undefined) {\r\n        prevActive = this.selectpicker.main.elements[this.prevActiveIndex];\r\n\r\n        this.defocusItem(prevActive);\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @param {number} index - the index of the option that is being disabled\r\n     * @param {boolean} disabled - true if the option is being disabled, false if being enabled\r\n     */\r\n    setDisabled: function (index, disabled) {\r\n      var li = this.selectpicker.main.elements[index],\r\n          a;\r\n\r\n      this.selectpicker.main.data[index].disabled = disabled;\r\n\r\n      a = li.firstChild;\r\n\r\n      li.classList.toggle(classNames.DISABLED, disabled);\r\n\r\n      if (a) {\r\n        if (version.major === '4') a.classList.toggle(classNames.DISABLED, disabled);\r\n\r\n        if (disabled) {\r\n          a.setAttribute('aria-disabled', disabled);\r\n          a.setAttribute('tabindex', -1);\r\n        } else {\r\n          a.removeAttribute('aria-disabled');\r\n          a.setAttribute('tabindex', 0);\r\n        }\r\n      }\r\n    },\r\n\r\n    isDisabled: function () {\r\n      return this.$element[0].disabled;\r\n    },\r\n\r\n    checkDisabled: function () {\r\n      if (this.isDisabled()) {\r\n        this.$newElement[0].classList.add(classNames.DISABLED);\r\n        this.$button.addClass(classNames.DISABLED).attr('aria-disabled', true);\r\n      } else {\r\n        if (this.$button[0].classList.contains(classNames.DISABLED)) {\r\n          this.$newElement[0].classList.remove(classNames.DISABLED);\r\n          this.$button.removeClass(classNames.DISABLED).attr('aria-disabled', false);\r\n        }\r\n      }\r\n    },\r\n\r\n    clickListener: function () {\r\n      var that = this,\r\n          $document = $(document);\r\n\r\n      $document.data('spaceSelect', false);\r\n\r\n      this.$button.on('keyup', function (e) {\r\n        if (/(32)/.test(e.keyCode.toString(10)) && $document.data('spaceSelect')) {\r\n          e.preventDefault();\r\n          $document.data('spaceSelect', false);\r\n        }\r\n      });\r\n\r\n      this.$newElement.on('show.bs.dropdown', function () {\r\n        if (version.major > 3 && !that.dropdown) {\r\n          that.dropdown = that.$button.data('bs.dropdown');\r\n          that.dropdown._menu = that.$menu[0];\r\n        }\r\n      });\r\n\r\n      this.$button.on('click.bs.dropdown.data-api', function () {\r\n        if (!that.$newElement.hasClass(classNames.SHOW)) {\r\n          that.setSize();\r\n        }\r\n      });\r\n\r\n      function setFocus () {\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          that.$menuInner.trigger('focus');\r\n        }\r\n      }\r\n\r\n      function checkPopperExists () {\r\n        if (that.dropdown && that.dropdown._popper && that.dropdown._popper.state.isCreated) {\r\n          setFocus();\r\n        } else {\r\n          requestAnimationFrame(checkPopperExists);\r\n        }\r\n      }\r\n\r\n      this.$element.on('shown' + EVENT_KEY, function () {\r\n        if (that.$menuInner[0].scrollTop !== that.selectpicker.view.scrollTop) {\r\n          that.$menuInner[0].scrollTop = that.selectpicker.view.scrollTop;\r\n        }\r\n\r\n        if (version.major > 3) {\r\n          requestAnimationFrame(checkPopperExists);\r\n        } else {\r\n          setFocus();\r\n        }\r\n      });\r\n\r\n      // ensure posinset and setsize are correct before selecting an option via a click\r\n      this.$menuInner.on('mouseenter', 'li a', function (e) {\r\n        var hoverLi = this.parentElement,\r\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\r\n            index = Array.prototype.indexOf.call(hoverLi.parentElement.children, hoverLi),\r\n            hoverData = that.selectpicker.current.data[index + position0];\r\n\r\n        that.focusItem(hoverLi, hoverData, true);\r\n      });\r\n\r\n      this.$menuInner.on('click', 'li a', function (e, retainActive) {\r\n        var $this = $(this),\r\n            element = that.$element[0],\r\n            position0 = that.isVirtual() ? that.selectpicker.view.position0 : 0,\r\n            clickedData = that.selectpicker.current.data[$this.parent().index() + position0],\r\n            clickedIndex = clickedData.index,\r\n            prevValue = getSelectValues(element),\r\n            prevIndex = element.selectedIndex,\r\n            prevOption = element.options[prevIndex],\r\n            triggerChange = true;\r\n\r\n        // Don't close on multi choice menu\r\n        if (that.multiple && that.options.maxOptions !== 1) {\r\n          e.stopPropagation();\r\n        }\r\n\r\n        e.preventDefault();\r\n\r\n        // Don't run if the select is disabled\r\n        if (!that.isDisabled() && !$this.parent().hasClass(classNames.DISABLED)) {\r\n          var option = clickedData.option,\r\n              $option = $(option),\r\n              state = option.selected,\r\n              $optgroup = $option.parent('optgroup'),\r\n              $optgroupOptions = $optgroup.find('option'),\r\n              maxOptions = that.options.maxOptions,\r\n              maxOptionsGrp = $optgroup.data('maxOptions') || false;\r\n\r\n          if (clickedIndex === that.activeIndex) retainActive = true;\r\n\r\n          if (!retainActive) {\r\n            that.prevActiveIndex = that.activeIndex;\r\n            that.activeIndex = undefined;\r\n          }\r\n\r\n          if (!that.multiple) { // Deselect all others if not multi select box\r\n            if (prevOption) prevOption.selected = false;\r\n            option.selected = true;\r\n            that.setSelected(clickedIndex, true);\r\n          } else { // Toggle the one we have chosen if we are multi select.\r\n            option.selected = !state;\r\n\r\n            that.setSelected(clickedIndex, !state);\r\n            that.focusedParent.focus();\r\n\r\n            if (maxOptions !== false || maxOptionsGrp !== false) {\r\n              var maxReached = maxOptions < getSelectedOptions(element).length,\r\n                  maxReachedGrp = maxOptionsGrp < $optgroup.find('option:selected').length;\r\n\r\n              if ((maxOptions && maxReached) || (maxOptionsGrp && maxReachedGrp)) {\r\n                if (maxOptions && maxOptions == 1) {\r\n                  element.selectedIndex = -1;\r\n                  option.selected = true;\r\n                  that.setOptionStatus(true);\r\n                } else if (maxOptionsGrp && maxOptionsGrp == 1) {\r\n                  for (var i = 0; i < $optgroupOptions.length; i++) {\r\n                    var _option = $optgroupOptions[i];\r\n                    _option.selected = false;\r\n                    that.setSelected(_option.liIndex, false);\r\n                  }\r\n\r\n                  option.selected = true;\r\n                  that.setSelected(clickedIndex, true);\r\n                } else {\r\n                  var maxOptionsText = typeof that.options.maxOptionsText === 'string' ? [that.options.maxOptionsText, that.options.maxOptionsText] : that.options.maxOptionsText,\r\n                      maxOptionsArr = typeof maxOptionsText === 'function' ? maxOptionsText(maxOptions, maxOptionsGrp) : maxOptionsText,\r\n                      maxTxt = maxOptionsArr[0].replace('{n}', maxOptions),\r\n                      maxTxtGrp = maxOptionsArr[1].replace('{n}', maxOptionsGrp),\r\n                      $notify = $('<div class=\"notify\"></div>');\r\n                  // If {var} is set in array, replace it\r\n                  /** @deprecated */\r\n                  if (maxOptionsArr[2]) {\r\n                    maxTxt = maxTxt.replace('{var}', maxOptionsArr[2][maxOptions > 1 ? 0 : 1]);\r\n                    maxTxtGrp = maxTxtGrp.replace('{var}', maxOptionsArr[2][maxOptionsGrp > 1 ? 0 : 1]);\r\n                  }\r\n\r\n                  option.selected = false;\r\n\r\n                  that.$menu.append($notify);\r\n\r\n                  if (maxOptions && maxReached) {\r\n                    $notify.append($('<div>' + maxTxt + '</div>'));\r\n                    triggerChange = false;\r\n                    that.$element.trigger('maxReached' + EVENT_KEY);\r\n                  }\r\n\r\n                  if (maxOptionsGrp && maxReachedGrp) {\r\n                    $notify.append($('<div>' + maxTxtGrp + '</div>'));\r\n                    triggerChange = false;\r\n                    that.$element.trigger('maxReachedGrp' + EVENT_KEY);\r\n                  }\r\n\r\n                  setTimeout(function () {\r\n                    that.setSelected(clickedIndex, false);\r\n                  }, 10);\r\n\r\n                  $notify[0].classList.add('fadeOut');\r\n\r\n                  setTimeout(function () {\r\n                    $notify.remove();\r\n                  }, 1050);\r\n                }\r\n              }\r\n            }\r\n          }\r\n\r\n          if (!that.multiple || (that.multiple && that.options.maxOptions === 1)) {\r\n            that.$button.trigger('focus');\r\n          } else if (that.options.liveSearch) {\r\n            that.$searchbox.trigger('focus');\r\n          }\r\n\r\n          // Trigger select 'change'\r\n          if (triggerChange) {\r\n            if (that.multiple || prevIndex !== element.selectedIndex) {\r\n              // $option.prop('selected') is current option state (selected/unselected). prevValue is the value of the select prior to being changed.\r\n              changedArguments = [option.index, $option.prop('selected'), prevValue];\r\n              that.$element\r\n                .triggerNative('change');\r\n            }\r\n          }\r\n        }\r\n      });\r\n\r\n      this.$menu.on('click', 'li.' + classNames.DISABLED + ' a, .' + classNames.POPOVERHEADER + ', .' + classNames.POPOVERHEADER + ' :not(.close)', function (e) {\r\n        if (e.currentTarget == this) {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n          if (that.options.liveSearch && !$(e.target).hasClass('close')) {\r\n            that.$searchbox.trigger('focus');\r\n          } else {\r\n            that.$button.trigger('focus');\r\n          }\r\n        }\r\n      });\r\n\r\n      this.$menuInner.on('click', '.divider, .dropdown-header', function (e) {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          that.$button.trigger('focus');\r\n        }\r\n      });\r\n\r\n      this.$menu.on('click', '.' + classNames.POPOVERHEADER + ' .close', function () {\r\n        that.$button.trigger('click');\r\n      });\r\n\r\n      this.$searchbox.on('click', function (e) {\r\n        e.stopPropagation();\r\n      });\r\n\r\n      this.$menu.on('click', '.actions-btn', function (e) {\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          that.$button.trigger('focus');\r\n        }\r\n\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n\r\n        if ($(this).hasClass('bs-select-all')) {\r\n          that.selectAll();\r\n        } else {\r\n          that.deselectAll();\r\n        }\r\n      });\r\n\r\n      this.$button\r\n        .on('focus' + EVENT_KEY, function (e) {\r\n          var tabindex = that.$element[0].getAttribute('tabindex');\r\n\r\n          // only change when button is actually focused\r\n          if (tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\r\n            // apply select element's tabindex to ensure correct order is followed when tabbing to the next element\r\n            this.setAttribute('tabindex', tabindex);\r\n            // set element's tabindex to -1 to allow for reverse tabbing\r\n            that.$element[0].setAttribute('tabindex', -1);\r\n            that.selectpicker.view.tabindex = tabindex;\r\n          }\r\n        })\r\n        .on('blur' + EVENT_KEY, function (e) {\r\n          // revert everything to original tabindex\r\n          if (that.selectpicker.view.tabindex !== undefined && e.originalEvent && e.originalEvent.isTrusted) {\r\n            that.$element[0].setAttribute('tabindex', that.selectpicker.view.tabindex);\r\n            this.setAttribute('tabindex', -1);\r\n            that.selectpicker.view.tabindex = undefined;\r\n          }\r\n        });\r\n\r\n      this.$element\r\n        .on('change' + EVENT_KEY, function () {\r\n          that.render();\r\n          that.$element.trigger('changed' + EVENT_KEY, changedArguments);\r\n          changedArguments = null;\r\n        })\r\n        .on('focus' + EVENT_KEY, function () {\r\n          if (!that.options.mobile) that.$button[0].focus();\r\n        });\r\n    },\r\n\r\n    liveSearchListener: function () {\r\n      var that = this;\r\n\r\n      this.$button.on('click.bs.dropdown.data-api', function () {\r\n        if (!!that.$searchbox.val()) {\r\n          that.$searchbox.val('');\r\n          that.selectpicker.search.previousValue = undefined;\r\n        }\r\n      });\r\n\r\n      this.$searchbox.on('click.bs.dropdown.data-api focus.bs.dropdown.data-api touchend.bs.dropdown.data-api', function (e) {\r\n        e.stopPropagation();\r\n      });\r\n\r\n      this.$searchbox.on('input propertychange', function () {\r\n        var searchValue = that.$searchbox[0].value;\r\n\r\n        that.selectpicker.search.elements = [];\r\n        that.selectpicker.search.data = [];\r\n\r\n        if (searchValue) {\r\n          var i,\r\n              searchMatch = [],\r\n              q = searchValue.toUpperCase(),\r\n              cache = {},\r\n              cacheArr = [],\r\n              searchStyle = that._searchStyle(),\r\n              normalizeSearch = that.options.liveSearchNormalize;\r\n\r\n          if (normalizeSearch) q = normalizeToBase(q);\r\n\r\n          for (var i = 0; i < that.selectpicker.main.data.length; i++) {\r\n            var li = that.selectpicker.main.data[i];\r\n\r\n            if (!cache[i]) {\r\n              cache[i] = stringSearch(li, q, searchStyle, normalizeSearch);\r\n            }\r\n\r\n            if (cache[i] && li.headerIndex !== undefined && cacheArr.indexOf(li.headerIndex) === -1) {\r\n              if (li.headerIndex > 0) {\r\n                cache[li.headerIndex - 1] = true;\r\n                cacheArr.push(li.headerIndex - 1);\r\n              }\r\n\r\n              cache[li.headerIndex] = true;\r\n              cacheArr.push(li.headerIndex);\r\n\r\n              cache[li.lastIndex + 1] = true;\r\n            }\r\n\r\n            if (cache[i] && li.type !== 'optgroup-label') cacheArr.push(i);\r\n          }\r\n\r\n          for (var i = 0, cacheLen = cacheArr.length; i < cacheLen; i++) {\r\n            var index = cacheArr[i],\r\n                prevIndex = cacheArr[i - 1],\r\n                li = that.selectpicker.main.data[index],\r\n                liPrev = that.selectpicker.main.data[prevIndex];\r\n\r\n            if (li.type !== 'divider' || (li.type === 'divider' && liPrev && liPrev.type !== 'divider' && cacheLen - 1 !== i)) {\r\n              that.selectpicker.search.data.push(li);\r\n              searchMatch.push(that.selectpicker.main.elements[index]);\r\n            }\r\n          }\r\n\r\n          that.activeIndex = undefined;\r\n          that.noScroll = true;\r\n          that.$menuInner.scrollTop(0);\r\n          that.selectpicker.search.elements = searchMatch;\r\n          that.createView(true);\r\n          showNoResults.call(that, searchMatch, searchValue);\r\n        } else if (that.selectpicker.search.previousValue) { // for IE11 (#2402)\r\n          that.$menuInner.scrollTop(0);\r\n          that.createView(false);\r\n        }\r\n\r\n        that.selectpicker.search.previousValue =  searchValue;\r\n      });\r\n    },\r\n\r\n    _searchStyle: function () {\r\n      return this.options.liveSearchStyle || 'contains';\r\n    },\r\n\r\n    val: function (value) {\r\n      var element = this.$element[0];\r\n\r\n      if (typeof value !== 'undefined') {\r\n        var prevValue = getSelectValues(element);\r\n\r\n        changedArguments = [null, null, prevValue];\r\n\r\n        this.$element\r\n          .val(value)\r\n          .trigger('changed' + EVENT_KEY, changedArguments);\r\n\r\n        if (this.$newElement.hasClass(classNames.SHOW)) {\r\n          if (this.multiple) {\r\n            this.setOptionStatus(true);\r\n          } else {\r\n            var liSelectedIndex = (element.options[element.selectedIndex] || {}).liIndex;\r\n\r\n            if (typeof liSelectedIndex === 'number') {\r\n              this.setSelected(this.selectedIndex, false);\r\n              this.setSelected(liSelectedIndex, true);\r\n            }\r\n          }\r\n        }\r\n\r\n        this.render();\r\n\r\n        changedArguments = null;\r\n\r\n        return this.$element;\r\n      } else {\r\n        return this.$element.val();\r\n      }\r\n    },\r\n\r\n    changeAll: function (status) {\r\n      if (!this.multiple) return;\r\n      if (typeof status === 'undefined') status = true;\r\n\r\n      var element = this.$element[0],\r\n          previousSelected = 0,\r\n          currentSelected = 0,\r\n          prevValue = getSelectValues(element);\r\n\r\n      element.classList.add('bs-select-hidden');\r\n\r\n      for (var i = 0, data = this.selectpicker.current.data, len = data.length; i < len; i++) {\r\n        var liData = data[i],\r\n            option = liData.option;\r\n\r\n        if (option && !liData.disabled && liData.type !== 'divider') {\r\n          if (liData.selected) previousSelected++;\r\n          option.selected = status;\r\n          if (status === true) currentSelected++;\r\n        }\r\n      }\r\n\r\n      element.classList.remove('bs-select-hidden');\r\n\r\n      if (previousSelected === currentSelected) return;\r\n\r\n      this.setOptionStatus();\r\n\r\n      changedArguments = [null, null, prevValue];\r\n\r\n      this.$element\r\n        .triggerNative('change');\r\n    },\r\n\r\n    selectAll: function () {\r\n      return this.changeAll(true);\r\n    },\r\n\r\n    deselectAll: function () {\r\n      return this.changeAll(false);\r\n    },\r\n\r\n    toggle: function (e) {\r\n      e = e || window.event;\r\n\r\n      if (e) e.stopPropagation();\r\n\r\n      this.$button.trigger('click.bs.dropdown.data-api');\r\n    },\r\n\r\n    keydown: function (e) {\r\n      var $this = $(this),\r\n          isToggle = $this.hasClass('dropdown-toggle'),\r\n          $parent = isToggle ? $this.closest('.dropdown') : $this.closest(Selector.MENU),\r\n          that = $parent.data('this'),\r\n          $items = that.findLis(),\r\n          index,\r\n          isActive,\r\n          liActive,\r\n          activeLi,\r\n          offset,\r\n          updateScroll = false,\r\n          downOnTab = e.which === keyCodes.TAB && !isToggle && !that.options.selectOnTab,\r\n          isArrowKey = REGEXP_ARROW.test(e.which) || downOnTab,\r\n          scrollTop = that.$menuInner[0].scrollTop,\r\n          isVirtual = that.isVirtual(),\r\n          position0 = isVirtual === true ? that.selectpicker.view.position0 : 0;\r\n\r\n      // do nothing if a function key is pressed\r\n      if (e.which >= 112 && e.which <= 123) return;\r\n\r\n      isActive = that.$newElement.hasClass(classNames.SHOW);\r\n\r\n      if (\r\n        !isActive &&\r\n        (\r\n          isArrowKey ||\r\n          (e.which >= 48 && e.which <= 57) ||\r\n          (e.which >= 96 && e.which <= 105) ||\r\n          (e.which >= 65 && e.which <= 90)\r\n        )\r\n      ) {\r\n        that.$button.trigger('click.bs.dropdown.data-api');\r\n\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n          return;\r\n        }\r\n      }\r\n\r\n      if (e.which === keyCodes.ESCAPE && isActive) {\r\n        e.preventDefault();\r\n        that.$button.trigger('click.bs.dropdown.data-api').trigger('focus');\r\n      }\r\n\r\n      if (isArrowKey) { // if up or down\r\n        if (!$items.length) return;\r\n\r\n        liActive = that.selectpicker.main.elements[that.activeIndex];\r\n        index = liActive ? Array.prototype.indexOf.call(liActive.parentElement.children, liActive) : -1;\r\n\r\n        if (index !== -1) {\r\n          that.defocusItem(liActive);\r\n        }\r\n\r\n        if (e.which === keyCodes.ARROW_UP) { // up\r\n          if (index !== -1) index--;\r\n          if (index + position0 < 0) index += $items.length;\r\n\r\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\r\n            index = that.selectpicker.view.canHighlight.slice(0, index + position0).lastIndexOf(true) - position0;\r\n            if (index === -1) index = $items.length - 1;\r\n          }\r\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\r\n          index++;\r\n          if (index + position0 >= that.selectpicker.view.canHighlight.length) index = that.selectpicker.view.firstHighlightIndex;\r\n\r\n          if (!that.selectpicker.view.canHighlight[index + position0]) {\r\n            index = index + 1 + that.selectpicker.view.canHighlight.slice(index + position0 + 1).indexOf(true);\r\n          }\r\n        }\r\n\r\n        e.preventDefault();\r\n\r\n        var liActiveIndex = position0 + index;\r\n\r\n        if (e.which === keyCodes.ARROW_UP) { // up\r\n          // scroll to bottom and highlight last option\r\n          if (position0 === 0 && index === $items.length - 1) {\r\n            that.$menuInner[0].scrollTop = that.$menuInner[0].scrollHeight;\r\n\r\n            liActiveIndex = that.selectpicker.current.elements.length - 1;\r\n          } else {\r\n            activeLi = that.selectpicker.current.data[liActiveIndex];\r\n            offset = activeLi.position - activeLi.height;\r\n\r\n            updateScroll = offset < scrollTop;\r\n          }\r\n        } else if (e.which === keyCodes.ARROW_DOWN || downOnTab) { // down\r\n          // scroll to top and highlight first option\r\n          if (index === that.selectpicker.view.firstHighlightIndex) {\r\n            that.$menuInner[0].scrollTop = 0;\r\n\r\n            liActiveIndex = that.selectpicker.view.firstHighlightIndex;\r\n          } else {\r\n            activeLi = that.selectpicker.current.data[liActiveIndex];\r\n            offset = activeLi.position - that.sizeInfo.menuInnerHeight;\r\n\r\n            updateScroll = offset > scrollTop;\r\n          }\r\n        }\r\n\r\n        liActive = that.selectpicker.current.elements[liActiveIndex];\r\n\r\n        that.activeIndex = that.selectpicker.current.data[liActiveIndex].index;\r\n\r\n        that.focusItem(liActive);\r\n\r\n        that.selectpicker.view.currentActive = liActive;\r\n\r\n        if (updateScroll) that.$menuInner[0].scrollTop = offset;\r\n\r\n        if (that.options.liveSearch) {\r\n          that.$searchbox.trigger('focus');\r\n        } else {\r\n          $this.trigger('focus');\r\n        }\r\n      } else if (\r\n        (!$this.is('input') && !REGEXP_TAB_OR_ESCAPE.test(e.which)) ||\r\n        (e.which === keyCodes.SPACE && that.selectpicker.keydown.keyHistory)\r\n      ) {\r\n        var searchMatch,\r\n            matches = [],\r\n            keyHistory;\r\n\r\n        e.preventDefault();\r\n\r\n        that.selectpicker.keydown.keyHistory += keyCodeMap[e.which];\r\n\r\n        if (that.selectpicker.keydown.resetKeyHistory.cancel) clearTimeout(that.selectpicker.keydown.resetKeyHistory.cancel);\r\n        that.selectpicker.keydown.resetKeyHistory.cancel = that.selectpicker.keydown.resetKeyHistory.start();\r\n\r\n        keyHistory = that.selectpicker.keydown.keyHistory;\r\n\r\n        // if all letters are the same, set keyHistory to just the first character when searching\r\n        if (/^(.)\\1+$/.test(keyHistory)) {\r\n          keyHistory = keyHistory.charAt(0);\r\n        }\r\n\r\n        // find matches\r\n        for (var i = 0; i < that.selectpicker.current.data.length; i++) {\r\n          var li = that.selectpicker.current.data[i],\r\n              hasMatch;\r\n\r\n          hasMatch = stringSearch(li, keyHistory, 'startsWith', true);\r\n\r\n          if (hasMatch && that.selectpicker.view.canHighlight[i]) {\r\n            matches.push(li.index);\r\n          }\r\n        }\r\n\r\n        if (matches.length) {\r\n          var matchIndex = 0;\r\n\r\n          $items.removeClass('active').find('a').removeClass('active');\r\n\r\n          // either only one key has been pressed or they are all the same key\r\n          if (keyHistory.length === 1) {\r\n            matchIndex = matches.indexOf(that.activeIndex);\r\n\r\n            if (matchIndex === -1 || matchIndex === matches.length - 1) {\r\n              matchIndex = 0;\r\n            } else {\r\n              matchIndex++;\r\n            }\r\n          }\r\n\r\n          searchMatch = matches[matchIndex];\r\n\r\n          activeLi = that.selectpicker.main.data[searchMatch];\r\n\r\n          if (scrollTop - activeLi.position > 0) {\r\n            offset = activeLi.position - activeLi.height;\r\n            updateScroll = true;\r\n          } else {\r\n            offset = activeLi.position - that.sizeInfo.menuInnerHeight;\r\n            // if the option is already visible at the current scroll position, just keep it the same\r\n            updateScroll = activeLi.position > scrollTop + that.sizeInfo.menuInnerHeight;\r\n          }\r\n\r\n          liActive = that.selectpicker.main.elements[searchMatch];\r\n\r\n          that.activeIndex = matches[matchIndex];\r\n\r\n          that.focusItem(liActive);\r\n\r\n          if (liActive) liActive.firstChild.focus();\r\n\r\n          if (updateScroll) that.$menuInner[0].scrollTop = offset;\r\n\r\n          $this.trigger('focus');\r\n        }\r\n      }\r\n\r\n      // Select focused option if \"Enter\", \"Spacebar\" or \"Tab\" (when selectOnTab is true) are pressed inside the menu.\r\n      if (\r\n        isActive &&\r\n        (\r\n          (e.which === keyCodes.SPACE && !that.selectpicker.keydown.keyHistory) ||\r\n          e.which === keyCodes.ENTER ||\r\n          (e.which === keyCodes.TAB && that.options.selectOnTab)\r\n        )\r\n      ) {\r\n        if (e.which !== keyCodes.SPACE) e.preventDefault();\r\n\r\n        if (!that.options.liveSearch || e.which !== keyCodes.SPACE) {\r\n          that.$menuInner.find('.active a').trigger('click', true); // retain active class\r\n          $this.trigger('focus');\r\n\r\n          if (!that.options.liveSearch) {\r\n            // Prevent screen from scrolling if the user hits the spacebar\r\n            e.preventDefault();\r\n            // Fixes spacebar selection of dropdown items in FF & IE\r\n            $(document).data('spaceSelect', true);\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    mobile: function () {\r\n      // ensure mobile is set to true if mobile function is called after init\r\n      this.options.mobile = true;\r\n      this.$element[0].classList.add('mobile-device');\r\n    },\r\n\r\n    refresh: function () {\r\n      // update options if data attributes have been changed\r\n      var config = $.extend({}, this.options, this.$element.data());\r\n      this.options = config;\r\n\r\n      this.checkDisabled();\r\n      this.buildData();\r\n      this.setStyle();\r\n      this.render();\r\n      this.buildList();\r\n      this.setWidth();\r\n\r\n      this.setSize(true);\r\n\r\n      this.$element.trigger('refreshed' + EVENT_KEY);\r\n    },\r\n\r\n    hide: function () {\r\n      this.$newElement.hide();\r\n    },\r\n\r\n    show: function () {\r\n      this.$newElement.show();\r\n    },\r\n\r\n    remove: function () {\r\n      this.$newElement.remove();\r\n      this.$element.remove();\r\n    },\r\n\r\n    destroy: function () {\r\n      this.$newElement.before(this.$element).remove();\r\n\r\n      if (this.$bsContainer) {\r\n        this.$bsContainer.remove();\r\n      } else {\r\n        this.$menu.remove();\r\n      }\r\n\r\n      if (this.selectpicker.view.titleOption && this.selectpicker.view.titleOption.parentNode) {\r\n        this.selectpicker.view.titleOption.parentNode.removeChild(this.selectpicker.view.titleOption);\r\n      }\r\n\r\n      this.$element\r\n        .off(EVENT_KEY)\r\n        .removeData('selectpicker')\r\n        .removeClass('bs-select-hidden selectpicker');\r\n\r\n      $(window).off(EVENT_KEY + '.' + this.selectId);\r\n    }\r\n  };\r\n\r\n  // SELECTPICKER PLUGIN DEFINITION\r\n  // ==============================\r\n  function Plugin (option) {\r\n    // get the args of the outer function..\r\n    var args = arguments;\r\n    // The arguments of the function are explicitly re-defined from the argument list, because the shift causes them\r\n    // to get lost/corrupted in android 2.3 and IE9 #715 #775\r\n    var _option = option;\r\n\r\n    [].shift.apply(args);\r\n\r\n    // if the version was not set successfully\r\n    if (!version.success) {\r\n      // try to retreive it again\r\n      try {\r\n        version.full = ($.fn.dropdown.Constructor.VERSION || '').split(' ')[0].split('.');\r\n      } catch (err) {\r\n        // fall back to use BootstrapVersion if set\r\n        if (Selectpicker.BootstrapVersion) {\r\n          version.full = Selectpicker.BootstrapVersion.split(' ')[0].split('.');\r\n        } else {\r\n          version.full = [version.major, '0', '0'];\r\n\r\n          console.warn(\r\n            'There was an issue retrieving Bootstrap\\'s version. ' +\r\n            'Ensure Bootstrap is being loaded before bootstrap-select and there is no namespace collision. ' +\r\n            'If loading Bootstrap asynchronously, the version may need to be manually specified via $.fn.selectpicker.Constructor.BootstrapVersion.',\r\n            err\r\n          );\r\n        }\r\n      }\r\n\r\n      version.major = version.full[0];\r\n      version.success = true;\r\n    }\r\n\r\n    if (version.major === '4') {\r\n      // some defaults need to be changed if using Bootstrap 4\r\n      // check to see if they have already been manually changed before forcing them to update\r\n      var toUpdate = [];\r\n\r\n      if (Selectpicker.DEFAULTS.style === classNames.BUTTONCLASS) toUpdate.push({ name: 'style', className: 'BUTTONCLASS' });\r\n      if (Selectpicker.DEFAULTS.iconBase === classNames.ICONBASE) toUpdate.push({ name: 'iconBase', className: 'ICONBASE' });\r\n      if (Selectpicker.DEFAULTS.tickIcon === classNames.TICKICON) toUpdate.push({ name: 'tickIcon', className: 'TICKICON' });\r\n\r\n      classNames.DIVIDER = 'dropdown-divider';\r\n      classNames.SHOW = 'show';\r\n      classNames.BUTTONCLASS = 'btn-light';\r\n      classNames.POPOVERHEADER = 'popover-header';\r\n      classNames.ICONBASE = '';\r\n      classNames.TICKICON = 'bs-ok-default';\r\n\r\n      for (var i = 0; i < toUpdate.length; i++) {\r\n        var option = toUpdate[i];\r\n        Selectpicker.DEFAULTS[option.name] = classNames[option.className];\r\n      }\r\n    }\r\n\r\n    var value;\r\n    var chain = this.each(function () {\r\n      var $this = $(this);\r\n      if ($this.is('select')) {\r\n        var data = $this.data('selectpicker'),\r\n            options = typeof _option == 'object' && _option;\r\n\r\n        if (!data) {\r\n          var dataAttributes = $this.data();\r\n\r\n          for (var dataAttr in dataAttributes) {\r\n            if (Object.prototype.hasOwnProperty.call(dataAttributes, dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {\r\n              delete dataAttributes[dataAttr];\r\n            }\r\n          }\r\n\r\n          var config = $.extend({}, Selectpicker.DEFAULTS, $.fn.selectpicker.defaults || {}, dataAttributes, options);\r\n          config.template = $.extend({}, Selectpicker.DEFAULTS.template, ($.fn.selectpicker.defaults ? $.fn.selectpicker.defaults.template : {}), dataAttributes.template, options.template);\r\n          $this.data('selectpicker', (data = new Selectpicker(this, config)));\r\n        } else if (options) {\r\n          for (var i in options) {\r\n            if (Object.prototype.hasOwnProperty.call(options, i)) {\r\n              data.options[i] = options[i];\r\n            }\r\n          }\r\n        }\r\n\r\n        if (typeof _option == 'string') {\r\n          if (data[_option] instanceof Function) {\r\n            value = data[_option].apply(data, args);\r\n          } else {\r\n            value = data.options[_option];\r\n          }\r\n        }\r\n      }\r\n    });\r\n\r\n    if (typeof value !== 'undefined') {\r\n      // noinspection JSUnusedAssignment\r\n      return value;\r\n    } else {\r\n      return chain;\r\n    }\r\n  }\r\n\r\n  var old = $.fn.selectpicker;\r\n  $.fn.selectpicker = Plugin;\r\n  $.fn.selectpicker.Constructor = Selectpicker;\r\n\r\n  // SELECTPICKER NO CONFLICT\r\n  // ========================\r\n  $.fn.selectpicker.noConflict = function () {\r\n    $.fn.selectpicker = old;\r\n    return this;\r\n  };\r\n\r\n  // get Bootstrap's keydown event handler for either Bootstrap 4 or Bootstrap 3\r\n  function keydownHandler () {\r\n    if ($.fn.dropdown) {\r\n      // wait to define until function is called in case Bootstrap isn't loaded yet\r\n      var bootstrapKeydown = $.fn.dropdown.Constructor._dataApiKeydownHandler || $.fn.dropdown.Constructor.prototype.keydown;\r\n      return bootstrapKeydown.apply(this, arguments);\r\n    }\r\n  }\r\n\r\n  $(document)\r\n    .off('keydown.bs.dropdown.data-api')\r\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > [data-toggle=\"dropdown\"]', keydownHandler)\r\n    .on('keydown.bs.dropdown.data-api', ':not(.bootstrap-select) > .dropdown-menu', keydownHandler)\r\n    .on('keydown' + EVENT_KEY, '.bootstrap-select [data-toggle=\"dropdown\"], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', Selectpicker.prototype.keydown)\r\n    .on('focusin.modal', '.bootstrap-select [data-toggle=\"dropdown\"], .bootstrap-select [role=\"listbox\"], .bootstrap-select .bs-searchbox input', function (e) {\r\n      e.stopPropagation();\r\n    });\r\n\r\n  // SELECTPICKER DATA-API\r\n  // =====================\r\n  $(window).on('load' + EVENT_KEY + '.data-api', function () {\r\n    $('.selectpicker').each(function () {\r\n      var $selectpicker = $(this);\r\n      Plugin.call($selectpicker, $selectpicker.data());\r\n    })\r\n  });\r\n})(jQuery);\r\n\r\n\r\n}));\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js":
/*!**********************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \**********************************************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n  * Bootstrap v5.2.0 (https://getbootstrap.com/)\n  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('@popperjs/core')) :\n  typeof define === 'function' && define.amd ? define(['@popperjs/core'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bootstrap = factory(global.Popper));\n})(this, (function (Popper) { 'use strict';\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });\n    if (e) {\n      for (const k in e) {\n        if (k !== 'default') {\n          const d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: () => e[k]\n          });\n        }\n      }\n    }\n    n.default = e;\n    return Object.freeze(n);\n  }\n\n  const Popper__namespace = /*#__PURE__*/_interopNamespace(Popper);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  const MAX_UID = 1000000;\n  const MILLISECONDS_MULTIPLIER = 1000;\n  const TRANSITION_END = 'transitionend'; // Shout-out Angus Croll (https://goo.gl/pxwQGp)\n\n  const toType = object => {\n    if (object === null || object === undefined) {\n      return `${object}`;\n    }\n\n    return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  };\n  /**\n   * Public Util API\n   */\n\n\n  const getUID = prefix => {\n    do {\n      prefix += Math.floor(Math.random() * MAX_UID);\n    } while (document.getElementById(prefix));\n\n    return prefix;\n  };\n\n  const getSelector = element => {\n    let selector = element.getAttribute('data-bs-target');\n\n    if (!selector || selector === '#') {\n      let hrefAttribute = element.getAttribute('href'); // The only valid content that could double as a selector are IDs or classes,\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n      // `document.querySelector` will rightfully complain it is invalid.\n      // See https://github.com/twbs/bootstrap/issues/32273\n\n      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\n        return null;\n      } // Just in case some CMS puts out a full URL with the anchor appended\n\n\n      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\n        hrefAttribute = `#${hrefAttribute.split('#')[1]}`;\n      }\n\n      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\n    }\n\n    return selector;\n  };\n\n  const getSelectorFromElement = element => {\n    const selector = getSelector(element);\n\n    if (selector) {\n      return document.querySelector(selector) ? selector : null;\n    }\n\n    return null;\n  };\n\n  const getElementFromSelector = element => {\n    const selector = getSelector(element);\n    return selector ? document.querySelector(selector) : null;\n  };\n\n  const getTransitionDurationFromElement = element => {\n    if (!element) {\n      return 0;\n    } // Get transition-duration of the element\n\n\n    let {\n      transitionDuration,\n      transitionDelay\n    } = window.getComputedStyle(element);\n    const floatTransitionDuration = Number.parseFloat(transitionDuration);\n    const floatTransitionDelay = Number.parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n    if (!floatTransitionDuration && !floatTransitionDelay) {\n      return 0;\n    } // If multiple durations are defined, take the first\n\n\n    transitionDuration = transitionDuration.split(',')[0];\n    transitionDelay = transitionDelay.split(',')[0];\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n  };\n\n  const triggerTransitionEnd = element => {\n    element.dispatchEvent(new Event(TRANSITION_END));\n  };\n\n  const isElement = object => {\n    if (!object || typeof object !== 'object') {\n      return false;\n    }\n\n    if (typeof object.jquery !== 'undefined') {\n      object = object[0];\n    }\n\n    return typeof object.nodeType !== 'undefined';\n  };\n\n  const getElement = object => {\n    // it's a jQuery object or a node element\n    if (isElement(object)) {\n      return object.jquery ? object[0] : object;\n    }\n\n    if (typeof object === 'string' && object.length > 0) {\n      return document.querySelector(object);\n    }\n\n    return null;\n  };\n\n  const isVisible = element => {\n    if (!isElement(element) || element.getClientRects().length === 0) {\n      return false;\n    }\n\n    const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible'; // Handle `details` element as its content may falsie appear visible when it is closed\n\n    const closedDetails = element.closest('details:not([open])');\n\n    if (!closedDetails) {\n      return elementIsVisible;\n    }\n\n    if (closedDetails !== element) {\n      const summary = element.closest('summary');\n\n      if (summary && summary.parentNode !== closedDetails) {\n        return false;\n      }\n\n      if (summary === null) {\n        return false;\n      }\n    }\n\n    return elementIsVisible;\n  };\n\n  const isDisabled = element => {\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n      return true;\n    }\n\n    if (element.classList.contains('disabled')) {\n      return true;\n    }\n\n    if (typeof element.disabled !== 'undefined') {\n      return element.disabled;\n    }\n\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\n  };\n\n  const findShadowRoot = element => {\n    if (!document.documentElement.attachShadow) {\n      return null;\n    } // Can find the shadow root otherwise it'll return the document\n\n\n    if (typeof element.getRootNode === 'function') {\n      const root = element.getRootNode();\n      return root instanceof ShadowRoot ? root : null;\n    }\n\n    if (element instanceof ShadowRoot) {\n      return element;\n    } // when we don't find a shadow root\n\n\n    if (!element.parentNode) {\n      return null;\n    }\n\n    return findShadowRoot(element.parentNode);\n  };\n\n  const noop = () => {};\n  /**\n   * Trick to restart an element's animation\n   *\n   * @param {HTMLElement} element\n   * @return void\n   *\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n   */\n\n\n  const reflow = element => {\n    element.offsetHeight; // eslint-disable-line no-unused-expressions\n  };\n\n  const getjQuery = () => {\n    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\n      return window.jQuery;\n    }\n\n    return null;\n  };\n\n  const DOMContentLoadedCallbacks = [];\n\n  const onDOMContentLoaded = callback => {\n    if (document.readyState === 'loading') {\n      // add listener on the first call when the document is in loading state\n      if (!DOMContentLoadedCallbacks.length) {\n        document.addEventListener('DOMContentLoaded', () => {\n          for (const callback of DOMContentLoadedCallbacks) {\n            callback();\n          }\n        });\n      }\n\n      DOMContentLoadedCallbacks.push(callback);\n    } else {\n      callback();\n    }\n  };\n\n  const isRTL = () => document.documentElement.dir === 'rtl';\n\n  const defineJQueryPlugin = plugin => {\n    onDOMContentLoaded(() => {\n      const $ = getjQuery();\n      /* istanbul ignore if */\n\n      if ($) {\n        const name = plugin.NAME;\n        const JQUERY_NO_CONFLICT = $.fn[name];\n        $.fn[name] = plugin.jQueryInterface;\n        $.fn[name].Constructor = plugin;\n\n        $.fn[name].noConflict = () => {\n          $.fn[name] = JQUERY_NO_CONFLICT;\n          return plugin.jQueryInterface;\n        };\n      }\n    });\n  };\n\n  const execute = callback => {\n    if (typeof callback === 'function') {\n      callback();\n    }\n  };\n\n  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {\n    if (!waitForTransition) {\n      execute(callback);\n      return;\n    }\n\n    const durationPadding = 5;\n    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n    let called = false;\n\n    const handler = ({\n      target\n    }) => {\n      if (target !== transitionElement) {\n        return;\n      }\n\n      called = true;\n      transitionElement.removeEventListener(TRANSITION_END, handler);\n      execute(callback);\n    };\n\n    transitionElement.addEventListener(TRANSITION_END, handler);\n    setTimeout(() => {\n      if (!called) {\n        triggerTransitionEnd(transitionElement);\n      }\n    }, emulatedDuration);\n  };\n  /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */\n\n\n  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {\n    const listLength = list.length;\n    let index = list.indexOf(activeElement); // if the element does not exist in the list return an element\n    // depending on the direction and if cycle is allowed\n\n    if (index === -1) {\n      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n    }\n\n    index += shouldGetNext ? 1 : -1;\n\n    if (isCycleAllowed) {\n      index = (index + listLength) % listLength;\n    }\n\n    return list[Math.max(0, Math.min(index, listLength - 1))];\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/event-handler.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n  const stripNameRegex = /\\..*/;\n  const stripUidRegex = /::\\d+$/;\n  const eventRegistry = {}; // Events storage\n\n  let uidEvent = 1;\n  const customEvents = {\n    mouseenter: 'mouseover',\n    mouseleave: 'mouseout'\n  };\n  const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\n  /**\n   * Private methods\n   */\n\n  function makeEventUid(element, uid) {\n    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n  }\n\n  function getElementEvents(element) {\n    const uid = makeEventUid(element);\n    element.uidEvent = uid;\n    eventRegistry[uid] = eventRegistry[uid] || {};\n    return eventRegistry[uid];\n  }\n\n  function bootstrapHandler(element, fn) {\n    return function handler(event) {\n      hydrateObj(event, {\n        delegateTarget: element\n      });\n\n      if (handler.oneOff) {\n        EventHandler.off(element, event.type, fn);\n      }\n\n      return fn.apply(element, [event]);\n    };\n  }\n\n  function bootstrapDelegationHandler(element, selector, fn) {\n    return function handler(event) {\n      const domElements = element.querySelectorAll(selector);\n\n      for (let {\n        target\n      } = event; target && target !== this; target = target.parentNode) {\n        for (const domElement of domElements) {\n          if (domElement !== target) {\n            continue;\n          }\n\n          hydrateObj(event, {\n            delegateTarget: target\n          });\n\n          if (handler.oneOff) {\n            EventHandler.off(element, event.type, selector, fn);\n          }\n\n          return fn.apply(target, [event]);\n        }\n      }\n    };\n  }\n\n  function findHandler(events, callable, delegationSelector = null) {\n    return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);\n  }\n\n  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n    const isDelegated = typeof handler === 'string'; // todo: tooltip passes `false` instead of selector, so we need to check\n\n    const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n    let typeEvent = getTypeEvent(originalTypeEvent);\n\n    if (!nativeEvents.has(typeEvent)) {\n      typeEvent = originalTypeEvent;\n    }\n\n    return [isDelegated, callable, typeEvent];\n  }\n\n  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n    if (typeof originalTypeEvent !== 'string' || !element) {\n      return;\n    }\n\n    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction); // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n\n    if (originalTypeEvent in customEvents) {\n      const wrapFunction = fn => {\n        return function (event) {\n          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n            return fn.call(this, event);\n          }\n        };\n      };\n\n      callable = wrapFunction(callable);\n    }\n\n    const events = getElementEvents(element);\n    const handlers = events[typeEvent] || (events[typeEvent] = {});\n    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n\n    if (previousFunction) {\n      previousFunction.oneOff = previousFunction.oneOff && oneOff;\n      return;\n    }\n\n    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\n    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n    fn.delegationSelector = isDelegated ? handler : null;\n    fn.callable = callable;\n    fn.oneOff = oneOff;\n    fn.uidEvent = uid;\n    handlers[uid] = fn;\n    element.addEventListener(typeEvent, fn, isDelegated);\n  }\n\n  function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n    const fn = findHandler(events[typeEvent], handler, delegationSelector);\n\n    if (!fn) {\n      return;\n    }\n\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n    delete events[typeEvent][fn.uidEvent];\n  }\n\n  function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n    const storeElementEvent = events[typeEvent] || {};\n\n    for (const handlerKey of Object.keys(storeElementEvent)) {\n      if (handlerKey.includes(namespace)) {\n        const event = storeElementEvent[handlerKey];\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n      }\n    }\n  }\n\n  function getTypeEvent(event) {\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n    event = event.replace(stripNameRegex, '');\n    return customEvents[event] || event;\n  }\n\n  const EventHandler = {\n    on(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, false);\n    },\n\n    one(element, event, handler, delegationFunction) {\n      addHandler(element, event, handler, delegationFunction, true);\n    },\n\n    off(element, originalTypeEvent, handler, delegationFunction) {\n      if (typeof originalTypeEvent !== 'string' || !element) {\n        return;\n      }\n\n      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n      const inNamespace = typeEvent !== originalTypeEvent;\n      const events = getElementEvents(element);\n      const storeElementEvent = events[typeEvent] || {};\n      const isNamespace = originalTypeEvent.startsWith('.');\n\n      if (typeof callable !== 'undefined') {\n        // Simplest case: handler is passed, remove that listener ONLY.\n        if (!Object.keys(storeElementEvent).length) {\n          return;\n        }\n\n        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n        return;\n      }\n\n      if (isNamespace) {\n        for (const elementEvent of Object.keys(events)) {\n          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n        }\n      }\n\n      for (const keyHandlers of Object.keys(storeElementEvent)) {\n        const handlerKey = keyHandlers.replace(stripUidRegex, '');\n\n        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n          const event = storeElementEvent[keyHandlers];\n          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n        }\n      }\n    },\n\n    trigger(element, event, args) {\n      if (typeof event !== 'string' || !element) {\n        return null;\n      }\n\n      const $ = getjQuery();\n      const typeEvent = getTypeEvent(event);\n      const inNamespace = event !== typeEvent;\n      let jQueryEvent = null;\n      let bubbles = true;\n      let nativeDispatch = true;\n      let defaultPrevented = false;\n\n      if (inNamespace && $) {\n        jQueryEvent = $.Event(event, args);\n        $(element).trigger(jQueryEvent);\n        bubbles = !jQueryEvent.isPropagationStopped();\n        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n        defaultPrevented = jQueryEvent.isDefaultPrevented();\n      }\n\n      let evt = new Event(event, {\n        bubbles,\n        cancelable: true\n      });\n      evt = hydrateObj(evt, args);\n\n      if (defaultPrevented) {\n        evt.preventDefault();\n      }\n\n      if (nativeDispatch) {\n        element.dispatchEvent(evt);\n      }\n\n      if (evt.defaultPrevented && jQueryEvent) {\n        jQueryEvent.preventDefault();\n      }\n\n      return evt;\n    }\n\n  };\n\n  function hydrateObj(obj, meta) {\n    for (const [key, value] of Object.entries(meta || {})) {\n      try {\n        obj[key] = value;\n      } catch (_unused) {\n        Object.defineProperty(obj, key, {\n          configurable: true,\n\n          get() {\n            return value;\n          }\n\n        });\n      }\n    }\n\n    return obj;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/data.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  /**\n   * Constants\n   */\n  const elementMap = new Map();\n  const Data = {\n    set(element, key, instance) {\n      if (!elementMap.has(element)) {\n        elementMap.set(element, new Map());\n      }\n\n      const instanceMap = elementMap.get(element); // make it clear we only want one instance per element\n      // can be removed later when multiple key/instances are fine to be used\n\n      if (!instanceMap.has(key) && instanceMap.size !== 0) {\n        // eslint-disable-next-line no-console\n        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n        return;\n      }\n\n      instanceMap.set(key, instance);\n    },\n\n    get(element, key) {\n      if (elementMap.has(element)) {\n        return elementMap.get(element).get(key) || null;\n      }\n\n      return null;\n    },\n\n    remove(element, key) {\n      if (!elementMap.has(element)) {\n        return;\n      }\n\n      const instanceMap = elementMap.get(element);\n      instanceMap.delete(key); // free up element references if there are no instances left for an element\n\n      if (instanceMap.size === 0) {\n        elementMap.delete(element);\n      }\n    }\n\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/manipulator.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  function normalizeData(value) {\n    if (value === 'true') {\n      return true;\n    }\n\n    if (value === 'false') {\n      return false;\n    }\n\n    if (value === Number(value).toString()) {\n      return Number(value);\n    }\n\n    if (value === '' || value === 'null') {\n      return null;\n    }\n\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    try {\n      return JSON.parse(decodeURIComponent(value));\n    } catch (_unused) {\n      return value;\n    }\n  }\n\n  function normalizeDataKey(key) {\n    return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\n  }\n\n  const Manipulator = {\n    setDataAttribute(element, key, value) {\n      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n    },\n\n    removeDataAttribute(element, key) {\n      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n    },\n\n    getDataAttributes(element) {\n      if (!element) {\n        return {};\n      }\n\n      const attributes = {};\n      const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));\n\n      for (const key of bsKeys) {\n        let pureKey = key.replace(/^bs/, '');\n        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n        attributes[pureKey] = normalizeData(element.dataset[key]);\n      }\n\n      return attributes;\n    },\n\n    getDataAttribute(element, key) {\n      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n    }\n\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Class definition\n   */\n\n  class Config {\n    // Getters\n    static get Default() {\n      return {};\n    }\n\n    static get DefaultType() {\n      return {};\n    }\n\n    static get NAME() {\n      throw new Error('You have to implement the static method \"NAME\", for each component!');\n    }\n\n    _getConfig(config) {\n      config = this._mergeConfigObj(config);\n      config = this._configAfterMerge(config);\n\n      this._typeCheckConfig(config);\n\n      return config;\n    }\n\n    _configAfterMerge(config) {\n      return config;\n    }\n\n    _mergeConfigObj(config, element) {\n      const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\n\n      return { ...this.constructor.Default,\n        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\n        ...(isElement(element) ? Manipulator.getDataAttributes(element) : {}),\n        ...(typeof config === 'object' ? config : {})\n      };\n    }\n\n    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n      for (const property of Object.keys(configTypes)) {\n        const expectedTypes = configTypes[property];\n        const value = config[property];\n        const valueType = isElement(value) ? 'element' : toType(value);\n\n        if (!new RegExp(expectedTypes).test(valueType)) {\n          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n        }\n      }\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): base-component.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const VERSION = '5.2.0';\n  /**\n   * Class definition\n   */\n\n  class BaseComponent extends Config {\n    constructor(element, config) {\n      super();\n      element = getElement(element);\n\n      if (!element) {\n        return;\n      }\n\n      this._element = element;\n      this._config = this._getConfig(config);\n      Data.set(this._element, this.constructor.DATA_KEY, this);\n    } // Public\n\n\n    dispose() {\n      Data.remove(this._element, this.constructor.DATA_KEY);\n      EventHandler.off(this._element, this.constructor.EVENT_KEY);\n\n      for (const propertyName of Object.getOwnPropertyNames(this)) {\n        this[propertyName] = null;\n      }\n    }\n\n    _queueCallback(callback, element, isAnimated = true) {\n      executeAfterTransition(callback, element, isAnimated);\n    }\n\n    _getConfig(config) {\n      config = this._mergeConfigObj(config, this._element);\n      config = this._configAfterMerge(config);\n\n      this._typeCheckConfig(config);\n\n      return config;\n    } // Static\n\n\n    static getInstance(element) {\n      return Data.get(getElement(element), this.DATA_KEY);\n    }\n\n    static getOrCreateInstance(element, config = {}) {\n      return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);\n    }\n\n    static get VERSION() {\n      return VERSION;\n    }\n\n    static get DATA_KEY() {\n      return `bs.${this.NAME}`;\n    }\n\n    static get EVENT_KEY() {\n      return `.${this.DATA_KEY}`;\n    }\n\n    static eventName(name) {\n      return `${name}${this.EVENT_KEY}`;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/component-functions.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n\n  const enableDismissTrigger = (component, method = 'hide') => {\n    const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n    const name = component.NAME;\n    EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function (event) {\n      if (['A', 'AREA'].includes(this.tagName)) {\n        event.preventDefault();\n      }\n\n      if (isDisabled(this)) {\n        return;\n      }\n\n      const target = getElementFromSelector(this) || this.closest(`.${name}`);\n      const instance = component.getOrCreateInstance(target); // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n\n      instance[method]();\n    });\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): alert.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$f = 'alert';\n  const DATA_KEY$a = 'bs.alert';\n  const EVENT_KEY$b = `.${DATA_KEY$a}`;\n  const EVENT_CLOSE = `close${EVENT_KEY$b}`;\n  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;\n  const CLASS_NAME_FADE$5 = 'fade';\n  const CLASS_NAME_SHOW$8 = 'show';\n  /**\n   * Class definition\n   */\n\n  class Alert extends BaseComponent {\n    // Getters\n    static get NAME() {\n      return NAME$f;\n    } // Public\n\n\n    close() {\n      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n\n      if (closeEvent.defaultPrevented) {\n        return;\n      }\n\n      this._element.classList.remove(CLASS_NAME_SHOW$8);\n\n      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n\n      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);\n    } // Private\n\n\n    _destroyElement() {\n      this._element.remove();\n\n      EventHandler.trigger(this._element, EVENT_CLOSED);\n      this.dispose();\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Alert.getOrCreateInstance(this);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](this);\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  enableDismissTrigger(Alert, 'close');\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Alert);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): button.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$e = 'button';\n  const DATA_KEY$9 = 'bs.button';\n  const EVENT_KEY$a = `.${DATA_KEY$9}`;\n  const DATA_API_KEY$6 = '.data-api';\n  const CLASS_NAME_ACTIVE$3 = 'active';\n  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\n  /**\n   * Class definition\n   */\n\n  class Button extends BaseComponent {\n    // Getters\n    static get NAME() {\n      return NAME$e;\n    } // Public\n\n\n    toggle() {\n      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Button.getOrCreateInstance(this);\n\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\n    event.preventDefault();\n    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n    const data = Button.getOrCreateInstance(button);\n    data.toggle();\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Button);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dom/selector-engine.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const SelectorEngine = {\n    find(selector, element = document.documentElement) {\n      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n    },\n\n    findOne(selector, element = document.documentElement) {\n      return Element.prototype.querySelector.call(element, selector);\n    },\n\n    children(element, selector) {\n      return [].concat(...element.children).filter(child => child.matches(selector));\n    },\n\n    parents(element, selector) {\n      const parents = [];\n      let ancestor = element.parentNode.closest(selector);\n\n      while (ancestor) {\n        parents.push(ancestor);\n        ancestor = ancestor.parentNode.closest(selector);\n      }\n\n      return parents;\n    },\n\n    prev(element, selector) {\n      let previous = element.previousElementSibling;\n\n      while (previous) {\n        if (previous.matches(selector)) {\n          return [previous];\n        }\n\n        previous = previous.previousElementSibling;\n      }\n\n      return [];\n    },\n\n    // TODO: this is now unused; remove later along with prev()\n    next(element, selector) {\n      let next = element.nextElementSibling;\n\n      while (next) {\n        if (next.matches(selector)) {\n          return [next];\n        }\n\n        next = next.nextElementSibling;\n      }\n\n      return [];\n    },\n\n    focusableChildren(element) {\n      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',');\n      return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));\n    }\n\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/swipe.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$d = 'swipe';\n  const EVENT_KEY$9 = '.bs.swipe';\n  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\n  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\n  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\n  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\n  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\n  const POINTER_TYPE_TOUCH = 'touch';\n  const POINTER_TYPE_PEN = 'pen';\n  const CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  const SWIPE_THRESHOLD = 40;\n  const Default$c = {\n    endCallback: null,\n    leftCallback: null,\n    rightCallback: null\n  };\n  const DefaultType$c = {\n    endCallback: '(function|null)',\n    leftCallback: '(function|null)',\n    rightCallback: '(function|null)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Swipe extends Config {\n    constructor(element, config) {\n      super();\n      this._element = element;\n\n      if (!element || !Swipe.isSupported()) {\n        return;\n      }\n\n      this._config = this._getConfig(config);\n      this._deltaX = 0;\n      this._supportPointerEvents = Boolean(window.PointerEvent);\n\n      this._initEvents();\n    } // Getters\n\n\n    static get Default() {\n      return Default$c;\n    }\n\n    static get DefaultType() {\n      return DefaultType$c;\n    }\n\n    static get NAME() {\n      return NAME$d;\n    } // Public\n\n\n    dispose() {\n      EventHandler.off(this._element, EVENT_KEY$9);\n    } // Private\n\n\n    _start(event) {\n      if (!this._supportPointerEvents) {\n        this._deltaX = event.touches[0].clientX;\n        return;\n      }\n\n      if (this._eventIsPointerPenTouch(event)) {\n        this._deltaX = event.clientX;\n      }\n    }\n\n    _end(event) {\n      if (this._eventIsPointerPenTouch(event)) {\n        this._deltaX = event.clientX - this._deltaX;\n      }\n\n      this._handleSwipe();\n\n      execute(this._config.endCallback);\n    }\n\n    _move(event) {\n      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n    }\n\n    _handleSwipe() {\n      const absDeltaX = Math.abs(this._deltaX);\n\n      if (absDeltaX <= SWIPE_THRESHOLD) {\n        return;\n      }\n\n      const direction = absDeltaX / this._deltaX;\n      this._deltaX = 0;\n\n      if (!direction) {\n        return;\n      }\n\n      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n    }\n\n    _initEvents() {\n      if (this._supportPointerEvents) {\n        EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));\n        EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));\n\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n      } else {\n        EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));\n        EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));\n        EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));\n      }\n    }\n\n    _eventIsPointerPenTouch(event) {\n      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n    } // Static\n\n\n    static isSupported() {\n      return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): carousel.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$c = 'carousel';\n  const DATA_KEY$8 = 'bs.carousel';\n  const EVENT_KEY$8 = `.${DATA_KEY$8}`;\n  const DATA_API_KEY$5 = '.data-api';\n  const ARROW_LEFT_KEY$1 = 'ArrowLeft';\n  const ARROW_RIGHT_KEY$1 = 'ArrowRight';\n  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  const ORDER_NEXT = 'next';\n  const ORDER_PREV = 'prev';\n  const DIRECTION_LEFT = 'left';\n  const DIRECTION_RIGHT = 'right';\n  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;\n  const EVENT_SLID = `slid${EVENT_KEY$8}`;\n  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\n  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\n  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\n  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\n  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\n  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\n  const CLASS_NAME_CAROUSEL = 'carousel';\n  const CLASS_NAME_ACTIVE$2 = 'active';\n  const CLASS_NAME_SLIDE = 'slide';\n  const CLASS_NAME_END = 'carousel-item-end';\n  const CLASS_NAME_START = 'carousel-item-start';\n  const CLASS_NAME_NEXT = 'carousel-item-next';\n  const CLASS_NAME_PREV = 'carousel-item-prev';\n  const SELECTOR_ACTIVE = '.active';\n  const SELECTOR_ITEM = '.carousel-item';\n  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\n  const SELECTOR_ITEM_IMG = '.carousel-item img';\n  const SELECTOR_INDICATORS = '.carousel-indicators';\n  const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\n  const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n  const KEY_TO_DIRECTION = {\n    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n  };\n  const Default$b = {\n    interval: 5000,\n    keyboard: true,\n    pause: 'hover',\n    ride: false,\n    touch: true,\n    wrap: true\n  };\n  const DefaultType$b = {\n    interval: '(number|boolean)',\n    // TODO:v6 remove boolean support\n    keyboard: 'boolean',\n    pause: '(string|boolean)',\n    ride: '(boolean|string)',\n    touch: 'boolean',\n    wrap: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Carousel extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._interval = null;\n      this._activeElement = null;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this._swipeHelper = null;\n      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n\n      this._addEventListeners();\n\n      if (this._config.ride === CLASS_NAME_CAROUSEL) {\n        this.cycle();\n      }\n    } // Getters\n\n\n    static get Default() {\n      return Default$b;\n    }\n\n    static get DefaultType() {\n      return DefaultType$b;\n    }\n\n    static get NAME() {\n      return NAME$c;\n    } // Public\n\n\n    next() {\n      this._slide(ORDER_NEXT);\n    }\n\n    nextWhenVisible() {\n      // FIXME TODO use `document.visibilityState`\n      // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n      if (!document.hidden && isVisible(this._element)) {\n        this.next();\n      }\n    }\n\n    prev() {\n      this._slide(ORDER_PREV);\n    }\n\n    pause() {\n      if (this._isSliding) {\n        triggerTransitionEnd(this._element);\n      }\n\n      this._clearInterval();\n    }\n\n    cycle() {\n      this._clearInterval();\n\n      this._updateInterval();\n\n      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);\n    }\n\n    _maybeEnableCycle() {\n      if (!this._config.ride) {\n        return;\n      }\n\n      if (this._isSliding) {\n        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());\n        return;\n      }\n\n      this.cycle();\n    }\n\n    to(index) {\n      const items = this._getItems();\n\n      if (index > items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\n        return;\n      }\n\n      const activeIndex = this._getItemIndex(this._getActive());\n\n      if (activeIndex === index) {\n        return;\n      }\n\n      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n\n      this._slide(order, items[index]);\n    }\n\n    dispose() {\n      if (this._swipeHelper) {\n        this._swipeHelper.dispose();\n      }\n\n      super.dispose();\n    } // Private\n\n\n    _configAfterMerge(config) {\n      config.defaultInterval = config.interval;\n      return config;\n    }\n\n    _addEventListeners() {\n      if (this._config.keyboard) {\n        EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));\n      }\n\n      if (this._config.pause === 'hover') {\n        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());\n        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());\n      }\n\n      if (this._config.touch && Swipe.isSupported()) {\n        this._addTouchEventListeners();\n      }\n    }\n\n    _addTouchEventListeners() {\n      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {\n        EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());\n      }\n\n      const endCallBack = () => {\n        if (this._config.pause !== 'hover') {\n          return;\n        } // If it's a touch-enabled device, mouseenter/leave are fired as\n        // part of the mouse compatibility events on first tap - the carousel\n        // would stop cycling until user tapped out of it;\n        // here, we listen for touchend, explicitly pause the carousel\n        // (as if it's the second time we tap on it, mouseenter compat event\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\n        // events to fire) we explicitly restart cycling\n\n\n        this.pause();\n\n        if (this.touchTimeout) {\n          clearTimeout(this.touchTimeout);\n        }\n\n        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n      };\n\n      const swipeConfig = {\n        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),\n        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n        endCallback: endCallBack\n      };\n      this._swipeHelper = new Swipe(this._element, swipeConfig);\n    }\n\n    _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      const direction = KEY_TO_DIRECTION[event.key];\n\n      if (direction) {\n        event.preventDefault();\n\n        this._slide(this._directionToOrder(direction));\n      }\n    }\n\n    _getItemIndex(element) {\n      return this._getItems().indexOf(element);\n    }\n\n    _setActiveIndicatorElement(index) {\n      if (!this._indicatorsElement) {\n        return;\n      }\n\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n      activeIndicator.removeAttribute('aria-current');\n      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\n\n      if (newActiveIndicator) {\n        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n        newActiveIndicator.setAttribute('aria-current', 'true');\n      }\n    }\n\n    _updateInterval() {\n      const element = this._activeElement || this._getActive();\n\n      if (!element) {\n        return;\n      }\n\n      const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\n      this._config.interval = elementInterval || this._config.defaultInterval;\n    }\n\n    _slide(order, element = null) {\n      if (this._isSliding) {\n        return;\n      }\n\n      const activeElement = this._getActive();\n\n      const isNext = order === ORDER_NEXT;\n      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n\n      if (nextElement === activeElement) {\n        return;\n      }\n\n      const nextElementIndex = this._getItemIndex(nextElement);\n\n      const triggerEvent = eventName => {\n        return EventHandler.trigger(this._element, eventName, {\n          relatedTarget: nextElement,\n          direction: this._orderToDirection(order),\n          from: this._getItemIndex(activeElement),\n          to: nextElementIndex\n        });\n      };\n\n      const slideEvent = triggerEvent(EVENT_SLIDE);\n\n      if (slideEvent.defaultPrevented) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        // todo: change tests that use empty divs to avoid this check\n        return;\n      }\n\n      const isCycling = Boolean(this._interval);\n      this.pause();\n      this._isSliding = true;\n\n      this._setActiveIndicatorElement(nextElementIndex);\n\n      this._activeElement = nextElement;\n      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n      nextElement.classList.add(orderClassName);\n      reflow(nextElement);\n      activeElement.classList.add(directionalClassName);\n      nextElement.classList.add(directionalClassName);\n\n      const completeCallBack = () => {\n        nextElement.classList.remove(directionalClassName, orderClassName);\n        nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n        this._isSliding = false;\n        triggerEvent(EVENT_SLID);\n      };\n\n      this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n\n      if (isCycling) {\n        this.cycle();\n      }\n    }\n\n    _isAnimated() {\n      return this._element.classList.contains(CLASS_NAME_SLIDE);\n    }\n\n    _getActive() {\n      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n    }\n\n    _getItems() {\n      return SelectorEngine.find(SELECTOR_ITEM, this._element);\n    }\n\n    _clearInterval() {\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n    }\n\n    _directionToOrder(direction) {\n      if (isRTL()) {\n        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n      }\n\n      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n    }\n\n    _orderToDirection(order) {\n      if (isRTL()) {\n        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n      }\n\n      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Carousel.getOrCreateInstance(this, config);\n\n        if (typeof config === 'number') {\n          data.to(config);\n          return;\n        }\n\n        if (typeof config === 'string') {\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n            throw new TypeError(`No method named \"${config}\"`);\n          }\n\n          data[config]();\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\n    const target = getElementFromSelector(this);\n\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n      return;\n    }\n\n    event.preventDefault();\n    const carousel = Carousel.getOrCreateInstance(target);\n    const slideIndex = this.getAttribute('data-bs-slide-to');\n\n    if (slideIndex) {\n      carousel.to(slideIndex);\n\n      carousel._maybeEnableCycle();\n\n      return;\n    }\n\n    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\n      carousel.next();\n\n      carousel._maybeEnableCycle();\n\n      return;\n    }\n\n    carousel.prev();\n\n    carousel._maybeEnableCycle();\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {\n    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n\n    for (const carousel of carousels) {\n      Carousel.getOrCreateInstance(carousel);\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Carousel);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): collapse.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$b = 'collapse';\n  const DATA_KEY$7 = 'bs.collapse';\n  const EVENT_KEY$7 = `.${DATA_KEY$7}`;\n  const DATA_API_KEY$4 = '.data-api';\n  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\n  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\n  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\n  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\n  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\n  const CLASS_NAME_SHOW$7 = 'show';\n  const CLASS_NAME_COLLAPSE = 'collapse';\n  const CLASS_NAME_COLLAPSING = 'collapsing';\n  const CLASS_NAME_COLLAPSED = 'collapsed';\n  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\n  const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\n  const WIDTH = 'width';\n  const HEIGHT = 'height';\n  const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\n  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n  const Default$a = {\n    parent: null,\n    toggle: true\n  };\n  const DefaultType$a = {\n    parent: '(null|element)',\n    toggle: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Collapse extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._isTransitioning = false;\n      this._triggerArray = [];\n      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n\n      for (const elem of toggleList) {\n        const selector = getSelectorFromElement(elem);\n        const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);\n\n        if (selector !== null && filterElement.length) {\n          this._triggerArray.push(elem);\n        }\n      }\n\n      this._initializeChildren();\n\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n      }\n\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n\n    static get Default() {\n      return Default$a;\n    }\n\n    static get DefaultType() {\n      return DefaultType$a;\n    }\n\n    static get NAME() {\n      return NAME$b;\n    } // Public\n\n\n    toggle() {\n      if (this._isShown()) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    }\n\n    show() {\n      if (this._isTransitioning || this._isShown()) {\n        return;\n      }\n\n      let activeChildren = []; // find active children\n\n      if (this._config.parent) {\n        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {\n          toggle: false\n        }));\n      }\n\n      if (activeChildren.length && activeChildren[0]._isTransitioning) {\n        return;\n      }\n\n      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n\n      if (startEvent.defaultPrevented) {\n        return;\n      }\n\n      for (const activeInstance of activeChildren) {\n        activeInstance.hide();\n      }\n\n      const dimension = this._getDimension();\n\n      this._element.classList.remove(CLASS_NAME_COLLAPSE);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n      this._element.style[dimension] = 0;\n\n      this._addAriaAndCollapsedClass(this._triggerArray, true);\n\n      this._isTransitioning = true;\n\n      const complete = () => {\n        this._isTransitioning = false;\n\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n\n        this._element.style[dimension] = '';\n        EventHandler.trigger(this._element, EVENT_SHOWN$6);\n      };\n\n      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      const scrollSize = `scroll${capitalizedDimension}`;\n\n      this._queueCallback(complete, this._element, true);\n\n      this._element.style[dimension] = `${this._element[scrollSize]}px`;\n    }\n\n    hide() {\n      if (this._isTransitioning || !this._isShown()) {\n        return;\n      }\n\n      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n\n      if (startEvent.defaultPrevented) {\n        return;\n      }\n\n      const dimension = this._getDimension();\n\n      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n      reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\n\n      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n\n      for (const trigger of this._triggerArray) {\n        const element = getElementFromSelector(trigger);\n\n        if (element && !this._isShown(element)) {\n          this._addAriaAndCollapsedClass([trigger], false);\n        }\n      }\n\n      this._isTransitioning = true;\n\n      const complete = () => {\n        this._isTransitioning = false;\n\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\n\n        this._element.classList.add(CLASS_NAME_COLLAPSE);\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n      };\n\n      this._element.style[dimension] = '';\n\n      this._queueCallback(complete, this._element, true);\n    }\n\n    _isShown(element = this._element) {\n      return element.classList.contains(CLASS_NAME_SHOW$7);\n    } // Private\n\n\n    _configAfterMerge(config) {\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      config.parent = getElement(config.parent);\n      return config;\n    }\n\n    _getDimension() {\n      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n    }\n\n    _initializeChildren() {\n      if (!this._config.parent) {\n        return;\n      }\n\n      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n\n      for (const element of children) {\n        const selected = getElementFromSelector(element);\n\n        if (selected) {\n          this._addAriaAndCollapsedClass([element], this._isShown(selected));\n        }\n      }\n    }\n\n    _getFirstLevelChildren(selector) {\n      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent); // remove children if greater depth\n\n      return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));\n    }\n\n    _addAriaAndCollapsedClass(triggerArray, isOpen) {\n      if (!triggerArray.length) {\n        return;\n      }\n\n      for (const element of triggerArray) {\n        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n        element.setAttribute('aria-expanded', isOpen);\n      }\n    } // Static\n\n\n    static jQueryInterface(config) {\n      const _config = {};\n\n      if (typeof config === 'string' && /show|hide/.test(config)) {\n        _config.toggle = false;\n      }\n\n      return this.each(function () {\n        const data = Collapse.getOrCreateInstance(this, _config);\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(`No method named \"${config}\"`);\n          }\n\n          data[config]();\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n\n    const selector = getSelectorFromElement(this);\n    const selectorElements = SelectorEngine.find(selector);\n\n    for (const element of selectorElements) {\n      Collapse.getOrCreateInstance(element, {\n        toggle: false\n      }).toggle();\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Collapse);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$a = 'dropdown';\n  const DATA_KEY$6 = 'bs.dropdown';\n  const EVENT_KEY$6 = `.${DATA_KEY$6}`;\n  const DATA_API_KEY$3 = '.data-api';\n  const ESCAPE_KEY$2 = 'Escape';\n  const TAB_KEY$1 = 'Tab';\n  const ARROW_UP_KEY$1 = 'ArrowUp';\n  const ARROW_DOWN_KEY$1 = 'ArrowDown';\n  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n\n  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\n  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\n  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\n  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\n  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\n  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\n  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\n  const CLASS_NAME_SHOW$6 = 'show';\n  const CLASS_NAME_DROPUP = 'dropup';\n  const CLASS_NAME_DROPEND = 'dropend';\n  const CLASS_NAME_DROPSTART = 'dropstart';\n  const CLASS_NAME_DROPUP_CENTER = 'dropup-center';\n  const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\n  const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\n  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\n  const SELECTOR_MENU = '.dropdown-menu';\n  const SELECTOR_NAVBAR = '.navbar';\n  const SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\n  const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\n  const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\n  const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\n  const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\n  const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\n  const PLACEMENT_TOPCENTER = 'top';\n  const PLACEMENT_BOTTOMCENTER = 'bottom';\n  const Default$9 = {\n    autoClose: true,\n    boundary: 'clippingParents',\n    display: 'dynamic',\n    offset: [0, 2],\n    popperConfig: null,\n    reference: 'toggle'\n  };\n  const DefaultType$9 = {\n    autoClose: '(boolean|string)',\n    boundary: '(string|element)',\n    display: 'string',\n    offset: '(array|string|function)',\n    popperConfig: '(null|object|function)',\n    reference: '(string|element|object)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Dropdown extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._popper = null;\n      this._parent = this._element.parentNode; // dropdown wrapper\n\n      this._menu = SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n      this._inNavbar = this._detectNavbar();\n    } // Getters\n\n\n    static get Default() {\n      return Default$9;\n    }\n\n    static get DefaultType() {\n      return DefaultType$9;\n    }\n\n    static get NAME() {\n      return NAME$a;\n    } // Public\n\n\n    toggle() {\n      return this._isShown() ? this.hide() : this.show();\n    }\n\n    show() {\n      if (isDisabled(this._element) || this._isShown()) {\n        return;\n      }\n\n      const relatedTarget = {\n        relatedTarget: this._element\n      };\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._createPopper(); // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n      if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.on(element, 'mouseover', noop);\n        }\n      }\n\n      this._element.focus();\n\n      this._element.setAttribute('aria-expanded', true);\n\n      this._menu.classList.add(CLASS_NAME_SHOW$6);\n\n      this._element.classList.add(CLASS_NAME_SHOW$6);\n\n      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n    }\n\n    hide() {\n      if (isDisabled(this._element) || !this._isShown()) {\n        return;\n      }\n\n      const relatedTarget = {\n        relatedTarget: this._element\n      };\n\n      this._completeHide(relatedTarget);\n    }\n\n    dispose() {\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      super.dispose();\n    }\n\n    update() {\n      this._inNavbar = this._detectNavbar();\n\n      if (this._popper) {\n        this._popper.update();\n      }\n    } // Private\n\n\n    _completeHide(relatedTarget) {\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      } // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n\n      if ('ontouchstart' in document.documentElement) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.off(element, 'mouseover', noop);\n        }\n      }\n\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      this._menu.classList.remove(CLASS_NAME_SHOW$6);\n\n      this._element.classList.remove(CLASS_NAME_SHOW$6);\n\n      this._element.setAttribute('aria-expanded', 'false');\n\n      Manipulator.removeDataAttribute(this._menu, 'popper');\n      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n    }\n\n    _getConfig(config) {\n      config = super._getConfig(config);\n\n      if (typeof config.reference === 'object' && !isElement(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\n        // Popper virtual elements require a getBoundingClientRect method\n        throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n      }\n\n      return config;\n    }\n\n    _createPopper() {\n      if (typeof Popper__namespace === 'undefined') {\n        throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n      }\n\n      let referenceElement = this._element;\n\n      if (this._config.reference === 'parent') {\n        referenceElement = this._parent;\n      } else if (isElement(this._config.reference)) {\n        referenceElement = getElement(this._config.reference);\n      } else if (typeof this._config.reference === 'object') {\n        referenceElement = this._config.reference;\n      }\n\n      const popperConfig = this._getPopperConfig();\n\n      this._popper = Popper__namespace.createPopper(referenceElement, this._menu, popperConfig);\n    }\n\n    _isShown() {\n      return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n    }\n\n    _getPlacement() {\n      const parentDropdown = this._parent;\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n        return PLACEMENT_RIGHT;\n      }\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n        return PLACEMENT_LEFT;\n      }\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n        return PLACEMENT_TOPCENTER;\n      }\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n        return PLACEMENT_BOTTOMCENTER;\n      } // We need to trim the value because custom properties can also include spaces\n\n\n      const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\n\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n      }\n\n      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n    }\n\n    _detectNavbar() {\n      return this._element.closest(SELECTOR_NAVBAR) !== null;\n    }\n\n    _getOffset() {\n      const {\n        offset\n      } = this._config;\n\n      if (typeof offset === 'string') {\n        return offset.split(',').map(value => Number.parseInt(value, 10));\n      }\n\n      if (typeof offset === 'function') {\n        return popperData => offset(popperData, this._element);\n      }\n\n      return offset;\n    }\n\n    _getPopperConfig() {\n      const defaultBsPopperConfig = {\n        placement: this._getPlacement(),\n        modifiers: [{\n          name: 'preventOverflow',\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: 'offset',\n          options: {\n            offset: this._getOffset()\n          }\n        }]\n      }; // Disable Popper if we have a static display or Dropdown is in Navbar\n\n      if (this._inNavbar || this._config.display === 'static') {\n        Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // todo:v6 remove\n\n        defaultBsPopperConfig.modifiers = [{\n          name: 'applyStyles',\n          enabled: false\n        }];\n      }\n\n      return { ...defaultBsPopperConfig,\n        ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n      };\n    }\n\n    _selectMenuItem({\n      key,\n      target\n    }) {\n      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));\n\n      if (!items.length) {\n        return;\n      } // if target isn't included in items (e.g. when expanding the dropdown)\n      // allow cycling to get the last item in case key equals ARROW_UP_KEY\n\n\n      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Dropdown.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n    static clearMenus(event) {\n      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\n        return;\n      }\n\n      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n\n      for (const toggle of openToggles) {\n        const context = Dropdown.getInstance(toggle);\n\n        if (!context || context._config.autoClose === false) {\n          continue;\n        }\n\n        const composedPath = event.composedPath();\n        const isMenuTarget = composedPath.includes(context._menu);\n\n        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\n          continue;\n        } // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n\n\n        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n          continue;\n        }\n\n        const relatedTarget = {\n          relatedTarget: context._element\n        };\n\n        if (event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n\n        context._completeHide(relatedTarget);\n      }\n    }\n\n    static dataApiKeydownHandler(event) {\n      // If not an UP | DOWN | ESCAPE key => not a dropdown command\n      // If input/textarea && if key is other than ESCAPE => not a dropdown command\n      const isInput = /input|textarea/i.test(event.target.tagName);\n      const isEscapeEvent = event.key === ESCAPE_KEY$2;\n      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\n\n      if (!isUpOrDownEvent && !isEscapeEvent) {\n        return;\n      }\n\n      if (isInput && !isEscapeEvent) {\n        return;\n      }\n\n      event.preventDefault();\n      const getToggleButton = SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n      const instance = Dropdown.getOrCreateInstance(getToggleButton);\n\n      if (isUpOrDownEvent) {\n        event.stopPropagation();\n        instance.show();\n\n        instance._selectMenuItem(event);\n\n        return;\n      }\n\n      if (instance._isShown()) {\n        // else is escape and we check if it is shown\n        event.stopPropagation();\n        instance.hide();\n        getToggleButton.focus();\n      }\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n    event.preventDefault();\n    Dropdown.getOrCreateInstance(this).toggle();\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Dropdown);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/scrollBar.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  const SELECTOR_STICKY_CONTENT = '.sticky-top';\n  const PROPERTY_PADDING = 'padding-right';\n  const PROPERTY_MARGIN = 'margin-right';\n  /**\n   * Class definition\n   */\n\n  class ScrollBarHelper {\n    constructor() {\n      this._element = document.body;\n    } // Public\n\n\n    getWidth() {\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n      const documentWidth = document.documentElement.clientWidth;\n      return Math.abs(window.innerWidth - documentWidth);\n    }\n\n    hide() {\n      const width = this.getWidth();\n\n      this._disableOverFlow(); // give padding to element to balance the hidden scrollbar width\n\n\n      this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width); // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n\n\n      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\n\n      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);\n    }\n\n    reset() {\n      this._resetElementAttributes(this._element, 'overflow');\n\n      this._resetElementAttributes(this._element, PROPERTY_PADDING);\n\n      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n\n      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n    }\n\n    isOverflowing() {\n      return this.getWidth() > 0;\n    } // Private\n\n\n    _disableOverFlow() {\n      this._saveInitialAttribute(this._element, 'overflow');\n\n      this._element.style.overflow = 'hidden';\n    }\n\n    _setElementAttributes(selector, styleProperty, callback) {\n      const scrollbarWidth = this.getWidth();\n\n      const manipulationCallBack = element => {\n        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n          return;\n        }\n\n        this._saveInitialAttribute(element, styleProperty);\n\n        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n      };\n\n      this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n\n    _saveInitialAttribute(element, styleProperty) {\n      const actualValue = element.style.getPropertyValue(styleProperty);\n\n      if (actualValue) {\n        Manipulator.setDataAttribute(element, styleProperty, actualValue);\n      }\n    }\n\n    _resetElementAttributes(selector, styleProperty) {\n      const manipulationCallBack = element => {\n        const value = Manipulator.getDataAttribute(element, styleProperty); // We only want to remove the property if the value is `null`; the value can also be zero\n\n        if (value === null) {\n          element.style.removeProperty(styleProperty);\n          return;\n        }\n\n        Manipulator.removeDataAttribute(element, styleProperty);\n        element.style.setProperty(styleProperty, value);\n      };\n\n      this._applyManipulationCallback(selector, manipulationCallBack);\n    }\n\n    _applyManipulationCallback(selector, callBack) {\n      if (isElement(selector)) {\n        callBack(selector);\n        return;\n      }\n\n      for (const sel of SelectorEngine.find(selector, this._element)) {\n        callBack(sel);\n      }\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/backdrop.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$9 = 'backdrop';\n  const CLASS_NAME_FADE$4 = 'fade';\n  const CLASS_NAME_SHOW$5 = 'show';\n  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\n  const Default$8 = {\n    className: 'modal-backdrop',\n    clickCallback: null,\n    isAnimated: false,\n    isVisible: true,\n    // if false, we use the backdrop helper without adding any element to the dom\n    rootElement: 'body' // give the choice to place backdrop under different elements\n\n  };\n  const DefaultType$8 = {\n    className: 'string',\n    clickCallback: '(function|null)',\n    isAnimated: 'boolean',\n    isVisible: 'boolean',\n    rootElement: '(element|string)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Backdrop extends Config {\n    constructor(config) {\n      super();\n      this._config = this._getConfig(config);\n      this._isAppended = false;\n      this._element = null;\n    } // Getters\n\n\n    static get Default() {\n      return Default$8;\n    }\n\n    static get DefaultType() {\n      return DefaultType$8;\n    }\n\n    static get NAME() {\n      return NAME$9;\n    } // Public\n\n\n    show(callback) {\n      if (!this._config.isVisible) {\n        execute(callback);\n        return;\n      }\n\n      this._append();\n\n      const element = this._getElement();\n\n      if (this._config.isAnimated) {\n        reflow(element);\n      }\n\n      element.classList.add(CLASS_NAME_SHOW$5);\n\n      this._emulateAnimation(() => {\n        execute(callback);\n      });\n    }\n\n    hide(callback) {\n      if (!this._config.isVisible) {\n        execute(callback);\n        return;\n      }\n\n      this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n\n      this._emulateAnimation(() => {\n        this.dispose();\n        execute(callback);\n      });\n    }\n\n    dispose() {\n      if (!this._isAppended) {\n        return;\n      }\n\n      EventHandler.off(this._element, EVENT_MOUSEDOWN);\n\n      this._element.remove();\n\n      this._isAppended = false;\n    } // Private\n\n\n    _getElement() {\n      if (!this._element) {\n        const backdrop = document.createElement('div');\n        backdrop.className = this._config.className;\n\n        if (this._config.isAnimated) {\n          backdrop.classList.add(CLASS_NAME_FADE$4);\n        }\n\n        this._element = backdrop;\n      }\n\n      return this._element;\n    }\n\n    _configAfterMerge(config) {\n      // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n      config.rootElement = getElement(config.rootElement);\n      return config;\n    }\n\n    _append() {\n      if (this._isAppended) {\n        return;\n      }\n\n      const element = this._getElement();\n\n      this._config.rootElement.append(element);\n\n      EventHandler.on(element, EVENT_MOUSEDOWN, () => {\n        execute(this._config.clickCallback);\n      });\n      this._isAppended = true;\n    }\n\n    _emulateAnimation(callback) {\n      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/focustrap.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$8 = 'focustrap';\n  const DATA_KEY$5 = 'bs.focustrap';\n  const EVENT_KEY$5 = `.${DATA_KEY$5}`;\n  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\n  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\n  const TAB_KEY = 'Tab';\n  const TAB_NAV_FORWARD = 'forward';\n  const TAB_NAV_BACKWARD = 'backward';\n  const Default$7 = {\n    autofocus: true,\n    trapElement: null // The element to trap focus inside of\n\n  };\n  const DefaultType$7 = {\n    autofocus: 'boolean',\n    trapElement: 'element'\n  };\n  /**\n   * Class definition\n   */\n\n  class FocusTrap extends Config {\n    constructor(config) {\n      super();\n      this._config = this._getConfig(config);\n      this._isActive = false;\n      this._lastTabNavDirection = null;\n    } // Getters\n\n\n    static get Default() {\n      return Default$7;\n    }\n\n    static get DefaultType() {\n      return DefaultType$7;\n    }\n\n    static get NAME() {\n      return NAME$8;\n    } // Public\n\n\n    activate() {\n      if (this._isActive) {\n        return;\n      }\n\n      if (this._config.autofocus) {\n        this._config.trapElement.focus();\n      }\n\n      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n\n      EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));\n      EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));\n      this._isActive = true;\n    }\n\n    deactivate() {\n      if (!this._isActive) {\n        return;\n      }\n\n      this._isActive = false;\n      EventHandler.off(document, EVENT_KEY$5);\n    } // Private\n\n\n    _handleFocusin(event) {\n      const {\n        trapElement\n      } = this._config;\n\n      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n        return;\n      }\n\n      const elements = SelectorEngine.focusableChildren(trapElement);\n\n      if (elements.length === 0) {\n        trapElement.focus();\n      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n        elements[elements.length - 1].focus();\n      } else {\n        elements[0].focus();\n      }\n    }\n\n    _handleKeydown(event) {\n      if (event.key !== TAB_KEY) {\n        return;\n      }\n\n      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): modal.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$7 = 'modal';\n  const DATA_KEY$4 = 'bs.modal';\n  const EVENT_KEY$4 = `.${DATA_KEY$4}`;\n  const DATA_API_KEY$2 = '.data-api';\n  const ESCAPE_KEY$1 = 'Escape';\n  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\n  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\n  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\n  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\n  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\n  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\n  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\n  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\n  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\n  const CLASS_NAME_OPEN = 'modal-open';\n  const CLASS_NAME_FADE$3 = 'fade';\n  const CLASS_NAME_SHOW$4 = 'show';\n  const CLASS_NAME_STATIC = 'modal-static';\n  const OPEN_SELECTOR$1 = '.modal.show';\n  const SELECTOR_DIALOG = '.modal-dialog';\n  const SELECTOR_MODAL_BODY = '.modal-body';\n  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n  const Default$6 = {\n    backdrop: true,\n    focus: true,\n    keyboard: true\n  };\n  const DefaultType$6 = {\n    backdrop: '(boolean|string)',\n    focus: 'boolean',\n    keyboard: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Modal extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n      this._backdrop = this._initializeBackDrop();\n      this._focustrap = this._initializeFocusTrap();\n      this._isShown = false;\n      this._isTransitioning = false;\n      this._scrollBar = new ScrollBarHelper();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default$6;\n    }\n\n    static get DefaultType() {\n      return DefaultType$6;\n    }\n\n    static get NAME() {\n      return NAME$7;\n    } // Public\n\n\n    toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    }\n\n    show(relatedTarget) {\n      if (this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n        relatedTarget\n      });\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._isShown = true;\n      this._isTransitioning = true;\n\n      this._scrollBar.hide();\n\n      document.body.classList.add(CLASS_NAME_OPEN);\n\n      this._adjustDialog();\n\n      this._backdrop.show(() => this._showElement(relatedTarget));\n    }\n\n    hide() {\n      if (!this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      this._isShown = false;\n      this._isTransitioning = true;\n\n      this._focustrap.deactivate();\n\n      this._element.classList.remove(CLASS_NAME_SHOW$4);\n\n      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());\n    }\n\n    dispose() {\n      for (const htmlElement of [window, this._dialog]) {\n        EventHandler.off(htmlElement, EVENT_KEY$4);\n      }\n\n      this._backdrop.dispose();\n\n      this._focustrap.deactivate();\n\n      super.dispose();\n    }\n\n    handleUpdate() {\n      this._adjustDialog();\n    } // Private\n\n\n    _initializeBackDrop() {\n      return new Backdrop({\n        isVisible: Boolean(this._config.backdrop),\n        // 'static' option will be translated to true, and booleans will keep their value,\n        isAnimated: this._isAnimated()\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new FocusTrap({\n        trapElement: this._element\n      });\n    }\n\n    _showElement(relatedTarget) {\n      // try to append dynamic modal\n      if (!document.body.contains(this._element)) {\n        document.body.append(this._element);\n      }\n\n      this._element.style.display = 'block';\n\n      this._element.removeAttribute('aria-hidden');\n\n      this._element.setAttribute('aria-modal', true);\n\n      this._element.setAttribute('role', 'dialog');\n\n      this._element.scrollTop = 0;\n      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n\n      if (modalBody) {\n        modalBody.scrollTop = 0;\n      }\n\n      reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_SHOW$4);\n\n      const transitionComplete = () => {\n        if (this._config.focus) {\n          this._focustrap.activate();\n        }\n\n        this._isTransitioning = false;\n        EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n          relatedTarget\n        });\n      };\n\n      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n    }\n\n    _addEventListeners() {\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\n        if (event.key !== ESCAPE_KEY$1) {\n          return;\n        }\n\n        if (this._config.keyboard) {\n          event.preventDefault();\n          this.hide();\n          return;\n        }\n\n        this._triggerBackdropTransition();\n      });\n      EventHandler.on(window, EVENT_RESIZE$1, () => {\n        if (this._isShown && !this._isTransitioning) {\n          this._adjustDialog();\n        }\n      });\n      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {\n        if (event.target !== event.currentTarget) {\n          // click is inside modal-dialog\n          return;\n        }\n\n        if (this._config.backdrop === 'static') {\n          this._triggerBackdropTransition();\n\n          return;\n        }\n\n        if (this._config.backdrop) {\n          this.hide();\n        }\n      });\n    }\n\n    _hideModal() {\n      this._element.style.display = 'none';\n\n      this._element.setAttribute('aria-hidden', true);\n\n      this._element.removeAttribute('aria-modal');\n\n      this._element.removeAttribute('role');\n\n      this._isTransitioning = false;\n\n      this._backdrop.hide(() => {\n        document.body.classList.remove(CLASS_NAME_OPEN);\n\n        this._resetAdjustments();\n\n        this._scrollBar.reset();\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n      });\n    }\n\n    _isAnimated() {\n      return this._element.classList.contains(CLASS_NAME_FADE$3);\n    }\n\n    _triggerBackdropTransition() {\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      const initialOverflowY = this._element.style.overflowY; // return if the following background transition hasn't yet completed\n\n      if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\n        return;\n      }\n\n      if (!isModalOverflowing) {\n        this._element.style.overflowY = 'hidden';\n      }\n\n      this._element.classList.add(CLASS_NAME_STATIC);\n\n      this._queueCallback(() => {\n        this._element.classList.remove(CLASS_NAME_STATIC);\n\n        this._queueCallback(() => {\n          this._element.style.overflowY = initialOverflowY;\n        }, this._dialog);\n      }, this._dialog);\n\n      this._element.focus();\n    }\n    /**\n     * The following methods are used to handle overflowing modals\n     */\n\n\n    _adjustDialog() {\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      const scrollbarWidth = this._scrollBar.getWidth();\n\n      const isBodyOverflowing = scrollbarWidth > 0;\n\n      if (isBodyOverflowing && !isModalOverflowing) {\n        const property = isRTL() ? 'paddingLeft' : 'paddingRight';\n        this._element.style[property] = `${scrollbarWidth}px`;\n      }\n\n      if (!isBodyOverflowing && isModalOverflowing) {\n        const property = isRTL() ? 'paddingRight' : 'paddingLeft';\n        this._element.style[property] = `${scrollbarWidth}px`;\n      }\n    }\n\n    _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    } // Static\n\n\n    static jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        const data = Modal.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](relatedTarget);\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n    const target = getElementFromSelector(this);\n\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n\n    EventHandler.one(target, EVENT_SHOW$4, showEvent => {\n      if (showEvent.defaultPrevented) {\n        // only register focus restorer if modal will actually get shown\n        return;\n      }\n\n      EventHandler.one(target, EVENT_HIDDEN$4, () => {\n        if (isVisible(this)) {\n          this.focus();\n        }\n      });\n    }); // avoid conflict when clicking modal toggler while another one is open\n\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n\n    if (alreadyOpen) {\n      Modal.getInstance(alreadyOpen).hide();\n    }\n\n    const data = Modal.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  enableDismissTrigger(Modal);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Modal);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): offcanvas.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$6 = 'offcanvas';\n  const DATA_KEY$3 = 'bs.offcanvas';\n  const EVENT_KEY$3 = `.${DATA_KEY$3}`;\n  const DATA_API_KEY$1 = '.data-api';\n  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\n  const ESCAPE_KEY = 'Escape';\n  const CLASS_NAME_SHOW$3 = 'show';\n  const CLASS_NAME_SHOWING$1 = 'showing';\n  const CLASS_NAME_HIDING = 'hiding';\n  const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\n  const OPEN_SELECTOR = '.offcanvas.show';\n  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\n  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\n  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\n  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\n  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\n  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;\n  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\n  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\n  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n  const Default$5 = {\n    backdrop: true,\n    keyboard: true,\n    scroll: false\n  };\n  const DefaultType$5 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    scroll: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  class Offcanvas extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._isShown = false;\n      this._backdrop = this._initializeBackDrop();\n      this._focustrap = this._initializeFocusTrap();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default$5;\n    }\n\n    static get DefaultType() {\n      return DefaultType$5;\n    }\n\n    static get NAME() {\n      return NAME$6;\n    } // Public\n\n\n    toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    }\n\n    show(relatedTarget) {\n      if (this._isShown) {\n        return;\n      }\n\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n        relatedTarget\n      });\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._isShown = true;\n\n      this._backdrop.show();\n\n      if (!this._config.scroll) {\n        new ScrollBarHelper().hide();\n      }\n\n      this._element.setAttribute('aria-modal', true);\n\n      this._element.setAttribute('role', 'dialog');\n\n      this._element.classList.add(CLASS_NAME_SHOWING$1);\n\n      const completeCallBack = () => {\n        if (!this._config.scroll || this._config.backdrop) {\n          this._focustrap.activate();\n        }\n\n        this._element.classList.add(CLASS_NAME_SHOW$3);\n\n        this._element.classList.remove(CLASS_NAME_SHOWING$1);\n\n        EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n          relatedTarget\n        });\n      };\n\n      this._queueCallback(completeCallBack, this._element, true);\n    }\n\n    hide() {\n      if (!this._isShown) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      this._focustrap.deactivate();\n\n      this._element.blur();\n\n      this._isShown = false;\n\n      this._element.classList.add(CLASS_NAME_HIDING);\n\n      this._backdrop.hide();\n\n      const completeCallback = () => {\n        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n\n        this._element.removeAttribute('aria-modal');\n\n        this._element.removeAttribute('role');\n\n        if (!this._config.scroll) {\n          new ScrollBarHelper().reset();\n        }\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n      };\n\n      this._queueCallback(completeCallback, this._element, true);\n    }\n\n    dispose() {\n      this._backdrop.dispose();\n\n      this._focustrap.deactivate();\n\n      super.dispose();\n    } // Private\n\n\n    _initializeBackDrop() {\n      const clickCallback = () => {\n        if (this._config.backdrop === 'static') {\n          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n          return;\n        }\n\n        this.hide();\n      }; // 'static' option will be translated to true, and booleans will keep their value\n\n\n      const isVisible = Boolean(this._config.backdrop);\n      return new Backdrop({\n        className: CLASS_NAME_BACKDROP,\n        isVisible,\n        isAnimated: true,\n        rootElement: this._element.parentNode,\n        clickCallback: isVisible ? clickCallback : null\n      });\n    }\n\n    _initializeFocusTrap() {\n      return new FocusTrap({\n        trapElement: this._element\n      });\n    }\n\n    _addEventListeners() {\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\n        if (event.key !== ESCAPE_KEY) {\n          return;\n        }\n\n        if (!this._config.keyboard) {\n          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n          return;\n        }\n\n        this.hide();\n      });\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Offcanvas.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config](this);\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n    const target = getElementFromSelector(this);\n\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n\n    if (isDisabled(this)) {\n      return;\n    }\n\n    EventHandler.one(target, EVENT_HIDDEN$3, () => {\n      // focus on trigger when it is closed\n      if (isVisible(this)) {\n        this.focus();\n      }\n    }); // avoid conflict when clicking a toggler of an offcanvas, while another is open\n\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n\n    if (alreadyOpen && alreadyOpen !== target) {\n      Offcanvas.getInstance(alreadyOpen).hide();\n    }\n\n    const data = Offcanvas.getOrCreateInstance(target);\n    data.toggle(this);\n  });\n  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\n    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {\n      Offcanvas.getOrCreateInstance(selector).show();\n    }\n  });\n  EventHandler.on(window, EVENT_RESIZE, () => {\n    for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {\n      if (getComputedStyle(element).position !== 'fixed') {\n        Offcanvas.getOrCreateInstance(element).hide();\n      }\n    }\n  });\n  enableDismissTrigger(Offcanvas);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Offcanvas);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\n  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  const DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n\n  const allowedAttribute = (attribute, allowedAttributeList) => {\n    const attributeName = attribute.nodeName.toLowerCase();\n\n    if (allowedAttributeList.includes(attributeName)) {\n      if (uriAttributes.has(attributeName)) {\n        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue) || DATA_URL_PATTERN.test(attribute.nodeValue));\n      }\n\n      return true;\n    } // Check if a regular expression validates the attribute.\n\n\n    return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));\n  };\n\n  const DefaultAllowlist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n    if (!unsafeHtml.length) {\n      return unsafeHtml;\n    }\n\n    if (sanitizeFunction && typeof sanitizeFunction === 'function') {\n      return sanitizeFunction(unsafeHtml);\n    }\n\n    const domParser = new window.DOMParser();\n    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\n\n    for (const element of elements) {\n      const elementName = element.nodeName.toLowerCase();\n\n      if (!Object.keys(allowList).includes(elementName)) {\n        element.remove();\n        continue;\n      }\n\n      const attributeList = [].concat(...element.attributes);\n      const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\n\n      for (const attribute of attributeList) {\n        if (!allowedAttribute(attribute, allowedAttributes)) {\n          element.removeAttribute(attribute.nodeName);\n        }\n      }\n    }\n\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): util/template-factory.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$5 = 'TemplateFactory';\n  const Default$4 = {\n    allowList: DefaultAllowlist,\n    content: {},\n    // { selector : text ,  selector2 : text2 , }\n    extraClass: '',\n    html: false,\n    sanitize: true,\n    sanitizeFn: null,\n    template: '<div></div>'\n  };\n  const DefaultType$4 = {\n    allowList: 'object',\n    content: 'object',\n    extraClass: '(string|function)',\n    html: 'boolean',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    template: 'string'\n  };\n  const DefaultContentType = {\n    entry: '(string|element|function|null)',\n    selector: '(string|element)'\n  };\n  /**\n   * Class definition\n   */\n\n  class TemplateFactory extends Config {\n    constructor(config) {\n      super();\n      this._config = this._getConfig(config);\n    } // Getters\n\n\n    static get Default() {\n      return Default$4;\n    }\n\n    static get DefaultType() {\n      return DefaultType$4;\n    }\n\n    static get NAME() {\n      return NAME$5;\n    } // Public\n\n\n    getContent() {\n      return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);\n    }\n\n    hasContent() {\n      return this.getContent().length > 0;\n    }\n\n    changeContent(content) {\n      this._checkContent(content);\n\n      this._config.content = { ...this._config.content,\n        ...content\n      };\n      return this;\n    }\n\n    toHtml() {\n      const templateWrapper = document.createElement('div');\n      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n\n      for (const [selector, text] of Object.entries(this._config.content)) {\n        this._setContent(templateWrapper, text, selector);\n      }\n\n      const template = templateWrapper.children[0];\n\n      const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n\n      if (extraClass) {\n        template.classList.add(...extraClass.split(' '));\n      }\n\n      return template;\n    } // Private\n\n\n    _typeCheckConfig(config) {\n      super._typeCheckConfig(config);\n\n      this._checkContent(config.content);\n    }\n\n    _checkContent(arg) {\n      for (const [selector, content] of Object.entries(arg)) {\n        super._typeCheckConfig({\n          selector,\n          entry: content\n        }, DefaultContentType);\n      }\n    }\n\n    _setContent(template, content, selector) {\n      const templateElement = SelectorEngine.findOne(selector, template);\n\n      if (!templateElement) {\n        return;\n      }\n\n      content = this._resolvePossibleFunction(content);\n\n      if (!content) {\n        templateElement.remove();\n        return;\n      }\n\n      if (isElement(content)) {\n        this._putElementInTemplate(getElement(content), templateElement);\n\n        return;\n      }\n\n      if (this._config.html) {\n        templateElement.innerHTML = this._maybeSanitize(content);\n        return;\n      }\n\n      templateElement.textContent = content;\n    }\n\n    _maybeSanitize(arg) {\n      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n    }\n\n    _resolvePossibleFunction(arg) {\n      return typeof arg === 'function' ? arg(this) : arg;\n    }\n\n    _putElementInTemplate(element, templateElement) {\n      if (this._config.html) {\n        templateElement.innerHTML = '';\n        templateElement.append(element);\n        return;\n      }\n\n      templateElement.textContent = element.textContent;\n    }\n\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$4 = 'tooltip';\n  const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\n  const CLASS_NAME_FADE$2 = 'fade';\n  const CLASS_NAME_MODAL = 'modal';\n  const CLASS_NAME_SHOW$2 = 'show';\n  const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\n  const EVENT_MODAL_HIDE = 'hide.bs.modal';\n  const TRIGGER_HOVER = 'hover';\n  const TRIGGER_FOCUS = 'focus';\n  const TRIGGER_CLICK = 'click';\n  const TRIGGER_MANUAL = 'manual';\n  const EVENT_HIDE$2 = 'hide';\n  const EVENT_HIDDEN$2 = 'hidden';\n  const EVENT_SHOW$2 = 'show';\n  const EVENT_SHOWN$2 = 'shown';\n  const EVENT_INSERTED = 'inserted';\n  const EVENT_CLICK$1 = 'click';\n  const EVENT_FOCUSIN$1 = 'focusin';\n  const EVENT_FOCUSOUT$1 = 'focusout';\n  const EVENT_MOUSEENTER = 'mouseenter';\n  const EVENT_MOUSELEAVE = 'mouseleave';\n  const AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: isRTL() ? 'left' : 'right',\n    BOTTOM: 'bottom',\n    LEFT: isRTL() ? 'right' : 'left'\n  };\n  const Default$3 = {\n    allowList: DefaultAllowlist,\n    animation: true,\n    boundary: 'clippingParents',\n    container: false,\n    customClass: '',\n    delay: 0,\n    fallbackPlacements: ['top', 'right', 'bottom', 'left'],\n    html: false,\n    offset: [0, 0],\n    placement: 'top',\n    popperConfig: null,\n    sanitize: true,\n    sanitizeFn: null,\n    selector: false,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\n    title: '',\n    trigger: 'hover focus'\n  };\n  const DefaultType$3 = {\n    allowList: 'object',\n    animation: 'boolean',\n    boundary: '(string|element)',\n    container: '(string|element|boolean)',\n    customClass: '(string|function)',\n    delay: '(number|object)',\n    fallbackPlacements: 'array',\n    html: 'boolean',\n    offset: '(array|string|function)',\n    placement: '(string|function)',\n    popperConfig: '(null|object|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    selector: '(string|boolean)',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string'\n  };\n  /**\n   * Class definition\n   */\n\n  class Tooltip extends BaseComponent {\n    constructor(element, config) {\n      if (typeof Popper__namespace === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      }\n\n      super(element, config); // Private\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._isHovered = false;\n      this._activeTrigger = {};\n      this._popper = null;\n      this._templateFactory = null;\n      this._newContent = null; // Protected\n\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default$3;\n    }\n\n    static get DefaultType() {\n      return DefaultType$3;\n    }\n\n    static get NAME() {\n      return NAME$4;\n    } // Public\n\n\n    enable() {\n      this._isEnabled = true;\n    }\n\n    disable() {\n      this._isEnabled = false;\n    }\n\n    toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    }\n\n    toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        const context = this._initializeOnDelegatedTarget(event);\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter();\n        } else {\n          context._leave();\n        }\n\n        return;\n      }\n\n      if (this._isShown()) {\n        this._leave();\n\n        return;\n      }\n\n      this._enter();\n    }\n\n    dispose() {\n      clearTimeout(this._timeout);\n      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n\n      if (this.tip) {\n        this.tip.remove();\n      }\n\n      this._disposePopper();\n\n      super.dispose();\n    }\n\n    show() {\n      if (this._element.style.display === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      if (!(this._isWithContent() && this._isEnabled)) {\n        return;\n      }\n\n      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n      const shadowRoot = findShadowRoot(this._element);\n\n      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n\n      if (showEvent.defaultPrevented || !isInTheDom) {\n        return;\n      } // todo v6 remove this OR make it optional\n\n\n      if (this.tip) {\n        this.tip.remove();\n        this.tip = null;\n      }\n\n      const tip = this._getTipElement();\n\n      this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\n\n      const {\n        container\n      } = this._config;\n\n      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n        container.append(tip);\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n      }\n\n      if (this._popper) {\n        this._popper.update();\n      } else {\n        this._popper = this._createPopper(tip);\n      }\n\n      tip.classList.add(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n      if ('ontouchstart' in document.documentElement) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.on(element, 'mouseover', noop);\n        }\n      }\n\n      const complete = () => {\n        const previousHoverState = this._isHovered;\n        this._isHovered = false;\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n\n        if (previousHoverState) {\n          this._leave();\n        }\n      };\n\n      this._queueCallback(complete, this.tip, this._isAnimated());\n    }\n\n    hide() {\n      if (!this._isShown()) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      const tip = this._getTipElement();\n\n      tip.classList.remove(CLASS_NAME_SHOW$2); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        for (const element of [].concat(...document.body.children)) {\n          EventHandler.off(element, 'mouseover', noop);\n        }\n      }\n\n      this._activeTrigger[TRIGGER_CLICK] = false;\n      this._activeTrigger[TRIGGER_FOCUS] = false;\n      this._activeTrigger[TRIGGER_HOVER] = false;\n      this._isHovered = false;\n\n      const complete = () => {\n        if (this._isWithActiveTrigger()) {\n          return;\n        }\n\n        if (!this._isHovered) {\n          tip.remove();\n        }\n\n        this._element.removeAttribute('aria-describedby');\n\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n\n        this._disposePopper();\n      };\n\n      this._queueCallback(complete, this.tip, this._isAnimated());\n    }\n\n    update() {\n      if (this._popper) {\n        this._popper.update();\n      }\n    } // Protected\n\n\n    _isWithContent() {\n      return Boolean(this._getTitle());\n    }\n\n    _getTipElement() {\n      if (!this.tip) {\n        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n      }\n\n      return this.tip;\n    }\n\n    _createTipElement(content) {\n      const tip = this._getTemplateFactory(content).toHtml(); // todo: remove this check on v6\n\n\n      if (!tip) {\n        return null;\n      }\n\n      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2); // todo: on v6 the following can be achieved with CSS only\n\n      tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n      const tipId = getUID(this.constructor.NAME).toString();\n      tip.setAttribute('id', tipId);\n\n      if (this._isAnimated()) {\n        tip.classList.add(CLASS_NAME_FADE$2);\n      }\n\n      return tip;\n    }\n\n    setContent(content) {\n      this._newContent = content;\n\n      if (this._isShown()) {\n        this._disposePopper();\n\n        this.show();\n      }\n    }\n\n    _getTemplateFactory(content) {\n      if (this._templateFactory) {\n        this._templateFactory.changeContent(content);\n      } else {\n        this._templateFactory = new TemplateFactory({ ...this._config,\n          // the `content` var has to be after `this._config`\n          // to override config.content in case of popover\n          content,\n          extraClass: this._resolvePossibleFunction(this._config.customClass)\n        });\n      }\n\n      return this._templateFactory;\n    }\n\n    _getContentForTemplate() {\n      return {\n        [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n      };\n    }\n\n    _getTitle() {\n      return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle;\n    } // Private\n\n\n    _initializeOnDelegatedTarget(event) {\n      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n    }\n\n    _isAnimated() {\n      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n    }\n\n    _isShown() {\n      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n    }\n\n    _createPopper(tip) {\n      const placement = typeof this._config.placement === 'function' ? this._config.placement.call(this, tip, this._element) : this._config.placement;\n      const attachment = AttachmentMap[placement.toUpperCase()];\n      return Popper__namespace.createPopper(this._element, tip, this._getPopperConfig(attachment));\n    }\n\n    _getOffset() {\n      const {\n        offset\n      } = this._config;\n\n      if (typeof offset === 'string') {\n        return offset.split(',').map(value => Number.parseInt(value, 10));\n      }\n\n      if (typeof offset === 'function') {\n        return popperData => offset(popperData, this._element);\n      }\n\n      return offset;\n    }\n\n    _resolvePossibleFunction(arg) {\n      return typeof arg === 'function' ? arg.call(this._element) : arg;\n    }\n\n    _getPopperConfig(attachment) {\n      const defaultBsPopperConfig = {\n        placement: attachment,\n        modifiers: [{\n          name: 'flip',\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        }, {\n          name: 'offset',\n          options: {\n            offset: this._getOffset()\n          }\n        }, {\n          name: 'preventOverflow',\n          options: {\n            boundary: this._config.boundary\n          }\n        }, {\n          name: 'arrow',\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        }, {\n          name: 'preSetPlacement',\n          enabled: true,\n          phase: 'beforeMain',\n          fn: data => {\n            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n            this._getTipElement().setAttribute('data-popper-placement', data.state.placement);\n          }\n        }]\n      };\n      return { ...defaultBsPopperConfig,\n        ...(typeof this._config.popperConfig === 'function' ? this._config.popperConfig(defaultBsPopperConfig) : this._config.popperConfig)\n      };\n    }\n\n    _setListeners() {\n      const triggers = this._config.trigger.split(' ');\n\n      for (const trigger of triggers) {\n        if (trigger === 'click') {\n          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => this.toggle(event));\n        } else if (trigger !== TRIGGER_MANUAL) {\n          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n          EventHandler.on(this._element, eventIn, this._config.selector, event => {\n            const context = this._initializeOnDelegatedTarget(event);\n\n            context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n\n            context._enter();\n          });\n          EventHandler.on(this._element, eventOut, this._config.selector, event => {\n            const context = this._initializeOnDelegatedTarget(event);\n\n            context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n\n            context._leave();\n          });\n        }\n      }\n\n      this._hideModalHandler = () => {\n        if (this._element) {\n          this.hide();\n        }\n      };\n\n      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n\n      if (this._config.selector) {\n        this._config = { ...this._config,\n          trigger: 'manual',\n          selector: ''\n        };\n      } else {\n        this._fixTitle();\n      }\n    }\n\n    _fixTitle() {\n      const title = this._config.originalTitle;\n\n      if (!title) {\n        return;\n      }\n\n      if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\n        this._element.setAttribute('aria-label', title);\n      }\n\n      this._element.removeAttribute('title');\n    }\n\n    _enter() {\n      if (this._isShown() || this._isHovered) {\n        this._isHovered = true;\n        return;\n      }\n\n      this._isHovered = true;\n\n      this._setTimeout(() => {\n        if (this._isHovered) {\n          this.show();\n        }\n      }, this._config.delay.show);\n    }\n\n    _leave() {\n      if (this._isWithActiveTrigger()) {\n        return;\n      }\n\n      this._isHovered = false;\n\n      this._setTimeout(() => {\n        if (!this._isHovered) {\n          this.hide();\n        }\n      }, this._config.delay.hide);\n    }\n\n    _setTimeout(handler, timeout) {\n      clearTimeout(this._timeout);\n      this._timeout = setTimeout(handler, timeout);\n    }\n\n    _isWithActiveTrigger() {\n      return Object.values(this._activeTrigger).includes(true);\n    }\n\n    _getConfig(config) {\n      const dataAttributes = Manipulator.getDataAttributes(this._element);\n\n      for (const dataAttribute of Object.keys(dataAttributes)) {\n        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n          delete dataAttributes[dataAttribute];\n        }\n      }\n\n      config = { ...dataAttributes,\n        ...(typeof config === 'object' && config ? config : {})\n      };\n      config = this._mergeConfigObj(config);\n      config = this._configAfterMerge(config);\n\n      this._typeCheckConfig(config);\n\n      return config;\n    }\n\n    _configAfterMerge(config) {\n      config.container = config.container === false ? document.body : getElement(config.container);\n\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      config.originalTitle = this._element.getAttribute('title') || '';\n\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n\n      return config;\n    }\n\n    _getDelegateConfig() {\n      const config = {};\n\n      for (const key in this._config) {\n        if (this.constructor.Default[key] !== this._config[key]) {\n          config[key] = this._config[key];\n        }\n      } // In the future can be replaced with:\n      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n      // `Object.fromEntries(keysWithDifferentValues)`\n\n\n      return config;\n    }\n\n    _disposePopper() {\n      if (this._popper) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Tooltip.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * jQuery\n   */\n\n\n  defineJQueryPlugin(Tooltip);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): popover.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$3 = 'popover';\n  const SELECTOR_TITLE = '.popover-header';\n  const SELECTOR_CONTENT = '.popover-body';\n  const Default$2 = { ...Tooltip.Default,\n    content: '',\n    offset: [0, 8],\n    placement: 'right',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\n    trigger: 'click'\n  };\n  const DefaultType$2 = { ...Tooltip.DefaultType,\n    content: '(null|string|element|function)'\n  };\n  /**\n   * Class definition\n   */\n\n  class Popover extends Tooltip {\n    // Getters\n    static get Default() {\n      return Default$2;\n    }\n\n    static get DefaultType() {\n      return DefaultType$2;\n    }\n\n    static get NAME() {\n      return NAME$3;\n    } // Overrides\n\n\n    _isWithContent() {\n      return this._getTitle() || this._getContent();\n    } // Private\n\n\n    _getContentForTemplate() {\n      return {\n        [SELECTOR_TITLE]: this._getTitle(),\n        [SELECTOR_CONTENT]: this._getContent()\n      };\n    }\n\n    _getContent() {\n      return this._resolvePossibleFunction(this._config.content);\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Popover.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (typeof data[config] === 'undefined') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * jQuery\n   */\n\n\n  defineJQueryPlugin(Popover);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): scrollspy.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$2 = 'scrollspy';\n  const DATA_KEY$2 = 'bs.scrollspy';\n  const EVENT_KEY$2 = `.${DATA_KEY$2}`;\n  const DATA_API_KEY = '.data-api';\n  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\n  const EVENT_CLICK = `click${EVENT_KEY$2}`;\n  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\n  const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  const CLASS_NAME_ACTIVE$1 = 'active';\n  const SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n  const SELECTOR_TARGET_LINKS = '[href]';\n  const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  const SELECTOR_NAV_LINKS = '.nav-link';\n  const SELECTOR_NAV_ITEMS = '.nav-item';\n  const SELECTOR_LIST_ITEMS = '.list-group-item';\n  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\n  const SELECTOR_DROPDOWN = '.dropdown';\n  const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  const Default$1 = {\n    offset: null,\n    // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: '0px 0px -25%',\n    smoothScroll: false,\n    target: null\n  };\n  const DefaultType$1 = {\n    offset: '(number|null)',\n    // TODO v6 @deprecated, keep it for backwards compatibility reasons\n    rootMargin: 'string',\n    smoothScroll: 'boolean',\n    target: 'element'\n  };\n  /**\n   * Class definition\n   */\n\n  class ScrollSpy extends BaseComponent {\n    constructor(element, config) {\n      super(element, config); // this._element is the observablesContainer and config.target the menu links wrapper\n\n      this._targetLinks = new Map();\n      this._observableSections = new Map();\n      this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;\n      this._activeTarget = null;\n      this._observer = null;\n      this._previousScrollData = {\n        visibleEntryTop: 0,\n        parentScrollTop: 0\n      };\n      this.refresh(); // initialize\n    } // Getters\n\n\n    static get Default() {\n      return Default$1;\n    }\n\n    static get DefaultType() {\n      return DefaultType$1;\n    }\n\n    static get NAME() {\n      return NAME$2;\n    } // Public\n\n\n    refresh() {\n      this._initializeTargetsAndObservables();\n\n      this._maybeEnableSmoothScroll();\n\n      if (this._observer) {\n        this._observer.disconnect();\n      } else {\n        this._observer = this._getNewObserver();\n      }\n\n      for (const section of this._observableSections.values()) {\n        this._observer.observe(section);\n      }\n    }\n\n    dispose() {\n      this._observer.disconnect();\n\n      super.dispose();\n    } // Private\n\n\n    _configAfterMerge(config) {\n      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n      config.target = getElement(config.target) || document.body;\n      return config;\n    }\n\n    _maybeEnableSmoothScroll() {\n      if (!this._config.smoothScroll) {\n        return;\n      } // unregister any previous listeners\n\n\n      EventHandler.off(this._config.target, EVENT_CLICK);\n      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {\n        const observableSection = this._observableSections.get(event.target.hash);\n\n        if (observableSection) {\n          event.preventDefault();\n          const root = this._rootElement || window;\n          const height = observableSection.offsetTop - this._element.offsetTop;\n\n          if (root.scrollTo) {\n            root.scrollTo({\n              top: height,\n              behavior: 'smooth'\n            });\n            return;\n          } // Chrome 60 doesn't support `scrollTo`\n\n\n          root.scrollTop = height;\n        }\n      });\n    }\n\n    _getNewObserver() {\n      const options = {\n        root: this._rootElement,\n        threshold: [0.1, 0.5, 1],\n        rootMargin: this._getRootMargin()\n      };\n      return new IntersectionObserver(entries => this._observerCallback(entries), options);\n    } // The logic of selection\n\n\n    _observerCallback(entries) {\n      const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);\n\n      const activate = entry => {\n        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n\n        this._process(targetElement(entry));\n      };\n\n      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n      this._previousScrollData.parentScrollTop = parentScrollTop;\n\n      for (const entry of entries) {\n        if (!entry.isIntersecting) {\n          this._activeTarget = null;\n\n          this._clearActiveClass(targetElement(entry));\n\n          continue;\n        }\n\n        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop; // if we are scrolling down, pick the bigger offsetTop\n\n        if (userScrollsDown && entryIsLowerThanPrevious) {\n          activate(entry); // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n\n          if (!parentScrollTop) {\n            return;\n          }\n\n          continue;\n        } // if we are scrolling up, pick the smallest offsetTop\n\n\n        if (!userScrollsDown && !entryIsLowerThanPrevious) {\n          activate(entry);\n        }\n      }\n    } // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n\n\n    _getRootMargin() {\n      return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin;\n    }\n\n    _initializeTargetsAndObservables() {\n      this._targetLinks = new Map();\n      this._observableSections = new Map();\n      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n\n      for (const anchor of targetLinks) {\n        // ensure that the anchor has an id and is not disabled\n        if (!anchor.hash || isDisabled(anchor)) {\n          continue;\n        }\n\n        const observableSection = SelectorEngine.findOne(anchor.hash, this._element); // ensure that the observableSection exists & is visible\n\n        if (isVisible(observableSection)) {\n          this._targetLinks.set(anchor.hash, anchor);\n\n          this._observableSections.set(anchor.hash, observableSection);\n        }\n      }\n    }\n\n    _process(target) {\n      if (this._activeTarget === target) {\n        return;\n      }\n\n      this._clearActiveClass(this._config.target);\n\n      this._activeTarget = target;\n      target.classList.add(CLASS_NAME_ACTIVE$1);\n\n      this._activateParents(target);\n\n      EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n        relatedTarget: target\n      });\n    }\n\n    _activateParents(target) {\n      // Activate dropdown parents\n      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n        return;\n      }\n\n      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {\n        // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {\n          item.classList.add(CLASS_NAME_ACTIVE$1);\n        }\n      }\n    }\n\n    _clearActiveClass(parent) {\n      parent.classList.remove(CLASS_NAME_ACTIVE$1);\n      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\n\n      for (const node of activeNodes) {\n        node.classList.remove(CLASS_NAME_ACTIVE$1);\n      }\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = ScrollSpy.getOrCreateInstance(this, config);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\n    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {\n      ScrollSpy.getOrCreateInstance(spy);\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(ScrollSpy);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): tab.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME$1 = 'tab';\n  const DATA_KEY$1 = 'bs.tab';\n  const EVENT_KEY$1 = `.${DATA_KEY$1}`;\n  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\n  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\n  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\n  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\n  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\n  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\n  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\n  const ARROW_LEFT_KEY = 'ArrowLeft';\n  const ARROW_RIGHT_KEY = 'ArrowRight';\n  const ARROW_UP_KEY = 'ArrowUp';\n  const ARROW_DOWN_KEY = 'ArrowDown';\n  const CLASS_NAME_ACTIVE = 'active';\n  const CLASS_NAME_FADE$1 = 'fade';\n  const CLASS_NAME_SHOW$1 = 'show';\n  const CLASS_DROPDOWN = 'dropdown';\n  const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\n  const SELECTOR_DROPDOWN_ITEM = '.dropdown-item';\n  const NOT_SELECTOR_DROPDOWN_TOGGLE = ':not(.dropdown-toggle)';\n  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\n  const SELECTOR_OUTER = '.nav-item, .list-group-item';\n  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\n  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // todo:v6: could be only `tab`\n\n  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\n  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\n  /**\n   * Class definition\n   */\n\n  class Tab extends BaseComponent {\n    constructor(element) {\n      super(element);\n      this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n\n      if (!this._parent) {\n        return; // todo: should Throw exception on v6\n        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n      } // Set up initial aria attributes\n\n\n      this._setInitialAttributes(this._parent, this._getChildren());\n\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\n    } // Getters\n\n\n    static get NAME() {\n      return NAME$1;\n    } // Public\n\n\n    show() {\n      // Shows this elem and deactivate the active sibling if exists\n      const innerElem = this._element;\n\n      if (this._elemIsActive(innerElem)) {\n        return;\n      } // Search for active tab on same parent to deactivate it\n\n\n      const active = this._getActiveElem();\n\n      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n        relatedTarget: innerElem\n      }) : null;\n      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n        relatedTarget: active\n      });\n\n      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n        return;\n      }\n\n      this._deactivate(active, innerElem);\n\n      this._activate(innerElem, active);\n    } // Private\n\n\n    _activate(element, relatedElem) {\n      if (!element) {\n        return;\n      }\n\n      element.classList.add(CLASS_NAME_ACTIVE);\n\n      this._activate(getElementFromSelector(element)); // Search and activate/show the proper section\n\n\n      const complete = () => {\n        if (element.getAttribute('role') !== 'tab') {\n          element.classList.add(CLASS_NAME_SHOW$1);\n          return;\n        }\n\n        element.focus();\n        element.removeAttribute('tabindex');\n        element.setAttribute('aria-selected', true);\n\n        this._toggleDropDown(element, true);\n\n        EventHandler.trigger(element, EVENT_SHOWN$1, {\n          relatedTarget: relatedElem\n        });\n      };\n\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n    }\n\n    _deactivate(element, relatedElem) {\n      if (!element) {\n        return;\n      }\n\n      element.classList.remove(CLASS_NAME_ACTIVE);\n      element.blur();\n\n      this._deactivate(getElementFromSelector(element)); // Search and deactivate the shown section too\n\n\n      const complete = () => {\n        if (element.getAttribute('role') !== 'tab') {\n          element.classList.remove(CLASS_NAME_SHOW$1);\n          return;\n        }\n\n        element.setAttribute('aria-selected', false);\n        element.setAttribute('tabindex', '-1');\n\n        this._toggleDropDown(element, false);\n\n        EventHandler.trigger(element, EVENT_HIDDEN$1, {\n          relatedTarget: relatedElem\n        });\n      };\n\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n    }\n\n    _keydown(event) {\n      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY].includes(event.key)) {\n        return;\n      }\n\n      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n\n      event.preventDefault();\n      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\n      const nextActiveElement = getNextActiveElement(this._getChildren().filter(element => !isDisabled(element)), event.target, isNext, true);\n\n      if (nextActiveElement) {\n        Tab.getOrCreateInstance(nextActiveElement).show();\n      }\n    }\n\n    _getChildren() {\n      // collection of inner elements\n      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n    }\n\n    _getActiveElem() {\n      return this._getChildren().find(child => this._elemIsActive(child)) || null;\n    }\n\n    _setInitialAttributes(parent, children) {\n      this._setAttributeIfNotExists(parent, 'role', 'tablist');\n\n      for (const child of children) {\n        this._setInitialAttributesOnChild(child);\n      }\n    }\n\n    _setInitialAttributesOnChild(child) {\n      child = this._getInnerElement(child);\n\n      const isActive = this._elemIsActive(child);\n\n      const outerElem = this._getOuterElement(child);\n\n      child.setAttribute('aria-selected', isActive);\n\n      if (outerElem !== child) {\n        this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\n      }\n\n      if (!isActive) {\n        child.setAttribute('tabindex', '-1');\n      }\n\n      this._setAttributeIfNotExists(child, 'role', 'tab'); // set attributes to the related panel too\n\n\n      this._setInitialAttributesOnTargetPanel(child);\n    }\n\n    _setInitialAttributesOnTargetPanel(child) {\n      const target = getElementFromSelector(child);\n\n      if (!target) {\n        return;\n      }\n\n      this._setAttributeIfNotExists(target, 'role', 'tabpanel');\n\n      if (child.id) {\n        this._setAttributeIfNotExists(target, 'aria-labelledby', `#${child.id}`);\n      }\n    }\n\n    _toggleDropDown(element, open) {\n      const outerElem = this._getOuterElement(element);\n\n      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n        return;\n      }\n\n      const toggle = (selector, className) => {\n        const element = SelectorEngine.findOne(selector, outerElem);\n\n        if (element) {\n          element.classList.toggle(className, open);\n        }\n      };\n\n      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n      toggle(SELECTOR_DROPDOWN_ITEM, CLASS_NAME_ACTIVE);\n      outerElem.setAttribute('aria-expanded', open);\n    }\n\n    _setAttributeIfNotExists(element, attribute, value) {\n      if (!element.hasAttribute(attribute)) {\n        element.setAttribute(attribute, value);\n      }\n    }\n\n    _elemIsActive(elem) {\n      return elem.classList.contains(CLASS_NAME_ACTIVE);\n    } // Try to get the inner element (usually the .nav-link)\n\n\n    _getInnerElement(elem) {\n      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n    } // Try to get the outer element (usually the .nav-item)\n\n\n    _getOuterElement(elem) {\n      return elem.closest(SELECTOR_OUTER) || elem;\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Tab.getOrCreateInstance(this);\n\n        if (typeof config !== 'string') {\n          return;\n        }\n\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\n          throw new TypeError(`No method named \"${config}\"`);\n        }\n\n        data[config]();\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    if (['A', 'AREA'].includes(this.tagName)) {\n      event.preventDefault();\n    }\n\n    if (isDisabled(this)) {\n      return;\n    }\n\n    Tab.getOrCreateInstance(this).show();\n  });\n  /**\n   * Initialize on focus\n   */\n\n  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {\n    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {\n      Tab.getOrCreateInstance(element);\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Tab);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): toast.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Constants\n   */\n\n  const NAME = 'toast';\n  const DATA_KEY = 'bs.toast';\n  const EVENT_KEY = `.${DATA_KEY}`;\n  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\n  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\n  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\n  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\n  const EVENT_HIDE = `hide${EVENT_KEY}`;\n  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;\n  const EVENT_SHOW = `show${EVENT_KEY}`;\n  const EVENT_SHOWN = `shown${EVENT_KEY}`;\n  const CLASS_NAME_FADE = 'fade';\n  const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\n\n  const CLASS_NAME_SHOW = 'show';\n  const CLASS_NAME_SHOWING = 'showing';\n  const DefaultType = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  const Default = {\n    animation: true,\n    autohide: true,\n    delay: 5000\n  };\n  /**\n   * Class definition\n   */\n\n  class Toast extends BaseComponent {\n    constructor(element, config) {\n      super(element, config);\n      this._timeout = null;\n      this._hasMouseInteraction = false;\n      this._hasKeyboardInteraction = false;\n\n      this._setListeners();\n    } // Getters\n\n\n    static get Default() {\n      return Default;\n    }\n\n    static get DefaultType() {\n      return DefaultType;\n    }\n\n    static get NAME() {\n      return NAME;\n    } // Public\n\n\n    show() {\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n\n      if (showEvent.defaultPrevented) {\n        return;\n      }\n\n      this._clearTimeout();\n\n      if (this._config.animation) {\n        this._element.classList.add(CLASS_NAME_FADE);\n      }\n\n      const complete = () => {\n        this._element.classList.remove(CLASS_NAME_SHOWING);\n\n        EventHandler.trigger(this._element, EVENT_SHOWN);\n\n        this._maybeScheduleHide();\n      };\n\n      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n\n\n      reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n\n      this._queueCallback(complete, this._element, this._config.animation);\n    }\n\n    hide() {\n      if (!this.isShown()) {\n        return;\n      }\n\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n\n      if (hideEvent.defaultPrevented) {\n        return;\n      }\n\n      const complete = () => {\n        this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n\n\n        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n\n        EventHandler.trigger(this._element, EVENT_HIDDEN);\n      };\n\n      this._element.classList.add(CLASS_NAME_SHOWING);\n\n      this._queueCallback(complete, this._element, this._config.animation);\n    }\n\n    dispose() {\n      this._clearTimeout();\n\n      if (this.isShown()) {\n        this._element.classList.remove(CLASS_NAME_SHOW);\n      }\n\n      super.dispose();\n    }\n\n    isShown() {\n      return this._element.classList.contains(CLASS_NAME_SHOW);\n    } // Private\n\n\n    _maybeScheduleHide() {\n      if (!this._config.autohide) {\n        return;\n      }\n\n      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n        return;\n      }\n\n      this._timeout = setTimeout(() => {\n        this.hide();\n      }, this._config.delay);\n    }\n\n    _onInteraction(event, isInteracting) {\n      switch (event.type) {\n        case 'mouseover':\n        case 'mouseout':\n          this._hasMouseInteraction = isInteracting;\n          break;\n\n        case 'focusin':\n        case 'focusout':\n          this._hasKeyboardInteraction = isInteracting;\n          break;\n      }\n\n      if (isInteracting) {\n        this._clearTimeout();\n\n        return;\n      }\n\n      const nextElement = event.relatedTarget;\n\n      if (this._element === nextElement || this._element.contains(nextElement)) {\n        return;\n      }\n\n      this._maybeScheduleHide();\n    }\n\n    _setListeners() {\n      EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\n      EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\n      EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\n      EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\n    }\n\n    _clearTimeout() {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    } // Static\n\n\n    static jQueryInterface(config) {\n      return this.each(function () {\n        const data = Toast.getOrCreateInstance(this, config);\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(`No method named \"${config}\"`);\n          }\n\n          data[config](this);\n        }\n      });\n    }\n\n  }\n  /**\n   * Data API implementation\n   */\n\n\n  enableDismissTrigger(Toast);\n  /**\n   * jQuery\n   */\n\n  defineJQueryPlugin(Toast);\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v5.2.0): index.umd.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  const index_umd = {\n    Alert,\n    Button,\n    Carousel,\n    Collapse,\n    Dropdown,\n    Modal,\n    Offcanvas,\n    Popover,\n    ScrollSpy,\n    Tab,\n    Toast,\n    Tooltip\n  };\n\n  return index_umd;\n\n}));\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js":
/*!******************************************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js ***!
  \******************************************************************************************************************************/
/***/ ((module) => {

module.exports = "/*!\n * Select2 4.0.13\n * https://select2.github.io\n *\n * Released under the MIT license\n * https://github.com/select2/select2/blob/master/LICENSE.md\n */\n;(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = function (root, jQuery) {\n      if (jQuery === undefined) {\n        // require('jQuery') returns a factory that requires window to\n        // build a jQuery instance, we normalize how we use modules\n        // that require this pattern but the window provided is a noop\n        // if it's defined (how jquery works)\n        if (typeof window !== 'undefined') {\n          jQuery = require('jquery');\n        }\n        else {\n          jQuery = require('jquery')(root);\n        }\n      }\n      factory(jQuery);\n      return jQuery;\n    };\n  } else {\n    // Browser globals\n    factory(jQuery);\n  }\n} (function (jQuery) {\n  // This is needed so we can catch the AMD loader configuration and use it\n  // The inner file should be wrapped (by `banner.start.js`) in a function that\n  // returns the AMD loader references.\n  var S2 =(function () {\n  // Restore the Select2 AMD loader so it can be used\n  // Needed mostly in the language files, where the loader is not inserted\n  if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) {\n    var S2 = jQuery.fn.select2.amd;\n  }\nvar S2;(function () { if (!S2 || !S2.requirejs) {\nif (!S2) { S2 = {}; } else { require = S2; }\n/**\n * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.\n * Released under MIT license, http://github.com/requirejs/almond/LICENSE\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice,\n        jsSuffixRegExp = /\\.js$/;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap, lastIndex,\n            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name) {\n            name = name.split('/');\n            lastIndex = name.length - 1;\n\n            // If wanting node ID compatibility, strip .js from end\n            // of IDs. Have to do this here, and not in nameToUrl\n            // because node allows either .js or non .js to map\n            // to same file.\n            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {\n                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');\n            }\n\n            // Starts with a '.' so need the baseName\n            if (name[0].charAt(0) === '.' && baseParts) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that 'directory' and not name of the baseName's\n                //module. For instance, baseName of 'one/two/three', maps to\n                //'one/two/three.js', but we want the directory, 'one/two' for\n                //this normalization.\n                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);\n                name = normalizedBaseParts.concat(name);\n            }\n\n            //start trimDots\n            for (i = 0; i < name.length; i++) {\n                part = name[i];\n                if (part === '.') {\n                    name.splice(i, 1);\n                    i -= 1;\n                } else if (part === '..') {\n                    // If at the start, or previous value is still ..,\n                    // keep them so that when converted to a path it may\n                    // still work when converted to a path, even though\n                    // as an ID it is less than ideal. In larger point\n                    // releases, may be better to just kick out an error.\n                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {\n                        continue;\n                    } else if (i > 0) {\n                        name.splice(i - 1, 2);\n                        i -= 2;\n                    }\n                }\n            }\n            //end trimDots\n\n            name = name.join('/');\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            var args = aps.call(arguments, 0);\n\n            //If first arg is not require('string'), and there is only\n            //one arg, it is the array form without a callback. Insert\n            //a null so that the following concat is correct.\n            if (typeof args[0] !== 'string' && args.length === 1) {\n                args.push(null);\n            }\n            return req.apply(undef, args.concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    //Creates a parts array for a relName where first part is plugin ID,\n    //second part is resource ID. Assumes relName has already been normalized.\n    function makeRelParts(relName) {\n        return relName ? splitPrefix(relName) : [];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relParts) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0],\n            relResourceName = relParts[1];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relResourceName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relResourceName));\n            } else {\n                name = normalize(name, relResourceName);\n            }\n        } else {\n            name = normalize(name, relResourceName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i, relParts,\n            args = [],\n            callbackType = typeof callback,\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n        relParts = makeRelParts(relName);\n\n        //Call the callback to define the module, if necessary.\n        if (callbackType === 'undefined' || callbackType === 'function') {\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relParts);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback ? callback.apply(defined[name], args) : undefined;\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, makeRelParts(callback)).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (config.deps) {\n                req(config.deps, config.callback);\n            }\n            if (!callback) {\n                return;\n            }\n\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        return req(cfg);\n    };\n\n    /**\n     * Expose module registry for debugging and tooling\n     */\n    requirejs._defined = defined;\n\n    define = function (name, deps, callback) {\n        if (typeof name !== 'string') {\n            throw new Error('See almond README: incorrect module build, no module name');\n        }\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\nS2.requirejs = requirejs;S2.require = require;S2.define = define;\n}\n}());\nS2.define(\"almond\", function(){});\n\n/* global jQuery:false, $:false */\nS2.define('jquery',[],function () {\n  var _$ = jQuery || $;\n\n  if (_$ == null && console && console.error) {\n    console.error(\n      'Select2: An instance of jQuery or a jQuery-compatible library was not ' +\n      'found. Make sure that you are including jQuery before Select2 on your ' +\n      'web page.'\n    );\n  }\n\n  return _$;\n});\n\nS2.define('select2/utils',[\n  'jquery'\n], function ($) {\n  var Utils = {};\n\n  Utils.Extend = function (ChildClass, SuperClass) {\n    var __hasProp = {}.hasOwnProperty;\n\n    function BaseConstructor () {\n      this.constructor = ChildClass;\n    }\n\n    for (var key in SuperClass) {\n      if (__hasProp.call(SuperClass, key)) {\n        ChildClass[key] = SuperClass[key];\n      }\n    }\n\n    BaseConstructor.prototype = SuperClass.prototype;\n    ChildClass.prototype = new BaseConstructor();\n    ChildClass.__super__ = SuperClass.prototype;\n\n    return ChildClass;\n  };\n\n  function getMethods (theClass) {\n    var proto = theClass.prototype;\n\n    var methods = [];\n\n    for (var methodName in proto) {\n      var m = proto[methodName];\n\n      if (typeof m !== 'function') {\n        continue;\n      }\n\n      if (methodName === 'constructor') {\n        continue;\n      }\n\n      methods.push(methodName);\n    }\n\n    return methods;\n  }\n\n  Utils.Decorate = function (SuperClass, DecoratorClass) {\n    var decoratedMethods = getMethods(DecoratorClass);\n    var superMethods = getMethods(SuperClass);\n\n    function DecoratedClass () {\n      var unshift = Array.prototype.unshift;\n\n      var argCount = DecoratorClass.prototype.constructor.length;\n\n      var calledConstructor = SuperClass.prototype.constructor;\n\n      if (argCount > 0) {\n        unshift.call(arguments, SuperClass.prototype.constructor);\n\n        calledConstructor = DecoratorClass.prototype.constructor;\n      }\n\n      calledConstructor.apply(this, arguments);\n    }\n\n    DecoratorClass.displayName = SuperClass.displayName;\n\n    function ctr () {\n      this.constructor = DecoratedClass;\n    }\n\n    DecoratedClass.prototype = new ctr();\n\n    for (var m = 0; m < superMethods.length; m++) {\n      var superMethod = superMethods[m];\n\n      DecoratedClass.prototype[superMethod] =\n        SuperClass.prototype[superMethod];\n    }\n\n    var calledMethod = function (methodName) {\n      // Stub out the original method if it's not decorating an actual method\n      var originalMethod = function () {};\n\n      if (methodName in DecoratedClass.prototype) {\n        originalMethod = DecoratedClass.prototype[methodName];\n      }\n\n      var decoratedMethod = DecoratorClass.prototype[methodName];\n\n      return function () {\n        var unshift = Array.prototype.unshift;\n\n        unshift.call(arguments, originalMethod);\n\n        return decoratedMethod.apply(this, arguments);\n      };\n    };\n\n    for (var d = 0; d < decoratedMethods.length; d++) {\n      var decoratedMethod = decoratedMethods[d];\n\n      DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);\n    }\n\n    return DecoratedClass;\n  };\n\n  var Observable = function () {\n    this.listeners = {};\n  };\n\n  Observable.prototype.on = function (event, callback) {\n    this.listeners = this.listeners || {};\n\n    if (event in this.listeners) {\n      this.listeners[event].push(callback);\n    } else {\n      this.listeners[event] = [callback];\n    }\n  };\n\n  Observable.prototype.trigger = function (event) {\n    var slice = Array.prototype.slice;\n    var params = slice.call(arguments, 1);\n\n    this.listeners = this.listeners || {};\n\n    // Params should always come in as an array\n    if (params == null) {\n      params = [];\n    }\n\n    // If there are no arguments to the event, use a temporary object\n    if (params.length === 0) {\n      params.push({});\n    }\n\n    // Set the `_type` of the first object to the event\n    params[0]._type = event;\n\n    if (event in this.listeners) {\n      this.invoke(this.listeners[event], slice.call(arguments, 1));\n    }\n\n    if ('*' in this.listeners) {\n      this.invoke(this.listeners['*'], arguments);\n    }\n  };\n\n  Observable.prototype.invoke = function (listeners, params) {\n    for (var i = 0, len = listeners.length; i < len; i++) {\n      listeners[i].apply(this, params);\n    }\n  };\n\n  Utils.Observable = Observable;\n\n  Utils.generateChars = function (length) {\n    var chars = '';\n\n    for (var i = 0; i < length; i++) {\n      var randomChar = Math.floor(Math.random() * 36);\n      chars += randomChar.toString(36);\n    }\n\n    return chars;\n  };\n\n  Utils.bind = function (func, context) {\n    return function () {\n      func.apply(context, arguments);\n    };\n  };\n\n  Utils._convertData = function (data) {\n    for (var originalKey in data) {\n      var keys = originalKey.split('-');\n\n      var dataLevel = data;\n\n      if (keys.length === 1) {\n        continue;\n      }\n\n      for (var k = 0; k < keys.length; k++) {\n        var key = keys[k];\n\n        // Lowercase the first letter\n        // By default, dash-separated becomes camelCase\n        key = key.substring(0, 1).toLowerCase() + key.substring(1);\n\n        if (!(key in dataLevel)) {\n          dataLevel[key] = {};\n        }\n\n        if (k == keys.length - 1) {\n          dataLevel[key] = data[originalKey];\n        }\n\n        dataLevel = dataLevel[key];\n      }\n\n      delete data[originalKey];\n    }\n\n    return data;\n  };\n\n  Utils.hasScroll = function (index, el) {\n    // Adapted from the function created by @ShadowScripter\n    // and adapted by @BillBarry on the Stack Exchange Code Review website.\n    // The original code can be found at\n    // http://codereview.stackexchange.com/q/13338\n    // and was designed to be used with the Sizzle selector engine.\n\n    var $el = $(el);\n    var overflowX = el.style.overflowX;\n    var overflowY = el.style.overflowY;\n\n    //Check both x and y declarations\n    if (overflowX === overflowY &&\n        (overflowY === 'hidden' || overflowY === 'visible')) {\n      return false;\n    }\n\n    if (overflowX === 'scroll' || overflowY === 'scroll') {\n      return true;\n    }\n\n    return ($el.innerHeight() < el.scrollHeight ||\n      $el.innerWidth() < el.scrollWidth);\n  };\n\n  Utils.escapeMarkup = function (markup) {\n    var replaceMap = {\n      '\\\\': '&#92;',\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '/': '&#47;'\n    };\n\n    // Do not try to escape the markup if it's not a string\n    if (typeof markup !== 'string') {\n      return markup;\n    }\n\n    return String(markup).replace(/[&<>\"'\\/\\\\]/g, function (match) {\n      return replaceMap[match];\n    });\n  };\n\n  // Append an array of jQuery nodes to a given element.\n  Utils.appendMany = function ($element, $nodes) {\n    // jQuery 1.7.x does not support $.fn.append() with an array\n    // Fall back to a jQuery object collection using $.fn.add()\n    if ($.fn.jquery.substr(0, 3) === '1.7') {\n      var $jqNodes = $();\n\n      $.map($nodes, function (node) {\n        $jqNodes = $jqNodes.add(node);\n      });\n\n      $nodes = $jqNodes;\n    }\n\n    $element.append($nodes);\n  };\n\n  // Cache objects in Utils.__cache instead of $.data (see #4346)\n  Utils.__cache = {};\n\n  var id = 0;\n  Utils.GetUniqueElementId = function (element) {\n    // Get a unique element Id. If element has no id,\n    // creates a new unique number, stores it in the id\n    // attribute and returns the new id.\n    // If an id already exists, it simply returns it.\n\n    var select2Id = element.getAttribute('data-select2-id');\n    if (select2Id == null) {\n      // If element has id, use it.\n      if (element.id) {\n        select2Id = element.id;\n        element.setAttribute('data-select2-id', select2Id);\n      } else {\n        element.setAttribute('data-select2-id', ++id);\n        select2Id = id.toString();\n      }\n    }\n    return select2Id;\n  };\n\n  Utils.StoreData = function (element, name, value) {\n    // Stores an item in the cache for a specified element.\n    // name is the cache key.\n    var id = Utils.GetUniqueElementId(element);\n    if (!Utils.__cache[id]) {\n      Utils.__cache[id] = {};\n    }\n\n    Utils.__cache[id][name] = value;\n  };\n\n  Utils.GetData = function (element, name) {\n    // Retrieves a value from the cache by its key (name)\n    // name is optional. If no name specified, return\n    // all cache items for the specified element.\n    // and for a specified element.\n    var id = Utils.GetUniqueElementId(element);\n    if (name) {\n      if (Utils.__cache[id]) {\n        if (Utils.__cache[id][name] != null) {\n          return Utils.__cache[id][name];\n        }\n        return $(element).data(name); // Fallback to HTML5 data attribs.\n      }\n      return $(element).data(name); // Fallback to HTML5 data attribs.\n    } else {\n      return Utils.__cache[id];\n    }\n  };\n\n  Utils.RemoveData = function (element) {\n    // Removes all cached items for a specified element.\n    var id = Utils.GetUniqueElementId(element);\n    if (Utils.__cache[id] != null) {\n      delete Utils.__cache[id];\n    }\n\n    element.removeAttribute('data-select2-id');\n  };\n\n  return Utils;\n});\n\nS2.define('select2/results',[\n  'jquery',\n  './utils'\n], function ($, Utils) {\n  function Results ($element, options, dataAdapter) {\n    this.$element = $element;\n    this.data = dataAdapter;\n    this.options = options;\n\n    Results.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(Results, Utils.Observable);\n\n  Results.prototype.render = function () {\n    var $results = $(\n      '<ul class=\"select2-results__options\" role=\"listbox\"></ul>'\n    );\n\n    if (this.options.get('multiple')) {\n      $results.attr('aria-multiselectable', 'true');\n    }\n\n    this.$results = $results;\n\n    return $results;\n  };\n\n  Results.prototype.clear = function () {\n    this.$results.empty();\n  };\n\n  Results.prototype.displayMessage = function (params) {\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    this.clear();\n    this.hideLoading();\n\n    var $message = $(\n      '<li role=\"alert\" aria-live=\"assertive\"' +\n      ' class=\"select2-results__option\"></li>'\n    );\n\n    var message = this.options.get('translations').get(params.message);\n\n    $message.append(\n      escapeMarkup(\n        message(params.args)\n      )\n    );\n\n    $message[0].className += ' select2-results__message';\n\n    this.$results.append($message);\n  };\n\n  Results.prototype.hideMessages = function () {\n    this.$results.find('.select2-results__message').remove();\n  };\n\n  Results.prototype.append = function (data) {\n    this.hideLoading();\n\n    var $options = [];\n\n    if (data.results == null || data.results.length === 0) {\n      if (this.$results.children().length === 0) {\n        this.trigger('results:message', {\n          message: 'noResults'\n        });\n      }\n\n      return;\n    }\n\n    data.results = this.sort(data.results);\n\n    for (var d = 0; d < data.results.length; d++) {\n      var item = data.results[d];\n\n      var $option = this.option(item);\n\n      $options.push($option);\n    }\n\n    this.$results.append($options);\n  };\n\n  Results.prototype.position = function ($results, $dropdown) {\n    var $resultsContainer = $dropdown.find('.select2-results');\n    $resultsContainer.append($results);\n  };\n\n  Results.prototype.sort = function (data) {\n    var sorter = this.options.get('sorter');\n\n    return sorter(data);\n  };\n\n  Results.prototype.highlightFirstItem = function () {\n    var $options = this.$results\n      .find('.select2-results__option[aria-selected]');\n\n    var $selected = $options.filter('[aria-selected=true]');\n\n    // Check if there are any selected options\n    if ($selected.length > 0) {\n      // If there are selected options, highlight the first\n      $selected.first().trigger('mouseenter');\n    } else {\n      // If there are no selected options, highlight the first option\n      // in the dropdown\n      $options.first().trigger('mouseenter');\n    }\n\n    this.ensureHighlightVisible();\n  };\n\n  Results.prototype.setClasses = function () {\n    var self = this;\n\n    this.data.current(function (selected) {\n      var selectedIds = $.map(selected, function (s) {\n        return s.id.toString();\n      });\n\n      var $options = self.$results\n        .find('.select2-results__option[aria-selected]');\n\n      $options.each(function () {\n        var $option = $(this);\n\n        var item = Utils.GetData(this, 'data');\n\n        // id needs to be converted to a string when comparing\n        var id = '' + item.id;\n\n        if ((item.element != null && item.element.selected) ||\n            (item.element == null && $.inArray(id, selectedIds) > -1)) {\n          $option.attr('aria-selected', 'true');\n        } else {\n          $option.attr('aria-selected', 'false');\n        }\n      });\n\n    });\n  };\n\n  Results.prototype.showLoading = function (params) {\n    this.hideLoading();\n\n    var loadingMore = this.options.get('translations').get('searching');\n\n    var loading = {\n      disabled: true,\n      loading: true,\n      text: loadingMore(params)\n    };\n    var $loading = this.option(loading);\n    $loading.className += ' loading-results';\n\n    this.$results.prepend($loading);\n  };\n\n  Results.prototype.hideLoading = function () {\n    this.$results.find('.loading-results').remove();\n  };\n\n  Results.prototype.option = function (data) {\n    var option = document.createElement('li');\n    option.className = 'select2-results__option';\n\n    var attrs = {\n      'role': 'option',\n      'aria-selected': 'false'\n    };\n\n    var matches = window.Element.prototype.matches ||\n      window.Element.prototype.msMatchesSelector ||\n      window.Element.prototype.webkitMatchesSelector;\n\n    if ((data.element != null && matches.call(data.element, ':disabled')) ||\n        (data.element == null && data.disabled)) {\n      delete attrs['aria-selected'];\n      attrs['aria-disabled'] = 'true';\n    }\n\n    if (data.id == null) {\n      delete attrs['aria-selected'];\n    }\n\n    if (data._resultId != null) {\n      option.id = data._resultId;\n    }\n\n    if (data.title) {\n      option.title = data.title;\n    }\n\n    if (data.children) {\n      attrs.role = 'group';\n      attrs['aria-label'] = data.text;\n      delete attrs['aria-selected'];\n    }\n\n    for (var attr in attrs) {\n      var val = attrs[attr];\n\n      option.setAttribute(attr, val);\n    }\n\n    if (data.children) {\n      var $option = $(option);\n\n      var label = document.createElement('strong');\n      label.className = 'select2-results__group';\n\n      var $label = $(label);\n      this.template(data, label);\n\n      var $children = [];\n\n      for (var c = 0; c < data.children.length; c++) {\n        var child = data.children[c];\n\n        var $child = this.option(child);\n\n        $children.push($child);\n      }\n\n      var $childrenContainer = $('<ul></ul>', {\n        'class': 'select2-results__options select2-results__options--nested'\n      });\n\n      $childrenContainer.append($children);\n\n      $option.append(label);\n      $option.append($childrenContainer);\n    } else {\n      this.template(data, option);\n    }\n\n    Utils.StoreData(option, 'data', data);\n\n    return option;\n  };\n\n  Results.prototype.bind = function (container, $container) {\n    var self = this;\n\n    var id = container.id + '-results';\n\n    this.$results.attr('id', id);\n\n    container.on('results:all', function (params) {\n      self.clear();\n      self.append(params.data);\n\n      if (container.isOpen()) {\n        self.setClasses();\n        self.highlightFirstItem();\n      }\n    });\n\n    container.on('results:append', function (params) {\n      self.append(params.data);\n\n      if (container.isOpen()) {\n        self.setClasses();\n      }\n    });\n\n    container.on('query', function (params) {\n      self.hideMessages();\n      self.showLoading(params);\n    });\n\n    container.on('select', function () {\n      if (!container.isOpen()) {\n        return;\n      }\n\n      self.setClasses();\n\n      if (self.options.get('scrollAfterSelect')) {\n        self.highlightFirstItem();\n      }\n    });\n\n    container.on('unselect', function () {\n      if (!container.isOpen()) {\n        return;\n      }\n\n      self.setClasses();\n\n      if (self.options.get('scrollAfterSelect')) {\n        self.highlightFirstItem();\n      }\n    });\n\n    container.on('open', function () {\n      // When the dropdown is open, aria-expended=\"true\"\n      self.$results.attr('aria-expanded', 'true');\n      self.$results.attr('aria-hidden', 'false');\n\n      self.setClasses();\n      self.ensureHighlightVisible();\n    });\n\n    container.on('close', function () {\n      // When the dropdown is closed, aria-expended=\"false\"\n      self.$results.attr('aria-expanded', 'false');\n      self.$results.attr('aria-hidden', 'true');\n      self.$results.removeAttr('aria-activedescendant');\n    });\n\n    container.on('results:toggle', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      if ($highlighted.length === 0) {\n        return;\n      }\n\n      $highlighted.trigger('mouseup');\n    });\n\n    container.on('results:select', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      if ($highlighted.length === 0) {\n        return;\n      }\n\n      var data = Utils.GetData($highlighted[0], 'data');\n\n      if ($highlighted.attr('aria-selected') == 'true') {\n        self.trigger('close', {});\n      } else {\n        self.trigger('select', {\n          data: data\n        });\n      }\n    });\n\n    container.on('results:previous', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      var $options = self.$results.find('[aria-selected]');\n\n      var currentIndex = $options.index($highlighted);\n\n      // If we are already at the top, don't move further\n      // If no options, currentIndex will be -1\n      if (currentIndex <= 0) {\n        return;\n      }\n\n      var nextIndex = currentIndex - 1;\n\n      // If none are highlighted, highlight the first\n      if ($highlighted.length === 0) {\n        nextIndex = 0;\n      }\n\n      var $next = $options.eq(nextIndex);\n\n      $next.trigger('mouseenter');\n\n      var currentOffset = self.$results.offset().top;\n      var nextTop = $next.offset().top;\n      var nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);\n\n      if (nextIndex === 0) {\n        self.$results.scrollTop(0);\n      } else if (nextTop - currentOffset < 0) {\n        self.$results.scrollTop(nextOffset);\n      }\n    });\n\n    container.on('results:next', function () {\n      var $highlighted = self.getHighlightedResults();\n\n      var $options = self.$results.find('[aria-selected]');\n\n      var currentIndex = $options.index($highlighted);\n\n      var nextIndex = currentIndex + 1;\n\n      // If we are at the last option, stay there\n      if (nextIndex >= $options.length) {\n        return;\n      }\n\n      var $next = $options.eq(nextIndex);\n\n      $next.trigger('mouseenter');\n\n      var currentOffset = self.$results.offset().top +\n        self.$results.outerHeight(false);\n      var nextBottom = $next.offset().top + $next.outerHeight(false);\n      var nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;\n\n      if (nextIndex === 0) {\n        self.$results.scrollTop(0);\n      } else if (nextBottom > currentOffset) {\n        self.$results.scrollTop(nextOffset);\n      }\n    });\n\n    container.on('results:focus', function (params) {\n      params.element.addClass('select2-results__option--highlighted');\n    });\n\n    container.on('results:message', function (params) {\n      self.displayMessage(params);\n    });\n\n    if ($.fn.mousewheel) {\n      this.$results.on('mousewheel', function (e) {\n        var top = self.$results.scrollTop();\n\n        var bottom = self.$results.get(0).scrollHeight - top + e.deltaY;\n\n        var isAtTop = e.deltaY > 0 && top - e.deltaY <= 0;\n        var isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();\n\n        if (isAtTop) {\n          self.$results.scrollTop(0);\n\n          e.preventDefault();\n          e.stopPropagation();\n        } else if (isAtBottom) {\n          self.$results.scrollTop(\n            self.$results.get(0).scrollHeight - self.$results.height()\n          );\n\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      });\n    }\n\n    this.$results.on('mouseup', '.select2-results__option[aria-selected]',\n      function (evt) {\n      var $this = $(this);\n\n      var data = Utils.GetData(this, 'data');\n\n      if ($this.attr('aria-selected') === 'true') {\n        if (self.options.get('multiple')) {\n          self.trigger('unselect', {\n            originalEvent: evt,\n            data: data\n          });\n        } else {\n          self.trigger('close', {});\n        }\n\n        return;\n      }\n\n      self.trigger('select', {\n        originalEvent: evt,\n        data: data\n      });\n    });\n\n    this.$results.on('mouseenter', '.select2-results__option[aria-selected]',\n      function (evt) {\n      var data = Utils.GetData(this, 'data');\n\n      self.getHighlightedResults()\n          .removeClass('select2-results__option--highlighted');\n\n      self.trigger('results:focus', {\n        data: data,\n        element: $(this)\n      });\n    });\n  };\n\n  Results.prototype.getHighlightedResults = function () {\n    var $highlighted = this.$results\n    .find('.select2-results__option--highlighted');\n\n    return $highlighted;\n  };\n\n  Results.prototype.destroy = function () {\n    this.$results.remove();\n  };\n\n  Results.prototype.ensureHighlightVisible = function () {\n    var $highlighted = this.getHighlightedResults();\n\n    if ($highlighted.length === 0) {\n      return;\n    }\n\n    var $options = this.$results.find('[aria-selected]');\n\n    var currentIndex = $options.index($highlighted);\n\n    var currentOffset = this.$results.offset().top;\n    var nextTop = $highlighted.offset().top;\n    var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);\n\n    var offsetDelta = nextTop - currentOffset;\n    nextOffset -= $highlighted.outerHeight(false) * 2;\n\n    if (currentIndex <= 2) {\n      this.$results.scrollTop(0);\n    } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {\n      this.$results.scrollTop(nextOffset);\n    }\n  };\n\n  Results.prototype.template = function (result, container) {\n    var template = this.options.get('templateResult');\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    var content = template(result, container);\n\n    if (content == null) {\n      container.style.display = 'none';\n    } else if (typeof content === 'string') {\n      container.innerHTML = escapeMarkup(content);\n    } else {\n      $(container).append(content);\n    }\n  };\n\n  return Results;\n});\n\nS2.define('select2/keys',[\n\n], function () {\n  var KEYS = {\n    BACKSPACE: 8,\n    TAB: 9,\n    ENTER: 13,\n    SHIFT: 16,\n    CTRL: 17,\n    ALT: 18,\n    ESC: 27,\n    SPACE: 32,\n    PAGE_UP: 33,\n    PAGE_DOWN: 34,\n    END: 35,\n    HOME: 36,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    DELETE: 46\n  };\n\n  return KEYS;\n});\n\nS2.define('select2/selection/base',[\n  'jquery',\n  '../utils',\n  '../keys'\n], function ($, Utils, KEYS) {\n  function BaseSelection ($element, options) {\n    this.$element = $element;\n    this.options = options;\n\n    BaseSelection.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(BaseSelection, Utils.Observable);\n\n  BaseSelection.prototype.render = function () {\n    var $selection = $(\n      '<span class=\"select2-selection\" role=\"combobox\" ' +\n      ' aria-haspopup=\"true\" aria-expanded=\"false\">' +\n      '</span>'\n    );\n\n    this._tabindex = 0;\n\n    if (Utils.GetData(this.$element[0], 'old-tabindex') != null) {\n      this._tabindex = Utils.GetData(this.$element[0], 'old-tabindex');\n    } else if (this.$element.attr('tabindex') != null) {\n      this._tabindex = this.$element.attr('tabindex');\n    }\n\n    $selection.attr('title', this.$element.attr('title'));\n    $selection.attr('tabindex', this._tabindex);\n    $selection.attr('aria-disabled', 'false');\n\n    this.$selection = $selection;\n\n    return $selection;\n  };\n\n  BaseSelection.prototype.bind = function (container, $container) {\n    var self = this;\n\n    var resultsId = container.id + '-results';\n\n    this.container = container;\n\n    this.$selection.on('focus', function (evt) {\n      self.trigger('focus', evt);\n    });\n\n    this.$selection.on('blur', function (evt) {\n      self._handleBlur(evt);\n    });\n\n    this.$selection.on('keydown', function (evt) {\n      self.trigger('keypress', evt);\n\n      if (evt.which === KEYS.SPACE) {\n        evt.preventDefault();\n      }\n    });\n\n    container.on('results:focus', function (params) {\n      self.$selection.attr('aria-activedescendant', params.data._resultId);\n    });\n\n    container.on('selection:update', function (params) {\n      self.update(params.data);\n    });\n\n    container.on('open', function () {\n      // When the dropdown is open, aria-expanded=\"true\"\n      self.$selection.attr('aria-expanded', 'true');\n      self.$selection.attr('aria-owns', resultsId);\n\n      self._attachCloseHandler(container);\n    });\n\n    container.on('close', function () {\n      // When the dropdown is closed, aria-expanded=\"false\"\n      self.$selection.attr('aria-expanded', 'false');\n      self.$selection.removeAttr('aria-activedescendant');\n      self.$selection.removeAttr('aria-owns');\n\n      self.$selection.trigger('focus');\n\n      self._detachCloseHandler(container);\n    });\n\n    container.on('enable', function () {\n      self.$selection.attr('tabindex', self._tabindex);\n      self.$selection.attr('aria-disabled', 'false');\n    });\n\n    container.on('disable', function () {\n      self.$selection.attr('tabindex', '-1');\n      self.$selection.attr('aria-disabled', 'true');\n    });\n  };\n\n  BaseSelection.prototype._handleBlur = function (evt) {\n    var self = this;\n\n    // This needs to be delayed as the active element is the body when the tab\n    // key is pressed, possibly along with others.\n    window.setTimeout(function () {\n      // Don't trigger `blur` if the focus is still in the selection\n      if (\n        (document.activeElement == self.$selection[0]) ||\n        ($.contains(self.$selection[0], document.activeElement))\n      ) {\n        return;\n      }\n\n      self.trigger('blur', evt);\n    }, 1);\n  };\n\n  BaseSelection.prototype._attachCloseHandler = function (container) {\n\n    $(document.body).on('mousedown.select2.' + container.id, function (e) {\n      var $target = $(e.target);\n\n      var $select = $target.closest('.select2');\n\n      var $all = $('.select2.select2-container--open');\n\n      $all.each(function () {\n        if (this == $select[0]) {\n          return;\n        }\n\n        var $element = Utils.GetData(this, 'element');\n\n        $element.select2('close');\n      });\n    });\n  };\n\n  BaseSelection.prototype._detachCloseHandler = function (container) {\n    $(document.body).off('mousedown.select2.' + container.id);\n  };\n\n  BaseSelection.prototype.position = function ($selection, $container) {\n    var $selectionContainer = $container.find('.selection');\n    $selectionContainer.append($selection);\n  };\n\n  BaseSelection.prototype.destroy = function () {\n    this._detachCloseHandler(this.container);\n  };\n\n  BaseSelection.prototype.update = function (data) {\n    throw new Error('The `update` method must be defined in child classes.');\n  };\n\n  /**\n   * Helper method to abstract the \"enabled\" (not \"disabled\") state of this\n   * object.\n   *\n   * @return {true} if the instance is not disabled.\n   * @return {false} if the instance is disabled.\n   */\n  BaseSelection.prototype.isEnabled = function () {\n    return !this.isDisabled();\n  };\n\n  /**\n   * Helper method to abstract the \"disabled\" state of this object.\n   *\n   * @return {true} if the disabled option is true.\n   * @return {false} if the disabled option is false.\n   */\n  BaseSelection.prototype.isDisabled = function () {\n    return this.options.get('disabled');\n  };\n\n  return BaseSelection;\n});\n\nS2.define('select2/selection/single',[\n  'jquery',\n  './base',\n  '../utils',\n  '../keys'\n], function ($, BaseSelection, Utils, KEYS) {\n  function SingleSelection () {\n    SingleSelection.__super__.constructor.apply(this, arguments);\n  }\n\n  Utils.Extend(SingleSelection, BaseSelection);\n\n  SingleSelection.prototype.render = function () {\n    var $selection = SingleSelection.__super__.render.call(this);\n\n    $selection.addClass('select2-selection--single');\n\n    $selection.html(\n      '<span class=\"select2-selection__rendered\"></span>' +\n      '<span class=\"select2-selection__arrow\" role=\"presentation\">' +\n        '<b role=\"presentation\"></b>' +\n      '</span>'\n    );\n\n    return $selection;\n  };\n\n  SingleSelection.prototype.bind = function (container, $container) {\n    var self = this;\n\n    SingleSelection.__super__.bind.apply(this, arguments);\n\n    var id = container.id + '-container';\n\n    this.$selection.find('.select2-selection__rendered')\n      .attr('id', id)\n      .attr('role', 'textbox')\n      .attr('aria-readonly', 'true');\n    this.$selection.attr('aria-labelledby', id);\n\n    this.$selection.on('mousedown', function (evt) {\n      // Only respond to left clicks\n      if (evt.which !== 1) {\n        return;\n      }\n\n      self.trigger('toggle', {\n        originalEvent: evt\n      });\n    });\n\n    this.$selection.on('focus', function (evt) {\n      // User focuses on the container\n    });\n\n    this.$selection.on('blur', function (evt) {\n      // User exits the container\n    });\n\n    container.on('focus', function (evt) {\n      if (!container.isOpen()) {\n        self.$selection.trigger('focus');\n      }\n    });\n  };\n\n  SingleSelection.prototype.clear = function () {\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n    $rendered.empty();\n    $rendered.removeAttr('title'); // clear tooltip on empty\n  };\n\n  SingleSelection.prototype.display = function (data, container) {\n    var template = this.options.get('templateSelection');\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    return escapeMarkup(template(data, container));\n  };\n\n  SingleSelection.prototype.selectionContainer = function () {\n    return $('<span></span>');\n  };\n\n  SingleSelection.prototype.update = function (data) {\n    if (data.length === 0) {\n      this.clear();\n      return;\n    }\n\n    var selection = data[0];\n\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n    var formatted = this.display(selection, $rendered);\n\n    $rendered.empty().append(formatted);\n\n    var title = selection.title || selection.text;\n\n    if (title) {\n      $rendered.attr('title', title);\n    } else {\n      $rendered.removeAttr('title');\n    }\n  };\n\n  return SingleSelection;\n});\n\nS2.define('select2/selection/multiple',[\n  'jquery',\n  './base',\n  '../utils'\n], function ($, BaseSelection, Utils) {\n  function MultipleSelection ($element, options) {\n    MultipleSelection.__super__.constructor.apply(this, arguments);\n  }\n\n  Utils.Extend(MultipleSelection, BaseSelection);\n\n  MultipleSelection.prototype.render = function () {\n    var $selection = MultipleSelection.__super__.render.call(this);\n\n    $selection.addClass('select2-selection--multiple');\n\n    $selection.html(\n      '<ul class=\"select2-selection__rendered\"></ul>'\n    );\n\n    return $selection;\n  };\n\n  MultipleSelection.prototype.bind = function (container, $container) {\n    var self = this;\n\n    MultipleSelection.__super__.bind.apply(this, arguments);\n\n    this.$selection.on('click', function (evt) {\n      self.trigger('toggle', {\n        originalEvent: evt\n      });\n    });\n\n    this.$selection.on(\n      'click',\n      '.select2-selection__choice__remove',\n      function (evt) {\n        // Ignore the event if it is disabled\n        if (self.isDisabled()) {\n          return;\n        }\n\n        var $remove = $(this);\n        var $selection = $remove.parent();\n\n        var data = Utils.GetData($selection[0], 'data');\n\n        self.trigger('unselect', {\n          originalEvent: evt,\n          data: data\n        });\n      }\n    );\n  };\n\n  MultipleSelection.prototype.clear = function () {\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n    $rendered.empty();\n    $rendered.removeAttr('title');\n  };\n\n  MultipleSelection.prototype.display = function (data, container) {\n    var template = this.options.get('templateSelection');\n    var escapeMarkup = this.options.get('escapeMarkup');\n\n    return escapeMarkup(template(data, container));\n  };\n\n  MultipleSelection.prototype.selectionContainer = function () {\n    var $container = $(\n      '<li class=\"select2-selection__choice\">' +\n        '<span class=\"select2-selection__choice__remove\" role=\"presentation\">' +\n          '&times;' +\n        '</span>' +\n      '</li>'\n    );\n\n    return $container;\n  };\n\n  MultipleSelection.prototype.update = function (data) {\n    this.clear();\n\n    if (data.length === 0) {\n      return;\n    }\n\n    var $selections = [];\n\n    for (var d = 0; d < data.length; d++) {\n      var selection = data[d];\n\n      var $selection = this.selectionContainer();\n      var formatted = this.display(selection, $selection);\n\n      $selection.append(formatted);\n\n      var title = selection.title || selection.text;\n\n      if (title) {\n        $selection.attr('title', title);\n      }\n\n      Utils.StoreData($selection[0], 'data', selection);\n\n      $selections.push($selection);\n    }\n\n    var $rendered = this.$selection.find('.select2-selection__rendered');\n\n    Utils.appendMany($rendered, $selections);\n  };\n\n  return MultipleSelection;\n});\n\nS2.define('select2/selection/placeholder',[\n  '../utils'\n], function (Utils) {\n  function Placeholder (decorated, $element, options) {\n    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));\n\n    decorated.call(this, $element, options);\n  }\n\n  Placeholder.prototype.normalizePlaceholder = function (_, placeholder) {\n    if (typeof placeholder === 'string') {\n      placeholder = {\n        id: '',\n        text: placeholder\n      };\n    }\n\n    return placeholder;\n  };\n\n  Placeholder.prototype.createPlaceholder = function (decorated, placeholder) {\n    var $placeholder = this.selectionContainer();\n\n    $placeholder.html(this.display(placeholder));\n    $placeholder.addClass('select2-selection__placeholder')\n                .removeClass('select2-selection__choice');\n\n    return $placeholder;\n  };\n\n  Placeholder.prototype.update = function (decorated, data) {\n    var singlePlaceholder = (\n      data.length == 1 && data[0].id != this.placeholder.id\n    );\n    var multipleSelections = data.length > 1;\n\n    if (multipleSelections || singlePlaceholder) {\n      return decorated.call(this, data);\n    }\n\n    this.clear();\n\n    var $placeholder = this.createPlaceholder(this.placeholder);\n\n    this.$selection.find('.select2-selection__rendered').append($placeholder);\n  };\n\n  return Placeholder;\n});\n\nS2.define('select2/selection/allowClear',[\n  'jquery',\n  '../keys',\n  '../utils'\n], function ($, KEYS, Utils) {\n  function AllowClear () { }\n\n  AllowClear.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    if (this.placeholder == null) {\n      if (this.options.get('debug') && window.console && console.error) {\n        console.error(\n          'Select2: The `allowClear` option should be used in combination ' +\n          'with the `placeholder` option.'\n        );\n      }\n    }\n\n    this.$selection.on('mousedown', '.select2-selection__clear',\n      function (evt) {\n        self._handleClear(evt);\n    });\n\n    container.on('keypress', function (evt) {\n      self._handleKeyboardClear(evt, container);\n    });\n  };\n\n  AllowClear.prototype._handleClear = function (_, evt) {\n    // Ignore the event if it is disabled\n    if (this.isDisabled()) {\n      return;\n    }\n\n    var $clear = this.$selection.find('.select2-selection__clear');\n\n    // Ignore the event if nothing has been selected\n    if ($clear.length === 0) {\n      return;\n    }\n\n    evt.stopPropagation();\n\n    var data = Utils.GetData($clear[0], 'data');\n\n    var previousVal = this.$element.val();\n    this.$element.val(this.placeholder.id);\n\n    var unselectData = {\n      data: data\n    };\n    this.trigger('clear', unselectData);\n    if (unselectData.prevented) {\n      this.$element.val(previousVal);\n      return;\n    }\n\n    for (var d = 0; d < data.length; d++) {\n      unselectData = {\n        data: data[d]\n      };\n\n      // Trigger the `unselect` event, so people can prevent it from being\n      // cleared.\n      this.trigger('unselect', unselectData);\n\n      // If the event was prevented, don't clear it out.\n      if (unselectData.prevented) {\n        this.$element.val(previousVal);\n        return;\n      }\n    }\n\n    this.$element.trigger('input').trigger('change');\n\n    this.trigger('toggle', {});\n  };\n\n  AllowClear.prototype._handleKeyboardClear = function (_, evt, container) {\n    if (container.isOpen()) {\n      return;\n    }\n\n    if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {\n      this._handleClear(evt);\n    }\n  };\n\n  AllowClear.prototype.update = function (decorated, data) {\n    decorated.call(this, data);\n\n    if (this.$selection.find('.select2-selection__placeholder').length > 0 ||\n        data.length === 0) {\n      return;\n    }\n\n    var removeAll = this.options.get('translations').get('removeAllItems');\n\n    var $remove = $(\n      '<span class=\"select2-selection__clear\" title=\"' + removeAll() +'\">' +\n        '&times;' +\n      '</span>'\n    );\n    Utils.StoreData($remove[0], 'data', data);\n\n    this.$selection.find('.select2-selection__rendered').prepend($remove);\n  };\n\n  return AllowClear;\n});\n\nS2.define('select2/selection/search',[\n  'jquery',\n  '../utils',\n  '../keys'\n], function ($, Utils, KEYS) {\n  function Search (decorated, $element, options) {\n    decorated.call(this, $element, options);\n  }\n\n  Search.prototype.render = function (decorated) {\n    var $search = $(\n      '<li class=\"select2-search select2-search--inline\">' +\n        '<input class=\"select2-search__field\" type=\"search\" tabindex=\"-1\"' +\n        ' autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"none\"' +\n        ' spellcheck=\"false\" role=\"searchbox\" aria-autocomplete=\"list\" />' +\n      '</li>'\n    );\n\n    this.$searchContainer = $search;\n    this.$search = $search.find('input');\n\n    var $rendered = decorated.call(this);\n\n    this._transferTabIndex();\n\n    return $rendered;\n  };\n\n  Search.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    var resultsId = container.id + '-results';\n\n    decorated.call(this, container, $container);\n\n    container.on('open', function () {\n      self.$search.attr('aria-controls', resultsId);\n      self.$search.trigger('focus');\n    });\n\n    container.on('close', function () {\n      self.$search.val('');\n      self.$search.removeAttr('aria-controls');\n      self.$search.removeAttr('aria-activedescendant');\n      self.$search.trigger('focus');\n    });\n\n    container.on('enable', function () {\n      self.$search.prop('disabled', false);\n\n      self._transferTabIndex();\n    });\n\n    container.on('disable', function () {\n      self.$search.prop('disabled', true);\n    });\n\n    container.on('focus', function (evt) {\n      self.$search.trigger('focus');\n    });\n\n    container.on('results:focus', function (params) {\n      if (params.data._resultId) {\n        self.$search.attr('aria-activedescendant', params.data._resultId);\n      } else {\n        self.$search.removeAttr('aria-activedescendant');\n      }\n    });\n\n    this.$selection.on('focusin', '.select2-search--inline', function (evt) {\n      self.trigger('focus', evt);\n    });\n\n    this.$selection.on('focusout', '.select2-search--inline', function (evt) {\n      self._handleBlur(evt);\n    });\n\n    this.$selection.on('keydown', '.select2-search--inline', function (evt) {\n      evt.stopPropagation();\n\n      self.trigger('keypress', evt);\n\n      self._keyUpPrevented = evt.isDefaultPrevented();\n\n      var key = evt.which;\n\n      if (key === KEYS.BACKSPACE && self.$search.val() === '') {\n        var $previousChoice = self.$searchContainer\n          .prev('.select2-selection__choice');\n\n        if ($previousChoice.length > 0) {\n          var item = Utils.GetData($previousChoice[0], 'data');\n\n          self.searchRemoveChoice(item);\n\n          evt.preventDefault();\n        }\n      }\n    });\n\n    this.$selection.on('click', '.select2-search--inline', function (evt) {\n      if (self.$search.val()) {\n        evt.stopPropagation();\n      }\n    });\n\n    // Try to detect the IE version should the `documentMode` property that\n    // is stored on the document. This is only implemented in IE and is\n    // slightly cleaner than doing a user agent check.\n    // This property is not available in Edge, but Edge also doesn't have\n    // this bug.\n    var msie = document.documentMode;\n    var disableInputEvents = msie && msie <= 11;\n\n    // Workaround for browsers which do not support the `input` event\n    // This will prevent double-triggering of events for browsers which support\n    // both the `keyup` and `input` events.\n    this.$selection.on(\n      'input.searchcheck',\n      '.select2-search--inline',\n      function (evt) {\n        // IE will trigger the `input` event when a placeholder is used on a\n        // search box. To get around this issue, we are forced to ignore all\n        // `input` events in IE and keep using `keyup`.\n        if (disableInputEvents) {\n          self.$selection.off('input.search input.searchcheck');\n          return;\n        }\n\n        // Unbind the duplicated `keyup` event\n        self.$selection.off('keyup.search');\n      }\n    );\n\n    this.$selection.on(\n      'keyup.search input.search',\n      '.select2-search--inline',\n      function (evt) {\n        // IE will trigger the `input` event when a placeholder is used on a\n        // search box. To get around this issue, we are forced to ignore all\n        // `input` events in IE and keep using `keyup`.\n        if (disableInputEvents && evt.type === 'input') {\n          self.$selection.off('input.search input.searchcheck');\n          return;\n        }\n\n        var key = evt.which;\n\n        // We can freely ignore events from modifier keys\n        if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {\n          return;\n        }\n\n        // Tabbing will be handled during the `keydown` phase\n        if (key == KEYS.TAB) {\n          return;\n        }\n\n        self.handleSearch(evt);\n      }\n    );\n  };\n\n  /**\n   * This method will transfer the tabindex attribute from the rendered\n   * selection to the search box. This allows for the search box to be used as\n   * the primary focus instead of the selection container.\n   *\n   * @private\n   */\n  Search.prototype._transferTabIndex = function (decorated) {\n    this.$search.attr('tabindex', this.$selection.attr('tabindex'));\n    this.$selection.attr('tabindex', '-1');\n  };\n\n  Search.prototype.createPlaceholder = function (decorated, placeholder) {\n    this.$search.attr('placeholder', placeholder.text);\n  };\n\n  Search.prototype.update = function (decorated, data) {\n    var searchHadFocus = this.$search[0] == document.activeElement;\n\n    this.$search.attr('placeholder', '');\n\n    decorated.call(this, data);\n\n    this.$selection.find('.select2-selection__rendered')\n                   .append(this.$searchContainer);\n\n    this.resizeSearch();\n    if (searchHadFocus) {\n      this.$search.trigger('focus');\n    }\n  };\n\n  Search.prototype.handleSearch = function () {\n    this.resizeSearch();\n\n    if (!this._keyUpPrevented) {\n      var input = this.$search.val();\n\n      this.trigger('query', {\n        term: input\n      });\n    }\n\n    this._keyUpPrevented = false;\n  };\n\n  Search.prototype.searchRemoveChoice = function (decorated, item) {\n    this.trigger('unselect', {\n      data: item\n    });\n\n    this.$search.val(item.text);\n    this.handleSearch();\n  };\n\n  Search.prototype.resizeSearch = function () {\n    this.$search.css('width', '25px');\n\n    var width = '';\n\n    if (this.$search.attr('placeholder') !== '') {\n      width = this.$selection.find('.select2-selection__rendered').width();\n    } else {\n      var minimumWidth = this.$search.val().length + 1;\n\n      width = (minimumWidth * 0.75) + 'em';\n    }\n\n    this.$search.css('width', width);\n  };\n\n  return Search;\n});\n\nS2.define('select2/selection/eventRelay',[\n  'jquery'\n], function ($) {\n  function EventRelay () { }\n\n  EventRelay.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n    var relayEvents = [\n      'open', 'opening',\n      'close', 'closing',\n      'select', 'selecting',\n      'unselect', 'unselecting',\n      'clear', 'clearing'\n    ];\n\n    var preventableEvents = [\n      'opening', 'closing', 'selecting', 'unselecting', 'clearing'\n    ];\n\n    decorated.call(this, container, $container);\n\n    container.on('*', function (name, params) {\n      // Ignore events that should not be relayed\n      if ($.inArray(name, relayEvents) === -1) {\n        return;\n      }\n\n      // The parameters should always be an object\n      params = params || {};\n\n      // Generate the jQuery event for the Select2 event\n      var evt = $.Event('select2:' + name, {\n        params: params\n      });\n\n      self.$element.trigger(evt);\n\n      // Only handle preventable events if it was one\n      if ($.inArray(name, preventableEvents) === -1) {\n        return;\n      }\n\n      params.prevented = evt.isDefaultPrevented();\n    });\n  };\n\n  return EventRelay;\n});\n\nS2.define('select2/translation',[\n  'jquery',\n  'require'\n], function ($, require) {\n  function Translation (dict) {\n    this.dict = dict || {};\n  }\n\n  Translation.prototype.all = function () {\n    return this.dict;\n  };\n\n  Translation.prototype.get = function (key) {\n    return this.dict[key];\n  };\n\n  Translation.prototype.extend = function (translation) {\n    this.dict = $.extend({}, translation.all(), this.dict);\n  };\n\n  // Static functions\n\n  Translation._cache = {};\n\n  Translation.loadPath = function (path) {\n    if (!(path in Translation._cache)) {\n      var translations = require(path);\n\n      Translation._cache[path] = translations;\n    }\n\n    return new Translation(Translation._cache[path]);\n  };\n\n  return Translation;\n});\n\nS2.define('select2/diacritics',[\n\n], function () {\n  var diacritics = {\n    '\\u24B6': 'A',\n    '\\uFF21': 'A',\n    '\\u00C0': 'A',\n    '\\u00C1': 'A',\n    '\\u00C2': 'A',\n    '\\u1EA6': 'A',\n    '\\u1EA4': 'A',\n    '\\u1EAA': 'A',\n    '\\u1EA8': 'A',\n    '\\u00C3': 'A',\n    '\\u0100': 'A',\n    '\\u0102': 'A',\n    '\\u1EB0': 'A',\n    '\\u1EAE': 'A',\n    '\\u1EB4': 'A',\n    '\\u1EB2': 'A',\n    '\\u0226': 'A',\n    '\\u01E0': 'A',\n    '\\u00C4': 'A',\n    '\\u01DE': 'A',\n    '\\u1EA2': 'A',\n    '\\u00C5': 'A',\n    '\\u01FA': 'A',\n    '\\u01CD': 'A',\n    '\\u0200': 'A',\n    '\\u0202': 'A',\n    '\\u1EA0': 'A',\n    '\\u1EAC': 'A',\n    '\\u1EB6': 'A',\n    '\\u1E00': 'A',\n    '\\u0104': 'A',\n    '\\u023A': 'A',\n    '\\u2C6F': 'A',\n    '\\uA732': 'AA',\n    '\\u00C6': 'AE',\n    '\\u01FC': 'AE',\n    '\\u01E2': 'AE',\n    '\\uA734': 'AO',\n    '\\uA736': 'AU',\n    '\\uA738': 'AV',\n    '\\uA73A': 'AV',\n    '\\uA73C': 'AY',\n    '\\u24B7': 'B',\n    '\\uFF22': 'B',\n    '\\u1E02': 'B',\n    '\\u1E04': 'B',\n    '\\u1E06': 'B',\n    '\\u0243': 'B',\n    '\\u0182': 'B',\n    '\\u0181': 'B',\n    '\\u24B8': 'C',\n    '\\uFF23': 'C',\n    '\\u0106': 'C',\n    '\\u0108': 'C',\n    '\\u010A': 'C',\n    '\\u010C': 'C',\n    '\\u00C7': 'C',\n    '\\u1E08': 'C',\n    '\\u0187': 'C',\n    '\\u023B': 'C',\n    '\\uA73E': 'C',\n    '\\u24B9': 'D',\n    '\\uFF24': 'D',\n    '\\u1E0A': 'D',\n    '\\u010E': 'D',\n    '\\u1E0C': 'D',\n    '\\u1E10': 'D',\n    '\\u1E12': 'D',\n    '\\u1E0E': 'D',\n    '\\u0110': 'D',\n    '\\u018B': 'D',\n    '\\u018A': 'D',\n    '\\u0189': 'D',\n    '\\uA779': 'D',\n    '\\u01F1': 'DZ',\n    '\\u01C4': 'DZ',\n    '\\u01F2': 'Dz',\n    '\\u01C5': 'Dz',\n    '\\u24BA': 'E',\n    '\\uFF25': 'E',\n    '\\u00C8': 'E',\n    '\\u00C9': 'E',\n    '\\u00CA': 'E',\n    '\\u1EC0': 'E',\n    '\\u1EBE': 'E',\n    '\\u1EC4': 'E',\n    '\\u1EC2': 'E',\n    '\\u1EBC': 'E',\n    '\\u0112': 'E',\n    '\\u1E14': 'E',\n    '\\u1E16': 'E',\n    '\\u0114': 'E',\n    '\\u0116': 'E',\n    '\\u00CB': 'E',\n    '\\u1EBA': 'E',\n    '\\u011A': 'E',\n    '\\u0204': 'E',\n    '\\u0206': 'E',\n    '\\u1EB8': 'E',\n    '\\u1EC6': 'E',\n    '\\u0228': 'E',\n    '\\u1E1C': 'E',\n    '\\u0118': 'E',\n    '\\u1E18': 'E',\n    '\\u1E1A': 'E',\n    '\\u0190': 'E',\n    '\\u018E': 'E',\n    '\\u24BB': 'F',\n    '\\uFF26': 'F',\n    '\\u1E1E': 'F',\n    '\\u0191': 'F',\n    '\\uA77B': 'F',\n    '\\u24BC': 'G',\n    '\\uFF27': 'G',\n    '\\u01F4': 'G',\n    '\\u011C': 'G',\n    '\\u1E20': 'G',\n    '\\u011E': 'G',\n    '\\u0120': 'G',\n    '\\u01E6': 'G',\n    '\\u0122': 'G',\n    '\\u01E4': 'G',\n    '\\u0193': 'G',\n    '\\uA7A0': 'G',\n    '\\uA77D': 'G',\n    '\\uA77E': 'G',\n    '\\u24BD': 'H',\n    '\\uFF28': 'H',\n    '\\u0124': 'H',\n    '\\u1E22': 'H',\n    '\\u1E26': 'H',\n    '\\u021E': 'H',\n    '\\u1E24': 'H',\n    '\\u1E28': 'H',\n    '\\u1E2A': 'H',\n    '\\u0126': 'H',\n    '\\u2C67': 'H',\n    '\\u2C75': 'H',\n    '\\uA78D': 'H',\n    '\\u24BE': 'I',\n    '\\uFF29': 'I',\n    '\\u00CC': 'I',\n    '\\u00CD': 'I',\n    '\\u00CE': 'I',\n    '\\u0128': 'I',\n    '\\u012A': 'I',\n    '\\u012C': 'I',\n    '\\u0130': 'I',\n    '\\u00CF': 'I',\n    '\\u1E2E': 'I',\n    '\\u1EC8': 'I',\n    '\\u01CF': 'I',\n    '\\u0208': 'I',\n    '\\u020A': 'I',\n    '\\u1ECA': 'I',\n    '\\u012E': 'I',\n    '\\u1E2C': 'I',\n    '\\u0197': 'I',\n    '\\u24BF': 'J',\n    '\\uFF2A': 'J',\n    '\\u0134': 'J',\n    '\\u0248': 'J',\n    '\\u24C0': 'K',\n    '\\uFF2B': 'K',\n    '\\u1E30': 'K',\n    '\\u01E8': 'K',\n    '\\u1E32': 'K',\n    '\\u0136': 'K',\n    '\\u1E34': 'K',\n    '\\u0198': 'K',\n    '\\u2C69': 'K',\n    '\\uA740': 'K',\n    '\\uA742': 'K',\n    '\\uA744': 'K',\n    '\\uA7A2': 'K',\n    '\\u24C1': 'L',\n    '\\uFF2C': 'L',\n    '\\u013F': 'L',\n    '\\u0139': 'L',\n    '\\u013D': 'L',\n    '\\u1E36': 'L',\n    '\\u1E38': 'L',\n    '\\u013B': 'L',\n    '\\u1E3C': 'L',\n    '\\u1E3A': 'L',\n    '\\u0141': 'L',\n    '\\u023D': 'L',\n    '\\u2C62': 'L',\n    '\\u2C60': 'L',\n    '\\uA748': 'L',\n    '\\uA746': 'L',\n    '\\uA780': 'L',\n    '\\u01C7': 'LJ',\n    '\\u01C8': 'Lj',\n    '\\u24C2': 'M',\n    '\\uFF2D': 'M',\n    '\\u1E3E': 'M',\n    '\\u1E40': 'M',\n    '\\u1E42': 'M',\n    '\\u2C6E': 'M',\n    '\\u019C': 'M',\n    '\\u24C3': 'N',\n    '\\uFF2E': 'N',\n    '\\u01F8': 'N',\n    '\\u0143': 'N',\n    '\\u00D1': 'N',\n    '\\u1E44': 'N',\n    '\\u0147': 'N',\n    '\\u1E46': 'N',\n    '\\u0145': 'N',\n    '\\u1E4A': 'N',\n    '\\u1E48': 'N',\n    '\\u0220': 'N',\n    '\\u019D': 'N',\n    '\\uA790': 'N',\n    '\\uA7A4': 'N',\n    '\\u01CA': 'NJ',\n    '\\u01CB': 'Nj',\n    '\\u24C4': 'O',\n    '\\uFF2F': 'O',\n    '\\u00D2': 'O',\n    '\\u00D3': 'O',\n    '\\u00D4': 'O',\n    '\\u1ED2': 'O',\n    '\\u1ED0': 'O',\n    '\\u1ED6': 'O',\n    '\\u1ED4': 'O',\n    '\\u00D5': 'O',\n    '\\u1E4C': 'O',\n    '\\u022C': 'O',\n    '\\u1E4E': 'O',\n    '\\u014C': 'O',\n    '\\u1E50': 'O',\n    '\\u1E52': 'O',\n    '\\u014E': 'O',\n    '\\u022E': 'O',\n    '\\u0230': 'O',\n    '\\u00D6': 'O',\n    '\\u022A': 'O',\n    '\\u1ECE': 'O',\n    '\\u0150': 'O',\n    '\\u01D1': 'O',\n    '\\u020C': 'O',\n    '\\u020E': 'O',\n    '\\u01A0': 'O',\n    '\\u1EDC': 'O',\n    '\\u1EDA': 'O',\n    '\\u1EE0': 'O',\n    '\\u1EDE': 'O',\n    '\\u1EE2': 'O',\n    '\\u1ECC': 'O',\n    '\\u1ED8': 'O',\n    '\\u01EA': 'O',\n    '\\u01EC': 'O',\n    '\\u00D8': 'O',\n    '\\u01FE': 'O',\n    '\\u0186': 'O',\n    '\\u019F': 'O',\n    '\\uA74A': 'O',\n    '\\uA74C': 'O',\n    '\\u0152': 'OE',\n    '\\u01A2': 'OI',\n    '\\uA74E': 'OO',\n    '\\u0222': 'OU',\n    '\\u24C5': 'P',\n    '\\uFF30': 'P',\n    '\\u1E54': 'P',\n    '\\u1E56': 'P',\n    '\\u01A4': 'P',\n    '\\u2C63': 'P',\n    '\\uA750': 'P',\n    '\\uA752': 'P',\n    '\\uA754': 'P',\n    '\\u24C6': 'Q',\n    '\\uFF31': 'Q',\n    '\\uA756': 'Q',\n    '\\uA758': 'Q',\n    '\\u024A': 'Q',\n    '\\u24C7': 'R',\n    '\\uFF32': 'R',\n    '\\u0154': 'R',\n    '\\u1E58': 'R',\n    '\\u0158': 'R',\n    '\\u0210': 'R',\n    '\\u0212': 'R',\n    '\\u1E5A': 'R',\n    '\\u1E5C': 'R',\n    '\\u0156': 'R',\n    '\\u1E5E': 'R',\n    '\\u024C': 'R',\n    '\\u2C64': 'R',\n    '\\uA75A': 'R',\n    '\\uA7A6': 'R',\n    '\\uA782': 'R',\n    '\\u24C8': 'S',\n    '\\uFF33': 'S',\n    '\\u1E9E': 'S',\n    '\\u015A': 'S',\n    '\\u1E64': 'S',\n    '\\u015C': 'S',\n    '\\u1E60': 'S',\n    '\\u0160': 'S',\n    '\\u1E66': 'S',\n    '\\u1E62': 'S',\n    '\\u1E68': 'S',\n    '\\u0218': 'S',\n    '\\u015E': 'S',\n    '\\u2C7E': 'S',\n    '\\uA7A8': 'S',\n    '\\uA784': 'S',\n    '\\u24C9': 'T',\n    '\\uFF34': 'T',\n    '\\u1E6A': 'T',\n    '\\u0164': 'T',\n    '\\u1E6C': 'T',\n    '\\u021A': 'T',\n    '\\u0162': 'T',\n    '\\u1E70': 'T',\n    '\\u1E6E': 'T',\n    '\\u0166': 'T',\n    '\\u01AC': 'T',\n    '\\u01AE': 'T',\n    '\\u023E': 'T',\n    '\\uA786': 'T',\n    '\\uA728': 'TZ',\n    '\\u24CA': 'U',\n    '\\uFF35': 'U',\n    '\\u00D9': 'U',\n    '\\u00DA': 'U',\n    '\\u00DB': 'U',\n    '\\u0168': 'U',\n    '\\u1E78': 'U',\n    '\\u016A': 'U',\n    '\\u1E7A': 'U',\n    '\\u016C': 'U',\n    '\\u00DC': 'U',\n    '\\u01DB': 'U',\n    '\\u01D7': 'U',\n    '\\u01D5': 'U',\n    '\\u01D9': 'U',\n    '\\u1EE6': 'U',\n    '\\u016E': 'U',\n    '\\u0170': 'U',\n    '\\u01D3': 'U',\n    '\\u0214': 'U',\n    '\\u0216': 'U',\n    '\\u01AF': 'U',\n    '\\u1EEA': 'U',\n    '\\u1EE8': 'U',\n    '\\u1EEE': 'U',\n    '\\u1EEC': 'U',\n    '\\u1EF0': 'U',\n    '\\u1EE4': 'U',\n    '\\u1E72': 'U',\n    '\\u0172': 'U',\n    '\\u1E76': 'U',\n    '\\u1E74': 'U',\n    '\\u0244': 'U',\n    '\\u24CB': 'V',\n    '\\uFF36': 'V',\n    '\\u1E7C': 'V',\n    '\\u1E7E': 'V',\n    '\\u01B2': 'V',\n    '\\uA75E': 'V',\n    '\\u0245': 'V',\n    '\\uA760': 'VY',\n    '\\u24CC': 'W',\n    '\\uFF37': 'W',\n    '\\u1E80': 'W',\n    '\\u1E82': 'W',\n    '\\u0174': 'W',\n    '\\u1E86': 'W',\n    '\\u1E84': 'W',\n    '\\u1E88': 'W',\n    '\\u2C72': 'W',\n    '\\u24CD': 'X',\n    '\\uFF38': 'X',\n    '\\u1E8A': 'X',\n    '\\u1E8C': 'X',\n    '\\u24CE': 'Y',\n    '\\uFF39': 'Y',\n    '\\u1EF2': 'Y',\n    '\\u00DD': 'Y',\n    '\\u0176': 'Y',\n    '\\u1EF8': 'Y',\n    '\\u0232': 'Y',\n    '\\u1E8E': 'Y',\n    '\\u0178': 'Y',\n    '\\u1EF6': 'Y',\n    '\\u1EF4': 'Y',\n    '\\u01B3': 'Y',\n    '\\u024E': 'Y',\n    '\\u1EFE': 'Y',\n    '\\u24CF': 'Z',\n    '\\uFF3A': 'Z',\n    '\\u0179': 'Z',\n    '\\u1E90': 'Z',\n    '\\u017B': 'Z',\n    '\\u017D': 'Z',\n    '\\u1E92': 'Z',\n    '\\u1E94': 'Z',\n    '\\u01B5': 'Z',\n    '\\u0224': 'Z',\n    '\\u2C7F': 'Z',\n    '\\u2C6B': 'Z',\n    '\\uA762': 'Z',\n    '\\u24D0': 'a',\n    '\\uFF41': 'a',\n    '\\u1E9A': 'a',\n    '\\u00E0': 'a',\n    '\\u00E1': 'a',\n    '\\u00E2': 'a',\n    '\\u1EA7': 'a',\n    '\\u1EA5': 'a',\n    '\\u1EAB': 'a',\n    '\\u1EA9': 'a',\n    '\\u00E3': 'a',\n    '\\u0101': 'a',\n    '\\u0103': 'a',\n    '\\u1EB1': 'a',\n    '\\u1EAF': 'a',\n    '\\u1EB5': 'a',\n    '\\u1EB3': 'a',\n    '\\u0227': 'a',\n    '\\u01E1': 'a',\n    '\\u00E4': 'a',\n    '\\u01DF': 'a',\n    '\\u1EA3': 'a',\n    '\\u00E5': 'a',\n    '\\u01FB': 'a',\n    '\\u01CE': 'a',\n    '\\u0201': 'a',\n    '\\u0203': 'a',\n    '\\u1EA1': 'a',\n    '\\u1EAD': 'a',\n    '\\u1EB7': 'a',\n    '\\u1E01': 'a',\n    '\\u0105': 'a',\n    '\\u2C65': 'a',\n    '\\u0250': 'a',\n    '\\uA733': 'aa',\n    '\\u00E6': 'ae',\n    '\\u01FD': 'ae',\n    '\\u01E3': 'ae',\n    '\\uA735': 'ao',\n    '\\uA737': 'au',\n    '\\uA739': 'av',\n    '\\uA73B': 'av',\n    '\\uA73D': 'ay',\n    '\\u24D1': 'b',\n    '\\uFF42': 'b',\n    '\\u1E03': 'b',\n    '\\u1E05': 'b',\n    '\\u1E07': 'b',\n    '\\u0180': 'b',\n    '\\u0183': 'b',\n    '\\u0253': 'b',\n    '\\u24D2': 'c',\n    '\\uFF43': 'c',\n    '\\u0107': 'c',\n    '\\u0109': 'c',\n    '\\u010B': 'c',\n    '\\u010D': 'c',\n    '\\u00E7': 'c',\n    '\\u1E09': 'c',\n    '\\u0188': 'c',\n    '\\u023C': 'c',\n    '\\uA73F': 'c',\n    '\\u2184': 'c',\n    '\\u24D3': 'd',\n    '\\uFF44': 'd',\n    '\\u1E0B': 'd',\n    '\\u010F': 'd',\n    '\\u1E0D': 'd',\n    '\\u1E11': 'd',\n    '\\u1E13': 'd',\n    '\\u1E0F': 'd',\n    '\\u0111': 'd',\n    '\\u018C': 'd',\n    '\\u0256': 'd',\n    '\\u0257': 'd',\n    '\\uA77A': 'd',\n    '\\u01F3': 'dz',\n    '\\u01C6': 'dz',\n    '\\u24D4': 'e',\n    '\\uFF45': 'e',\n    '\\u00E8': 'e',\n    '\\u00E9': 'e',\n    '\\u00EA': 'e',\n    '\\u1EC1': 'e',\n    '\\u1EBF': 'e',\n    '\\u1EC5': 'e',\n    '\\u1EC3': 'e',\n    '\\u1EBD': 'e',\n    '\\u0113': 'e',\n    '\\u1E15': 'e',\n    '\\u1E17': 'e',\n    '\\u0115': 'e',\n    '\\u0117': 'e',\n    '\\u00EB': 'e',\n    '\\u1EBB': 'e',\n    '\\u011B': 'e',\n    '\\u0205': 'e',\n    '\\u0207': 'e',\n    '\\u1EB9': 'e',\n    '\\u1EC7': 'e',\n    '\\u0229': 'e',\n    '\\u1E1D': 'e',\n    '\\u0119': 'e',\n    '\\u1E19': 'e',\n    '\\u1E1B': 'e',\n    '\\u0247': 'e',\n    '\\u025B': 'e',\n    '\\u01DD': 'e',\n    '\\u24D5': 'f',\n    '\\uFF46': 'f',\n    '\\u1E1F': 'f',\n    '\\u0192': 'f',\n    '\\uA77C': 'f',\n    '\\u24D6': 'g',\n    '\\uFF47': 'g',\n    '\\u01F5': 'g',\n    '\\u011D': 'g',\n    '\\u1E21': 'g',\n    '\\u011F': 'g',\n    '\\u0121': 'g',\n    '\\u01E7': 'g',\n    '\\u0123': 'g',\n    '\\u01E5': 'g',\n    '\\u0260': 'g',\n    '\\uA7A1': 'g',\n    '\\u1D79': 'g',\n    '\\uA77F': 'g',\n    '\\u24D7': 'h',\n    '\\uFF48': 'h',\n    '\\u0125': 'h',\n    '\\u1E23': 'h',\n    '\\u1E27': 'h',\n    '\\u021F': 'h',\n    '\\u1E25': 'h',\n    '\\u1E29': 'h',\n    '\\u1E2B': 'h',\n    '\\u1E96': 'h',\n    '\\u0127': 'h',\n    '\\u2C68': 'h',\n    '\\u2C76': 'h',\n    '\\u0265': 'h',\n    '\\u0195': 'hv',\n    '\\u24D8': 'i',\n    '\\uFF49': 'i',\n    '\\u00EC': 'i',\n    '\\u00ED': 'i',\n    '\\u00EE': 'i',\n    '\\u0129': 'i',\n    '\\u012B': 'i',\n    '\\u012D': 'i',\n    '\\u00EF': 'i',\n    '\\u1E2F': 'i',\n    '\\u1EC9': 'i',\n    '\\u01D0': 'i',\n    '\\u0209': 'i',\n    '\\u020B': 'i',\n    '\\u1ECB': 'i',\n    '\\u012F': 'i',\n    '\\u1E2D': 'i',\n    '\\u0268': 'i',\n    '\\u0131': 'i',\n    '\\u24D9': 'j',\n    '\\uFF4A': 'j',\n    '\\u0135': 'j',\n    '\\u01F0': 'j',\n    '\\u0249': 'j',\n    '\\u24DA': 'k',\n    '\\uFF4B': 'k',\n    '\\u1E31': 'k',\n    '\\u01E9': 'k',\n    '\\u1E33': 'k',\n    '\\u0137': 'k',\n    '\\u1E35': 'k',\n    '\\u0199': 'k',\n    '\\u2C6A': 'k',\n    '\\uA741': 'k',\n    '\\uA743': 'k',\n    '\\uA745': 'k',\n    '\\uA7A3': 'k',\n    '\\u24DB': 'l',\n    '\\uFF4C': 'l',\n    '\\u0140': 'l',\n    '\\u013A': 'l',\n    '\\u013E': 'l',\n    '\\u1E37': 'l',\n    '\\u1E39': 'l',\n    '\\u013C': 'l',\n    '\\u1E3D': 'l',\n    '\\u1E3B': 'l',\n    '\\u017F': 'l',\n    '\\u0142': 'l',\n    '\\u019A': 'l',\n    '\\u026B': 'l',\n    '\\u2C61': 'l',\n    '\\uA749': 'l',\n    '\\uA781': 'l',\n    '\\uA747': 'l',\n    '\\u01C9': 'lj',\n    '\\u24DC': 'm',\n    '\\uFF4D': 'm',\n    '\\u1E3F': 'm',\n    '\\u1E41': 'm',\n    '\\u1E43': 'm',\n    '\\u0271': 'm',\n    '\\u026F': 'm',\n    '\\u24DD': 'n',\n    '\\uFF4E': 'n',\n    '\\u01F9': 'n',\n    '\\u0144': 'n',\n    '\\u00F1': 'n',\n    '\\u1E45': 'n',\n    '\\u0148': 'n',\n    '\\u1E47': 'n',\n    '\\u0146': 'n',\n    '\\u1E4B': 'n',\n    '\\u1E49': 'n',\n    '\\u019E': 'n',\n    '\\u0272': 'n',\n    '\\u0149': 'n',\n    '\\uA791': 'n',\n    '\\uA7A5': 'n',\n    '\\u01CC': 'nj',\n    '\\u24DE': 'o',\n    '\\uFF4F': 'o',\n    '\\u00F2': 'o',\n    '\\u00F3': 'o',\n    '\\u00F4': 'o',\n    '\\u1ED3': 'o',\n    '\\u1ED1': 'o',\n    '\\u1ED7': 'o',\n    '\\u1ED5': 'o',\n    '\\u00F5': 'o',\n    '\\u1E4D': 'o',\n    '\\u022D': 'o',\n    '\\u1E4F': 'o',\n    '\\u014D': 'o',\n    '\\u1E51': 'o',\n    '\\u1E53': 'o',\n    '\\u014F': 'o',\n    '\\u022F': 'o',\n    '\\u0231': 'o',\n    '\\u00F6': 'o',\n    '\\u022B': 'o',\n    '\\u1ECF': 'o',\n    '\\u0151': 'o',\n    '\\u01D2': 'o',\n    '\\u020D': 'o',\n    '\\u020F': 'o',\n    '\\u01A1': 'o',\n    '\\u1EDD': 'o',\n    '\\u1EDB': 'o',\n    '\\u1EE1': 'o',\n    '\\u1EDF': 'o',\n    '\\u1EE3': 'o',\n    '\\u1ECD': 'o',\n    '\\u1ED9': 'o',\n    '\\u01EB': 'o',\n    '\\u01ED': 'o',\n    '\\u00F8': 'o',\n    '\\u01FF': 'o',\n    '\\u0254': 'o',\n    '\\uA74B': 'o',\n    '\\uA74D': 'o',\n    '\\u0275': 'o',\n    '\\u0153': 'oe',\n    '\\u01A3': 'oi',\n    '\\u0223': 'ou',\n    '\\uA74F': 'oo',\n    '\\u24DF': 'p',\n    '\\uFF50': 'p',\n    '\\u1E55': 'p',\n    '\\u1E57': 'p',\n    '\\u01A5': 'p',\n    '\\u1D7D': 'p',\n    '\\uA751': 'p',\n    '\\uA753': 'p',\n    '\\uA755': 'p',\n    '\\u24E0': 'q',\n    '\\uFF51': 'q',\n    '\\u024B': 'q',\n    '\\uA757': 'q',\n    '\\uA759': 'q',\n    '\\u24E1': 'r',\n    '\\uFF52': 'r',\n    '\\u0155': 'r',\n    '\\u1E59': 'r',\n    '\\u0159': 'r',\n    '\\u0211': 'r',\n    '\\u0213': 'r',\n    '\\u1E5B': 'r',\n    '\\u1E5D': 'r',\n    '\\u0157': 'r',\n    '\\u1E5F': 'r',\n    '\\u024D': 'r',\n    '\\u027D': 'r',\n    '\\uA75B': 'r',\n    '\\uA7A7': 'r',\n    '\\uA783': 'r',\n    '\\u24E2': 's',\n    '\\uFF53': 's',\n    '\\u00DF': 's',\n    '\\u015B': 's',\n    '\\u1E65': 's',\n    '\\u015D': 's',\n    '\\u1E61': 's',\n    '\\u0161': 's',\n    '\\u1E67': 's',\n    '\\u1E63': 's',\n    '\\u1E69': 's',\n    '\\u0219': 's',\n    '\\u015F': 's',\n    '\\u023F': 's',\n    '\\uA7A9': 's',\n    '\\uA785': 's',\n    '\\u1E9B': 's',\n    '\\u24E3': 't',\n    '\\uFF54': 't',\n    '\\u1E6B': 't',\n    '\\u1E97': 't',\n    '\\u0165': 't',\n    '\\u1E6D': 't',\n    '\\u021B': 't',\n    '\\u0163': 't',\n    '\\u1E71': 't',\n    '\\u1E6F': 't',\n    '\\u0167': 't',\n    '\\u01AD': 't',\n    '\\u0288': 't',\n    '\\u2C66': 't',\n    '\\uA787': 't',\n    '\\uA729': 'tz',\n    '\\u24E4': 'u',\n    '\\uFF55': 'u',\n    '\\u00F9': 'u',\n    '\\u00FA': 'u',\n    '\\u00FB': 'u',\n    '\\u0169': 'u',\n    '\\u1E79': 'u',\n    '\\u016B': 'u',\n    '\\u1E7B': 'u',\n    '\\u016D': 'u',\n    '\\u00FC': 'u',\n    '\\u01DC': 'u',\n    '\\u01D8': 'u',\n    '\\u01D6': 'u',\n    '\\u01DA': 'u',\n    '\\u1EE7': 'u',\n    '\\u016F': 'u',\n    '\\u0171': 'u',\n    '\\u01D4': 'u',\n    '\\u0215': 'u',\n    '\\u0217': 'u',\n    '\\u01B0': 'u',\n    '\\u1EEB': 'u',\n    '\\u1EE9': 'u',\n    '\\u1EEF': 'u',\n    '\\u1EED': 'u',\n    '\\u1EF1': 'u',\n    '\\u1EE5': 'u',\n    '\\u1E73': 'u',\n    '\\u0173': 'u',\n    '\\u1E77': 'u',\n    '\\u1E75': 'u',\n    '\\u0289': 'u',\n    '\\u24E5': 'v',\n    '\\uFF56': 'v',\n    '\\u1E7D': 'v',\n    '\\u1E7F': 'v',\n    '\\u028B': 'v',\n    '\\uA75F': 'v',\n    '\\u028C': 'v',\n    '\\uA761': 'vy',\n    '\\u24E6': 'w',\n    '\\uFF57': 'w',\n    '\\u1E81': 'w',\n    '\\u1E83': 'w',\n    '\\u0175': 'w',\n    '\\u1E87': 'w',\n    '\\u1E85': 'w',\n    '\\u1E98': 'w',\n    '\\u1E89': 'w',\n    '\\u2C73': 'w',\n    '\\u24E7': 'x',\n    '\\uFF58': 'x',\n    '\\u1E8B': 'x',\n    '\\u1E8D': 'x',\n    '\\u24E8': 'y',\n    '\\uFF59': 'y',\n    '\\u1EF3': 'y',\n    '\\u00FD': 'y',\n    '\\u0177': 'y',\n    '\\u1EF9': 'y',\n    '\\u0233': 'y',\n    '\\u1E8F': 'y',\n    '\\u00FF': 'y',\n    '\\u1EF7': 'y',\n    '\\u1E99': 'y',\n    '\\u1EF5': 'y',\n    '\\u01B4': 'y',\n    '\\u024F': 'y',\n    '\\u1EFF': 'y',\n    '\\u24E9': 'z',\n    '\\uFF5A': 'z',\n    '\\u017A': 'z',\n    '\\u1E91': 'z',\n    '\\u017C': 'z',\n    '\\u017E': 'z',\n    '\\u1E93': 'z',\n    '\\u1E95': 'z',\n    '\\u01B6': 'z',\n    '\\u0225': 'z',\n    '\\u0240': 'z',\n    '\\u2C6C': 'z',\n    '\\uA763': 'z',\n    '\\u0386': '\\u0391',\n    '\\u0388': '\\u0395',\n    '\\u0389': '\\u0397',\n    '\\u038A': '\\u0399',\n    '\\u03AA': '\\u0399',\n    '\\u038C': '\\u039F',\n    '\\u038E': '\\u03A5',\n    '\\u03AB': '\\u03A5',\n    '\\u038F': '\\u03A9',\n    '\\u03AC': '\\u03B1',\n    '\\u03AD': '\\u03B5',\n    '\\u03AE': '\\u03B7',\n    '\\u03AF': '\\u03B9',\n    '\\u03CA': '\\u03B9',\n    '\\u0390': '\\u03B9',\n    '\\u03CC': '\\u03BF',\n    '\\u03CD': '\\u03C5',\n    '\\u03CB': '\\u03C5',\n    '\\u03B0': '\\u03C5',\n    '\\u03CE': '\\u03C9',\n    '\\u03C2': '\\u03C3',\n    '\\u2019': '\\''\n  };\n\n  return diacritics;\n});\n\nS2.define('select2/data/base',[\n  '../utils'\n], function (Utils) {\n  function BaseAdapter ($element, options) {\n    BaseAdapter.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(BaseAdapter, Utils.Observable);\n\n  BaseAdapter.prototype.current = function (callback) {\n    throw new Error('The `current` method must be defined in child classes.');\n  };\n\n  BaseAdapter.prototype.query = function (params, callback) {\n    throw new Error('The `query` method must be defined in child classes.');\n  };\n\n  BaseAdapter.prototype.bind = function (container, $container) {\n    // Can be implemented in subclasses\n  };\n\n  BaseAdapter.prototype.destroy = function () {\n    // Can be implemented in subclasses\n  };\n\n  BaseAdapter.prototype.generateResultId = function (container, data) {\n    var id = container.id + '-result-';\n\n    id += Utils.generateChars(4);\n\n    if (data.id != null) {\n      id += '-' + data.id.toString();\n    } else {\n      id += '-' + Utils.generateChars(4);\n    }\n    return id;\n  };\n\n  return BaseAdapter;\n});\n\nS2.define('select2/data/select',[\n  './base',\n  '../utils',\n  'jquery'\n], function (BaseAdapter, Utils, $) {\n  function SelectAdapter ($element, options) {\n    this.$element = $element;\n    this.options = options;\n\n    SelectAdapter.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(SelectAdapter, BaseAdapter);\n\n  SelectAdapter.prototype.current = function (callback) {\n    var data = [];\n    var self = this;\n\n    this.$element.find(':selected').each(function () {\n      var $option = $(this);\n\n      var option = self.item($option);\n\n      data.push(option);\n    });\n\n    callback(data);\n  };\n\n  SelectAdapter.prototype.select = function (data) {\n    var self = this;\n\n    data.selected = true;\n\n    // If data.element is a DOM node, use it instead\n    if ($(data.element).is('option')) {\n      data.element.selected = true;\n\n      this.$element.trigger('input').trigger('change');\n\n      return;\n    }\n\n    if (this.$element.prop('multiple')) {\n      this.current(function (currentData) {\n        var val = [];\n\n        data = [data];\n        data.push.apply(data, currentData);\n\n        for (var d = 0; d < data.length; d++) {\n          var id = data[d].id;\n\n          if ($.inArray(id, val) === -1) {\n            val.push(id);\n          }\n        }\n\n        self.$element.val(val);\n        self.$element.trigger('input').trigger('change');\n      });\n    } else {\n      var val = data.id;\n\n      this.$element.val(val);\n      this.$element.trigger('input').trigger('change');\n    }\n  };\n\n  SelectAdapter.prototype.unselect = function (data) {\n    var self = this;\n\n    if (!this.$element.prop('multiple')) {\n      return;\n    }\n\n    data.selected = false;\n\n    if ($(data.element).is('option')) {\n      data.element.selected = false;\n\n      this.$element.trigger('input').trigger('change');\n\n      return;\n    }\n\n    this.current(function (currentData) {\n      var val = [];\n\n      for (var d = 0; d < currentData.length; d++) {\n        var id = currentData[d].id;\n\n        if (id !== data.id && $.inArray(id, val) === -1) {\n          val.push(id);\n        }\n      }\n\n      self.$element.val(val);\n\n      self.$element.trigger('input').trigger('change');\n    });\n  };\n\n  SelectAdapter.prototype.bind = function (container, $container) {\n    var self = this;\n\n    this.container = container;\n\n    container.on('select', function (params) {\n      self.select(params.data);\n    });\n\n    container.on('unselect', function (params) {\n      self.unselect(params.data);\n    });\n  };\n\n  SelectAdapter.prototype.destroy = function () {\n    // Remove anything added to child elements\n    this.$element.find('*').each(function () {\n      // Remove any custom data set by Select2\n      Utils.RemoveData(this);\n    });\n  };\n\n  SelectAdapter.prototype.query = function (params, callback) {\n    var data = [];\n    var self = this;\n\n    var $options = this.$element.children();\n\n    $options.each(function () {\n      var $option = $(this);\n\n      if (!$option.is('option') && !$option.is('optgroup')) {\n        return;\n      }\n\n      var option = self.item($option);\n\n      var matches = self.matches(params, option);\n\n      if (matches !== null) {\n        data.push(matches);\n      }\n    });\n\n    callback({\n      results: data\n    });\n  };\n\n  SelectAdapter.prototype.addOptions = function ($options) {\n    Utils.appendMany(this.$element, $options);\n  };\n\n  SelectAdapter.prototype.option = function (data) {\n    var option;\n\n    if (data.children) {\n      option = document.createElement('optgroup');\n      option.label = data.text;\n    } else {\n      option = document.createElement('option');\n\n      if (option.textContent !== undefined) {\n        option.textContent = data.text;\n      } else {\n        option.innerText = data.text;\n      }\n    }\n\n    if (data.id !== undefined) {\n      option.value = data.id;\n    }\n\n    if (data.disabled) {\n      option.disabled = true;\n    }\n\n    if (data.selected) {\n      option.selected = true;\n    }\n\n    if (data.title) {\n      option.title = data.title;\n    }\n\n    var $option = $(option);\n\n    var normalizedData = this._normalizeItem(data);\n    normalizedData.element = option;\n\n    // Override the option's data with the combined data\n    Utils.StoreData(option, 'data', normalizedData);\n\n    return $option;\n  };\n\n  SelectAdapter.prototype.item = function ($option) {\n    var data = {};\n\n    data = Utils.GetData($option[0], 'data');\n\n    if (data != null) {\n      return data;\n    }\n\n    if ($option.is('option')) {\n      data = {\n        id: $option.val(),\n        text: $option.text(),\n        disabled: $option.prop('disabled'),\n        selected: $option.prop('selected'),\n        title: $option.prop('title')\n      };\n    } else if ($option.is('optgroup')) {\n      data = {\n        text: $option.prop('label'),\n        children: [],\n        title: $option.prop('title')\n      };\n\n      var $children = $option.children('option');\n      var children = [];\n\n      for (var c = 0; c < $children.length; c++) {\n        var $child = $($children[c]);\n\n        var child = this.item($child);\n\n        children.push(child);\n      }\n\n      data.children = children;\n    }\n\n    data = this._normalizeItem(data);\n    data.element = $option[0];\n\n    Utils.StoreData($option[0], 'data', data);\n\n    return data;\n  };\n\n  SelectAdapter.prototype._normalizeItem = function (item) {\n    if (item !== Object(item)) {\n      item = {\n        id: item,\n        text: item\n      };\n    }\n\n    item = $.extend({}, {\n      text: ''\n    }, item);\n\n    var defaults = {\n      selected: false,\n      disabled: false\n    };\n\n    if (item.id != null) {\n      item.id = item.id.toString();\n    }\n\n    if (item.text != null) {\n      item.text = item.text.toString();\n    }\n\n    if (item._resultId == null && item.id && this.container != null) {\n      item._resultId = this.generateResultId(this.container, item);\n    }\n\n    return $.extend({}, defaults, item);\n  };\n\n  SelectAdapter.prototype.matches = function (params, data) {\n    var matcher = this.options.get('matcher');\n\n    return matcher(params, data);\n  };\n\n  return SelectAdapter;\n});\n\nS2.define('select2/data/array',[\n  './select',\n  '../utils',\n  'jquery'\n], function (SelectAdapter, Utils, $) {\n  function ArrayAdapter ($element, options) {\n    this._dataToConvert = options.get('data') || [];\n\n    ArrayAdapter.__super__.constructor.call(this, $element, options);\n  }\n\n  Utils.Extend(ArrayAdapter, SelectAdapter);\n\n  ArrayAdapter.prototype.bind = function (container, $container) {\n    ArrayAdapter.__super__.bind.call(this, container, $container);\n\n    this.addOptions(this.convertToOptions(this._dataToConvert));\n  };\n\n  ArrayAdapter.prototype.select = function (data) {\n    var $option = this.$element.find('option').filter(function (i, elm) {\n      return elm.value == data.id.toString();\n    });\n\n    if ($option.length === 0) {\n      $option = this.option(data);\n\n      this.addOptions($option);\n    }\n\n    ArrayAdapter.__super__.select.call(this, data);\n  };\n\n  ArrayAdapter.prototype.convertToOptions = function (data) {\n    var self = this;\n\n    var $existing = this.$element.find('option');\n    var existingIds = $existing.map(function () {\n      return self.item($(this)).id;\n    }).get();\n\n    var $options = [];\n\n    // Filter out all items except for the one passed in the argument\n    function onlyItem (item) {\n      return function () {\n        return $(this).val() == item.id;\n      };\n    }\n\n    for (var d = 0; d < data.length; d++) {\n      var item = this._normalizeItem(data[d]);\n\n      // Skip items which were pre-loaded, only merge the data\n      if ($.inArray(item.id, existingIds) >= 0) {\n        var $existingOption = $existing.filter(onlyItem(item));\n\n        var existingData = this.item($existingOption);\n        var newData = $.extend(true, {}, item, existingData);\n\n        var $newOption = this.option(newData);\n\n        $existingOption.replaceWith($newOption);\n\n        continue;\n      }\n\n      var $option = this.option(item);\n\n      if (item.children) {\n        var $children = this.convertToOptions(item.children);\n\n        Utils.appendMany($option, $children);\n      }\n\n      $options.push($option);\n    }\n\n    return $options;\n  };\n\n  return ArrayAdapter;\n});\n\nS2.define('select2/data/ajax',[\n  './array',\n  '../utils',\n  'jquery'\n], function (ArrayAdapter, Utils, $) {\n  function AjaxAdapter ($element, options) {\n    this.ajaxOptions = this._applyDefaults(options.get('ajax'));\n\n    if (this.ajaxOptions.processResults != null) {\n      this.processResults = this.ajaxOptions.processResults;\n    }\n\n    AjaxAdapter.__super__.constructor.call(this, $element, options);\n  }\n\n  Utils.Extend(AjaxAdapter, ArrayAdapter);\n\n  AjaxAdapter.prototype._applyDefaults = function (options) {\n    var defaults = {\n      data: function (params) {\n        return $.extend({}, params, {\n          q: params.term\n        });\n      },\n      transport: function (params, success, failure) {\n        var $request = $.ajax(params);\n\n        $request.then(success);\n        $request.fail(failure);\n\n        return $request;\n      }\n    };\n\n    return $.extend({}, defaults, options, true);\n  };\n\n  AjaxAdapter.prototype.processResults = function (results) {\n    return results;\n  };\n\n  AjaxAdapter.prototype.query = function (params, callback) {\n    var matches = [];\n    var self = this;\n\n    if (this._request != null) {\n      // JSONP requests cannot always be aborted\n      if ($.isFunction(this._request.abort)) {\n        this._request.abort();\n      }\n\n      this._request = null;\n    }\n\n    var options = $.extend({\n      type: 'GET'\n    }, this.ajaxOptions);\n\n    if (typeof options.url === 'function') {\n      options.url = options.url.call(this.$element, params);\n    }\n\n    if (typeof options.data === 'function') {\n      options.data = options.data.call(this.$element, params);\n    }\n\n    function request () {\n      var $request = options.transport(options, function (data) {\n        var results = self.processResults(data, params);\n\n        if (self.options.get('debug') && window.console && console.error) {\n          // Check to make sure that the response included a `results` key.\n          if (!results || !results.results || !$.isArray(results.results)) {\n            console.error(\n              'Select2: The AJAX results did not return an array in the ' +\n              '`results` key of the response.'\n            );\n          }\n        }\n\n        callback(results);\n      }, function () {\n        // Attempt to detect if a request was aborted\n        // Only works if the transport exposes a status property\n        if ('status' in $request &&\n            ($request.status === 0 || $request.status === '0')) {\n          return;\n        }\n\n        self.trigger('results:message', {\n          message: 'errorLoading'\n        });\n      });\n\n      self._request = $request;\n    }\n\n    if (this.ajaxOptions.delay && params.term != null) {\n      if (this._queryTimeout) {\n        window.clearTimeout(this._queryTimeout);\n      }\n\n      this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);\n    } else {\n      request();\n    }\n  };\n\n  return AjaxAdapter;\n});\n\nS2.define('select2/data/tags',[\n  'jquery'\n], function ($) {\n  function Tags (decorated, $element, options) {\n    var tags = options.get('tags');\n\n    var createTag = options.get('createTag');\n\n    if (createTag !== undefined) {\n      this.createTag = createTag;\n    }\n\n    var insertTag = options.get('insertTag');\n\n    if (insertTag !== undefined) {\n        this.insertTag = insertTag;\n    }\n\n    decorated.call(this, $element, options);\n\n    if ($.isArray(tags)) {\n      for (var t = 0; t < tags.length; t++) {\n        var tag = tags[t];\n        var item = this._normalizeItem(tag);\n\n        var $option = this.option(item);\n\n        this.$element.append($option);\n      }\n    }\n  }\n\n  Tags.prototype.query = function (decorated, params, callback) {\n    var self = this;\n\n    this._removeOldTags();\n\n    if (params.term == null || params.page != null) {\n      decorated.call(this, params, callback);\n      return;\n    }\n\n    function wrapper (obj, child) {\n      var data = obj.results;\n\n      for (var i = 0; i < data.length; i++) {\n        var option = data[i];\n\n        var checkChildren = (\n          option.children != null &&\n          !wrapper({\n            results: option.children\n          }, true)\n        );\n\n        var optionText = (option.text || '').toUpperCase();\n        var paramsTerm = (params.term || '').toUpperCase();\n\n        var checkText = optionText === paramsTerm;\n\n        if (checkText || checkChildren) {\n          if (child) {\n            return false;\n          }\n\n          obj.data = data;\n          callback(obj);\n\n          return;\n        }\n      }\n\n      if (child) {\n        return true;\n      }\n\n      var tag = self.createTag(params);\n\n      if (tag != null) {\n        var $option = self.option(tag);\n        $option.attr('data-select2-tag', true);\n\n        self.addOptions([$option]);\n\n        self.insertTag(data, tag);\n      }\n\n      obj.results = data;\n\n      callback(obj);\n    }\n\n    decorated.call(this, params, wrapper);\n  };\n\n  Tags.prototype.createTag = function (decorated, params) {\n    var term = $.trim(params.term);\n\n    if (term === '') {\n      return null;\n    }\n\n    return {\n      id: term,\n      text: term\n    };\n  };\n\n  Tags.prototype.insertTag = function (_, data, tag) {\n    data.unshift(tag);\n  };\n\n  Tags.prototype._removeOldTags = function (_) {\n    var $options = this.$element.find('option[data-select2-tag]');\n\n    $options.each(function () {\n      if (this.selected) {\n        return;\n      }\n\n      $(this).remove();\n    });\n  };\n\n  return Tags;\n});\n\nS2.define('select2/data/tokenizer',[\n  'jquery'\n], function ($) {\n  function Tokenizer (decorated, $element, options) {\n    var tokenizer = options.get('tokenizer');\n\n    if (tokenizer !== undefined) {\n      this.tokenizer = tokenizer;\n    }\n\n    decorated.call(this, $element, options);\n  }\n\n  Tokenizer.prototype.bind = function (decorated, container, $container) {\n    decorated.call(this, container, $container);\n\n    this.$search =  container.dropdown.$search || container.selection.$search ||\n      $container.find('.select2-search__field');\n  };\n\n  Tokenizer.prototype.query = function (decorated, params, callback) {\n    var self = this;\n\n    function createAndSelect (data) {\n      // Normalize the data object so we can use it for checks\n      var item = self._normalizeItem(data);\n\n      // Check if the data object already exists as a tag\n      // Select it if it doesn't\n      var $existingOptions = self.$element.find('option').filter(function () {\n        return $(this).val() === item.id;\n      });\n\n      // If an existing option wasn't found for it, create the option\n      if (!$existingOptions.length) {\n        var $option = self.option(item);\n        $option.attr('data-select2-tag', true);\n\n        self._removeOldTags();\n        self.addOptions([$option]);\n      }\n\n      // Select the item, now that we know there is an option for it\n      select(item);\n    }\n\n    function select (data) {\n      self.trigger('select', {\n        data: data\n      });\n    }\n\n    params.term = params.term || '';\n\n    var tokenData = this.tokenizer(params, this.options, createAndSelect);\n\n    if (tokenData.term !== params.term) {\n      // Replace the search term if we have the search box\n      if (this.$search.length) {\n        this.$search.val(tokenData.term);\n        this.$search.trigger('focus');\n      }\n\n      params.term = tokenData.term;\n    }\n\n    decorated.call(this, params, callback);\n  };\n\n  Tokenizer.prototype.tokenizer = function (_, params, options, callback) {\n    var separators = options.get('tokenSeparators') || [];\n    var term = params.term;\n    var i = 0;\n\n    var createTag = this.createTag || function (params) {\n      return {\n        id: params.term,\n        text: params.term\n      };\n    };\n\n    while (i < term.length) {\n      var termChar = term[i];\n\n      if ($.inArray(termChar, separators) === -1) {\n        i++;\n\n        continue;\n      }\n\n      var part = term.substr(0, i);\n      var partParams = $.extend({}, params, {\n        term: part\n      });\n\n      var data = createTag(partParams);\n\n      if (data == null) {\n        i++;\n        continue;\n      }\n\n      callback(data);\n\n      // Reset the term to not include the tokenized portion\n      term = term.substr(i + 1) || '';\n      i = 0;\n    }\n\n    return {\n      term: term\n    };\n  };\n\n  return Tokenizer;\n});\n\nS2.define('select2/data/minimumInputLength',[\n\n], function () {\n  function MinimumInputLength (decorated, $e, options) {\n    this.minimumInputLength = options.get('minimumInputLength');\n\n    decorated.call(this, $e, options);\n  }\n\n  MinimumInputLength.prototype.query = function (decorated, params, callback) {\n    params.term = params.term || '';\n\n    if (params.term.length < this.minimumInputLength) {\n      this.trigger('results:message', {\n        message: 'inputTooShort',\n        args: {\n          minimum: this.minimumInputLength,\n          input: params.term,\n          params: params\n        }\n      });\n\n      return;\n    }\n\n    decorated.call(this, params, callback);\n  };\n\n  return MinimumInputLength;\n});\n\nS2.define('select2/data/maximumInputLength',[\n\n], function () {\n  function MaximumInputLength (decorated, $e, options) {\n    this.maximumInputLength = options.get('maximumInputLength');\n\n    decorated.call(this, $e, options);\n  }\n\n  MaximumInputLength.prototype.query = function (decorated, params, callback) {\n    params.term = params.term || '';\n\n    if (this.maximumInputLength > 0 &&\n        params.term.length > this.maximumInputLength) {\n      this.trigger('results:message', {\n        message: 'inputTooLong',\n        args: {\n          maximum: this.maximumInputLength,\n          input: params.term,\n          params: params\n        }\n      });\n\n      return;\n    }\n\n    decorated.call(this, params, callback);\n  };\n\n  return MaximumInputLength;\n});\n\nS2.define('select2/data/maximumSelectionLength',[\n\n], function (){\n  function MaximumSelectionLength (decorated, $e, options) {\n    this.maximumSelectionLength = options.get('maximumSelectionLength');\n\n    decorated.call(this, $e, options);\n  }\n\n  MaximumSelectionLength.prototype.bind =\n    function (decorated, container, $container) {\n      var self = this;\n\n      decorated.call(this, container, $container);\n\n      container.on('select', function () {\n        self._checkIfMaximumSelected();\n      });\n  };\n\n  MaximumSelectionLength.prototype.query =\n    function (decorated, params, callback) {\n      var self = this;\n\n      this._checkIfMaximumSelected(function () {\n        decorated.call(self, params, callback);\n      });\n  };\n\n  MaximumSelectionLength.prototype._checkIfMaximumSelected =\n    function (_, successCallback) {\n      var self = this;\n\n      this.current(function (currentData) {\n        var count = currentData != null ? currentData.length : 0;\n        if (self.maximumSelectionLength > 0 &&\n          count >= self.maximumSelectionLength) {\n          self.trigger('results:message', {\n            message: 'maximumSelected',\n            args: {\n              maximum: self.maximumSelectionLength\n            }\n          });\n          return;\n        }\n\n        if (successCallback) {\n          successCallback();\n        }\n      });\n  };\n\n  return MaximumSelectionLength;\n});\n\nS2.define('select2/dropdown',[\n  'jquery',\n  './utils'\n], function ($, Utils) {\n  function Dropdown ($element, options) {\n    this.$element = $element;\n    this.options = options;\n\n    Dropdown.__super__.constructor.call(this);\n  }\n\n  Utils.Extend(Dropdown, Utils.Observable);\n\n  Dropdown.prototype.render = function () {\n    var $dropdown = $(\n      '<span class=\"select2-dropdown\">' +\n        '<span class=\"select2-results\"></span>' +\n      '</span>'\n    );\n\n    $dropdown.attr('dir', this.options.get('dir'));\n\n    this.$dropdown = $dropdown;\n\n    return $dropdown;\n  };\n\n  Dropdown.prototype.bind = function () {\n    // Should be implemented in subclasses\n  };\n\n  Dropdown.prototype.position = function ($dropdown, $container) {\n    // Should be implemented in subclasses\n  };\n\n  Dropdown.prototype.destroy = function () {\n    // Remove the dropdown from the DOM\n    this.$dropdown.remove();\n  };\n\n  return Dropdown;\n});\n\nS2.define('select2/dropdown/search',[\n  'jquery',\n  '../utils'\n], function ($, Utils) {\n  function Search () { }\n\n  Search.prototype.render = function (decorated) {\n    var $rendered = decorated.call(this);\n\n    var $search = $(\n      '<span class=\"select2-search select2-search--dropdown\">' +\n        '<input class=\"select2-search__field\" type=\"search\" tabindex=\"-1\"' +\n        ' autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"none\"' +\n        ' spellcheck=\"false\" role=\"searchbox\" aria-autocomplete=\"list\" />' +\n      '</span>'\n    );\n\n    this.$searchContainer = $search;\n    this.$search = $search.find('input');\n\n    $rendered.prepend($search);\n\n    return $rendered;\n  };\n\n  Search.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    var resultsId = container.id + '-results';\n\n    decorated.call(this, container, $container);\n\n    this.$search.on('keydown', function (evt) {\n      self.trigger('keypress', evt);\n\n      self._keyUpPrevented = evt.isDefaultPrevented();\n    });\n\n    // Workaround for browsers which do not support the `input` event\n    // This will prevent double-triggering of events for browsers which support\n    // both the `keyup` and `input` events.\n    this.$search.on('input', function (evt) {\n      // Unbind the duplicated `keyup` event\n      $(this).off('keyup');\n    });\n\n    this.$search.on('keyup input', function (evt) {\n      self.handleSearch(evt);\n    });\n\n    container.on('open', function () {\n      self.$search.attr('tabindex', 0);\n      self.$search.attr('aria-controls', resultsId);\n\n      self.$search.trigger('focus');\n\n      window.setTimeout(function () {\n        self.$search.trigger('focus');\n      }, 0);\n    });\n\n    container.on('close', function () {\n      self.$search.attr('tabindex', -1);\n      self.$search.removeAttr('aria-controls');\n      self.$search.removeAttr('aria-activedescendant');\n\n      self.$search.val('');\n      self.$search.trigger('blur');\n    });\n\n    container.on('focus', function () {\n      if (!container.isOpen()) {\n        self.$search.trigger('focus');\n      }\n    });\n\n    container.on('results:all', function (params) {\n      if (params.query.term == null || params.query.term === '') {\n        var showSearch = self.showSearch(params);\n\n        if (showSearch) {\n          self.$searchContainer.removeClass('select2-search--hide');\n        } else {\n          self.$searchContainer.addClass('select2-search--hide');\n        }\n      }\n    });\n\n    container.on('results:focus', function (params) {\n      if (params.data._resultId) {\n        self.$search.attr('aria-activedescendant', params.data._resultId);\n      } else {\n        self.$search.removeAttr('aria-activedescendant');\n      }\n    });\n  };\n\n  Search.prototype.handleSearch = function (evt) {\n    if (!this._keyUpPrevented) {\n      var input = this.$search.val();\n\n      this.trigger('query', {\n        term: input\n      });\n    }\n\n    this._keyUpPrevented = false;\n  };\n\n  Search.prototype.showSearch = function (_, params) {\n    return true;\n  };\n\n  return Search;\n});\n\nS2.define('select2/dropdown/hidePlaceholder',[\n\n], function () {\n  function HidePlaceholder (decorated, $element, options, dataAdapter) {\n    this.placeholder = this.normalizePlaceholder(options.get('placeholder'));\n\n    decorated.call(this, $element, options, dataAdapter);\n  }\n\n  HidePlaceholder.prototype.append = function (decorated, data) {\n    data.results = this.removePlaceholder(data.results);\n\n    decorated.call(this, data);\n  };\n\n  HidePlaceholder.prototype.normalizePlaceholder = function (_, placeholder) {\n    if (typeof placeholder === 'string') {\n      placeholder = {\n        id: '',\n        text: placeholder\n      };\n    }\n\n    return placeholder;\n  };\n\n  HidePlaceholder.prototype.removePlaceholder = function (_, data) {\n    var modifiedData = data.slice(0);\n\n    for (var d = data.length - 1; d >= 0; d--) {\n      var item = data[d];\n\n      if (this.placeholder.id === item.id) {\n        modifiedData.splice(d, 1);\n      }\n    }\n\n    return modifiedData;\n  };\n\n  return HidePlaceholder;\n});\n\nS2.define('select2/dropdown/infiniteScroll',[\n  'jquery'\n], function ($) {\n  function InfiniteScroll (decorated, $element, options, dataAdapter) {\n    this.lastParams = {};\n\n    decorated.call(this, $element, options, dataAdapter);\n\n    this.$loadingMore = this.createLoadingMore();\n    this.loading = false;\n  }\n\n  InfiniteScroll.prototype.append = function (decorated, data) {\n    this.$loadingMore.remove();\n    this.loading = false;\n\n    decorated.call(this, data);\n\n    if (this.showLoadingMore(data)) {\n      this.$results.append(this.$loadingMore);\n      this.loadMoreIfNeeded();\n    }\n  };\n\n  InfiniteScroll.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('query', function (params) {\n      self.lastParams = params;\n      self.loading = true;\n    });\n\n    container.on('query:append', function (params) {\n      self.lastParams = params;\n      self.loading = true;\n    });\n\n    this.$results.on('scroll', this.loadMoreIfNeeded.bind(this));\n  };\n\n  InfiniteScroll.prototype.loadMoreIfNeeded = function () {\n    var isLoadMoreVisible = $.contains(\n      document.documentElement,\n      this.$loadingMore[0]\n    );\n\n    if (this.loading || !isLoadMoreVisible) {\n      return;\n    }\n\n    var currentOffset = this.$results.offset().top +\n      this.$results.outerHeight(false);\n    var loadingMoreOffset = this.$loadingMore.offset().top +\n      this.$loadingMore.outerHeight(false);\n\n    if (currentOffset + 50 >= loadingMoreOffset) {\n      this.loadMore();\n    }\n  };\n\n  InfiniteScroll.prototype.loadMore = function () {\n    this.loading = true;\n\n    var params = $.extend({}, {page: 1}, this.lastParams);\n\n    params.page++;\n\n    this.trigger('query:append', params);\n  };\n\n  InfiniteScroll.prototype.showLoadingMore = function (_, data) {\n    return data.pagination && data.pagination.more;\n  };\n\n  InfiniteScroll.prototype.createLoadingMore = function () {\n    var $option = $(\n      '<li ' +\n      'class=\"select2-results__option select2-results__option--load-more\"' +\n      'role=\"option\" aria-disabled=\"true\"></li>'\n    );\n\n    var message = this.options.get('translations').get('loadingMore');\n\n    $option.html(message(this.lastParams));\n\n    return $option;\n  };\n\n  return InfiniteScroll;\n});\n\nS2.define('select2/dropdown/attachBody',[\n  'jquery',\n  '../utils'\n], function ($, Utils) {\n  function AttachBody (decorated, $element, options) {\n    this.$dropdownParent = $(options.get('dropdownParent') || document.body);\n\n    decorated.call(this, $element, options);\n  }\n\n  AttachBody.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('open', function () {\n      self._showDropdown();\n      self._attachPositioningHandler(container);\n\n      // Must bind after the results handlers to ensure correct sizing\n      self._bindContainerResultHandlers(container);\n    });\n\n    container.on('close', function () {\n      self._hideDropdown();\n      self._detachPositioningHandler(container);\n    });\n\n    this.$dropdownContainer.on('mousedown', function (evt) {\n      evt.stopPropagation();\n    });\n  };\n\n  AttachBody.prototype.destroy = function (decorated) {\n    decorated.call(this);\n\n    this.$dropdownContainer.remove();\n  };\n\n  AttachBody.prototype.position = function (decorated, $dropdown, $container) {\n    // Clone all of the container classes\n    $dropdown.attr('class', $container.attr('class'));\n\n    $dropdown.removeClass('select2');\n    $dropdown.addClass('select2-container--open');\n\n    $dropdown.css({\n      position: 'absolute',\n      top: -999999\n    });\n\n    this.$container = $container;\n  };\n\n  AttachBody.prototype.render = function (decorated) {\n    var $container = $('<span></span>');\n\n    var $dropdown = decorated.call(this);\n    $container.append($dropdown);\n\n    this.$dropdownContainer = $container;\n\n    return $container;\n  };\n\n  AttachBody.prototype._hideDropdown = function (decorated) {\n    this.$dropdownContainer.detach();\n  };\n\n  AttachBody.prototype._bindContainerResultHandlers =\n      function (decorated, container) {\n\n    // These should only be bound once\n    if (this._containerResultsHandlersBound) {\n      return;\n    }\n\n    var self = this;\n\n    container.on('results:all', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('results:append', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('results:message', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('select', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    container.on('unselect', function () {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n\n    this._containerResultsHandlersBound = true;\n  };\n\n  AttachBody.prototype._attachPositioningHandler =\n      function (decorated, container) {\n    var self = this;\n\n    var scrollEvent = 'scroll.select2.' + container.id;\n    var resizeEvent = 'resize.select2.' + container.id;\n    var orientationEvent = 'orientationchange.select2.' + container.id;\n\n    var $watchers = this.$container.parents().filter(Utils.hasScroll);\n    $watchers.each(function () {\n      Utils.StoreData(this, 'select2-scroll-position', {\n        x: $(this).scrollLeft(),\n        y: $(this).scrollTop()\n      });\n    });\n\n    $watchers.on(scrollEvent, function (ev) {\n      var position = Utils.GetData(this, 'select2-scroll-position');\n      $(this).scrollTop(position.y);\n    });\n\n    $(window).on(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent,\n      function (e) {\n      self._positionDropdown();\n      self._resizeDropdown();\n    });\n  };\n\n  AttachBody.prototype._detachPositioningHandler =\n      function (decorated, container) {\n    var scrollEvent = 'scroll.select2.' + container.id;\n    var resizeEvent = 'resize.select2.' + container.id;\n    var orientationEvent = 'orientationchange.select2.' + container.id;\n\n    var $watchers = this.$container.parents().filter(Utils.hasScroll);\n    $watchers.off(scrollEvent);\n\n    $(window).off(scrollEvent + ' ' + resizeEvent + ' ' + orientationEvent);\n  };\n\n  AttachBody.prototype._positionDropdown = function () {\n    var $window = $(window);\n\n    var isCurrentlyAbove = this.$dropdown.hasClass('select2-dropdown--above');\n    var isCurrentlyBelow = this.$dropdown.hasClass('select2-dropdown--below');\n\n    var newDirection = null;\n\n    var offset = this.$container.offset();\n\n    offset.bottom = offset.top + this.$container.outerHeight(false);\n\n    var container = {\n      height: this.$container.outerHeight(false)\n    };\n\n    container.top = offset.top;\n    container.bottom = offset.top + container.height;\n\n    var dropdown = {\n      height: this.$dropdown.outerHeight(false)\n    };\n\n    var viewport = {\n      top: $window.scrollTop(),\n      bottom: $window.scrollTop() + $window.height()\n    };\n\n    var enoughRoomAbove = viewport.top < (offset.top - dropdown.height);\n    var enoughRoomBelow = viewport.bottom > (offset.bottom + dropdown.height);\n\n    var css = {\n      left: offset.left,\n      top: container.bottom\n    };\n\n    // Determine what the parent element is to use for calculating the offset\n    var $offsetParent = this.$dropdownParent;\n\n    // For statically positioned elements, we need to get the element\n    // that is determining the offset\n    if ($offsetParent.css('position') === 'static') {\n      $offsetParent = $offsetParent.offsetParent();\n    }\n\n    var parentOffset = {\n      top: 0,\n      left: 0\n    };\n\n    if (\n      $.contains(document.body, $offsetParent[0]) ||\n      $offsetParent[0].isConnected\n      ) {\n      parentOffset = $offsetParent.offset();\n    }\n\n    css.top -= parentOffset.top;\n    css.left -= parentOffset.left;\n\n    if (!isCurrentlyAbove && !isCurrentlyBelow) {\n      newDirection = 'below';\n    }\n\n    if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {\n      newDirection = 'above';\n    } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {\n      newDirection = 'below';\n    }\n\n    if (newDirection == 'above' ||\n      (isCurrentlyAbove && newDirection !== 'below')) {\n      css.top = container.top - parentOffset.top - dropdown.height;\n    }\n\n    if (newDirection != null) {\n      this.$dropdown\n        .removeClass('select2-dropdown--below select2-dropdown--above')\n        .addClass('select2-dropdown--' + newDirection);\n      this.$container\n        .removeClass('select2-container--below select2-container--above')\n        .addClass('select2-container--' + newDirection);\n    }\n\n    this.$dropdownContainer.css(css);\n  };\n\n  AttachBody.prototype._resizeDropdown = function () {\n    var css = {\n      width: this.$container.outerWidth(false) + 'px'\n    };\n\n    if (this.options.get('dropdownAutoWidth')) {\n      css.minWidth = css.width;\n      css.position = 'relative';\n      css.width = 'auto';\n    }\n\n    this.$dropdown.css(css);\n  };\n\n  AttachBody.prototype._showDropdown = function (decorated) {\n    this.$dropdownContainer.appendTo(this.$dropdownParent);\n\n    this._positionDropdown();\n    this._resizeDropdown();\n  };\n\n  return AttachBody;\n});\n\nS2.define('select2/dropdown/minimumResultsForSearch',[\n\n], function () {\n  function countResults (data) {\n    var count = 0;\n\n    for (var d = 0; d < data.length; d++) {\n      var item = data[d];\n\n      if (item.children) {\n        count += countResults(item.children);\n      } else {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  function MinimumResultsForSearch (decorated, $element, options, dataAdapter) {\n    this.minimumResultsForSearch = options.get('minimumResultsForSearch');\n\n    if (this.minimumResultsForSearch < 0) {\n      this.minimumResultsForSearch = Infinity;\n    }\n\n    decorated.call(this, $element, options, dataAdapter);\n  }\n\n  MinimumResultsForSearch.prototype.showSearch = function (decorated, params) {\n    if (countResults(params.data.results) < this.minimumResultsForSearch) {\n      return false;\n    }\n\n    return decorated.call(this, params);\n  };\n\n  return MinimumResultsForSearch;\n});\n\nS2.define('select2/dropdown/selectOnClose',[\n  '../utils'\n], function (Utils) {\n  function SelectOnClose () { }\n\n  SelectOnClose.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('close', function (params) {\n      self._handleSelectOnClose(params);\n    });\n  };\n\n  SelectOnClose.prototype._handleSelectOnClose = function (_, params) {\n    if (params && params.originalSelect2Event != null) {\n      var event = params.originalSelect2Event;\n\n      // Don't select an item if the close event was triggered from a select or\n      // unselect event\n      if (event._type === 'select' || event._type === 'unselect') {\n        return;\n      }\n    }\n\n    var $highlightedResults = this.getHighlightedResults();\n\n    // Only select highlighted results\n    if ($highlightedResults.length < 1) {\n      return;\n    }\n\n    var data = Utils.GetData($highlightedResults[0], 'data');\n\n    // Don't re-select already selected resulte\n    if (\n      (data.element != null && data.element.selected) ||\n      (data.element == null && data.selected)\n    ) {\n      return;\n    }\n\n    this.trigger('select', {\n        data: data\n    });\n  };\n\n  return SelectOnClose;\n});\n\nS2.define('select2/dropdown/closeOnSelect',[\n\n], function () {\n  function CloseOnSelect () { }\n\n  CloseOnSelect.prototype.bind = function (decorated, container, $container) {\n    var self = this;\n\n    decorated.call(this, container, $container);\n\n    container.on('select', function (evt) {\n      self._selectTriggered(evt);\n    });\n\n    container.on('unselect', function (evt) {\n      self._selectTriggered(evt);\n    });\n  };\n\n  CloseOnSelect.prototype._selectTriggered = function (_, evt) {\n    var originalEvent = evt.originalEvent;\n\n    // Don't close if the control key is being held\n    if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {\n      return;\n    }\n\n    this.trigger('close', {\n      originalEvent: originalEvent,\n      originalSelect2Event: evt\n    });\n  };\n\n  return CloseOnSelect;\n});\n\nS2.define('select2/i18n/en',[],function () {\n  // English\n  return {\n    errorLoading: function () {\n      return 'The results could not be loaded.';\n    },\n    inputTooLong: function (args) {\n      var overChars = args.input.length - args.maximum;\n\n      var message = 'Please delete ' + overChars + ' character';\n\n      if (overChars != 1) {\n        message += 's';\n      }\n\n      return message;\n    },\n    inputTooShort: function (args) {\n      var remainingChars = args.minimum - args.input.length;\n\n      var message = 'Please enter ' + remainingChars + ' or more characters';\n\n      return message;\n    },\n    loadingMore: function () {\n      return 'Loading more results…';\n    },\n    maximumSelected: function (args) {\n      var message = 'You can only select ' + args.maximum + ' item';\n\n      if (args.maximum != 1) {\n        message += 's';\n      }\n\n      return message;\n    },\n    noResults: function () {\n      return 'No results found';\n    },\n    searching: function () {\n      return 'Searching…';\n    },\n    removeAllItems: function () {\n      return 'Remove all items';\n    }\n  };\n});\n\nS2.define('select2/defaults',[\n  'jquery',\n  'require',\n\n  './results',\n\n  './selection/single',\n  './selection/multiple',\n  './selection/placeholder',\n  './selection/allowClear',\n  './selection/search',\n  './selection/eventRelay',\n\n  './utils',\n  './translation',\n  './diacritics',\n\n  './data/select',\n  './data/array',\n  './data/ajax',\n  './data/tags',\n  './data/tokenizer',\n  './data/minimumInputLength',\n  './data/maximumInputLength',\n  './data/maximumSelectionLength',\n\n  './dropdown',\n  './dropdown/search',\n  './dropdown/hidePlaceholder',\n  './dropdown/infiniteScroll',\n  './dropdown/attachBody',\n  './dropdown/minimumResultsForSearch',\n  './dropdown/selectOnClose',\n  './dropdown/closeOnSelect',\n\n  './i18n/en'\n], function ($, require,\n\n             ResultsList,\n\n             SingleSelection, MultipleSelection, Placeholder, AllowClear,\n             SelectionSearch, EventRelay,\n\n             Utils, Translation, DIACRITICS,\n\n             SelectData, ArrayData, AjaxData, Tags, Tokenizer,\n             MinimumInputLength, MaximumInputLength, MaximumSelectionLength,\n\n             Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll,\n             AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect,\n\n             EnglishTranslation) {\n  function Defaults () {\n    this.reset();\n  }\n\n  Defaults.prototype.apply = function (options) {\n    options = $.extend(true, {}, this.defaults, options);\n\n    if (options.dataAdapter == null) {\n      if (options.ajax != null) {\n        options.dataAdapter = AjaxData;\n      } else if (options.data != null) {\n        options.dataAdapter = ArrayData;\n      } else {\n        options.dataAdapter = SelectData;\n      }\n\n      if (options.minimumInputLength > 0) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          MinimumInputLength\n        );\n      }\n\n      if (options.maximumInputLength > 0) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          MaximumInputLength\n        );\n      }\n\n      if (options.maximumSelectionLength > 0) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          MaximumSelectionLength\n        );\n      }\n\n      if (options.tags) {\n        options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);\n      }\n\n      if (options.tokenSeparators != null || options.tokenizer != null) {\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          Tokenizer\n        );\n      }\n\n      if (options.query != null) {\n        var Query = require(options.amdBase + 'compat/query');\n\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          Query\n        );\n      }\n\n      if (options.initSelection != null) {\n        var InitSelection = require(options.amdBase + 'compat/initSelection');\n\n        options.dataAdapter = Utils.Decorate(\n          options.dataAdapter,\n          InitSelection\n        );\n      }\n    }\n\n    if (options.resultsAdapter == null) {\n      options.resultsAdapter = ResultsList;\n\n      if (options.ajax != null) {\n        options.resultsAdapter = Utils.Decorate(\n          options.resultsAdapter,\n          InfiniteScroll\n        );\n      }\n\n      if (options.placeholder != null) {\n        options.resultsAdapter = Utils.Decorate(\n          options.resultsAdapter,\n          HidePlaceholder\n        );\n      }\n\n      if (options.selectOnClose) {\n        options.resultsAdapter = Utils.Decorate(\n          options.resultsAdapter,\n          SelectOnClose\n        );\n      }\n    }\n\n    if (options.dropdownAdapter == null) {\n      if (options.multiple) {\n        options.dropdownAdapter = Dropdown;\n      } else {\n        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);\n\n        options.dropdownAdapter = SearchableDropdown;\n      }\n\n      if (options.minimumResultsForSearch !== 0) {\n        options.dropdownAdapter = Utils.Decorate(\n          options.dropdownAdapter,\n          MinimumResultsForSearch\n        );\n      }\n\n      if (options.closeOnSelect) {\n        options.dropdownAdapter = Utils.Decorate(\n          options.dropdownAdapter,\n          CloseOnSelect\n        );\n      }\n\n      if (\n        options.dropdownCssClass != null ||\n        options.dropdownCss != null ||\n        options.adaptDropdownCssClass != null\n      ) {\n        var DropdownCSS = require(options.amdBase + 'compat/dropdownCss');\n\n        options.dropdownAdapter = Utils.Decorate(\n          options.dropdownAdapter,\n          DropdownCSS\n        );\n      }\n\n      options.dropdownAdapter = Utils.Decorate(\n        options.dropdownAdapter,\n        AttachBody\n      );\n    }\n\n    if (options.selectionAdapter == null) {\n      if (options.multiple) {\n        options.selectionAdapter = MultipleSelection;\n      } else {\n        options.selectionAdapter = SingleSelection;\n      }\n\n      // Add the placeholder mixin if a placeholder was specified\n      if (options.placeholder != null) {\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          Placeholder\n        );\n      }\n\n      if (options.allowClear) {\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          AllowClear\n        );\n      }\n\n      if (options.multiple) {\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          SelectionSearch\n        );\n      }\n\n      if (\n        options.containerCssClass != null ||\n        options.containerCss != null ||\n        options.adaptContainerCssClass != null\n      ) {\n        var ContainerCSS = require(options.amdBase + 'compat/containerCss');\n\n        options.selectionAdapter = Utils.Decorate(\n          options.selectionAdapter,\n          ContainerCSS\n        );\n      }\n\n      options.selectionAdapter = Utils.Decorate(\n        options.selectionAdapter,\n        EventRelay\n      );\n    }\n\n    // If the defaults were not previously applied from an element, it is\n    // possible for the language option to have not been resolved\n    options.language = this._resolveLanguage(options.language);\n\n    // Always fall back to English since it will always be complete\n    options.language.push('en');\n\n    var uniqueLanguages = [];\n\n    for (var l = 0; l < options.language.length; l++) {\n      var language = options.language[l];\n\n      if (uniqueLanguages.indexOf(language) === -1) {\n        uniqueLanguages.push(language);\n      }\n    }\n\n    options.language = uniqueLanguages;\n\n    options.translations = this._processTranslations(\n      options.language,\n      options.debug\n    );\n\n    return options;\n  };\n\n  Defaults.prototype.reset = function () {\n    function stripDiacritics (text) {\n      // Used 'uni range + named function' from http://jsperf.com/diacritics/18\n      function match(a) {\n        return DIACRITICS[a] || a;\n      }\n\n      return text.replace(/[^\\u0000-\\u007E]/g, match);\n    }\n\n    function matcher (params, data) {\n      // Always return the object if there is nothing to compare\n      if ($.trim(params.term) === '') {\n        return data;\n      }\n\n      // Do a recursive check for options with children\n      if (data.children && data.children.length > 0) {\n        // Clone the data object if there are children\n        // This is required as we modify the object to remove any non-matches\n        var match = $.extend(true, {}, data);\n\n        // Check each child of the option\n        for (var c = data.children.length - 1; c >= 0; c--) {\n          var child = data.children[c];\n\n          var matches = matcher(params, child);\n\n          // If there wasn't a match, remove the object in the array\n          if (matches == null) {\n            match.children.splice(c, 1);\n          }\n        }\n\n        // If any children matched, return the new object\n        if (match.children.length > 0) {\n          return match;\n        }\n\n        // If there were no matching children, check just the plain object\n        return matcher(params, match);\n      }\n\n      var original = stripDiacritics(data.text).toUpperCase();\n      var term = stripDiacritics(params.term).toUpperCase();\n\n      // Check if the text contains the term\n      if (original.indexOf(term) > -1) {\n        return data;\n      }\n\n      // If it doesn't contain the term, don't return anything\n      return null;\n    }\n\n    this.defaults = {\n      amdBase: './',\n      amdLanguageBase: './i18n/',\n      closeOnSelect: true,\n      debug: false,\n      dropdownAutoWidth: false,\n      escapeMarkup: Utils.escapeMarkup,\n      language: {},\n      matcher: matcher,\n      minimumInputLength: 0,\n      maximumInputLength: 0,\n      maximumSelectionLength: 0,\n      minimumResultsForSearch: 0,\n      selectOnClose: false,\n      scrollAfterSelect: false,\n      sorter: function (data) {\n        return data;\n      },\n      templateResult: function (result) {\n        return result.text;\n      },\n      templateSelection: function (selection) {\n        return selection.text;\n      },\n      theme: 'default',\n      width: 'resolve'\n    };\n  };\n\n  Defaults.prototype.applyFromElement = function (options, $element) {\n    var optionLanguage = options.language;\n    var defaultLanguage = this.defaults.language;\n    var elementLanguage = $element.prop('lang');\n    var parentLanguage = $element.closest('[lang]').prop('lang');\n\n    var languages = Array.prototype.concat.call(\n      this._resolveLanguage(elementLanguage),\n      this._resolveLanguage(optionLanguage),\n      this._resolveLanguage(defaultLanguage),\n      this._resolveLanguage(parentLanguage)\n    );\n\n    options.language = languages;\n\n    return options;\n  };\n\n  Defaults.prototype._resolveLanguage = function (language) {\n    if (!language) {\n      return [];\n    }\n\n    if ($.isEmptyObject(language)) {\n      return [];\n    }\n\n    if ($.isPlainObject(language)) {\n      return [language];\n    }\n\n    var languages;\n\n    if (!$.isArray(language)) {\n      languages = [language];\n    } else {\n      languages = language;\n    }\n\n    var resolvedLanguages = [];\n\n    for (var l = 0; l < languages.length; l++) {\n      resolvedLanguages.push(languages[l]);\n\n      if (typeof languages[l] === 'string' && languages[l].indexOf('-') > 0) {\n        // Extract the region information if it is included\n        var languageParts = languages[l].split('-');\n        var baseLanguage = languageParts[0];\n\n        resolvedLanguages.push(baseLanguage);\n      }\n    }\n\n    return resolvedLanguages;\n  };\n\n  Defaults.prototype._processTranslations = function (languages, debug) {\n    var translations = new Translation();\n\n    for (var l = 0; l < languages.length; l++) {\n      var languageData = new Translation();\n\n      var language = languages[l];\n\n      if (typeof language === 'string') {\n        try {\n          // Try to load it with the original name\n          languageData = Translation.loadPath(language);\n        } catch (e) {\n          try {\n            // If we couldn't load it, check if it wasn't the full path\n            language = this.defaults.amdLanguageBase + language;\n            languageData = Translation.loadPath(language);\n          } catch (ex) {\n            // The translation could not be loaded at all. Sometimes this is\n            // because of a configuration problem, other times this can be\n            // because of how Select2 helps load all possible translation files\n            if (debug && window.console && console.warn) {\n              console.warn(\n                'Select2: The language file for \"' + language + '\" could ' +\n                'not be automatically loaded. A fallback will be used instead.'\n              );\n            }\n          }\n        }\n      } else if ($.isPlainObject(language)) {\n        languageData = new Translation(language);\n      } else {\n        languageData = language;\n      }\n\n      translations.extend(languageData);\n    }\n\n    return translations;\n  };\n\n  Defaults.prototype.set = function (key, value) {\n    var camelKey = $.camelCase(key);\n\n    var data = {};\n    data[camelKey] = value;\n\n    var convertedData = Utils._convertData(data);\n\n    $.extend(true, this.defaults, convertedData);\n  };\n\n  var defaults = new Defaults();\n\n  return defaults;\n});\n\nS2.define('select2/options',[\n  'require',\n  'jquery',\n  './defaults',\n  './utils'\n], function (require, $, Defaults, Utils) {\n  function Options (options, $element) {\n    this.options = options;\n\n    if ($element != null) {\n      this.fromElement($element);\n    }\n\n    if ($element != null) {\n      this.options = Defaults.applyFromElement(this.options, $element);\n    }\n\n    this.options = Defaults.apply(this.options);\n\n    if ($element && $element.is('input')) {\n      var InputCompat = require(this.get('amdBase') + 'compat/inputData');\n\n      this.options.dataAdapter = Utils.Decorate(\n        this.options.dataAdapter,\n        InputCompat\n      );\n    }\n  }\n\n  Options.prototype.fromElement = function ($e) {\n    var excludedData = ['select2'];\n\n    if (this.options.multiple == null) {\n      this.options.multiple = $e.prop('multiple');\n    }\n\n    if (this.options.disabled == null) {\n      this.options.disabled = $e.prop('disabled');\n    }\n\n    if (this.options.dir == null) {\n      if ($e.prop('dir')) {\n        this.options.dir = $e.prop('dir');\n      } else if ($e.closest('[dir]').prop('dir')) {\n        this.options.dir = $e.closest('[dir]').prop('dir');\n      } else {\n        this.options.dir = 'ltr';\n      }\n    }\n\n    $e.prop('disabled', this.options.disabled);\n    $e.prop('multiple', this.options.multiple);\n\n    if (Utils.GetData($e[0], 'select2Tags')) {\n      if (this.options.debug && window.console && console.warn) {\n        console.warn(\n          'Select2: The `data-select2-tags` attribute has been changed to ' +\n          'use the `data-data` and `data-tags=\"true\"` attributes and will be ' +\n          'removed in future versions of Select2.'\n        );\n      }\n\n      Utils.StoreData($e[0], 'data', Utils.GetData($e[0], 'select2Tags'));\n      Utils.StoreData($e[0], 'tags', true);\n    }\n\n    if (Utils.GetData($e[0], 'ajaxUrl')) {\n      if (this.options.debug && window.console && console.warn) {\n        console.warn(\n          'Select2: The `data-ajax-url` attribute has been changed to ' +\n          '`data-ajax--url` and support for the old attribute will be removed' +\n          ' in future versions of Select2.'\n        );\n      }\n\n      $e.attr('ajax--url', Utils.GetData($e[0], 'ajaxUrl'));\n      Utils.StoreData($e[0], 'ajax-Url', Utils.GetData($e[0], 'ajaxUrl'));\n    }\n\n    var dataset = {};\n\n    function upperCaseLetter(_, letter) {\n      return letter.toUpperCase();\n    }\n\n    // Pre-load all of the attributes which are prefixed with `data-`\n    for (var attr = 0; attr < $e[0].attributes.length; attr++) {\n      var attributeName = $e[0].attributes[attr].name;\n      var prefix = 'data-';\n\n      if (attributeName.substr(0, prefix.length) == prefix) {\n        // Get the contents of the attribute after `data-`\n        var dataName = attributeName.substring(prefix.length);\n\n        // Get the data contents from the consistent source\n        // This is more than likely the jQuery data helper\n        var dataValue = Utils.GetData($e[0], dataName);\n\n        // camelCase the attribute name to match the spec\n        var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);\n\n        // Store the data attribute contents into the dataset since\n        dataset[camelDataName] = dataValue;\n      }\n    }\n\n    // Prefer the element's `dataset` attribute if it exists\n    // jQuery 1.x does not correctly handle data attributes with multiple dashes\n    if ($.fn.jquery && $.fn.jquery.substr(0, 2) == '1.' && $e[0].dataset) {\n      dataset = $.extend(true, {}, $e[0].dataset, dataset);\n    }\n\n    // Prefer our internal data cache if it exists\n    var data = $.extend(true, {}, Utils.GetData($e[0]), dataset);\n\n    data = Utils._convertData(data);\n\n    for (var key in data) {\n      if ($.inArray(key, excludedData) > -1) {\n        continue;\n      }\n\n      if ($.isPlainObject(this.options[key])) {\n        $.extend(this.options[key], data[key]);\n      } else {\n        this.options[key] = data[key];\n      }\n    }\n\n    return this;\n  };\n\n  Options.prototype.get = function (key) {\n    return this.options[key];\n  };\n\n  Options.prototype.set = function (key, val) {\n    this.options[key] = val;\n  };\n\n  return Options;\n});\n\nS2.define('select2/core',[\n  'jquery',\n  './options',\n  './utils',\n  './keys'\n], function ($, Options, Utils, KEYS) {\n  var Select2 = function ($element, options) {\n    if (Utils.GetData($element[0], 'select2') != null) {\n      Utils.GetData($element[0], 'select2').destroy();\n    }\n\n    this.$element = $element;\n\n    this.id = this._generateId($element);\n\n    options = options || {};\n\n    this.options = new Options(options, $element);\n\n    Select2.__super__.constructor.call(this);\n\n    // Set up the tabindex\n\n    var tabindex = $element.attr('tabindex') || 0;\n    Utils.StoreData($element[0], 'old-tabindex', tabindex);\n    $element.attr('tabindex', '-1');\n\n    // Set up containers and adapters\n\n    var DataAdapter = this.options.get('dataAdapter');\n    this.dataAdapter = new DataAdapter($element, this.options);\n\n    var $container = this.render();\n\n    this._placeContainer($container);\n\n    var SelectionAdapter = this.options.get('selectionAdapter');\n    this.selection = new SelectionAdapter($element, this.options);\n    this.$selection = this.selection.render();\n\n    this.selection.position(this.$selection, $container);\n\n    var DropdownAdapter = this.options.get('dropdownAdapter');\n    this.dropdown = new DropdownAdapter($element, this.options);\n    this.$dropdown = this.dropdown.render();\n\n    this.dropdown.position(this.$dropdown, $container);\n\n    var ResultsAdapter = this.options.get('resultsAdapter');\n    this.results = new ResultsAdapter($element, this.options, this.dataAdapter);\n    this.$results = this.results.render();\n\n    this.results.position(this.$results, this.$dropdown);\n\n    // Bind events\n\n    var self = this;\n\n    // Bind the container to all of the adapters\n    this._bindAdapters();\n\n    // Register any DOM event handlers\n    this._registerDomEvents();\n\n    // Register any internal event handlers\n    this._registerDataEvents();\n    this._registerSelectionEvents();\n    this._registerDropdownEvents();\n    this._registerResultsEvents();\n    this._registerEvents();\n\n    // Set the initial state\n    this.dataAdapter.current(function (initialData) {\n      self.trigger('selection:update', {\n        data: initialData\n      });\n    });\n\n    // Hide the original select\n    $element.addClass('select2-hidden-accessible');\n    $element.attr('aria-hidden', 'true');\n\n    // Synchronize any monitored attributes\n    this._syncAttributes();\n\n    Utils.StoreData($element[0], 'select2', this);\n\n    // Ensure backwards compatibility with $element.data('select2').\n    $element.data('select2', this);\n  };\n\n  Utils.Extend(Select2, Utils.Observable);\n\n  Select2.prototype._generateId = function ($element) {\n    var id = '';\n\n    if ($element.attr('id') != null) {\n      id = $element.attr('id');\n    } else if ($element.attr('name') != null) {\n      id = $element.attr('name') + '-' + Utils.generateChars(2);\n    } else {\n      id = Utils.generateChars(4);\n    }\n\n    id = id.replace(/(:|\\.|\\[|\\]|,)/g, '');\n    id = 'select2-' + id;\n\n    return id;\n  };\n\n  Select2.prototype._placeContainer = function ($container) {\n    $container.insertAfter(this.$element);\n\n    var width = this._resolveWidth(this.$element, this.options.get('width'));\n\n    if (width != null) {\n      $container.css('width', width);\n    }\n  };\n\n  Select2.prototype._resolveWidth = function ($element, method) {\n    var WIDTH = /^width:(([-+]?([0-9]*\\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;\n\n    if (method == 'resolve') {\n      var styleWidth = this._resolveWidth($element, 'style');\n\n      if (styleWidth != null) {\n        return styleWidth;\n      }\n\n      return this._resolveWidth($element, 'element');\n    }\n\n    if (method == 'element') {\n      var elementWidth = $element.outerWidth(false);\n\n      if (elementWidth <= 0) {\n        return 'auto';\n      }\n\n      return elementWidth + 'px';\n    }\n\n    if (method == 'style') {\n      var style = $element.attr('style');\n\n      if (typeof(style) !== 'string') {\n        return null;\n      }\n\n      var attrs = style.split(';');\n\n      for (var i = 0, l = attrs.length; i < l; i = i + 1) {\n        var attr = attrs[i].replace(/\\s/g, '');\n        var matches = attr.match(WIDTH);\n\n        if (matches !== null && matches.length >= 1) {\n          return matches[1];\n        }\n      }\n\n      return null;\n    }\n\n    if (method == 'computedstyle') {\n      var computedStyle = window.getComputedStyle($element[0]);\n\n      return computedStyle.width;\n    }\n\n    return method;\n  };\n\n  Select2.prototype._bindAdapters = function () {\n    this.dataAdapter.bind(this, this.$container);\n    this.selection.bind(this, this.$container);\n\n    this.dropdown.bind(this, this.$container);\n    this.results.bind(this, this.$container);\n  };\n\n  Select2.prototype._registerDomEvents = function () {\n    var self = this;\n\n    this.$element.on('change.select2', function () {\n      self.dataAdapter.current(function (data) {\n        self.trigger('selection:update', {\n          data: data\n        });\n      });\n    });\n\n    this.$element.on('focus.select2', function (evt) {\n      self.trigger('focus', evt);\n    });\n\n    this._syncA = Utils.bind(this._syncAttributes, this);\n    this._syncS = Utils.bind(this._syncSubtree, this);\n\n    if (this.$element[0].attachEvent) {\n      this.$element[0].attachEvent('onpropertychange', this._syncA);\n    }\n\n    var observer = window.MutationObserver ||\n      window.WebKitMutationObserver ||\n      window.MozMutationObserver\n    ;\n\n    if (observer != null) {\n      this._observer = new observer(function (mutations) {\n        self._syncA();\n        self._syncS(null, mutations);\n      });\n      this._observer.observe(this.$element[0], {\n        attributes: true,\n        childList: true,\n        subtree: false\n      });\n    } else if (this.$element[0].addEventListener) {\n      this.$element[0].addEventListener(\n        'DOMAttrModified',\n        self._syncA,\n        false\n      );\n      this.$element[0].addEventListener(\n        'DOMNodeInserted',\n        self._syncS,\n        false\n      );\n      this.$element[0].addEventListener(\n        'DOMNodeRemoved',\n        self._syncS,\n        false\n      );\n    }\n  };\n\n  Select2.prototype._registerDataEvents = function () {\n    var self = this;\n\n    this.dataAdapter.on('*', function (name, params) {\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerSelectionEvents = function () {\n    var self = this;\n    var nonRelayEvents = ['toggle', 'focus'];\n\n    this.selection.on('toggle', function () {\n      self.toggleDropdown();\n    });\n\n    this.selection.on('focus', function (params) {\n      self.focus(params);\n    });\n\n    this.selection.on('*', function (name, params) {\n      if ($.inArray(name, nonRelayEvents) !== -1) {\n        return;\n      }\n\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerDropdownEvents = function () {\n    var self = this;\n\n    this.dropdown.on('*', function (name, params) {\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerResultsEvents = function () {\n    var self = this;\n\n    this.results.on('*', function (name, params) {\n      self.trigger(name, params);\n    });\n  };\n\n  Select2.prototype._registerEvents = function () {\n    var self = this;\n\n    this.on('open', function () {\n      self.$container.addClass('select2-container--open');\n    });\n\n    this.on('close', function () {\n      self.$container.removeClass('select2-container--open');\n    });\n\n    this.on('enable', function () {\n      self.$container.removeClass('select2-container--disabled');\n    });\n\n    this.on('disable', function () {\n      self.$container.addClass('select2-container--disabled');\n    });\n\n    this.on('blur', function () {\n      self.$container.removeClass('select2-container--focus');\n    });\n\n    this.on('query', function (params) {\n      if (!self.isOpen()) {\n        self.trigger('open', {});\n      }\n\n      this.dataAdapter.query(params, function (data) {\n        self.trigger('results:all', {\n          data: data,\n          query: params\n        });\n      });\n    });\n\n    this.on('query:append', function (params) {\n      this.dataAdapter.query(params, function (data) {\n        self.trigger('results:append', {\n          data: data,\n          query: params\n        });\n      });\n    });\n\n    this.on('keypress', function (evt) {\n      var key = evt.which;\n\n      if (self.isOpen()) {\n        if (key === KEYS.ESC || key === KEYS.TAB ||\n            (key === KEYS.UP && evt.altKey)) {\n          self.close(evt);\n\n          evt.preventDefault();\n        } else if (key === KEYS.ENTER) {\n          self.trigger('results:select', {});\n\n          evt.preventDefault();\n        } else if ((key === KEYS.SPACE && evt.ctrlKey)) {\n          self.trigger('results:toggle', {});\n\n          evt.preventDefault();\n        } else if (key === KEYS.UP) {\n          self.trigger('results:previous', {});\n\n          evt.preventDefault();\n        } else if (key === KEYS.DOWN) {\n          self.trigger('results:next', {});\n\n          evt.preventDefault();\n        }\n      } else {\n        if (key === KEYS.ENTER || key === KEYS.SPACE ||\n            (key === KEYS.DOWN && evt.altKey)) {\n          self.open();\n\n          evt.preventDefault();\n        }\n      }\n    });\n  };\n\n  Select2.prototype._syncAttributes = function () {\n    this.options.set('disabled', this.$element.prop('disabled'));\n\n    if (this.isDisabled()) {\n      if (this.isOpen()) {\n        this.close();\n      }\n\n      this.trigger('disable', {});\n    } else {\n      this.trigger('enable', {});\n    }\n  };\n\n  Select2.prototype._isChangeMutation = function (evt, mutations) {\n    var changed = false;\n    var self = this;\n\n    // Ignore any mutation events raised for elements that aren't options or\n    // optgroups. This handles the case when the select element is destroyed\n    if (\n      evt && evt.target && (\n        evt.target.nodeName !== 'OPTION' && evt.target.nodeName !== 'OPTGROUP'\n      )\n    ) {\n      return;\n    }\n\n    if (!mutations) {\n      // If mutation events aren't supported, then we can only assume that the\n      // change affected the selections\n      changed = true;\n    } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {\n      for (var n = 0; n < mutations.addedNodes.length; n++) {\n        var node = mutations.addedNodes[n];\n\n        if (node.selected) {\n          changed = true;\n        }\n      }\n    } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {\n      changed = true;\n    } else if ($.isArray(mutations)) {\n      $.each(mutations, function(evt, mutation) {\n        if (self._isChangeMutation(evt, mutation)) {\n          // We've found a change mutation.\n          // Let's escape from the loop and continue\n          changed = true;\n          return false;\n        }\n      });\n    }\n    return changed;\n  };\n\n  Select2.prototype._syncSubtree = function (evt, mutations) {\n    var changed = this._isChangeMutation(evt, mutations);\n    var self = this;\n\n    // Only re-pull the data if we think there is a change\n    if (changed) {\n      this.dataAdapter.current(function (currentData) {\n        self.trigger('selection:update', {\n          data: currentData\n        });\n      });\n    }\n  };\n\n  /**\n   * Override the trigger method to automatically trigger pre-events when\n   * there are events that can be prevented.\n   */\n  Select2.prototype.trigger = function (name, args) {\n    var actualTrigger = Select2.__super__.trigger;\n    var preTriggerMap = {\n      'open': 'opening',\n      'close': 'closing',\n      'select': 'selecting',\n      'unselect': 'unselecting',\n      'clear': 'clearing'\n    };\n\n    if (args === undefined) {\n      args = {};\n    }\n\n    if (name in preTriggerMap) {\n      var preTriggerName = preTriggerMap[name];\n      var preTriggerArgs = {\n        prevented: false,\n        name: name,\n        args: args\n      };\n\n      actualTrigger.call(this, preTriggerName, preTriggerArgs);\n\n      if (preTriggerArgs.prevented) {\n        args.prevented = true;\n\n        return;\n      }\n    }\n\n    actualTrigger.call(this, name, args);\n  };\n\n  Select2.prototype.toggleDropdown = function () {\n    if (this.isDisabled()) {\n      return;\n    }\n\n    if (this.isOpen()) {\n      this.close();\n    } else {\n      this.open();\n    }\n  };\n\n  Select2.prototype.open = function () {\n    if (this.isOpen()) {\n      return;\n    }\n\n    if (this.isDisabled()) {\n      return;\n    }\n\n    this.trigger('query', {});\n  };\n\n  Select2.prototype.close = function (evt) {\n    if (!this.isOpen()) {\n      return;\n    }\n\n    this.trigger('close', { originalEvent : evt });\n  };\n\n  /**\n   * Helper method to abstract the \"enabled\" (not \"disabled\") state of this\n   * object.\n   *\n   * @return {true} if the instance is not disabled.\n   * @return {false} if the instance is disabled.\n   */\n  Select2.prototype.isEnabled = function () {\n    return !this.isDisabled();\n  };\n\n  /**\n   * Helper method to abstract the \"disabled\" state of this object.\n   *\n   * @return {true} if the disabled option is true.\n   * @return {false} if the disabled option is false.\n   */\n  Select2.prototype.isDisabled = function () {\n    return this.options.get('disabled');\n  };\n\n  Select2.prototype.isOpen = function () {\n    return this.$container.hasClass('select2-container--open');\n  };\n\n  Select2.prototype.hasFocus = function () {\n    return this.$container.hasClass('select2-container--focus');\n  };\n\n  Select2.prototype.focus = function (data) {\n    // No need to re-trigger focus events if we are already focused\n    if (this.hasFocus()) {\n      return;\n    }\n\n    this.$container.addClass('select2-container--focus');\n    this.trigger('focus', {});\n  };\n\n  Select2.prototype.enable = function (args) {\n    if (this.options.get('debug') && window.console && console.warn) {\n      console.warn(\n        'Select2: The `select2(\"enable\")` method has been deprecated and will' +\n        ' be removed in later Select2 versions. Use $element.prop(\"disabled\")' +\n        ' instead.'\n      );\n    }\n\n    if (args == null || args.length === 0) {\n      args = [true];\n    }\n\n    var disabled = !args[0];\n\n    this.$element.prop('disabled', disabled);\n  };\n\n  Select2.prototype.data = function () {\n    if (this.options.get('debug') &&\n        arguments.length > 0 && window.console && console.warn) {\n      console.warn(\n        'Select2: Data can no longer be set using `select2(\"data\")`. You ' +\n        'should consider setting the value instead using `$element.val()`.'\n      );\n    }\n\n    var data = [];\n\n    this.dataAdapter.current(function (currentData) {\n      data = currentData;\n    });\n\n    return data;\n  };\n\n  Select2.prototype.val = function (args) {\n    if (this.options.get('debug') && window.console && console.warn) {\n      console.warn(\n        'Select2: The `select2(\"val\")` method has been deprecated and will be' +\n        ' removed in later Select2 versions. Use $element.val() instead.'\n      );\n    }\n\n    if (args == null || args.length === 0) {\n      return this.$element.val();\n    }\n\n    var newVal = args[0];\n\n    if ($.isArray(newVal)) {\n      newVal = $.map(newVal, function (obj) {\n        return obj.toString();\n      });\n    }\n\n    this.$element.val(newVal).trigger('input').trigger('change');\n  };\n\n  Select2.prototype.destroy = function () {\n    this.$container.remove();\n\n    if (this.$element[0].detachEvent) {\n      this.$element[0].detachEvent('onpropertychange', this._syncA);\n    }\n\n    if (this._observer != null) {\n      this._observer.disconnect();\n      this._observer = null;\n    } else if (this.$element[0].removeEventListener) {\n      this.$element[0]\n        .removeEventListener('DOMAttrModified', this._syncA, false);\n      this.$element[0]\n        .removeEventListener('DOMNodeInserted', this._syncS, false);\n      this.$element[0]\n        .removeEventListener('DOMNodeRemoved', this._syncS, false);\n    }\n\n    this._syncA = null;\n    this._syncS = null;\n\n    this.$element.off('.select2');\n    this.$element.attr('tabindex',\n    Utils.GetData(this.$element[0], 'old-tabindex'));\n\n    this.$element.removeClass('select2-hidden-accessible');\n    this.$element.attr('aria-hidden', 'false');\n    Utils.RemoveData(this.$element[0]);\n    this.$element.removeData('select2');\n\n    this.dataAdapter.destroy();\n    this.selection.destroy();\n    this.dropdown.destroy();\n    this.results.destroy();\n\n    this.dataAdapter = null;\n    this.selection = null;\n    this.dropdown = null;\n    this.results = null;\n  };\n\n  Select2.prototype.render = function () {\n    var $container = $(\n      '<span class=\"select2 select2-container\">' +\n        '<span class=\"selection\"></span>' +\n        '<span class=\"dropdown-wrapper\" aria-hidden=\"true\"></span>' +\n      '</span>'\n    );\n\n    $container.attr('dir', this.options.get('dir'));\n\n    this.$container = $container;\n\n    this.$container.addClass('select2-container--' + this.options.get('theme'));\n\n    Utils.StoreData($container[0], 'element', this.$element);\n\n    return $container;\n  };\n\n  return Select2;\n});\n\nS2.define('jquery-mousewheel',[\n  'jquery'\n], function ($) {\n  // Used to shim jQuery.mousewheel for non-full builds.\n  return $;\n});\n\nS2.define('jquery.select2',[\n  'jquery',\n  'jquery-mousewheel',\n\n  './select2/core',\n  './select2/defaults',\n  './select2/utils'\n], function ($, _, Select2, Defaults, Utils) {\n  if ($.fn.select2 == null) {\n    // All methods that should return the element\n    var thisMethods = ['open', 'close', 'destroy'];\n\n    $.fn.select2 = function (options) {\n      options = options || {};\n\n      if (typeof options === 'object') {\n        this.each(function () {\n          var instanceOptions = $.extend(true, {}, options);\n\n          var instance = new Select2($(this), instanceOptions);\n        });\n\n        return this;\n      } else if (typeof options === 'string') {\n        var ret;\n        var args = Array.prototype.slice.call(arguments, 1);\n\n        this.each(function () {\n          var instance = Utils.GetData(this, 'select2');\n\n          if (instance == null && window.console && console.error) {\n            console.error(\n              'The select2(\\'' + options + '\\') method was called on an ' +\n              'element that is not using Select2.'\n            );\n          }\n\n          ret = instance[options].apply(instance, args);\n        });\n\n        // Check if we should be returning `this`\n        if ($.inArray(options, thisMethods) > -1) {\n          return this;\n        }\n\n        return ret;\n      } else {\n        throw new Error('Invalid arguments for Select2: ' + options);\n      }\n    };\n  }\n\n  if ($.fn.select2.defaults == null) {\n    $.fn.select2.defaults = Defaults;\n  }\n\n  return Select2;\n});\n\n  // Return the AMD loader configuration so it can be used outside of this file\n  return {\n    define: S2.define,\n    require: S2.require\n  };\n}());\n\n  // Autoload the jQuery bindings\n  // We know that all of the modules exist above this, so we're safe\n  var select2 = S2.require('jquery.select2');\n\n  // Hold the AMD module references on the jQuery function that was just loaded\n  // This allows Select2 to use the internal loader outside of this file, such\n  // as in the language files.\n  jQuery.fn.select2.amd = S2;\n\n  // Return the Select2 instance for anyone who is importing it.\n  return select2;\n}));\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/***/ ((module) => {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js */ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///Users/johannes/Development/Libs/tutomvc/node_modules/source-map-loader/index.js!/Users/johannes/Development/Libs/tutomvc/node_modules/bootstrap-select/dist/js/bootstrap-select.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js */ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///Users/johannes/Development/Libs/tutomvc/node_modules/source-map-loader/index.js!/Users/johannes/Development/Libs/tutomvc/node_modules/bootstrap/dist/js/bootstrap.js")

/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/select2/dist/js/select2.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/script-loader/index.js!./node_modules/select2/dist/js/select2.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(/*! !!./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !!./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js */ "./node_modules/raw-loader/index.js!./node_modules/source-map-loader/index.js!./node_modules/select2/dist/js/select2.js")+"\n\n// SCRIPT-LOADER FOOTER\n//# sourceURL=script:///Users/johannes/Development/Libs/tutomvc/node_modules/source-map-loader/index.js!/Users/johannes/Development/Libs/tutomvc/node_modules/select2/dist/js/select2.js")

/***/ }),

/***/ "./src/tsc/plugins/jQueryWPAttachmentFormInput.ts":
/*!********************************************************!*\
  !*** ./src/tsc/plugins/jQueryWPAttachmentFormInput.ts ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var WPAttachmentFormInput_1 = __webpack_require__(/*! ../wp/form/inputs/WPAttachmentFormInput */ "./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts");
jQuery(document).ready(function () {
    jQuery(".wpattachmentforminput").each(function () {
        new WPAttachmentFormInput_1.WPAttachmentFormInput(jQuery(this), jQuery(this).data());
    });
    //	jQuery( ".wpattachmentforminput .btn-remove" ).click( function ( e )
    //	{
    //		e.preventDefault();
    //		var $el = $( this );
    //		$el.closest( ".list-group-item" ).remove();
    //
    //		new WPAttachmentFormInput( $( $( this ).data( "target" ) ), "render" );
    //	} );
    //	jQuery( ".wpattachmentforminput .btn-add" ).click( function ( e )
    //	{
    //		new WPAttachmentFormInput( $( $( this ).data( "target" ) ), "open" );
    //	} );
});


/***/ }),

/***/ "./src/tsc/plugins/jQueryWPEditorFormInput.ts":
/*!****************************************************!*\
  !*** ./src/tsc/plugins/jQueryWPEditorFormInput.ts ***!
  \****************************************************/
/***/ (() => {

jQuery(function () {
    jQuery("body").on("click", ".wpeditor-placeholder-overlay", function (e) {
        var $currentTarget = e.currentTarget;
        var $el = jQuery($currentTarget.closest(".wpeditor-placeholder"));
        var content = $el.find("textarea").val();
        console.log(content);
        jQuery.ajax($el.data("ajax-url"), {
            data: {
                content: content,
                "id": $el.data("id"),
            },
            success: function (result) {
                console.log(result);
                $el.html(result.html);
                tinymce.init(result.settings);
                quicktags({ id: $el.data("id") });
                window.wpActiveEditor = $el.data("id");
            },
            error: function (error) { return console.error(error); }
        });
    });
});


/***/ }),

/***/ "./src/tsc/plugins/jQueryWPMetaBox.ts":
/*!********************************************!*\
  !*** ./src/tsc/plugins/jQueryWPMetaBox.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var MetaBox_1 = __webpack_require__(/*! ../wp/form/groups/MetaBox */ "./src/tsc/wp/form/groups/MetaBox.ts");
jQuery(function () {
    jQuery(".tutomvc-settings,.tutomvc-metabox,.tutomvc-user_metabox").each(function (i, el) {
        new MetaBox_1.MetaBox(jQuery(el));
    });
});


/***/ }),

/***/ "./src/tsc/wp/form/groups/MetaBox.ts":
/*!*******************************************!*\
  !*** ./src/tsc/wp/form/groups/MetaBox.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var WPAttachmentFormInput_1 = __webpack_require__(/*! ../inputs/WPAttachmentFormInput */ "./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts");
var MetaBox = /** @class */ (function () {
    function MetaBox($el) {
        var _this = this;
        this._$el = $el;
        // TODO: Check if this is used. If not. Remove the Ajax Commands in SystemAppFacade.
        this._$el.on("change", ".fissile-form-group-nuke", function (e) { return _this.parse(); });
        console.log("MetaBox");
        console.log(TutoMVC);
    }
    MetaBox.prototype.render = function (html) {
        this._$el.html(html);
        this._$el.find(".form-input-element.select2").each(function () {
            jQuery(this).select2(jQuery(this).data());
        });
        this._$el.find(".selectpicker").each(function () {
            jQuery(this).selectpicker(jQuery(this).data());
        });
        this._$el.find(".wpattachmentforminput").each(function () {
            new WPAttachmentFormInput_1.WPAttachmentFormInput(jQuery(this), jQuery(this).data());
        });
    };
    MetaBox.prototype.destroy = function () {
        this._$el.find("textarea.wp-editor-area").each(function (i, el) {
            console.log("DESOTRY:", jQuery(el).attr("id"));
            tinymce.remove("#" + jQuery(el).attr("id"));
            //			tinymce.execCommand( 'mceRemoveControl', true, jQuery( el ).attr( "id" ) );
        });
    };
    MetaBox.prototype.parse = function () {
        var _this = this;
        if (this.$form.length) {
            if (typeof tinymce !== 'undefined') {
                tinymce.triggerSave();
            }
            var data = new FormData(this.$form[0]);
            data.append("action", TutoMVC.parseAction);
            data.append("nonce", TutoMVC.parseNonce);
            var url = TutoMVC.parseURL + "&id=" + this.id + "&type=" + this.type;
            console.log(url);
            var ajaxRequest = jQuery.ajax(url, {
                data: data,
                method: "POST",
                contentType: false,
                processData: false,
                success: function (result) {
                    if (result) {
                        console.log(result);
                        var $metabox = jQuery(result);
                        _this.destroy();
                        _this.render($metabox.html());
                    }
                },
                error: function (result) { return console.error(result); }
            });
        }
    };
    Object.defineProperty(MetaBox.prototype, "id", {
        /* SET AND GET */
        get: function () {
            return this._$el.attr("id");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MetaBox.prototype, "$form", {
        get: function () {
            return jQuery(this._$el.closest("form"));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MetaBox.prototype, "type", {
        get: function () {
            if (this._$el.hasClass("tutomvc-metabox"))
                return "metabox";
            if (this._$el.hasClass("tutomvc-user_metabox"))
                return "user_metabox";
            if (this._$el.hasClass("tutomvc-settings"))
                return "settings";
        },
        enumerable: true,
        configurable: true
    });
    return MetaBox;
}());
exports.MetaBox = MetaBox;


/***/ }),

/***/ "./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts":
/*!*********************************************************!*\
  !*** ./src/tsc/wp/form/inputs/WPAttachmentFormInput.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var WPAttachmentFormInput = /** @class */ (function () {
    function WPAttachmentFormInput($el, options) {
        var _this = this;
        this.options = {
            max: -1,
            title: "",
            buttonText: "",
            type: null,
            frame: "select"
        };
        this.$el = $el;
        // Model
        this.options = jQuery.extend({}, this.options, options);
        // View
        this.template = _.template(this.$el.find("textarea.underscore-template").val());
        this.wpMedia = wp.media({
            title: this.options.title,
            multiple: this.options.max < 0 || this.options.max > 1 ? true : false,
            library: this.options.type ? { type: this.options.type } : undefined,
            button: { text: this.options.buttonText },
            frame: this.options.frame
        });
        // Controller
        this.wpMedia.on("select", function () { return _this.onWPMediaSelect(); });
        this.$el.on("click", ".btn-add", function () { return _this.open(); });
        this.$el.on("click", ".btn-remove", function (e) { return _this.onRemoveClick(e); });
        this.render();
    }
    WPAttachmentFormInput.prototype.render = function () {
        if (this.count >= this.options.max && this.options.max >= 0)
            this.$el.find(".btn-add").prop("disabled", "disabled");
        else
            this.$el.find(".btn-add").prop("disabled", null);
    };
    WPAttachmentFormInput.prototype.open = function () {
        this.wpMedia.open();
    };
    ;
    WPAttachmentFormInput.prototype.add = function (attachmentModel) {
        var __this = this;
        attachmentModel.src = attachmentModel.icon;
        if (!attachmentModel.width)
            attachmentModel.width = "";
        if (!attachmentModel.height)
            attachmentModel.height = "";
        if (attachmentModel.sizes) {
            if (attachmentModel.sizes.thumbnail && attachmentModel.sizes.thumbnail.url) {
                attachmentModel.src = attachmentModel.sizes.thumbnail.url;
            }
            else if (attachmentModel.sizes.full && attachmentModel.sizes.full.url) {
                attachmentModel.src = attachmentModel.sizes.full.url;
            }
        }
        var $el = jQuery(this.template(attachmentModel));
        this.$el.find(".list-group").append($el);
    };
    ;
    Object.defineProperty(WPAttachmentFormInput.prototype, "count", {
        /* SET AND GET */
        get: function () {
            return this.$el.find(".list-group-item").length;
        },
        enumerable: true,
        configurable: true
    });
    /* EVENT HANDLERS */
    WPAttachmentFormInput.prototype.onWPMediaSelect = function () {
        var selection = this.wpMedia.state().get('selection');
        var __this = this;
        selection.each(function (attachment) {
            if (__this.options.max < 0 || __this.count < __this.options.max) {
                __this.add(attachment.toJSON());
            }
        });
        this.render();
    };
    ;
    WPAttachmentFormInput.prototype.onRemoveClick = function (e) {
        e.preventDefault();
        var $el = jQuery(e.currentTarget);
        $el.closest(".list-group-item").remove();
        this.render();
    };
    return WPAttachmentFormInput;
}());
exports.WPAttachmentFormInput = WPAttachmentFormInput;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!****************************!*\
  !*** ./src/tsc/tutomvc.ts ***!
  \****************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
__webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module '../less/tutomvc.less'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
__webpack_require__(/*! script-loader!bootstrap/dist/js/bootstrap.js */ "./node_modules/script-loader/index.js!./node_modules/bootstrap/dist/js/bootstrap.js");
__webpack_require__(/*! script-loader!select2/dist/js/select2.js */ "./node_modules/script-loader/index.js!./node_modules/select2/dist/js/select2.js");
__webpack_require__(/*! script-loader!bootstrap-select/dist/js/bootstrap-select.js */ "./node_modules/script-loader/index.js!./node_modules/bootstrap-select/dist/js/bootstrap-select.js");
__webpack_require__(/*! ./plugins/jQueryWPAttachmentFormInput */ "./src/tsc/plugins/jQueryWPAttachmentFormInput.ts");
__webpack_require__(/*! ./plugins/jQueryWPEditorFormInput */ "./src/tsc/plugins/jQueryWPEditorFormInput.ts");
__webpack_require__(/*! ./plugins/jQueryWPMetaBox */ "./src/tsc/plugins/jQueryWPMetaBox.ts");
(function ($) {
    $(document).ready(function () {
        // Select2FormInput
        $(".form-input-element.select2").each(function () {
            $(this).select2($(this).data());
        });
    });
})(jQuery);

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHV0b212Yy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxtVEFBbVQsb0VBQW9FLHVEQUF1RCxxSEFBcUgsK0JBQStCLFNBQVMsRUFBRSxRQUFRLHdEQUF3RCwwTUFBME0sUUFBUSxNQUFNLGtDQUFrQyxPQUFPLEtBQUssMEJBQTBCLHVCQUF1QixtQkFBbUIsOEVBQThFLDhLQUE4Syx5REFBeUQsa0NBQWtDLGtyQkFBa3JCLHVVQUF1VSxrWUFBa1ksd0JBQXdCLGtFQUFrRSxxSEFBcUgscURBQXFELHVIQUF1SCxrQ0FBa0MsaUZBQWlGLGlEQUFpRCxpSEFBaUgsT0FBTyxNQUFNLDBDQUEwQyxrQ0FBa0MsU0FBUywrQkFBK0IseUVBQXlFLDZEQUE2RCw0Q0FBNEMsU0FBUyx1REFBdUQseURBQXlELFNBQVMsTUFBTSxpRUFBaUUsc0RBQXNELFVBQVUsTUFBTSxpQ0FBaUMsbURBQW1ELDJEQUEyRCw0Q0FBNEMsMkJBQTJCLGFBQWEsaUVBQWlFLGlHQUFpRyw2REFBNkQsVUFBVSxNQUFNLDBDQUEwQyx1RUFBdUUsa0RBQWtELGVBQWUsYUFBYSxXQUFXLFNBQVMsT0FBTywySUFBMkksMEJBQTBCLDJDQUEyQyxvTkFBb04sb0NBQW9DLDRCQUE0QiwyQ0FBMkMsOEVBQThFLG1EQUFtRCxtQkFBbUIsK0NBQStDLDhFQUE4RSxzREFBc0QsbUJBQW1CLHNEQUFzRCw2REFBNkQsbUJBQW1CLGlEQUFpRCxtREFBbUQsbUJBQW1CLGlCQUFpQixnQkFBZ0IsMENBQTBDLHFDQUFxQyxnSEFBZ0gsaUJBQWlCLG9GQUFvRixjQUFjLGFBQWEsd1NBQXdTLHFEQUFxRCxzRkFBc0YsZUFBZSxhQUFhLFlBQVksOENBQThDLDBFQUEwRSxXQUFXLFNBQVMsVUFBVSxPQUFPLHdEQUF3RCxnREFBZ0Qsc0RBQXNELGtHQUFrRyxzREFBc0QsbUVBQW1FLFNBQVMseURBQXlELHNFQUFzRSxTQUFTLE9BQU8sb0RBQW9ELHNLQUFzSyxvREFBb0QscUVBQXFFLG1FQUFtRSx5QkFBeUIsWUFBWSxNQUFNLDZDQUE2QyxXQUFXLFVBQVUsT0FBTyw2QkFBNkIsOEVBQThFLDBGQUEwRiwyQ0FBMkMsU0FBUyxFQUFFLFFBQVEsa0ZBQWtGLHNCQUFzQix3QkFBd0Isd0dBQXdHLDBGQUEwRiw4QkFBOEIsMERBQTBELHNGQUFzRixjQUFjLGVBQWUsYUFBYSwwQkFBMEIsV0FBVyxJQUFJLDJCQUEyQixVQUFVLDhDQUE4QywrQkFBK0Isb0NBQW9DLGFBQWEsc0NBQXNDLHVFQUF1RSxvQ0FBb0MsYUFBYSw2Q0FBNkMsOENBQThDLG1EQUFtRCwyRUFBMkUsZ0ZBQWdGLDhCQUE4Qix1Q0FBdUMsYUFBYSxpRUFBaUUscUhBQXFILDJCQUEyQixhQUFhLDJCQUEyQiw0Q0FBNEMsdUZBQXVGLDZCQUE2QixlQUFlLGFBQWEsd0JBQXdCLFlBQVksK0JBQStCLDREQUE0RCxnSEFBZ0gsRUFBRSxZQUFZLE1BQU0scURBQXFELFdBQVcsU0FBUyxJQUFJLE9BQU8sNkJBQTZCLGdIQUFnSCwwREFBMEQsNkRBQTZELGdIQUFnSCxXQUFXLDZDQUE2QyxVQUFVLE9BQU8sb0dBQW9HLCtFQUErRSw0QkFBNEIscURBQXFELFdBQVcsU0FBUyxFQUFFLE9BQU8sZ0VBQWdFLDhGQUE4RixpQ0FBaUMsd0RBQXdELFNBQVMsTUFBTSxxQ0FBcUMsMEdBQTBHLGdDQUFnQyxhQUFhLFdBQVcsNkJBQTZCLFNBQVMsbUNBQW1DLE9BQU8sK0ZBQStGLHVHQUF1RyxrREFBa0QsU0FBUyxNQUFNLDJCQUEyQix3R0FBd0csa0NBQWtDLFdBQVcsU0FBUyxtQ0FBbUMsaURBQWlELFNBQVMseUJBQXlCLE9BQU8sMk9BQTJPLHFFQUFxRSwwREFBMEQsMEVBQTBFLHdEQUF3RCxRQUFRLHNDQUFzQywrQ0FBK0MsYUFBYSw4QkFBOEIsc0JBQXNCLFVBQVUsV0FBVyx1QkFBdUIsU0FBUyxPQUFPLElBQUkscURBQXFELDJDQUEyQyxvQ0FBb0MsOERBQThELDRFQUE0RSx3Q0FBd0MsRUFBRSxZQUFZLE1BQU0sa0hBQWtILG9EQUFvRCxXQUFXLHNDQUFzQyxVQUFVLHlCQUF5Qix5REFBeUQsc0NBQXNDLGdEQUFnRCxVQUFVLE1BQU0sMEVBQTBFLFNBQVMsUUFBUSw4RkFBOEYsaUpBQWlKLDRCQUE0Qix3QkFBd0IsTUFBTSxnRkFBZ0YsMkJBQTJCLHVDQUF1Qyw2SUFBNkksc0RBQXNELGFBQWEsZ0VBQWdFLDBDQUEwQyw0Q0FBNEMsZ0VBQWdFLGNBQWMsTUFBTSw4REFBOEQsYUFBYSx5Q0FBeUMsV0FBVyxTQUFTLGlDQUFpQyxPQUFPLHNDQUFzQyx3Q0FBd0MsT0FBTywrSUFBK0ksdTFHQUF1MUcsa0tBQWtLLDBlQUEwZSxxR0FBcUcsZ1RBQWdULHVDQUF1QyxvQ0FBb0MsUUFBUSw2Q0FBNkMsbUNBQW1DLHdGQUF3RixPQUFPLHVFQUF1RSxtQkFBbUIsb0JBQW9CLG9CQUFvQix1QkFBdUIsd0JBQXdCLHNCQUFzQixTQUFTLGdJQUFnSSx3Q0FBd0MsNEJBQTRCLFVBQVUsZ0lBQWdJLHdDQUF3QyxnREFBZ0Qsa0NBQWtDLHFEQUFxRCwyRkFBMkYsVUFBVSxRQUFRLG9EQUFvRCxzT0FBc08sOExBQThMLCtrQkFBK2tCLDBCQUEwQix1WUFBdVkseUJBQXlCLGlEQUFpRCxlQUFlLDBGQUEwRix3Q0FBd0MsK0JBQStCLFFBQVEsYUFBYSw0QkFBNEIsMkJBQTJCLHVDQUF1Qyw0QkFBNEIsOGFBQThhLDBCQUEwQiwwQ0FBMEMsa0NBQWtDLGlYQUFpWCw0RUFBNEUsMERBQTBELDREQUE0RCxxREFBcUQsNERBQTRELHlFQUF5RSwrQ0FBK0MsOEVBQThFLHVGQUF1Rix5RkFBeUYsZ0NBQWdDLG1EQUFtRCx3REFBd0QsNEJBQTRCLG9FQUFvRSxzQ0FBc0MsY0FBYyxNQUFNLHFDQUFxQyxhQUFhLFdBQVcsMkZBQTJGLDZHQUE2Ryx3QkFBd0IsU0FBUyxrREFBa0QscURBQXFELHlCQUF5Qix1Q0FBdUMsa0NBQWtDLGNBQWMsTUFBTSxzREFBc0QsYUFBYSxXQUFXLDhIQUE4SCxzREFBc0QsdUJBQXVCLFNBQVMsb0RBQW9ELDBIQUEwSCxvQ0FBb0Msb0RBQW9ELFlBQVksTUFBTSxtREFBbUQsbUNBQW1DLDRFQUE0RSxxUUFBcVEsaUZBQWlGLHFFQUFxRSxnRUFBZ0UsYUFBYSxzQ0FBc0MseUVBQXlFLDJEQUEyRCxzREFBc0QsYUFBYSxXQUFXLHlDQUF5Qyx1REFBdUQsK0VBQStFLGFBQWEsWUFBWSxNQUFNLCtEQUErRCxXQUFXLCtDQUErQyxTQUFTLHdDQUF3QywwSEFBMEgsc0RBQXNELGlDQUFpQywwRUFBMEUscUVBQXFFLCtFQUErRSxtRUFBbUUsOERBQThELFdBQVcsb0NBQW9DLHVFQUF1RSx5REFBeUQsb0RBQW9ELFdBQVcsaUVBQWlFLCtDQUErQyxTQUFTLE9BQU8sNkRBQTZELGtDQUFrQyx3RkFBd0YsRUFBRSwwQ0FBMEMsZ0ZBQWdGLFNBQVMsT0FBTywwREFBMEQsd0JBQXdCLGtKQUFrSixnREFBZ0QscUNBQXFDLFNBQVMsdUNBQXVDLGdDQUFnQyw0QkFBNEIsMEJBQTBCLCtCQUErQiw2QkFBNkIsa0JBQWtCLHFCQUFxQixzQkFBc0IsaUVBQWlFLGtEQUFrRCx5REFBeUQsa0NBQWtDLCtDQUErQyw0REFBNEQsaUJBQWlCLE9BQU8sZUFBZSxhQUFhLFdBQVcsVUFBVSwrQkFBK0IsaU1BQWlNLDJEQUEyRCxTQUFTLG9GQUFvRix5Q0FBeUMsd0VBQXdFLFNBQVMsa0ZBQWtGLG9EQUFvRCxzREFBc0Qsd0RBQXdELDBEQUEwRCw4REFBOEQsc0RBQXNELG9EQUFvRCxnREFBZ0QsZ0RBQWdELHdCQUF3QixRQUFRLDJDQUEyQywySEFBMkgsMkZBQTJGLEVBQUUsK0RBQStELHdDQUF3QyxHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixTQUFTLHNEQUFzRCwrREFBK0QsR0FBRyw4QkFBOEIsR0FBRyxpRUFBaUUsR0FBRyxvQ0FBb0MsR0FBRyx1QkFBdUIsU0FBUywrd0JBQSt3Qix5REFBeUQsb1JBQW9SLG9DQUFvQyxxRUFBcUUsaUpBQWlKLHlCQUF5QixrREFBa0Qsd0RBQXdELDZEQUE2RCwyREFBMkQsNERBQTRELHlDQUF5QyxXQUFXLHVEQUF1RCwyQkFBMkIsb0dBQW9HLGlLQUFpSyw0REFBNEQsa0RBQWtELFdBQVcsaUVBQWlFLGdFQUFnRSwwREFBMEQscURBQXFELDJEQUEyRCw4R0FBOEcsOENBQThDLDZDQUE2QyxXQUFXLG1DQUFtQywrQkFBK0IsNENBQTRDLHNDQUFzQyxvREFBb0QsWUFBWSxNQUFNLG9EQUFvRCxXQUFXLDhCQUE4Qix3QkFBd0IsMEJBQTBCLHVDQUF1QyxrQ0FBa0MsWUFBWSxNQUFNLDhEQUE4RCxxQ0FBcUMsK0pBQStKLDBMQUEwTCx3Q0FBd0MsZUFBZSxhQUFhLEVBQUUsV0FBVyx3Q0FBd0MsOENBQThDLGlEQUFpRCxtQ0FBbUMsOENBQThDLDJEQUEyRCxhQUFhLGlEQUFpRCw2REFBNkQsYUFBYSwrQ0FBK0MsMkRBQTJELGFBQWEsZ0RBQWdELDREQUE0RCxhQUFhLFdBQVcsRUFBRSxxREFBcUQsaUVBQWlFLDBEQUEwRCxrR0FBa0cscU5BQXFOLGlCQUFpQiwwREFBMEQsMEtBQTBLLDREQUE0RCxpQkFBaUIsRUFBRSxtRUFBbUUsK0RBQStELHFEQUFxRCxlQUFlLEVBQUUsYUFBYSxFQUFFLFdBQVcsc0NBQXNDLDZCQUE2Qix3REFBd0QsV0FBVyxFQUFFLFNBQVMsMENBQTBDLGtYQUFrWCx3RkFBd0YsNENBQTRDLFdBQVcsK0pBQStKLHdDQUF3QywyS0FBMkssMEVBQTBFLFdBQVcsNENBQTRDLGtoQkFBa2hCLFdBQVcsNkRBQTZELHdrQkFBd2tCLFdBQVcsNkRBQTZELGlXQUFpVyxXQUFXLG1nREFBbWdELDZCQUE2QixTQUFTLDJDQUEyQyxtREFBbUQsMENBQTBDLDZEQUE2RCw4QkFBOEIsMkNBQTJDLE1BQU0sMkZBQTJGLDRDQUE0QyxtQ0FBbUMsc0RBQXNELGNBQWMsd0NBQXdDLG1DQUFtQyw2REFBNkQsY0FBYyxNQUFNLGlEQUFpRCxhQUFhLHNEQUFzRCx1RUFBdUUsbUNBQW1DLDRDQUE0Qyx3REFBd0QsdUhBQXVILGFBQWEseUdBQXlHLFdBQVcsU0FBUyxxQ0FBcUMseUtBQXlLLFNBQVMsbUVBQW1FLGdJQUFnSSwwREFBMEQsc0dBQXNHLHFDQUFxQyw0QkFBNEIsMEJBQTBCLHVEQUF1RCxjQUFjLDBCQUEwQiw0SEFBNEgsVUFBVSx5RkFBeUYsbUpBQW1KLG1DQUFtQyx3R0FBd0csaUJBQWlCLGVBQWUsYUFBYSxXQUFXLHNDQUFzQywwR0FBMEcsb0VBQW9FLGtDQUFrQyxXQUFXLEVBQUUsaURBQWlELDJaQUEyWiw2REFBNkQscUdBQXFHLDJGQUEyRixtREFBbUQsZ0JBQWdCLE1BQU0sbURBQW1ELDZDQUE2QyxrQ0FBa0MsZUFBZSx3SEFBd0gsbUNBQW1DLCtKQUErSixpQ0FBaUMsZUFBZSxhQUFhLGlFQUFpRSxxR0FBcUcsMkhBQTJILG1FQUFtRSx1SEFBdUgsd0hBQXdILHFKQUFxSixxREFBcUQsaUZBQWlGLHlFQUF5RSw2RUFBNkUsNkJBQTZCLDhEQUE4RCwyQ0FBMkMsaUJBQWlCLDZDQUE2QyxlQUFlLG9GQUFvRiwyQ0FBMkMsZUFBZSxhQUFhLHFKQUFxSiwyQ0FBMkMsYUFBYSxrREFBa0QsOEhBQThILDRDQUE0Qyw0RkFBNEYsZ0JBQWdCLE1BQU0sc0tBQXNLLGVBQWUseUNBQXlDLG9UQUFvVCw2TUFBNk0sdVdBQXVXLHdLQUF3SywwRUFBMEUsd0JBQXdCLE1BQU0sMkdBQTJHLGtEQUFrRCwrQ0FBK0MscUNBQXFDLHlHQUF5Ryw2RkFBNkYsZ0RBQWdELHFEQUFxRCx1QkFBdUIscUJBQXFCLG1CQUFtQix3REFBd0QsaUJBQWlCLHFFQUFxRSw0RkFBNEYsaUJBQWlCLDZDQUE2QywySkFBMkosdU5BQXVOLDhFQUE4RSxnRkFBZ0Ysa0JBQWtCLE1BQU0sMkRBQTJELDhEQUE4RCxpQkFBaUIsbUVBQW1FLGdSQUFnUiw2RUFBNkUsd0pBQXdKLG1HQUFtRyxvQkFBb0IsbUVBQW1FLGdIQUFnSCwrRUFBK0Usa0ZBQWtGLDBFQUEwRSxxR0FBcUcscUJBQXFCLDZHQUE2RyxtQkFBbUIsaUJBQWlCLGVBQWUsYUFBYSx3REFBd0QsK0NBQStDLCtDQUErQyxjQUFjLCtCQUErQix3REFBd0Qsb0VBQW9FLHVGQUF1RixlQUFlLDRFQUE0RSx5RUFBeUUsaUZBQWlGLFFBQVEsNENBQTRDLGFBQWEsV0FBVyw0TEFBNEwsd0VBQXdFLHFFQUFxRSxhQUFhLEVBQUUsU0FBUyx3REFBd0QsbUJBQW1CLDZFQUE2RSxrQ0FBa0Msd0JBQXdCLDBFQUEwRSwrREFBK0QseUNBQXlDLCtFQUErRSwyQ0FBMkMsMENBQTBDLGVBQWUsYUFBYSxXQUFXLFNBQVMseUNBQXlDLG1CQUFtQiwwQ0FBMEMsd0VBQXdFLFdBQVcsU0FBUywwQ0FBMEMsNERBQTRELHlEQUF5RCwySEFBMkgsMFBBQTBQLDRvQkFBNG9CLHVDQUF1Qyx3SUFBd0ksNERBQTRELGlmQUFpZixhQUFhLHlGQUF5RiwyRkFBMkYsYUFBYSx3UkFBd1Isd0NBQXdDLGNBQWMsOENBQThDLHVQQUF1UCwyRkFBMkYsZUFBZSxFQUFFLGFBQWEsV0FBVyxpQ0FBaUMsU0FBUyxxQ0FBcUMsMExBQTBMLDZKQUE2SixtR0FBbUcsNENBQTRDLDZEQUE2RCxxT0FBcU8scUJBQXFCLGFBQWEsc0NBQXNDLG9DQUFvQyxzQ0FBc0MsV0FBVyxtREFBbUQsa0NBQWtDLGdGQUFnRixxQ0FBcUMsMEJBQTBCLGtEQUFrRCxFQUFFLGNBQWMsTUFBTSx3UEFBd1AsdUVBQXVFLDBEQUEwRCwrQ0FBK0MsK0NBQStDLHVFQUF1RSxpRUFBaUUsbUVBQW1FLDZEQUE2RCwyQ0FBMkMsaUVBQWlFLHFDQUFxQyxxQ0FBcUMscUNBQXFDLGtEQUFrRCxxRUFBcUUsd0NBQXdDLGFBQWEsV0FBVywyREFBMkQsOFNBQThTLDRDQUE0Qyw4QkFBOEIsNlNBQTZTLHVEQUF1RCx3QkFBd0IsK0JBQStCLDJCQUEyQixjQUFjLEVBQUUsYUFBYSxxQ0FBcUMsc0NBQXNDLHNEQUFzRCxTQUFTLE1BQU0sc0NBQXNDLGdDQUFnQyxrREFBa0QsOENBQThDLGVBQWUscUNBQXFDLGdPQUFnTyxFQUFFLGFBQWEsMkJBQTJCLDJCQUEyQixjQUFjLEVBQUUsYUFBYSxXQUFXLG1FQUFtRSxTQUFTLE1BQU0sd0NBQXdDLGtEQUFrRCxnQ0FBZ0MsRUFBRSxjQUFjLE1BQU0sNENBQTRDLGFBQWEsV0FBVyxzRkFBc0YsU0FBUyxxQ0FBcUMsc0pBQXNKLHVHQUF1Ryx1SEFBdUgsdUVBQXVFLFdBQVcsNENBQTRDLDZEQUE2RCxvQ0FBb0MseU5BQXlOLDBCQUEwQiwwVUFBMFUsK0NBQStDLDZFQUE2RSxpQkFBaUIsMEJBQTBCLHFQQUFxUCwwQkFBMEIsYUFBYSx5Q0FBeUMseUNBQXlDLGdMQUFnTCxvRUFBb0Usd0hBQXdILDBEQUEwRCxrREFBa0QsMFNBQTBTLGFBQWEsV0FBVyx1REFBdUQsU0FBUyxNQUFNLHFDQUFxQyxtQ0FBbUMsV0FBVyxrR0FBa0csU0FBUyxtQ0FBbUMscURBQXFELFNBQVMsa0NBQWtDLDJ2QkFBMnZCLHFJQUFxSSxtRUFBbUUsOEZBQThGLFdBQVcsaUVBQWlFLDZEQUE2RCwwQkFBMEIsUUFBUSxZQUFZLE1BQU0sc0hBQXNILDZIQUE2SCxvRUFBb0UsZ0lBQWdJLGFBQWEsMkhBQTJILHlDQUF5Qyw0Q0FBNEMsK0JBQStCLGtCQUFrQiwyQ0FBMkMseUxBQXlMLGlFQUFpRSxvRkFBb0YscUJBQXFCLDJDQUEyQyx1REFBdUQsc0JBQXNCLG9CQUFvQix5RUFBeUUsMkVBQTJFLDBDQUEwQyx3QkFBd0IsTUFBTSxvREFBb0QsNERBQTRELHlCQUF5QiwwSUFBMEksc0VBQXNFLHVCQUF1QixxQkFBcUIsc0dBQXNHLG9CQUFvQixNQUFNLDBCQUEwQixtQkFBbUIsaUJBQWlCLDRFQUE0RSw0RUFBNEUsaUJBQWlCLGVBQWUsY0FBYyxNQUFNLDZHQUE2RyxpRkFBaUYseWNBQXljLGtFQUFrRSx5Q0FBeUMsRUFBRSx1Q0FBdUMsRUFBRSx3Q0FBd0MsUUFBUSxhQUFhLFdBQVcsb0RBQW9ELG1KQUFtSixXQUFXLDZLQUE2Syw0REFBNEQsK0hBQStILFFBQVEsV0FBVywyS0FBMkssd0RBQXdELDJGQUEyRixXQUFXLHlDQUF5QyxpREFBaUQsaUdBQWlHLDBIQUEwSCxrREFBa0QsbUNBQW1DLHVEQUF1RCxjQUFjLE1BQU0sd0NBQXdDLGFBQWEsV0FBVyw0REFBNEQsU0FBUyw2SEFBNkgsZ0tBQWdLLGdEQUFnRCxpSkFBaUosV0FBVyxzQ0FBc0MsNENBQTRDLG1WQUFtVix3REFBd0QsYUFBYSxXQUFXLDZCQUE2QiwwQ0FBMEMsWUFBWSxNQUFNLGdDQUFnQyxXQUFXLG9DQUFvQyxrR0FBa0csWUFBWSw4QkFBOEIscUdBQXFHLFlBQVksTUFBTSx5RkFBeUYsa0dBQWtHLFdBQVcsU0FBUywyQ0FBMkMscUdBQXFHLGdyQ0FBZ3JDLDBFQUEwRSxzQ0FBc0Msc0ZBQXNGLDRGQUE0RixzQ0FBc0MsaUpBQWlKLG1FQUFtRSwyREFBMkQsa0hBQWtILGlEQUFpRCx1REFBdUQsbUVBQW1FLDBEQUEwRCw0QkFBNEIsMkNBQTJDLE1BQU0sMkRBQTJELDJDQUEyQyxrQ0FBa0Msc0JBQXNCLGVBQWUsYUFBYSxZQUFZLE1BQU0sc0RBQXNELGdDQUFnQyw4QkFBOEIsV0FBVywrREFBK0Qsd0RBQXdELDRGQUE0RixXQUFXLDZDQUE2Qyw4Q0FBOEMscURBQXFELCtDQUErQyx1QkFBdUIsd0RBQXdELDhDQUE4Qyw2Q0FBNkMsc0NBQXNDLHFDQUFxQyxXQUFXLGlEQUFpRCxnREFBZ0Qsc0NBQXNDLHVEQUF1RCx1Q0FBdUMsb0RBQW9ELGl1QkFBaXVCLDZ5QkFBNnlCLDZCQUE2Qiw4ZEFBOGQsOEJBQThCLG1EQUFtRCw0REFBNEQsb0RBQW9ELGdEQUFnRCxvRUFBb0Usb0RBQW9ELG9EQUFvRCxzREFBc0QsNERBQTRELHNEQUFzRCxrREFBa0QsZ0RBQWdELDhDQUE4Qyw0RUFBNEUsaUVBQWlFLHdEQUF3RCx3RUFBd0UscUNBQXFDLFNBQVMsNkNBQTZDLDBMQUEwTCwwRkFBMEYsK0NBQStDLDJFQUEyRSw2RUFBNkUsWUFBWSxNQUFNLDZCQUE2QixrQkFBa0IsV0FBVyxzREFBc0QsK0ZBQStGLHVKQUF1SiwrRkFBK0YseUpBQXlKLHFEQUFxRCxzREFBc0QsU0FBUyw2Q0FBNkMsbUNBQW1DLDJxQkFBMnFCLDRDQUE0QywrWUFBK1ksME1BQTBNLGdLQUFnSyxrREFBa0QsYUFBYSwwRUFBMEUsZ0RBQWdELFdBQVcsaURBQWlELDRJQUE0SSx1RkFBdUYsb0dBQW9HLDRFQUE0RSxtRUFBbUUseUZBQXlGLGFBQWEsdUNBQXVDLDZIQUE2SCxZQUFZLDZIQUE2SCw0QkFBNEIsdUJBQXVCLE1BQU0sb0ZBQW9GLGFBQWEscUdBQXFHLDREQUE0RCxvR0FBb0csZ0RBQWdELFdBQVcsOEJBQThCLGlJQUFpSSxFQUFFLG1DQUFtQyxnSkFBZ0osRUFBRSxnTUFBZ00sZ0xBQWdMLDhDQUE4QyxrR0FBa0csV0FBVywrREFBK0QsNk1BQTZNLFdBQVcseUZBQXlGLFNBQVMsMENBQTBDLGlDQUFpQyx3RUFBd0UsZ0RBQWdELGdFQUFnRSxtQ0FBbUMsOENBQThDLGtMQUFrTCw0Q0FBNEMsaUJBQWlCLEVBQUUsYUFBYSxtREFBbUQsa1VBQWtVLDRDQUE0QyxpQkFBaUIsRUFBRSxjQUFjLDZIQUE2SCxzSkFBc0osYUFBYSxXQUFXLG9EQUFvRCxTQUFTLG9DQUFvQywwQkFBMEIsa0RBQWtELCtDQUErQywrQ0FBK0Msc0VBQXNFLGdDQUFnQyxtQ0FBbUMsMk9BQTJPLDBDQUEwQyxrTEFBa0wsZ0ZBQWdGLGVBQWUsRUFBRSxhQUFhLEVBQUUsWUFBWSx3Q0FBd0Msc0hBQXNILG9FQUFvRSxZQUFZLDhCQUE4QixzSEFBc0gsOERBQThELFlBQVksTUFBTSxnSEFBZ0gsOENBQThDLFdBQVcsK0pBQStKLDhEQUE4RCxXQUFXLFNBQVMsMENBQTBDLGtFQUFrRSw2TUFBNk0sMENBQTBDLHNZQUFzWSxvTEFBb0wsd0NBQXdDLGlEQUFpRCxxREFBcUQsMEdBQTBHLDZHQUE2RyxrQkFBa0IsTUFBTSxtQ0FBbUMsa0JBQWtCLGlCQUFpQix1R0FBdUcsb0lBQW9JLG9GQUFvRix3RUFBd0UsaUJBQWlCLHNFQUFzRSw2REFBNkQsZ0JBQWdCLHlFQUF5RSxvQ0FBb0MscUJBQXFCLGFBQWEsK0NBQStDLHNNQUFzTSxXQUFXLEVBQUUsd1BBQXdQLHdFQUF3RSwrREFBK0QsYUFBYSxFQUFFLGdFQUFnRSwyREFBMkQsdUNBQXVDLFdBQVcsRUFBRSxTQUFTLHVEQUF1RCwwQkFBMEIsb0NBQW9DLDRHQUE0Ryw0QkFBNEIsbURBQW1ELE1BQU0seUlBQXlJLCtCQUErQiw0Q0FBNEMsMkhBQTJILGlCQUFpQix1SEFBdUgsZUFBZSxhQUFhLFdBQVcsU0FBUyxtQ0FBbUMsUUFBUSx3RUFBd0UsU0FBUyxzSUFBc0ksczBCQUFzMEIseUNBQXlDLGdDQUFnQyw2QkFBNkIsdUNBQXVDLFdBQVcsd0RBQXdELCtCQUErQix1Q0FBdUMsc0RBQXNELHFDQUFxQyxZQUFZLE1BQU0saUNBQWlDLFdBQVcsc0JBQXNCLHFEQUFxRCwrQkFBK0Isb0RBQW9ELGNBQWMsTUFBTSxrQ0FBa0MsdURBQXVELGdCQUFnQixNQUFNLG1EQUFtRCxlQUFlLGFBQWEsV0FBVyx1R0FBdUcsK0VBQStFLDZDQUE2QyxXQUFXLFNBQVMsbUNBQW1DLFFBQVEseUVBQXlFLFNBQVMsbUlBQW1JLDBFQUEwRSxxRUFBcUUsZ0NBQWdDLGlFQUFpRSxzQkFBc0IseUZBQXlGLCtCQUErQix3REFBd0QsNkNBQTZDLGNBQWMsTUFBTSxpREFBaUQsNENBQTRDLGFBQWEsV0FBVyxTQUFTLHNDQUFzQywyQ0FBMkMsU0FBUyx5Q0FBeUMsa0NBQWtDLG1FQUFtRSxtRkFBbUYsWUFBWSxNQUFNLDBFQUEwRSx3RUFBd0UseUZBQXlGLGFBQWEsV0FBVyxTQUFTLHlDQUF5QyxnRUFBZ0UsbURBQW1ELHFEQUFxRCx1RkFBdUYsaUNBQWlDLG1EQUFtRCxhQUFhLFdBQVcsRUFBRSxtRUFBbUUsc0RBQXNELCtEQUErRCxrREFBa0QsYUFBYSxXQUFXLEVBQUUseUVBQXlFLDhEQUE4RCw2QkFBNkIsYUFBYSxXQUFXLEVBQUUsb0NBQW9DLDBDQUEwQywrQ0FBK0MsY0FBYyxNQUFNLCtDQUErQyxhQUFhLFdBQVcsNkNBQTZDLGtHQUFrRyx5QkFBeUIsY0FBYyxNQUFNLHVEQUF1RCxhQUFhLFdBQVcsaUVBQWlFLG9GQUFvRiw4RUFBOEUsYUFBYSx3Q0FBd0MsdURBQXVELGNBQWMsTUFBTSx5QkFBeUIsYUFBYSxXQUFXLEVBQUUsZ0tBQWdLLDZTQUE2Uyx5REFBeUQsV0FBVyxFQUFFLDhFQUE4RSxxZkFBcWYsb0hBQW9ILGtDQUFrQyxhQUFhLG1DQUFtQyw0SUFBNEksb1hBQW9YLDZFQUE2RSxzQ0FBc0Msd0RBQXdELDZDQUE2QyxlQUFlLHdDQUF3QywwR0FBMEcsdUNBQXVDLHFEQUFxRCxnQkFBZ0IsT0FBTyxpR0FBaUcsMkRBQTJELDJDQUEyQywwRUFBMEUsa0xBQWtMLDJGQUEyRix3REFBd0QsaURBQWlELDZDQUE2QyxpREFBaUQsc0JBQXNCLCtDQUErQyxzQ0FBc0MsNkJBQTZCLE1BQU0sMERBQTBELGlEQUFpRCxpRUFBaUUsdUJBQXVCLGlEQUFpRCwyREFBMkQsc0JBQXNCLE1BQU0sZ1lBQWdZLEVBQUUsZ0ZBQWdGLEVBQUUsd0ZBQXdGLDZCQUE2QixLQUFLLGdIQUFnSCxrREFBa0QsSUFBSSw2Q0FBNkMsd0RBQXdELElBQUksZ0RBQWdELHVCQUF1QixrREFBa0QscURBQXFELHlEQUF5RCx1RUFBdUUsOENBQThDLHdFQUF3RSx1QkFBdUIsK0RBQStELDBFQUEwRSw4Q0FBOEMsMkVBQTJFLHVCQUF1QixrREFBa0QsOERBQThELHVCQUF1QixNQUFNLDhEQUE4RCxrREFBa0QseUNBQXlDLHVCQUF1QixRQUFRLHFCQUFxQixtQkFBbUIsaUJBQWlCLGVBQWUsMkZBQTJGLDhDQUE4QyxnQkFBZ0IsbUNBQW1DLGlEQUFpRCxlQUFlLDhFQUE4RSwyRUFBMkUsa1BBQWtQLDRFQUE0RSxpQkFBaUIsZUFBZSxhQUFhLFdBQVcsRUFBRSwwS0FBMEssMENBQTBDLGlDQUFpQyxrQ0FBa0MsOEVBQThFLGlEQUFpRCxnQkFBZ0IsTUFBTSw4Q0FBOEMsZUFBZSxhQUFhLFdBQVcsRUFBRSxzRkFBc0YsK0JBQStCLGdDQUFnQywwQ0FBMEMsK0NBQStDLGNBQWMsTUFBTSw0Q0FBNEMsYUFBYSxXQUFXLEVBQUUsOEZBQThGLDBDQUEwQyxXQUFXLEVBQUUsd0RBQXdELGdDQUFnQyxXQUFXLEVBQUUsbUVBQW1FLDBDQUEwQywrQ0FBK0MsY0FBYyxNQUFNLDRDQUE0QyxhQUFhLG1DQUFtQyxnQ0FBZ0Msd0RBQXdELCtCQUErQixjQUFjLE1BQU0saUNBQWlDLGFBQWEsV0FBVyxFQUFFLDZFQUE2RSx1RUFBdUUsMkpBQTJKLCtLQUErSywwSUFBMEksMkRBQTJELGVBQWUsYUFBYSxtREFBbUQseUtBQXlLLDJGQUEyRixrREFBa0QsNERBQTRELGVBQWUsYUFBYSxFQUFFLDhFQUE4RSw0QkFBNEIsNkVBQTZFLHNDQUFzQyxhQUFhLG1EQUFtRCxnRUFBZ0UsYUFBYSxFQUFFLFNBQVMsOENBQThDLDBCQUEwQix5RUFBeUUsMENBQTBDLHNDQUFzQyxpRUFBaUUsYUFBYSxXQUFXLEVBQUUsc0lBQXNJLGdDQUFnQyxXQUFXLEVBQUUsc0VBQXNFLHVEQUF1RCx1REFBdUQsK0NBQStDLGtDQUFrQyxtSUFBbUksMEpBQTBKLDhEQUE4RCxrQ0FBa0Msd0NBQXdDLE1BQU0sd0RBQXdELG9DQUFvQywrRUFBK0UsaUJBQWlCLDhHQUE4RywyQ0FBMkMscURBQXFELHNEQUFzRCxtQkFBbUIsbURBQW1ELGdEQUFnRCxxREFBcUQsaUJBQWlCLG1GQUFtRixlQUFlLDhEQUE4RCxjQUFjLE1BQU0sd05BQXdOLHdJQUF3SSx5REFBeUQsMkVBQTJFLGlCQUFpQixlQUFlLCtDQUErQyxtQ0FBbUMsMkNBQTJDLDhEQUE4RCxvQ0FBb0MsaUVBQWlFLGNBQWMsbURBQW1ELDhEQUE4RCxxQ0FBcUMsYUFBYSxzRUFBc0UsV0FBVyxFQUFFLFNBQVMsd0NBQXdDLDREQUE0RCxTQUFTLG9DQUFvQyx5Q0FBeUMsaURBQWlELHFEQUFxRCwyREFBMkQsc0hBQXNILGlFQUFpRSxrQ0FBa0MsMkNBQTJDLGdCQUFnQixNQUFNLG1GQUFtRixVQUFVLDhEQUE4RCw4REFBOEQsMERBQTBELGlCQUFpQixlQUFlLGFBQWEsOEJBQThCLHdDQUF3QyxxQ0FBcUMsWUFBWSxNQUFNLHVDQUF1QyxXQUFXLFNBQVMsMkNBQTJDLHFDQUFxQywyREFBMkQscUtBQXFLLHdEQUF3RCx3RkFBd0YsU0FBUyxNQUFNLHdFQUF3RSw4RUFBOEUsc0RBQXNELHVDQUF1QyxxREFBcUQsYUFBYSxXQUFXLDJEQUEyRCwrREFBK0QscUNBQXFDLHlEQUF5RCxnRUFBZ0UsU0FBUyxxQ0FBcUMsc0NBQXNDLFNBQVMsdUNBQXVDLHVDQUF1QyxTQUFTLG1DQUFtQyxnQ0FBZ0MseUNBQXlDLGlFQUFpRSxTQUFTLG9DQUFvQyw2dUJBQTZ1QiwrR0FBK0csb0VBQW9FLDZQQUE2UCwrREFBK0QsOENBQThDLCtDQUErQyxxQkFBcUIsYUFBYSxXQUFXLDREQUE0RCwrQkFBK0IsZ0ZBQWdGLFdBQVcsZ0NBQWdDLHVEQUF1RCw2RUFBNkUsNEdBQTRHLG1DQUFtQyx5Q0FBeUMsYUFBYSxxREFBcUQsNkNBQTZDLGdFQUFnRSxnRkFBZ0Ysc0hBQXNILDREQUE0RCxlQUFlLGNBQWMseURBQXlELDZCQUE2QixzSUFBc0ksZ0ZBQWdGLG1IQUFtSCxlQUFlLGFBQWEsbUNBQW1DLHNEQUFzRCxxREFBcUQsbUlBQW1JLCtFQUErRSxrRkFBa0YsZ0JBQWdCLE1BQU0seUVBQXlFLDZEQUE2RCxzREFBc0QsZUFBZSxjQUFjLHlEQUF5RCx5SUFBeUksaURBQWlELCtFQUErRSxnQkFBZ0IsTUFBTSx5RUFBeUUsMkVBQTJFLHNEQUFzRCxlQUFlLGFBQWEsNkVBQTZFLHVGQUF1Rix5Q0FBeUMsZ0VBQWdFLHdFQUF3RSw4Q0FBOEMsK0NBQStDLGNBQWMsTUFBTSxxQ0FBcUMsYUFBYSxZQUFZLGdMQUFnTCxvRkFBb0YsbUNBQW1DLDRFQUE0RSxxSUFBcUksaUhBQWlILGtFQUFrRSx3SkFBd0osZ0RBQWdELGFBQWEsMkRBQTJELDJDQUEyQyxNQUFNLG9GQUFvRiw4RUFBOEUsMkVBQTJFLHVDQUF1QyxlQUFlLGFBQWEscUNBQXFDLGlDQUFpQywrRUFBK0Usa0lBQWtJLCtEQUErRCxpRkFBaUYsaUNBQWlDLGtCQUFrQixNQUFNLCtCQUErQixpQkFBaUIsZUFBZSxvREFBb0Qsc0VBQXNFLDBEQUEwRCw2REFBNkQsb0NBQW9DLGdCQUFnQixNQUFNLDJFQUEyRSxzTUFBc00sZUFBZSwwRUFBMEUseURBQXlELDJDQUEyQyw0REFBNEQsMEVBQTBFLHlDQUF5QyxhQUFhLFdBQVcscVpBQXFaLCtEQUErRCw2RUFBNkUsd0VBQXdFLDJEQUEyRCxpREFBaUQsaUhBQWlILDhIQUE4SCxlQUFlLGFBQWEsV0FBVyxTQUFTLGtDQUFrQyxzSEFBc0gsMERBQTBELFNBQVMsbUNBQW1DLGtHQUFrRyxzQ0FBc0MsZ0NBQWdDLG1DQUFtQywyQkFBMkIsMEJBQTBCLHdCQUF3QiwyQkFBMkIsMEJBQTBCLGlDQUFpQyw2REFBNkQsU0FBUyxnQ0FBZ0Msa0NBQWtDLFNBQVMsZ0NBQWdDLGtDQUFrQyxTQUFTLGtDQUFrQyxvQ0FBb0MsaUNBQWlDLFNBQVMsbUNBQW1DLDBEQUEwRCxzQ0FBc0MsdUNBQXVDLFlBQVksTUFBTSxnQ0FBZ0MsV0FBVyx3R0FBd0csMEdBQTBHLFdBQVcsdUpBQXVKLDZEQUE2RCxTQUFTLFFBQVEsa0hBQWtILDRFQUE0RSxzTkFBc04saUNBQWlDLHFGQUFxRixvREFBb0QsOEZBQThGLFlBQVksYUFBYSx1R0FBdUcsb0ZBQW9GLGNBQWMsTUFBTSx1REFBdUQsc1pBQXNaLGFBQWEsV0FBVyw4Q0FBOEMsaUNBQWlDLFNBQVMsd0NBQXdDLGdNQUFnTSwwRkFBMEYseUNBQXlDLEVBQUUsc0ZBQXNGLHlDQUF5QyxFQUFFLHNGQUFzRix5Q0FBeUMsRUFBRSxzREFBc0QsbUNBQW1DLCtDQUErQyxzREFBc0QsbUNBQW1DLGdEQUFnRCw4QkFBOEIscUJBQXFCLE1BQU0scUNBQXFDLDhFQUE4RSxXQUFXLFNBQVMsc0JBQXNCLDJDQUEyQyw4QkFBOEIsbUNBQW1DLGtIQUFrSCw0QkFBNEIsZ0RBQWdELHdEQUF3RCwwSUFBMEksa0RBQWtELGlCQUFpQixlQUFlLDBDQUEwQyx5REFBeUQsMkJBQTJCLDJDQUEyQyx3R0FBd0csOENBQThDLGtGQUFrRixjQUFjLG1CQUFtQixzQ0FBc0MsdUVBQXVFLCtDQUErQyxpQkFBaUIsZUFBZSxhQUFhLGlEQUFpRCxzREFBc0Qsd0RBQXdELGdCQUFnQixNQUFNLDhDQUE4QyxlQUFlLGFBQWEsV0FBVyxTQUFTLEVBQUUsK0NBQStDLG1FQUFtRSxVQUFVLE1BQU0sdUJBQXVCLFNBQVMsT0FBTyxzQ0FBc0MsaUNBQWlDLG1EQUFtRCx3SEFBd0gsZ0NBQWdDLG9CQUFvQixRQUFRLDBIQUEwSCw0QkFBNEIsd05BQXdOLHlEQUF5RCxTQUFTLE9BQU8sa29CQUFrb0IsOEJBQThCLFNBQVMsRUFBRSxrSUFBa0ksNkNBQTZDLHNDQUFzQywyREFBMkQsU0FBUyxRQUFRLEVBQUUsS0FBSyxVQUFVLGFBQWEsR0FBRzs7Ozs7Ozs7OztBQ0F2bzJILGlTQUFpUyx3VUFBd1UsR0FBRyw2QkFBNkIsYUFBYSxxQ0FBcUMsc0NBQXNDLHNDQUFzQyx3QkFBd0IsbUJBQW1CLEVBQUUsY0FBYyw0QkFBNEIsZ0NBQWdDLDREQUE0RCxxREFBcUQseUVBQXlFLEVBQUUsV0FBVyxTQUFTLE9BQU8sb0JBQW9CLDhCQUE4QixLQUFLLHVFQUF1RSxxVUFBcVUseUNBQXlDLDRDQUE0QyxnRkFBZ0Ysb0RBQW9ELGtCQUFrQixPQUFPLEVBQUUsT0FBTyw2RkFBNkYsTUFBTSxzRUFBc0UsVUFBVSxzREFBc0QsUUFBUSx3Q0FBd0Msc0JBQXNCLE1BQU0sc0NBQXNDLDREQUE0RCw0Q0FBNEMsMERBQTBELG1aQUFtWixzQkFBc0IsVUFBVSxxSkFBcUosOEJBQThCLDRCQUE0QixFQUFFLFNBQVMsMEZBQTBGLE9BQU8sd0JBQXdCLE1BQU0saURBQWlELDRDQUE0Qyx1QkFBdUIsa0VBQWtFLE9BQU8sb0JBQW9CLE1BQU0saURBQWlELDRDQUE0QyxnRUFBZ0UsTUFBTSwyREFBMkQscUJBQXFCLGlCQUFpQixRQUFRLHdEQUF3RCwwREFBMEQsbUNBQW1DLDRFQUE0RSx1RUFBdUUsMEhBQTBILGlCQUFpQixRQUFRLG9IQUFvSCxzREFBc0Qsb0hBQW9ILE1BQU0sK0NBQStDLHVEQUF1RCxNQUFNLG1DQUFtQyxrREFBa0QscUJBQXFCLE9BQU8sbURBQW1ELDJCQUEyQixPQUFPLHNEQUFzRCxNQUFNLG9DQUFvQyw2RUFBNkUsa0RBQWtELE9BQU8sOERBQThELDhDQUE4QyxPQUFPLG9CQUFvQixNQUFNLG9DQUFvQyx5RUFBeUUscUJBQXFCLE9BQU8seUdBQXlHLDJKQUEySiw2QkFBNkIsZ0NBQWdDLE9BQU8sd0NBQXdDLG1EQUFtRCxnRUFBZ0UsdUJBQXVCLFNBQVMsaUNBQWlDLHVCQUF1QixTQUFTLE9BQU8sZ0NBQWdDLE1BQU0scUNBQXFDLCtEQUErRCxvQkFBb0IsT0FBTyxxREFBcUQsb0JBQW9CLE9BQU8sc0RBQXNELGdDQUFnQyxPQUFPLGdHQUFnRyxNQUFNLHlDQUF5QyxtREFBbUQsb0JBQW9CLFFBQVEseUhBQXlILDJDQUEyQyx3REFBd0QsT0FBTyw0Q0FBNEMsdUJBQXVCLFFBQVEsdUVBQXVFLG9CQUFvQixPQUFPLGtEQUFrRCxNQUFNLDRCQUE0QiwwRUFBMEUsYUFBYSxnTUFBZ00sNEJBQTRCLGtEQUFrRCwrQkFBK0IsOEVBQThFLDZCQUE2QixPQUFPLG9CQUFvQixNQUFNLDJDQUEyQyw4Q0FBOEMsOENBQThDLCtIQUErSCwrREFBK0QsK0RBQStELHlCQUF5QixhQUFhLFdBQVcsRUFBRSxTQUFTLG1EQUFtRCxRQUFRLE1BQU0sbUJBQW1CLE9BQU8sTUFBTSxpRUFBaUUsNENBQTRDLGdDQUFnQyw4QkFBOEIsa0RBQWtELG1DQUFtQyxnREFBZ0QsOENBQThDLDBDQUEwQywyQ0FBMkMsNENBQTRDLDBDQUEwQyxZQUFZLFNBQVMsT0FBTyxFQUFFLE1BQU0sbUNBQW1DLDJDQUEyQyxtQkFBbUIsT0FBTyxNQUFNLGlHQUFpRywrQkFBK0IsMEJBQTBCLGVBQWUsT0FBTyxrQ0FBa0MscUdBQXFHLHlCQUF5QiwwQkFBMEIscUJBQXFCLE1BQU0sMkNBQTJDLGlCQUFpQixTQUFTLHdCQUF3Qix1RUFBdUUsMEJBQTBCLFFBQVEsb0VBQW9FLHdCQUF3QixzQkFBc0Isa0RBQWtELFNBQVMsT0FBTyxvQkFBb0IsTUFBTSw4RUFBOEUsT0FBTyw0TEFBNEwsY0FBYyx1SEFBdUgscUNBQXFDLCtDQUErQyxvSkFBb0osaUZBQWlGLE9BQU8sd0NBQXdDLDZCQUE2QixrREFBa0QsT0FBTyxrRUFBa0UsTUFBTSxrWUFBa1ksbUNBQW1DLG9DQUFvQyw4QkFBOEIsd0NBQXdDLDBCQUEwQixnRUFBZ0UsOG1CQUE4bUIsK0VBQStFLHVCQUF1QixJQUFJLElBQUksV0FBVyxvQ0FBb0MsS0FBSywwQ0FBMEMsd0NBQXdDLDZCQUE2QixvREFBb0QsZ0NBQWdDLEtBQUssOENBQThDLHNDQUFzQywyQkFBMkIsMENBQTBDLEVBQUUsK0JBQStCLG9EQUFvRCxTQUFTLDRDQUE0QyxRQUFRLEtBQUssa0VBQWtFLHNDQUFzQywrREFBK0Qsb0JBQW9CLDBCQUEwQixTQUFTLDJCQUEyQiw2QkFBNkIsaURBQWlELHdDQUF3Qyx1QkFBdUIsYUFBYSxpQ0FBaUMsaURBQWlELEVBQUUsbUNBQW1DLGtFQUFrRSxhQUFhLCtDQUErQyxXQUFXLFNBQVMsUUFBUSxLQUFLLHlFQUF5RSxpSUFBaUksS0FBSyxvRkFBb0YsdURBQXVELGtLQUFrSyxzREFBc0QsMkNBQTJDLHNDQUFzQyxPQUFPLGtEQUFrRCxLQUFLLDRGQUE0Riw4REFBOEQsZUFBZSxPQUFPLHNIQUFzSCw2UEFBNlAsb0NBQW9DLG1DQUFtQyw4SUFBOEksMENBQTBDLGFBQWEsWUFBWSxVQUFVLDRDQUE0QyxPQUFPLGlEQUFpRCxtRUFBbUUsRUFBRSw2RkFBNkYsK0JBQStCLG9FQUFvRSxlQUFlLE9BQU8sMEZBQTBGLDRIQUE0SCwyREFBMkQsNkJBQTZCLHlCQUF5Qix3QkFBd0IseUJBQXlCLDJEQUEyRCxLQUFLLHVGQUF1Riw2RUFBNkUsa0JBQWtCLGVBQWUsT0FBTyxnRkFBZ0YsNENBQTRDLEtBQUssZ0ZBQWdGLHdEQUF3RCxrRUFBa0UsNkNBQTZDLHNEQUFzRCw4RkFBOEYsU0FBUyxPQUFPLEtBQUssb0NBQW9DLDhJQUE4SSwwQ0FBMEMsS0FBSyw0QkFBNEIsdURBQXVELHVFQUF1RSxPQUFPLDJEQUEyRCxzRUFBc0UsT0FBTyx1RUFBdUUsZ0VBQWdFLGlCQUFpQixTQUFTLHlIQUF5SCw0REFBNEQsaURBQWlELDBEQUEwRCw4REFBOEQsZ0RBQWdELGdJQUFnSSxtQkFBbUIsV0FBVyw4RkFBOEYsaUJBQWlCLFNBQVMsNEJBQTRCLDJEQUEyRCxnR0FBZ0csV0FBVyxTQUFTLHFFQUFxRSxvRUFBb0UseUVBQXlFLHlEQUF5RCxnR0FBZ0csV0FBVyxTQUFTLE9BQU8sd0NBQXdDLG9EQUFvRCxzQkFBc0IsU0FBUyxnQ0FBZ0MsOENBQThDLGdEQUFnRCwrQkFBK0IsMkJBQTJCLGtDQUFrQyxxQ0FBcUMsaUNBQWlDLDZDQUE2QywwQ0FBMEMsd0RBQXdELHdFQUF3RSw4REFBOEQsU0FBUyxzQ0FBc0MscURBQXFELEVBQUUsb0NBQW9DLGlDQUFpQywrQkFBK0IsU0FBUywrQkFBK0IscUNBQXFDLFNBQVMsb0RBQW9ELHVDQUF1QyxTQUFTLHFCQUFxQixPQUFPLFFBQVEsc0NBQXNDLDBEQUEwRCxJQUFJLGFBQWEsMkJBQTJCLFVBQVUsaUJBQWlCLDJDQUEyQyxvREFBb0QsMkJBQTJCLGFBQWEsYUFBYSxFQUFFLFNBQVMsT0FBTyxtQkFBbUIsS0FBSyx3V0FBd1csa0JBQWtCLG1DQUFtQyx1Q0FBdUMsNkNBQTZDLFNBQVMsdURBQXVELHFNQUFxTSx1SkFBdUosa0NBQWtDLElBQUksaUJBQWlCLFNBQVMseUNBQXlDLE9BQU8sNEJBQTRCLHNDQUFzQywwREFBMEQsU0FBUyxzQkFBc0IsT0FBTywrQkFBK0IsdUNBQXVDLGlCQUFpQixTQUFTLHNEQUFzRCxpQ0FBaUMsa0hBQWtILHFDQUFxQyxTQUFTLE9BQU8sUUFBUSxpVkFBaVYsNkJBQTZCLG9CQUFvQixPQUFPLGdDQUFnQyxxQkFBcUIsT0FBTyxpREFBaUQsNkJBQTZCLE9BQU8sK0NBQStDLG9CQUFvQixPQUFPLHdDQUF3QyxxQkFBcUIsT0FBTyxhQUFhLHFEQUFxRCxRQUFRLGlCQUFpQixxQkFBcUIsT0FBTyxLQUFLLHNDQUFzQyw4Q0FBOEMsa0JBQWtCLEdBQUcsS0FBSywyQkFBMkIsNkNBQTZDLHdDQUF3QyxzQkFBc0IsVUFBVSxPQUFPLDRDQUE0QywyQ0FBMkMsc0JBQXNCLEdBQUcsT0FBTyxxQ0FBcUMsdUJBQXVCLG9CQUFvQixTQUFTLGdDQUFnQyx1SEFBdUgscUNBQXFDLCtDQUErQyx1RkFBdUYsb0VBQW9FLFNBQVMsNEJBQTRCLE9BQU8seUNBQXlDLDZEQUE2RCxzQkFBc0IsSUFBSSxPQUFPLFFBQVEsbVdBQW1XLDRDQUE0QyxrQkFBa0IsT0FBTyxrQ0FBa0Msa0JBQWtCLE9BQU8sMkJBQTJCLGlHQUFpRyxPQUFPLDRCQUE0Qiw4Q0FBOEMsZ0RBQWdELHdDQUF3Qyx3QkFBd0IsT0FBTyxtQ0FBbUMsc0JBQXNCLE9BQU8sMENBQTBDLHNHQUFzRyxrQ0FBa0MsMEZBQTBGLGdGQUFnRix3REFBd0QsV0FBVyxPQUFPLDhFQUE4RSwwREFBMEQsc0RBQXNELHlDQUF5Qyx5RUFBeUUsNkRBQTZELG1DQUFtQyxvQ0FBb0MsYUFBYSxTQUFTLHFCQUFxQixVQUFVLHlCQUF5QixjQUFjLE1BQU0sV0FBVyxTQUFTLE9BQU8sT0FBTyx5V0FBeVcsK0VBQStFLG9DQUFvQyxnQkFBZ0Isc0NBQXNDLHlCQUF5QixpQkFBaUIsU0FBUyxrQ0FBa0MsK0NBQStDLGlFQUFpRSxRQUFRLDhCQUE4Qiw4REFBOEQsb0VBQW9FLHdFQUF3RSxvQ0FBb0MsU0FBUyxPQUFPLDhEQUE4RCw4REFBOEQsT0FBTyw0QkFBNEIsNkRBQTZELGdEQUFnRCx3Q0FBd0Msd0JBQXdCLFFBQVEsZ0RBQWdELDREQUE0RCxPQUFPLHVEQUF1RCxHQUFHLDBHQUEwRyxPQUFPLDhCQUE4Qix1QkFBdUIsT0FBTywrQkFBK0IscUJBQXFCLFVBQVUsRUFBRSxPQUFPLGdDQUFnQyxtQkFBbUIsY0FBYyxFQUFFLE9BQU8sZ0NBQWdDLGtCQUFrQixLQUFLLEVBQUUsZUFBZSxFQUFFLE9BQU8sT0FBTywyWEFBMlgseUNBQXlDLG9CQUFvQixFQUFFLGtDQUFrQyxrRUFBa0UsS0FBSyx3QkFBd0IsbURBQW1ELGlDQUFpQyxTQUFTLGlDQUFpQyxpQkFBaUIsU0FBUywwRUFBMEUsS0FBSyxHQUFHLGdFQUFnRSxzSEFBc0gsT0FBTyxFQUFFLE1BQU0sK1ZBQStWLGtDQUFrQyw0QkFBNEIsV0FBVyxFQUFFLGdDQUFnQyxZQUFZLEVBQUUsa0NBQWtDLFlBQVksRUFBRSxxQ0FBcUMscUNBQXFDLDhFQUE4RSx5Q0FBeUMsc0JBQXNCLFFBQVEsNEJBQTRCLDRFQUE0RSw0Q0FBNEMsaUJBQWlCLFNBQVMsNERBQTRELGlGQUFpRix1RkFBdUYsUUFBUSx1Q0FBdUMsK0JBQStCLDREQUE0RCx1QkFBdUIsUUFBUSxtREFBbUQsc0NBQXNDLHVEQUF1RCw2Q0FBNkMsbUJBQW1CLFdBQVcsbUdBQW1HLHFEQUFxRCxPQUFPLEtBQUssV0FBVywrQkFBK0IsU0FBUyxFQUFFLE9BQU8sT0FBTyx5RkFBeUYsMkRBQTJELGlXQUFpVyxtQ0FBbUMsNEJBQTRCLFdBQVcsRUFBRSx1Q0FBdUMseUNBQXlDLGlFQUFpRSwyQ0FBMkMsWUFBWSxFQUFFLGVBQWUsRUFBRSwrRUFBK0UseUNBQXlDLHNCQUFzQixRQUFRLDZCQUE2QixxTkFBcU4sUUFBUSxtREFBbUQsc0NBQXNDLHdEQUF3RCxzQ0FBc0MsMkJBQTJCLFdBQVcsU0FBUyxFQUFFLE9BQU8sT0FBTyx3SUFBd0ksNkJBQTZCLGtFQUFrRSxzREFBc0Qsb0JBQW9CLEtBQUssRUFBRSw0REFBNEQsOFdBQThXLDBEQUEwRCx3RkFBd0YsT0FBTyxnRUFBZ0UsdUVBQXVFLE9BQU8sc0NBQXNDLHVGQUF1RixPQUFPLHFDQUFxQywyQkFBMkIsNERBQTRELDRCQUE0QixpQ0FBaUMsMkRBQTJELFNBQVMseUJBQXlCLE9BQU8sa0NBQWtDLHNEQUFzRCw0QkFBNEIsMkNBQTJDLDhCQUE4QixXQUFXLHVEQUF1RCxTQUFTLG9CQUFvQixPQUFPLHNDQUFzQyw2REFBNkQsOENBQThDLHdCQUF3Qix1Q0FBdUMsMEJBQTBCLFdBQVcsMkNBQTJDLFNBQVMsb0JBQW9CLE9BQU8scUNBQXFDLG9KQUFvSixTQUFTLG9DQUFvQyw2RkFBNkYsT0FBTyxRQUFRLG9XQUFvVyxvQ0FBb0MsMENBQTBDLFlBQVksRUFBRSx3Q0FBd0MsWUFBWSxFQUFFLHNDQUFzQyxZQUFZLEVBQUUsNENBQTRDLFlBQVksRUFBRSx3Q0FBd0MsWUFBWSxFQUFFLHVDQUF1QyxtQ0FBbUMscURBQXFELCtCQUErQix1QkFBdUIsZ0ZBQWdGLDJCQUEyQix1SEFBdUgsdUVBQXVFLG9DQUFvQyxnQkFBZ0IsZ0NBQWdDLGlEQUFpRCxpQkFBaUIsU0FBUyxpREFBaUQseUJBQXlCLGtFQUFrRSw2QkFBNkIsUUFBUSwwQ0FBMEMseUJBQXlCLE9BQU8sa0NBQWtDLDZCQUE2QixPQUFPLDJCQUEyQixzQkFBc0IsUUFBUSw4QkFBOEIscURBQXFELFFBQVEsbUNBQW1DLDBDQUEwQyxrREFBa0QsaUJBQWlCLFNBQVMsb0RBQW9ELHVDQUF1QyxTQUFTLE9BQU8scUJBQXFCLGtEQUFrRCxzREFBc0QsU0FBUyw4QkFBOEIsNENBQTRDLE9BQU8sc0JBQXNCLCtHQUErRyxPQUFPLHdCQUF3QixpREFBaUQsNkNBQTZDLGlCQUFpQixTQUFTLHFEQUFxRCx5QkFBeUIsMkJBQTJCLGlCQUFpQixTQUFTLDBGQUEwRixPQUFPLHVCQUF1Qix5Q0FBeUMseUZBQXlGLHFGQUFxRixrRUFBa0UsVUFBVSxNQUFNLHdGQUF3RixzRkFBc0Ysb0ZBQW9GLFNBQVMsT0FBTyx3Q0FBd0Msa0lBQWtJLFFBQVEseUNBQXlDLDBGQUEwRixPQUFPLE9BQU8scVdBQXFXLHFDQUFxQyw0QkFBNEIsV0FBVyxFQUFFLHVDQUF1Qyx5Q0FBeUMsMkNBQTJDLHdDQUF3QyxtRkFBbUYsOEJBQThCLGtDQUFrQyxvQ0FBb0MsZ0NBQWdDLFlBQVksRUFBRSw4QkFBOEIsWUFBWSxFQUFFLHNDQUFzQyxZQUFZLEVBQUUsNENBQTRDLFlBQVksRUFBRSw0Q0FBNEMsWUFBWSxFQUFFLHlDQUF5QyxZQUFZLEVBQUUseUNBQXlDLFlBQVksRUFBRSxlQUFlLEVBQUUsMkNBQTJDLFlBQVksRUFBRSxlQUFlLEVBQUUsMkNBQTJDLHlDQUF5QyxxQ0FBcUMsK0NBQStDLG1EQUFtRCxpREFBaUQsaURBQWlELHNDQUFzQywyQ0FBMkMsaUVBQWlFLG1EQUFtRCx1REFBdUQsc0VBQXNFLDZEQUE2RCw4QkFBOEIseUZBQXlGLHVCQUF1Qix5SEFBeUgsMkJBQTJCLHFOQUFxTixpRkFBaUYsb0NBQW9DLCtCQUErQiw4QkFBOEIsbUNBQW1DLGdDQUFnQyxpQ0FBaUMsaUNBQWlDLDZGQUE2RixvQ0FBb0MsMERBQTBELHVCQUF1QixTQUFTLFFBQVEsMENBQTBDLHlCQUF5QixPQUFPLGtDQUFrQyw2QkFBNkIsT0FBTywyQkFBMkIsc0JBQXNCLFFBQVEsMkJBQTJCLGdDQUFnQyxPQUFPLDJCQUEyQiwyTkFBMk4sc0JBQXNCLFNBQVMsT0FBTyxnQkFBZ0IsZ0NBQWdDLE9BQU8saUJBQWlCLDhCQUE4Qiw4Q0FBOEMsU0FBUyxnQ0FBZ0MsT0FBTyxpQkFBaUIsOEJBQThCLGlDQUFpQyw0RkFBNEYsT0FBTyw2QkFBNkIsaUNBQWlDLGlCQUFpQixTQUFTLGdDQUFnQywwRUFBMEUsaUJBQWlCLFNBQVMsdUJBQXVCLE9BQU8sbUJBQW1CLHVDQUF1QyxzREFBc0QsaUJBQWlCLFNBQVMsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsU0FBUyxvRUFBb0Usc0NBQXNDLGlCQUFpQixTQUFTLHNFQUFzRSwyQ0FBMkMsT0FBTyxtQkFBbUIsZ0NBQWdDLHNDQUFzQyxTQUFTLDBCQUEwQixRQUFRLCtDQUErQyxpREFBaUQsc0JBQXNCLE9BQU8sOEJBQThCLG9DQUFvQyx5RkFBeUYsU0FBUywrQ0FBK0MsaUZBQWlGLDZGQUE2RixTQUFTLDBEQUEwRCx5Q0FBeUMsU0FBUyxPQUFPLG1DQUFtQyxrRkFBa0Ysa0ZBQWtGLFNBQVMscUNBQXFDLCtDQUErQyxtQkFBbUIsWUFBWSwyTUFBMk0sMlRBQTJULG9DQUFvQyw0Q0FBNEMsV0FBVywySEFBMkgsVUFBVSwrQkFBK0Isa05BQWtOLGtFQUFrRSxPQUFPLHlCQUF5QiwyREFBMkQsaUJBQWlCLFNBQVMsd0RBQXdELDBCQUEwQixpQ0FBaUMsMkRBQTJELFNBQVMsT0FBTyxnQ0FBZ0MsaURBQWlELE9BQU8sMkNBQTJDLHVDQUF1QyxpQkFBaUIsU0FBUyxtR0FBbUcsOERBQThELHdEQUF3RCxpRkFBaUYsTUFBTSwrQkFBK0IsbUNBQW1DLGdFQUFnRSxrRUFBa0UsU0FBUyxPQUFPLDJCQUEyQixpRUFBaUUseUJBQXlCLGlCQUFpQixTQUFTLGdHQUFnRyxnRkFBZ0YsT0FBTyx1Q0FBdUMsOEJBQThCLGlCQUFpQixTQUFTLGtEQUFrRCw4Q0FBOEMsd0hBQXdILDhDQUE4QyxpQkFBaUIsU0FBUyxtRUFBbUUsNkNBQTZDLGlFQUFpRSwyTEFBMkwsRUFBRSxVQUFVLHVEQUF1RCw0Q0FBNEMsaUJBQWlCLFNBQVMsK0NBQStDLDRJQUE0SSxTQUFTLG9EQUFvRCxxQkFBcUIsK0JBQStCLDREQUE0RCw0Q0FBNEMsZ0ZBQWdGLDBFQUEwRSxrREFBa0QsNEJBQTRCLDBEQUEwRCx3REFBd0QsMENBQTBDLDZFQUE2RSx5REFBeUQsb0dBQW9HLGtDQUFrQyxtQ0FBbUMsVUFBVSxtRkFBbUYsMEJBQTBCLHVCQUF1QixTQUFTLE9BQU8sdUJBQXVCLGtFQUFrRSxPQUFPLHNCQUFzQiwyRUFBMkUsT0FBTyxxQkFBcUIsaUVBQWlFLE9BQU8sMEJBQTBCLDZCQUE2Qix3Q0FBd0MsZ0NBQWdDLFNBQVMsT0FBTyxzQ0FBc0Msc0JBQXNCLHdFQUF3RSxTQUFTLHdFQUF3RSxPQUFPLGtDQUFrQyxzQkFBc0IseUVBQXlFLFNBQVMseUVBQXlFLFFBQVEsbURBQW1ELHNDQUFzQyxrRUFBa0UsNkNBQTZDLDRCQUE0QixtQkFBbUIsV0FBVyw2Q0FBNkMsbUdBQW1HLHVEQUF1RCxPQUFPLEtBQUssYUFBYSw2QkFBNkIsV0FBVyxTQUFTLEVBQUUsT0FBTyxPQUFPLDZJQUE2SSxrREFBa0QseUVBQXlFLGVBQWUsT0FBTywrQkFBK0IsNERBQTRELCtEQUErRCx5QkFBeUIsZ0NBQWdDLHVDQUF1QyxpQkFBaUIsT0FBTyxxRUFBcUUsd0JBQXdCLHVDQUF1QyxpQkFBaUIsT0FBTyx3QkFBd0IscUNBQXFDLEtBQUssRUFBRSwwREFBMEQsZ0VBQWdFLDJDQUEyQywrQ0FBK0MsT0FBTyxLQUFLLEVBQUUsOERBQThELHFXQUFxVyxxQ0FBcUMsNEJBQTRCLFdBQVcsRUFBRSx1Q0FBdUMsZ0NBQWdDLFlBQVksRUFBRSxrQ0FBa0MsWUFBWSxFQUFFLGdDQUFnQyxZQUFZLEVBQUUsb0NBQW9DLFlBQVksRUFBRSwyQ0FBMkMsWUFBWSxFQUFFLGVBQWUsRUFBRSxxQ0FBcUMsMkNBQTJDLCtDQUErQyw2Q0FBNkMsa0RBQWtELHFCQUFxQixHQUFHLG9CQUFvQixFQUFFLHdEQUF3RCwwQkFBMEIsNEJBQTRCLG9FQUFvRSxtRUFBbUUsdUJBQXVCLDJDQUEyQywyQkFBMkIsNERBQTRELGlGQUFpRixvQ0FBb0MsK0JBQStCLHNDQUFzQyxnQ0FBZ0MsdUVBQXVFLDBDQUEwQyx3REFBd0QscUhBQXFILDREQUE0RCwwQ0FBMEMsV0FBVyxTQUFTLHFDQUFxQyxxQ0FBcUMsOEVBQThFLFNBQVMsb0NBQW9DLHdCQUF3QixTQUFTLFFBQVEsMENBQTBDLHlCQUF5QixPQUFPLGtDQUFrQyw2QkFBNkIsT0FBTywyQkFBMkIsc0JBQXNCLFFBQVEsNkJBQTZCLDhCQUE4QixzQkFBc0IsVUFBVSxNQUFNLHNCQUFzQixTQUFTLE9BQU8sZ0JBQWdCLHVEQUF1RCxpQkFBaUIsU0FBUyxtQ0FBbUMsMkRBQTJELDRLQUE0SyxvQ0FBb0MsR0FBRyxTQUFTLDRFQUE0RSxpQkFBaUIsU0FBUywrRUFBK0UsNENBQTRDLGlCQUFpQixTQUFTLHdEQUF3RCxnQ0FBZ0MsU0FBUyxpREFBaUQsOERBQThELDZEQUE2RCw2Q0FBNkMsbUVBQW1FLHVDQUF1QyxrQ0FBa0Msd0NBQXdDLGtFQUFrRSxnRkFBZ0YsZ0RBQWdELDZEQUE2RCxVQUFVLHVGQUF1RixvQ0FBb0MscUJBQXFCLEVBQUUsNkRBQTZELDhDQUE4QywwQkFBMEIsSUFBSSxPQUFPLGdCQUFnQix3REFBd0QsaUJBQWlCLFNBQVMsK0VBQStFLDRDQUE0QyxpQkFBaUIsU0FBUyxpREFBaUQsOENBQThDLGlEQUFpRCxJQUFJLDhCQUE4Qiw2REFBNkQsaUZBQWlGLHFEQUFxRCwwREFBMEQscURBQXFELDZEQUE2RCxXQUFXLFNBQVMsdUNBQXVDLGtDQUFrQyx3Q0FBd0Msa0VBQWtFLDZEQUE2RCxnRUFBZ0UsVUFBVSw4Q0FBOEMsNkRBQTZELE9BQU8sMkNBQTJDLDZEQUE2RCxRQUFRLCtDQUErQyxnREFBZ0QsMkVBQTJFLHNCQUFzQixPQUFPLHlCQUF5Qix3RkFBd0YsT0FBTywrQkFBK0IsbUNBQW1DLGlCQUFpQixTQUFTLCtFQUErRSwyQ0FBMkMsMkRBQTJELDJCQUEyQiwrRUFBK0UsV0FBVyxTQUFTLE9BQU8sMENBQTBDLCtGQUErRixzSkFBc0osT0FBTyx5REFBeUQsbUNBQW1DLGlCQUFpQixTQUFTLCtDQUErQyxrRUFBa0Usd0RBQXdELFNBQVMsUUFBUSxtREFBbUQsMkJBQTJCLHVFQUF1RSxpQ0FBaUMsU0FBUyx3Q0FBd0MsbUVBQW1FLDZDQUE2QyxzREFBc0QsdURBQXVELE9BQU8sS0FBSyxhQUFhLDZCQUE2QixXQUFXLFNBQVMsRUFBRSxPQUFPLE9BQU8sZ0pBQWdKLGdOQUFnTiwrQkFBK0IsT0FBTyxzREFBc0QsNkRBQTZELGlEQUFpRCwrQ0FBK0MsZ0NBQWdDLFdBQVcsT0FBTyxLQUFLLEVBQUUsOERBQThELHFXQUFxVyxxQ0FBcUMsNEJBQTRCLFdBQVcsRUFBRSx1Q0FBdUMsa0NBQWtDLDRCQUE0QixxQ0FBcUMseUNBQXlDLGtDQUFrQywrR0FBK0csWUFBWSxFQUFFLG9DQUFvQyxZQUFZLEVBQUUsZ0NBQWdDLFlBQVksRUFBRSxrQ0FBa0MsWUFBWSxFQUFFLDJDQUEyQyxZQUFZLEVBQUUsZUFBZSxFQUFFLDZDQUE2QyxZQUFZLEVBQUUsZUFBZSxFQUFFLHlDQUF5QyxZQUFZLEVBQUUsZUFBZSxFQUFFLHFDQUFxQyx1Q0FBdUMseUNBQXlDLDZDQUE2QyxxREFBcUQseURBQXlELGlHQUFpRywwQ0FBMEMsdUJBQXVCLEdBQUcsa0JBQWtCLEVBQUUsMkNBQTJDLHNDQUFzQyw4Q0FBOEMsaUdBQWlHLDREQUE0RCwrREFBK0QscUVBQXFFLHdFQUF3RSxtRUFBbUUsa0VBQWtFLHNDQUFzQyw0Q0FBNEMsdUJBQXVCLDhKQUE4SiwyQkFBMkIsb09BQW9PLGlGQUFpRixvQ0FBb0MsK0JBQStCLDRCQUE0QixpREFBaUQsOEZBQThGLDhDQUE4QyxRQUFRLDBDQUEwQyx5QkFBeUIsT0FBTyxrQ0FBa0MsNkJBQTZCLE9BQU8sMkJBQTJCLHNCQUFzQixRQUFRLDZCQUE2QiwyREFBMkQsT0FBTyxnQkFBZ0IsMkRBQTJELGlCQUFpQixTQUFTLGlDQUFpQyxnREFBZ0QsMkZBQTJGLDJDQUEyQyxpQkFBaUIsU0FBUyxnQ0FBZ0MsdUhBQXVILDJQQUEyUCx1RUFBdUUsd0RBQXdELFdBQVcsU0FBUyxnQ0FBZ0MsNERBQTRELHNEQUFzRCx5REFBeUQsNEVBQTRFLE9BQU8sZ0JBQWdCLDREQUE0RCxpQkFBaUIsU0FBUyxpQ0FBaUMsZ0RBQWdELDRDQUE0QyxPQUFPLG1CQUFtQiwyQkFBMkIsaUNBQWlDLFNBQVMsMEJBQTBCLE9BQU8sa0JBQWtCLDhDQUE4Qyw2QkFBNkIsZ0NBQWdDLFNBQVMsUUFBUSxrREFBa0QsMkZBQTJGLDJDQUEyQyxpQkFBaUIsVUFBVSxrTEFBa0wsdUVBQXVFLHlEQUF5RCxXQUFXLFNBQVMsNkJBQTZCLGlDQUFpQyxTQUFTLHlEQUF5RCw0REFBNEQsK0RBQStELGdFQUFnRSwyRUFBMkUsT0FBTyw0QkFBNEIsMENBQTBDLHFKQUFxSiw0R0FBNEcscUJBQXFCLHVHQUF1RyxTQUFTLHdCQUF3QixPQUFPLHlCQUF5Qix1REFBdUQsZ0dBQWdHLFNBQVMsK0NBQStDLG9EQUFvRCwwQ0FBMEMsVUFBVSw2Q0FBNkMsZ0VBQWdFLFVBQVUsc0RBQXNELG9EQUFvRCxTQUFTLHVEQUF1RCxvR0FBb0csT0FBTyxvQkFBb0IsZ0VBQWdFLE9BQU8seUJBQXlCLDRDQUE0QyxzRUFBc0UsaUNBQWlDLFNBQVMsd0VBQXdFLGdDQUFnQyxTQUFTLDRFQUE0RSxxQ0FBcUMsU0FBUyw4RUFBOEUsd0NBQXdDLFVBQVUsd0xBQXdMLHFFQUFxRSwwREFBMEQsU0FBUyxnRUFBZ0UsT0FBTyx5QkFBeUIsK0RBQStELE9BQU8sc0JBQXNCLGVBQWUsMEJBQTBCLGVBQWUsMkNBQTJDLDRFQUE0RSxTQUFTLDZDQUE2QyxpRUFBaUUsU0FBUyx3QkFBd0IsT0FBTyw0QkFBNEIsdUNBQXVDLGlFQUFpRSwwREFBMEQsMERBQTBELFdBQVcsR0FBRyxpREFBaUQsb0RBQW9ELFdBQVcsWUFBWSwwSUFBMEksd0VBQXdFLGlFQUFpRSxxRUFBcUUsRUFBRSxTQUFTLG1CQUFtQixnTEFBZ0wsT0FBTyx5QkFBeUIsaUNBQWlDLEdBQUcsb0hBQW9ILDhCQUE4QixpQkFBaUIsVUFBVSwrUEFBK1AsUUFBUSxtREFBbUQsc0NBQXNDLGtFQUFrRSw2Q0FBNkMsbUJBQW1CLFdBQVcsc0RBQXNELHFEQUFxRCxPQUFPLEtBQUssV0FBVywyQkFBMkIsU0FBUyxFQUFFLE9BQU8sa0NBQWtDLHVHQUF1RyxpQkFBaUIsU0FBUyw4RUFBOEUsNkNBQTZDLHVEQUF1RCxrRUFBa0UscUJBQXFCLFdBQVcsc0RBQXNELG9FQUFvRSxnTEFBZ0wscUJBQXFCLFlBQVksdVJBQXVSLHFCQUFxQixXQUFXLG1DQUFtQyx1REFBdUQseUNBQXlDLDZDQUE2QyxXQUFXLGlEQUFpRCxTQUFTLE9BQU8sNkNBQTZDLCtOQUErTix5REFBeUQsdUZBQXVGLG1EQUFtRCxpQkFBaUIsU0FBUywwQ0FBMEMsaUJBQWlCLFNBQVMsaUNBQWlDLGdIQUFnSCx1RUFBdUUsZ0NBQWdDLGtDQUFrQywwQkFBMEIsNENBQTRDLG1CQUFtQixTQUFTLG9DQUFvQyx5RkFBeUYsMEJBQTBCLGtDQUFrQyxTQUFTLE9BQU8sT0FBTyw4SkFBOEoscUdBQXFHLDJFQUEyRSx5RUFBeUUsZ0dBQWdHLDZCQUE2QixrREFBa0QsS0FBSyxFQUFFLDhEQUE4RCxvYUFBb2Esa0RBQWtELDZDQUE2QywyQ0FBMkMsa0VBQWtFLHFCQUFxQixzQ0FBc0MsUUFBUSwrQkFBK0IsNEpBQTRKLDJEQUEyRCxPQUFPLGdCQUFnQixzQ0FBc0MsbUNBQW1DLHFMQUFxTCxnUEFBZ1AsMkhBQTJILE9BQU8saUJBQWlCLGdFQUFnRSx3RUFBd0UsaUZBQWlGLGlGQUFpRixPQUFPLHlCQUF5QixtQ0FBbUMsUUFBUSx3Q0FBd0MsOERBQThELGtEQUFrRCxPQUFPLGtFQUFrRSwrQ0FBK0MsbURBQW1ELHNHQUFzRyxtQkFBbUIsV0FBVywrREFBK0QscUdBQXFHLHNEQUFzRCw2Q0FBNkMsS0FBSyxVQUFVLDBFQUEwRSxPQUFPLHVEQUF1RCwwRUFBMEUsNEJBQTRCLDRFQUE0RSxTQUFTLE9BQU8sMERBQTBELGlEQUFpRCw4RUFBOEUsK0RBQStELDJEQUEyRCx3REFBd0QsbUJBQW1CLFdBQVcsb0VBQW9FLDBEQUEwRCxVQUFVLDBFQUEwRSxPQUFPLHdEQUF3RCxrQ0FBa0MsNkJBQTZCLGlCQUFpQixTQUFTLDJFQUEyRSx3QkFBd0IsU0FBUyxPQUFPLE9BQU8sMFdBQTBXLHFDQUFxQyxxQ0FBcUMsNENBQTRDLE9BQU8sRUFBRSx1QkFBdUIsNFJBQTRSLDJCQUEyQixtS0FBbUssMEVBQTBFLDJCQUEyQixnQkFBZ0IsK0NBQStDLGlDQUFpQyw2QkFBNkIsUUFBUSwwQ0FBMEMseUJBQXlCLE9BQU8sa0NBQWtDLDZCQUE2QixPQUFPLDJCQUEyQixzQkFBc0IsUUFBUSxtQ0FBbUMsc0NBQXNDLDRCQUE0QixpQkFBaUIsU0FBUyx5QkFBeUIsNkNBQTZDLHdDQUF3QywwQkFBMEIsU0FBUyxtREFBbUQsd0NBQXdDLDRCQUE0QixTQUFTLEVBQUUsT0FBTyx3QkFBd0Isc0NBQXNDLDRCQUE0QixpQkFBaUIsU0FBUyxpRUFBaUUsd0NBQXdDLHlCQUF5Qiw0QkFBNEIsU0FBUyxFQUFFLE9BQU8sbUJBQW1CLGdDQUFnQyxpQkFBaUIsU0FBUywyREFBMkQsaUNBQWlDLG1DQUFtQyxRQUFRLG1DQUFtQyw2QkFBNkIseURBQXlELHNEQUFzRCwwQ0FBMEMsc0RBQXNELFdBQVcscUNBQXFDLFNBQVMsK0JBQStCLE9BQU8sbUNBQW1DLDhKQUE4SixzQkFBc0IsT0FBTyxtQkFBbUIsK0JBQStCLGlCQUFpQixTQUFTLDZDQUE2QyxtREFBbUQsMkRBQTJELDhDQUE4QyxTQUFTLEVBQUUsZ0NBQWdDLE9BQU8scUNBQXFDLHNGQUFzRixPQUFPLE9BQU8sNFdBQTRXLHNDQUFzQyw0QkFBNEIsV0FBVyxFQUFFLHNDQUFzQyxZQUFZLEVBQUUsNENBQTRDLFlBQVksRUFBRSwwQkFBMEIsc0NBQXNDLHdDQUF3Qyx1QkFBdUIsNEZBQTRGLDJCQUEyQiw2REFBNkQsMkVBQTJFLDJCQUEyQixnQkFBZ0IsK0NBQStDLCtCQUErQix5Q0FBeUMsUUFBUSwwQ0FBMEMseUJBQXlCLE9BQU8sa0NBQWtDLDZCQUE2QixPQUFPLDJCQUEyQixzQkFBc0IsUUFBUSwrQkFBK0IsNkJBQTZCLGlCQUFpQixTQUFTLHVDQUF1QywyQ0FBMkMsU0FBUyxtREFBbUQsOEhBQThILDBGQUEwRiw4QkFBOEIsT0FBTyxzQkFBc0IsOEJBQThCLGlCQUFpQixTQUFTLGlDQUFpQyxnREFBZ0QsUUFBUSwyQ0FBMkMsZUFBZSwrQkFBK0IsZUFBZSxnSEFBZ0gsaUJBQWlCLFNBQVMseUVBQXlFLHNDQUFzQyw4QkFBOEIsVUFBVSwwREFBMEQsZ0RBQWdELFVBQVUsTUFBTSw4QkFBOEIsU0FBUyxPQUFPLCtCQUErQixvQ0FBb0MsaUJBQWlCLFNBQVMsMEZBQTBGLE9BQU8sT0FBTywrVkFBK1Ysa0NBQWtDLDRCQUE0QixXQUFXLEVBQUUsdUNBQXVDLGtDQUFrQyxnQ0FBZ0MsWUFBWSxFQUFFLG1EQUFtRCxZQUFZLEVBQUUsb0NBQW9DLFlBQVksRUFBRSxnQ0FBZ0MsWUFBWSxFQUFFLGtDQUFrQyxZQUFZLEVBQUUsb0NBQW9DLFlBQVksRUFBRSx3REFBd0QsWUFBWSxFQUFFLHNEQUFzRCxZQUFZLEVBQUUsMkNBQTJDLFlBQVksRUFBRSxlQUFlLEVBQUUseUNBQXlDLHFDQUFxQyxxQ0FBcUMsNkNBQTZDLDBDQUEwQyw0Q0FBNEMsOENBQThDLGdFQUFnRSx1QkFBdUIsaUVBQWlFLDJCQUEyQix5RkFBeUYsOEVBQThFLG9DQUFvQywrQkFBK0IsOEVBQThFLG9EQUFvRCxzREFBc0QsOEJBQThCLHNDQUFzQyxnREFBZ0Qsb0NBQW9DLFFBQVEsMENBQTBDLHlCQUF5QixPQUFPLGtDQUFrQyw2QkFBNkIsT0FBTywyQkFBMkIsc0JBQXNCLFFBQVEsMENBQTBDLHNFQUFzRSxPQUFPLDZCQUE2QixxREFBcUQsaUJBQWlCLFNBQVMsK0VBQStFLGdDQUFnQyxFQUFFLDJDQUEyQyxpQkFBaUIsU0FBUywrQkFBK0IscUNBQXFDLGlDQUFpQyx1REFBdUQsK0JBQStCLHNFQUFzRSxPQUFPLGdCQUFnQixzREFBc0QsaUJBQWlCLFNBQVMsOEVBQThFLDJDQUEyQyxpQkFBaUIsU0FBUyxnQ0FBZ0MscUNBQXFDLHVDQUF1Qyw0REFBNEQsMEZBQTBGLE9BQU8sbUJBQW1CLDJEQUEyRCxxREFBcUQsU0FBUyxtQ0FBbUMsdUNBQXVDLDBCQUEwQixPQUFPLHdCQUF3Qiw2QkFBNkIsUUFBUSwyQ0FBMkMsNkJBQTZCLGlNQUFpTSxFQUFFLE9BQU8sZ0NBQWdDLDhCQUE4Qiw2Q0FBNkMsRUFBRSxPQUFPLHFDQUFxQywyRkFBMkYsOENBQThDLFNBQVMsZ0RBQWdELHVEQUF1RCx5REFBeUQsdURBQXVELHNDQUFzQyxvRkFBb0YsMEJBQTBCLGtDQUFrQyxTQUFTLGdDQUFnQyx5REFBeUQsNENBQTRDLG1DQUFtQyx1Q0FBdUMsV0FBVywwQ0FBMEMsOERBQThELG9DQUFvQyxFQUFFLFVBQVUsb0ZBQW9GLE9BQU8sOEJBQThCLDBFQUEwRSwyQ0FBMkMsbUJBQW1CLFdBQVcsd0NBQXdDLG1DQUFtQyx3QkFBd0IsbUJBQW1CLFdBQVcsOENBQThDLFNBQVMsRUFBRSx1REFBdUQsd0RBQXdELGlDQUFpQyxXQUFXLFNBQVMsRUFBRSwwRUFBMEUscURBQXFELDhEQUE4RCxXQUFXLHFEQUFxRCw4Q0FBOEMscUJBQXFCLFdBQVcsd0NBQXdDLHdCQUF3QixXQUFXLFNBQVMsRUFBRSxPQUFPLHNCQUFzQiw2Q0FBNkMsMERBQTBELHNEQUFzRCxnREFBZ0Qsd0NBQXdDLHFDQUFxQywwREFBMEQscUNBQXFDLG9DQUFvQyxnRUFBZ0UsU0FBUyxFQUFFLE9BQU8sdUJBQXVCLG1FQUFtRSxPQUFPLHNDQUFzQyxzRkFBc0YsMkNBQTJDLGlCQUFpQixTQUFTLHdHQUF3RyxnRUFBZ0UsMEtBQTBLLGlCQUFpQixTQUFTLG9DQUFvQyxtREFBbUQsU0FBUyx5REFBeUQscUNBQXFDLDREQUE0RCx1Q0FBdUMsNkRBQTZELFdBQVcsZ0JBQWdCLFNBQVMsZ0JBQWdCLGdDQUFnQyxPQUFPLGlIQUFpSCxzR0FBc0csNERBQTRELHVEQUF1RCx5REFBeUQsb0VBQW9FLDZDQUE2QyxlQUFlLElBQUksU0FBUyx5REFBeUQsb0VBQW9FLDZDQUE2QyxlQUFlLElBQUksU0FBUyxPQUFPLDZCQUE2Qiw2Q0FBNkMsOENBQThDLFFBQVEsa0VBQWtFLHNDQUFzQywrREFBK0QsNkNBQTZDLG1CQUFtQixXQUFXLHNEQUFzRCxxREFBcUQsT0FBTyxLQUFLLFdBQVcsd0NBQXdDLFNBQVMsRUFBRSxPQUFPLE9BQU8sZ0pBQWdKLGtEQUFrRCxtREFBbUQsK0JBQStCLE9BQU8sNkRBQTZELHlDQUF5QywyRkFBMkYsU0FBUywwREFBMEQsZ0NBQWdDLHlCQUF5QixXQUFXLFNBQVMsRUFBRSxPQUFPLEdBQUcsMklBQTJJLDBCQUEwQiw4Q0FBOEMsT0FBTyx1REFBdUQsd0JBQXdCLEtBQUssRUFBRSxnQ0FBZ0MsMkRBQTJELHVXQUF1VyxzQ0FBc0MsNEJBQTRCLFdBQVcsRUFBRSx1Q0FBdUMseUNBQXlDLFlBQVksRUFBRSxlQUFlLEVBQUUsZ0NBQWdDLHFDQUFxQywyQ0FBMkMsdUNBQXVDLHFEQUFxRCw0Q0FBNEMsZ0NBQWdDLFlBQVksRUFBRSxrQ0FBa0MsWUFBWSxFQUFFLGdDQUFnQyxZQUFZLEVBQUUsaURBQWlELFlBQVksRUFBRSxvQ0FBb0MsWUFBWSxFQUFFLGtDQUFrQyxZQUFZLEVBQUUsMkNBQTJDLFlBQVksRUFBRSxlQUFlLEVBQUUsb0RBQW9ELFlBQVksRUFBRSxvRUFBb0UsdUJBQXVCLG1FQUFtRSwyQkFBMkIsMEZBQTBGLGtGQUFrRixvQ0FBb0MsK0JBQStCLDhCQUE4QixvREFBb0Qsc0RBQXNELG9DQUFvQyxRQUFRLDBDQUEwQyx5QkFBeUIsT0FBTyxrQ0FBa0MsNkJBQTZCLE9BQU8sMkJBQTJCLHNCQUFzQixRQUFRLDBDQUEwQyxzRUFBc0UsT0FBTyw2QkFBNkIsNEJBQTRCLGlCQUFpQixTQUFTLCtFQUErRSxnQ0FBZ0MsRUFBRSwyQ0FBMkMsaUJBQWlCLFNBQVMsK0JBQStCLGdDQUFnQyxxQ0FBcUMsdUNBQXVDLFNBQVMseURBQXlELHVEQUF1RCw0REFBNEQsMENBQTBDLDhEQUE4RCx1Q0FBdUMsV0FBVywyREFBMkQsaUVBQWlFLGdFQUFnRSxvQ0FBb0MsRUFBRSxVQUFVLHFFQUFxRSxPQUFPLGdCQUFnQiw2QkFBNkIsaUJBQWlCLFNBQVMsOEVBQThFLDJDQUEyQyxpQkFBaUIsU0FBUyx1Q0FBdUMsK0JBQStCLGdDQUFnQyx5REFBeUQsZ0NBQWdDLDBDQUEwQywrRUFBK0Usd0RBQXdELGtEQUFrRCx1Q0FBdUMsMENBQTBDLFdBQVcsZ0VBQWdFLFVBQVUscUVBQXFFLE9BQU8sbUJBQW1CLGlDQUFpQyx1Q0FBdUMsMEJBQTBCLFFBQVEsMkNBQTJDLHFDQUFxQyxtREFBbUQsc0VBQXNFLG1CQUFtQixXQUFXLHdCQUF3QixXQUFXLDhJQUE4SSw2QkFBNkIsME1BQTBNLEVBQUUsT0FBTyxnQ0FBZ0MsOEJBQThCLDZDQUE2QyxFQUFFLE9BQU8sOEJBQThCLHdFQUF3RSx5Q0FBeUMsbUJBQW1CLFdBQVcseUNBQXlDLHNFQUFzRSxtQkFBbUIsV0FBVyx3QkFBd0IsU0FBUyxFQUFFLFFBQVEsbURBQW1ELHNDQUFzQyxtRUFBbUUsNkNBQTZDLG1CQUFtQixXQUFXLG1HQUFtRyxxREFBcUQsT0FBTyxLQUFLLFdBQVcsK0JBQStCLFNBQVMsRUFBRSxPQUFPLE9BQU8sZ0pBQWdKLGtEQUFrRCxtREFBbUQsK0JBQStCLE9BQU8sK0JBQStCLGVBQWUsT0FBTyx3REFBd0QsMkVBQTJFLHVCQUF1QixTQUFTLE9BQU8sR0FBRyxrSkFBa0osb0RBQW9ELGtEQUFrRCxPQUFPLDJEQUEyRCx3QkFBd0IsS0FBSyxFQUFFLDBEQUEwRCxrRUFBa0UsdURBQXVELE9BQU8sS0FBSyxFQUFFLGlEQUFpRCxrR0FBa0csNkRBQTZELHdEQUF3RCxTQUFTLE9BQU8sS0FBSyxFQUFFLG9DQUFvQywrREFBK0Qsc2FBQXNhLHFEQUFxRCw4VEFBOFQsc1hBQXNYLHdCQUF3QixxRUFBcUUsNkRBQTZELDJEQUEyRCwrQ0FBK0MsbUhBQW1ILFNBQVMsc0JBQXNCLFFBQVEsbU1BQW1NLE1BQU0sZ0NBQWdDLHdtQkFBd21CLG9FQUFvRSwrQkFBK0IsMEJBQTBCLE9BQU8seUVBQXlFLDRDQUE0QyxPQUFPLGlEQUFpRCxpRkFBaUYsZ0ZBQWdGLHlDQUF5QywyREFBMkQsOERBQThELDJCQUEyQixtQkFBbUIsU0FBUyxpRUFBaUUsZ0dBQWdHLGtEQUFrRCxnRUFBZ0Usd0RBQXdELFdBQVcsU0FBUyxPQUFPLDhDQUE4QyxLQUFLLHlYQUF5WCx1QkFBdUIsbURBQW1ELFlBQVksd0NBQXdDLHNIQUFzSCwyQkFBMkIsME1BQTBNLGdDQUFnQyxzRkFBc0YsaUZBQWlGLDJCQUEyQixnQkFBZ0IsK0NBQStDLFFBQVEsMENBQTBDLHlCQUF5QixPQUFPLGtDQUFrQyw2QkFBNkIsT0FBTywyQkFBMkIsc0JBQXNCLFFBQVEsaUNBQWlDLHdIQUF3SCxPQUFPLHNCQUFzQiw0Q0FBNEMsT0FBTyxnQ0FBZ0Msb0NBQW9DLG1DQUFtQyxzREFBc0Qsb0JBQW9CLE9BQU8sa0JBQWtCLDhEQUE4RCwrRUFBK0UsZ0ZBQWdGLDREQUE0RCxTQUFTLHVEQUF1RCxvRkFBb0YsMkJBQTJCLDJEQUEyRCxTQUFTLDBCQUEwQixRQUFRLDhDQUE4Qyx1Q0FBdUMsNkNBQTZDLE9BQU8sNEJBQTRCLGdFQUFnRSxrQ0FBa0MsMERBQTBELHNCQUFzQixTQUFTLE9BQU8sa0RBQWtELDJFQUEyRSxpQ0FBaUMsaUJBQWlCLFNBQVMsMkRBQTJELHlCQUF5QixtQ0FBbUMsaUJBQWlCLFNBQVMsbUNBQW1DLDJFQUEyRSxtQkFBbUIsU0FBUyxrQ0FBa0MsbUVBQW1FLGlCQUFpQixTQUFTLGdEQUFnRCxPQUFPLDZCQUE2QixnSEFBZ0gsT0FBTyx1Q0FBdUMsMkRBQTJELE9BQU8seURBQXlELGdDQUFnQyx5Q0FBeUMsMENBQTBDLGlCQUFpQixTQUFTLDREQUE0RCxPQUFPLE9BQU8sbVdBQW1XLG1GQUFtRixxQ0FBcUMscUNBQXFDLHFDQUFxQyxvREFBb0QsK0JBQStCLGlCQUFpQixFQUFFLDZDQUE2QyxrQ0FBa0Msa0NBQWtDLGtDQUFrQyxvQ0FBb0MsZ0NBQWdDLG9DQUFvQyxnQ0FBZ0Msa0NBQWtDLHNDQUFzQyxrQ0FBa0Msc0NBQXNDLHdDQUF3QywwQ0FBMEMsMENBQTBDLDJCQUEyQiwrSUFBK0ksdUJBQXVCLG9qQkFBb2pCLDJCQUEyQiw0akJBQTRqQixnRkFBZ0Ysb0NBQW9DLHVEQUF1RCwrRkFBK0YsU0FBUyxrQ0FBa0MsMkNBQTJDLDBCQUEwQixnQ0FBZ0MsaUNBQWlDLDRCQUE0QixxQ0FBcUMsaUNBQWlDLHNDQUFzQywrQkFBK0IsUUFBUSwwQ0FBMEMseUJBQXlCLE9BQU8sa0NBQWtDLDZCQUE2QixPQUFPLDJCQUEyQixzQkFBc0IsUUFBUSw2QkFBNkIsK0JBQStCLE9BQU8sbUJBQW1CLGdDQUFnQyxPQUFPLHlCQUF5QiwyQ0FBMkMsT0FBTyx1QkFBdUIsK0JBQStCLGlCQUFpQixTQUFTLHNCQUFzQixtRUFBbUUseUVBQXlFLGlEQUFpRCw2QkFBNkIsWUFBWSxNQUFNLDZCQUE2QixXQUFXLG1CQUFtQixTQUFTLGdDQUFnQyx3QkFBd0IsbUJBQW1CLFNBQVMsd0JBQXdCLE9BQU8sbUJBQW1CLG9DQUFvQywwR0FBMEcseUJBQXlCLDRCQUE0QixTQUFTLGdDQUFnQywwQkFBMEIsT0FBTyxnQkFBZ0IscURBQXFELGlFQUFpRSxTQUFTLDREQUE0RCxpQkFBaUIsU0FBUywwR0FBMEcseURBQXlELGlIQUFpSCwwREFBMEQsaUJBQWlCLFVBQVUscUVBQXFFLDRCQUE0QiwwQkFBMEIsU0FBUyw0Q0FBNEMsaUZBQWlGLGlCQUFpQiw2QkFBNkIsZUFBZSxnRkFBZ0YsZ0NBQWdDLDBGQUEwRixTQUFTLDZCQUE2QixnQ0FBZ0MsVUFBVSxNQUFNLGlEQUFpRCxTQUFTLGdEQUFnRCx1SEFBdUgsMk1BQTJNLHVFQUF1RSx3REFBd0QsV0FBVyxTQUFTLGtDQUFrQyxxREFBcUQsa0NBQWtDLHlGQUF5RixxQ0FBcUMsMEJBQTBCLFdBQVcsVUFBVSxzRUFBc0UsT0FBTyxnQkFBZ0IsK0JBQStCLGlCQUFpQixTQUFTLDBHQUEwRywyQ0FBMkMsaUJBQWlCLFNBQVMsNENBQTRDLG1EQUFtRCxnTEFBZ0wsdUVBQXVFLHlEQUF5RCxXQUFXLFNBQVMscURBQXFELG1EQUFtRCxtREFBbUQsZ0NBQWdDLGtDQUFrQyw0Q0FBNEMsbUJBQW1CLFdBQVcsbUNBQW1DLHlCQUF5QixXQUFXLDhEQUE4RCw0RkFBNEYsa0NBQWtDLFVBQVUsc0VBQXNFLE9BQU8sa0JBQWtCLDJCQUEyQixnQ0FBZ0MsU0FBUyxRQUFRLHdDQUF3Qyx5Q0FBeUMsT0FBTywwQkFBMEIsd0JBQXdCLCtGQUErRixTQUFTLDBCQUEwQixPQUFPLG9DQUFvQyxnRUFBZ0UsdURBQXVELHNCQUFzQixTQUFTLHNFQUFzRSw0RkFBNEYsc0JBQXNCLFFBQVEsK0RBQStELHNDQUFzQyxtQ0FBbUMsK0NBQStDLFNBQVMscUJBQXFCLE9BQU8sNkJBQTZCLG1DQUFtQyxnQ0FBZ0MsZ0NBQWdDLHdCQUF3QixTQUFTLE9BQU8sc0NBQXNDLG9DQUFvQyx1REFBdUQsVUFBVSxNQUFNLHdEQUF3RCx5UEFBeVAsRUFBRSxTQUFTLHVDQUF1QyxPQUFPLGtDQUFrQyxnQkFBZ0IsOERBQThELE9BQU8scUJBQXFCLCtGQUErRixRQUFRLHlEQUF5RCxxR0FBcUcsT0FBTyx1QkFBdUIsb0dBQW9HLE9BQU8sb0JBQW9CLDBFQUEwRSxPQUFPLDRCQUE0Qix3SkFBd0osa0VBQWtFLHFHQUFxRyxPQUFPLHNCQUFzQixlQUFlLDBCQUEwQixlQUFlLDJDQUEyQyw0RUFBNEUsU0FBUyw2Q0FBNkMsaUVBQWlFLFNBQVMsd0JBQXdCLE9BQU8sdUNBQXVDLHlFQUF5RSxPQUFPLHNDQUFzQyx1Q0FBdUMsdURBQXVELCtDQUErQyw4RUFBOEUsV0FBVyxHQUFHLGlEQUFpRCxvREFBb0QsV0FBVyxHQUFHLDBEQUEwRCwwREFBMEQsV0FBVyxHQUFHLGdEQUFnRCwyQkFBMkIsc0JBQXNCLG9CQUFvQixXQUFXLEdBQUcsdUhBQXVILDhUQUE4VCxhQUFhLFdBQVcsV0FBVyxpQkFBaUIsZ0xBQWdMLE9BQU8seUJBQXlCLHlEQUF5RCwyQ0FBMkMsb0NBQW9DLDBJQUEwSSxZQUFZLHNDQUFzQyxtSkFBbUoscUpBQXFKLHFGQUFxRix1RUFBdUUsd0dBQXdHLGlDQUFpQyxhQUFhLEVBQUUsc0ZBQXNGLHVFQUF1RSxtSkFBbUosaUNBQWlDLGFBQWEsRUFBRSxXQUFXLFNBQVMsMENBQTBDLDhCQUE4Qix3QkFBd0IsV0FBVyxVQUFVLDJHQUEyRyxzQ0FBc0MsMkJBQTJCLGtGQUFrRixVQUFVLE1BQU0sMkJBQTJCLFNBQVMsT0FBTyxxQkFBcUIsaURBQWlELHVCQUF1QixpQkFBaUIsU0FBUywrRkFBK0YsMERBQTBELFNBQVMsaURBQWlELE9BQU8sa0JBQWtCLGlEQUFpRCxpQ0FBaUMsaUJBQWlCLFNBQVMsaUNBQWlDLGtDQUFrQyxnQ0FBZ0Msd0JBQXdCLFdBQVcsU0FBUywyQkFBMkIsT0FBTyxrQkFBa0IsMENBQTBDLGlCQUFpQixTQUFTLGtDQUFrQyxrQ0FBa0MsaUNBQWlDLHdCQUF3QixXQUFXLFNBQVMsMkJBQTJCLE9BQU8sdUNBQXVDLG9DQUFvQyxxREFBcUQsT0FBTyxnQ0FBZ0MsaUVBQWlFLE9BQU8sNEJBQTRCLDRFQUE0RSxvRUFBb0UseURBQXlELGlEQUFpRCxXQUFXLFNBQVMscUJBQXFCLGtGQUFrRixXQUFXLDhDQUE4QyxnREFBZ0Qsd0NBQXdDLHdCQUF3QixPQUFPLG1DQUFtQyxxR0FBcUcsaURBQWlELDBCQUEwQix5RUFBeUUsU0FBUywyRUFBMkUsaURBQWlELGlEQUFpRCxTQUFTLG1EQUFtRCxxREFBcUQsU0FBUyx3QkFBd0IsT0FBTyw4QkFBOEIsMEJBQTBCLDJDQUEyQyxvRUFBb0UsNENBQTRDLFdBQVcsVUFBVSw4UUFBOFEsT0FBTywwQkFBMEIsMkJBQTJCLGlDQUFpQyxnQ0FBZ0MsU0FBUyxRQUFRLG1EQUFtRCxzQ0FBc0MsaUVBQWlFLDZDQUE2QyxtQkFBbUIsV0FBVyxzREFBc0QscURBQXFELE9BQU8sS0FBSyxXQUFXLDJCQUEyQixTQUFTLEVBQUUsT0FBTyxPQUFPLCtEQUErRCxtV0FBbVcsNkNBQTZDLDZDQUE2Qyx3QkFBd0IsMlNBQTJTLDRCQUE0Qiw0RUFBNEUsMEVBQTBFLDRDQUE0Qyx5QkFBeUIsT0FBTyxrQ0FBa0MsNkJBQTZCLE9BQU8sMkJBQTJCLHNCQUFzQixRQUFRLHdDQUF3QyxzREFBc0QsUUFBUSw4Q0FBOEMsZ0JBQWdCLHVHQUF1RyxPQUFPLHVCQUF1QixtRUFBbUUsUUFBUSxtREFBbUQsc0NBQXNDLGlFQUFpRSw2Q0FBNkMsbUJBQW1CLFdBQVcsc0RBQXNELHFEQUFxRCxPQUFPLEtBQUssV0FBVywyQkFBMkIsU0FBUyxFQUFFLE9BQU8sT0FBTywrREFBK0QsdVdBQXVXLHNDQUFzQyw0QkFBNEIsV0FBVyxFQUFFLHFDQUFxQyxzQ0FBc0MsWUFBWSxFQUFFLGdDQUFnQyxZQUFZLEVBQUUseUNBQXlDLFlBQVksRUFBRSxhQUFhLEVBQUUscURBQXFELHlDQUF5Qyx5REFBeUQsMkNBQTJDLHdEQUF3RCwyQ0FBMkMsMkNBQTJDLG1EQUFtRCxtQ0FBbUMsbUJBQW1CLElBQUksb0JBQW9CLElBQUksbUJBQW1CLElBQUksb0JBQW9CLEVBQUUsMENBQTBDLDBEQUEwRCx1QkFBdUIsZ0xBQWdMLDJCQUEyQiw2TEFBNkwsa0ZBQWtGLG9DQUFvQyxnQ0FBZ0MsNkhBQTZILDZDQUE2QywyR0FBMkcsa0NBQWtDLDhCQUE4QixvQ0FBb0MsbUVBQW1FLHdCQUF3QixxQkFBcUIsMENBQTBDLHlCQUF5QixPQUFPLGtDQUFrQyw2QkFBNkIsT0FBTywyQkFBMkIsc0JBQXNCLFFBQVEsOEJBQThCLGdEQUFnRCwwQ0FBMEMsK0JBQStCLHNDQUFzQyxVQUFVLE1BQU0sa0RBQWtELFNBQVMsb0VBQW9FLDBDQUEwQyxTQUFTLE9BQU8sbUJBQW1CLG9DQUFvQywwQkFBMEIsUUFBUSwrQ0FBK0MsdUVBQXVFLHFCQUFxQix1RUFBdUUsc0JBQXNCLE9BQU8sb0NBQW9DLHlDQUF5QyxpQkFBaUIsVUFBVSxtR0FBbUcsMkZBQTJGLG9GQUFvRixvQ0FBb0MsbUNBQW1DLHFEQUFxRCxpRkFBaUYsa0NBQWtDLDZCQUE2Qiw2RUFBNkUsRUFBRSxxQkFBcUIsY0FBYywrRUFBK0UsV0FBVyxTQUFTLEVBQUUsT0FBTywyQkFBMkIseUJBQXlCLDBIQUEwSCw2RkFBNkYsUUFBUSwrREFBK0QsaUVBQWlFLGdCQUFnQixHQUFHLHFDQUFxQyw0RUFBNEUsZ0RBQWdELFVBQVUsNEZBQTRGLDRGQUE0RixtRUFBbUUsd0NBQXdDLHNDQUFzQyxzQ0FBc0MsMkRBQTJELHVCQUF1QixXQUFXLGlIQUFpSCxvSEFBb0gsNkJBQTZCLDJIQUEySCxxQkFBcUIsYUFBYSx1QkFBdUIsWUFBWSx3SEFBd0gsNEJBQTRCLFdBQVcsU0FBUyxRQUFRLHFHQUFxRyx3Q0FBd0Msb0JBQW9CLHVDQUF1QyxPQUFPLDRDQUE0QyxzQ0FBc0MsNkNBQTZDLDRGQUE0Riw2Q0FBNkMsb0hBQW9ILHFCQUFxQixXQUFXLDBGQUEwRix1R0FBdUcsdURBQXVELDJFQUEyRSxXQUFXLFNBQVMsT0FBTywwQkFBMEIsNENBQTRDLGlCQUFpQixTQUFTLHNEQUFzRCxzQ0FBc0Msa0RBQWtELHdDQUF3QywrREFBK0Qsd0NBQXdDLEVBQUUsT0FBTyxrQ0FBa0Msc0dBQXNHLG1JQUFtSSxpQkFBaUIsU0FBUyw0RkFBNEYsc09BQXNPLG9EQUFvRCxXQUFXLFNBQVMsT0FBTyxtQ0FBbUMscURBQXFELG1EQUFtRCxzQkFBc0IsR0FBRyxvQkFBb0IsV0FBVywyQ0FBMkMscURBQXFELFNBQVMsUUFBUSxtREFBbUQsc0NBQXNDLG1FQUFtRSw2Q0FBNkMsbUJBQW1CLFdBQVcsbUdBQW1HLHFEQUFxRCxPQUFPLEtBQUssV0FBVywyQkFBMkIsU0FBUyxFQUFFLE9BQU8sT0FBTywwR0FBMEcsaUVBQWlFLDJDQUEyQyxPQUFPLEtBQUssRUFBRSwrREFBK0QsMlZBQTJWLGdDQUFnQyw0QkFBNEIsV0FBVyxFQUFFLGdDQUFnQyxZQUFZLEVBQUUsb0NBQW9DLFlBQVksRUFBRSxnQ0FBZ0MsWUFBWSxFQUFFLGtDQUFrQyxZQUFZLEVBQUUseUNBQXlDLFlBQVksRUFBRSxvQ0FBb0MsWUFBWSxFQUFFLHVDQUF1QyxZQUFZLEVBQUUsdUNBQXVDLHlDQUF5QyxtQ0FBbUMsdUNBQXVDLHVDQUF1QyxxQ0FBcUMscUNBQXFDLHNDQUFzQyx3REFBd0Qsb0RBQW9ELG9EQUFvRCxrRUFBa0UsdUVBQXVFLHlEQUF5RCx1Q0FBdUMsNkJBQTZCLG9CQUFvQiw2QkFBNkIsa0JBQWtCLDZCQUE2QixFQUFFLG1IQUFtSCxvRUFBb0UsZUFBZSxJQUFJLHFCQUFxQixFQUFFLDRDQUE0QyxrQkFBa0IsNkJBQTZCLGtCQUFrQiw4QkFBOEIsa0JBQWtCLDJCQUEyQiw0RUFBNEUsNEJBQTRCLHVCQUF1QixpRUFBaUUsOEJBQThCLGtCQUFrQix5RUFBeUUsbUJBQW1CLHlCQUF5QixvQkFBb0IsWUFBWSwyR0FBMkcsdUZBQXVGLFFBQVEsdUNBQXVDLHNCQUFzQixRQUFRLDJCQUEyQiw4R0FBOEcsOENBQThDLGlCQUFpQixVQUFVLHlHQUF5RyxpRkFBaUYsMkNBQTJDLFNBQVMseUVBQXlFLHdDQUF3QyxFQUFFLHNGQUFzRixpQkFBaUIsU0FBUyw4Q0FBOEMsNENBQTRDLFFBQVEscURBQXFELHVCQUF1QixpQkFBaUIsU0FBUyxtREFBbUQsMkRBQTJELGtGQUFrRix1REFBdUQscURBQXFELG1CQUFtQixXQUFXLDRCQUE0Qiw4Q0FBOEMsc0RBQXNELGdEQUFnRCwwREFBMEQsaURBQWlELEVBQUUsVUFBVSxnR0FBZ0csT0FBTywyQ0FBMkMsdUJBQXVCLGlCQUFpQixTQUFTLHNEQUFzRCx1QkFBdUIsNkRBQTZELGtGQUFrRix1REFBdUQsd0RBQXdELG1CQUFtQixXQUFXLHlEQUF5RCxpREFBaUQsaURBQWlELDJEQUEyRCxpREFBaUQsRUFBRSxVQUFVLGdHQUFnRyxPQUFPLHlCQUF5QixtR0FBbUcsaUJBQWlCLFNBQVMsbUNBQW1DLGdJQUFnSSw2RUFBNkUsZ0pBQWdKLGtDQUFrQyw0REFBNEQsU0FBUyxPQUFPLHdCQUF3Qiw2R0FBNkcsT0FBTywwQkFBMEIsb0ZBQW9GLE9BQU8saURBQWlELGlFQUFpRSx5Q0FBeUMsbURBQW1ELFNBQVMsT0FBTyw2Q0FBNkMsNkNBQTZDLHFEQUFxRCx5REFBeUQsd0RBQXdELG9DQUFvQywyRUFBMkUsU0FBUywwQkFBMEIsK0NBQStDLFNBQVMsK0RBQStELHFHQUFxRyxPQUFPLG1EQUFtRCxxREFBcUQsd0JBQXdCLGlCQUFpQixTQUFTLG9FQUFvRSx5QkFBeUIsdUVBQXVFLFNBQVMsR0FBRyxTQUFTLE9BQU8sd0NBQXdDLHlEQUF5RCw4REFBOEQsaUJBQWlCLFNBQVMsbURBQW1ELHNFQUFzRSwwQkFBMEIsc0RBQXNELFdBQVcsVUFBVSw4REFBOEQsMERBQTBELDBEQUEwRCxzREFBc0QsT0FBTyw2REFBNkQsK0NBQStDLGlEQUFpRCxTQUFTLE9BQU8sNkJBQTZCLDBEQUEwRCxRQUFRLHlGQUF5Riw0R0FBNEcsUUFBUSx5RkFBeUYsb0RBQW9ELFFBQVEsbURBQW1ELHNDQUFzQyxxREFBcUQsNkNBQTZDLG1CQUFtQixXQUFXLG1HQUFtRyxxREFBcUQsT0FBTyxLQUFLLFdBQVcsMkJBQTJCLFNBQVMsRUFBRSxPQUFPLE9BQU8sNElBQTRJLGlEQUFpRCwrQkFBK0IsT0FBTywrQkFBK0IsZUFBZSxPQUFPLDZDQUE2QyxLQUFLLEVBQUUsa0dBQWtHLCtFQUErRSx5Q0FBeUMsT0FBTyxLQUFLLEVBQUUseURBQXlELDZWQUE2VixnQ0FBZ0MsMEJBQTBCLFNBQVMsRUFBRSx3Q0FBd0MsVUFBVSxFQUFFLHNDQUFzQyxVQUFVLEVBQUUsb0NBQW9DLFVBQVUsRUFBRSxzQ0FBc0MsVUFBVSxFQUFFLDhCQUE4QixVQUFVLEVBQUUsa0NBQWtDLFVBQVUsRUFBRSw4QkFBOEIsVUFBVSxFQUFFLGdDQUFnQyxVQUFVLEVBQUUsbUNBQW1DLG9DQUFvQyxnR0FBZ0cseUNBQXlDLHlCQUF5QixnRkFBZ0YscUJBQXFCLGtFQUFrRSw4RUFBOEUsb0NBQW9DLCtCQUErQiw2QkFBNkIsMENBQTBDLDZDQUE2QywrQkFBK0IsUUFBUSwwQ0FBMEMsdUJBQXVCLE9BQU8sa0NBQWtDLDJCQUEyQixPQUFPLDJCQUEyQixvQkFBb0IsUUFBUSwyQkFBMkIsMEVBQTBFLDJDQUEyQyxpQkFBaUIsU0FBUywrQkFBK0IsdUNBQXVDLHVEQUF1RCxTQUFTLGtDQUFrQyw2REFBNkQsNkRBQTZELHNDQUFzQyxVQUFVLDJEQUEyRCxnREFBZ0QsMkVBQTJFLCtFQUErRSxPQUFPLGdCQUFnQiw4QkFBOEIsaUJBQWlCLFNBQVMsNEVBQTRFLDJDQUEyQyxpQkFBaUIsU0FBUyxrQ0FBa0Msd0RBQXdELGdHQUFnRyw4REFBOEQsVUFBVSwwREFBMEQsK0VBQStFLE9BQU8sbUJBQW1CLDZCQUE2QiwrQkFBK0IsMERBQTBELFNBQVMsMEJBQTBCLE9BQU8sbUJBQW1CLGlFQUFpRSxRQUFRLDBDQUEwQyxxQ0FBcUMsaUJBQWlCLFNBQVMsMEVBQTBFLGlCQUFpQixTQUFTLDRDQUE0QyxzQkFBc0IsU0FBUyxzQkFBc0IsT0FBTyw4Q0FBOEMsNkJBQTZCLDJHQUEyRyxrQkFBa0IsOEdBQThHLGtCQUFrQixTQUFTLDhCQUE4QiwrQkFBK0IsbUJBQW1CLFNBQVMsa0RBQWtELHFGQUFxRixpQkFBaUIsU0FBUyxvQ0FBb0MsT0FBTyx5QkFBeUIsbUdBQW1HLG1HQUFtRyxpR0FBaUcsbUdBQW1HLE9BQU8seUJBQXlCLG9DQUFvQyw2QkFBNkIsUUFBUSxtREFBbUQsc0NBQXNDLCtEQUErRCw2Q0FBNkMsc0RBQXNELHVEQUF1RCxPQUFPLEtBQUssYUFBYSxpQ0FBaUMsV0FBVyxTQUFTLEVBQUUsT0FBTyxPQUFPLGdGQUFnRiwyREFBMkQsK1RBQStULHlLQUF5Syx1QkFBdUIsS0FBSyxHQUFHOzs7Ozs7Ozs7O0FDQXJobEosbUxBQW1MLHFCQUFxQixxREFBcUQsZ0ZBQWdGLE1BQU0sd0RBQXdELHNFQUFzRSxtQ0FBbUMsa1RBQWtULHVDQUF1QyxXQUFXLGdCQUFnQiw2Q0FBNkMsV0FBVyxTQUFTLHdCQUF3QixzQkFBc0IsUUFBUSxNQUFNLE1BQU0sOENBQThDLEtBQUssSUFBSSxvQkFBb0IsaU9BQWlPLCtNQUErTSxxQ0FBcUMsS0FBSyxTQUFTLGVBQWUsMkJBQTJCLGFBQWEsV0FBVyxPQUFPLGVBQWUsb1VBQW9VLHFCQUFxQiw2REFBNkQsdUJBQXVCLHNCQUFzQix3QkFBd0IsaUhBQWlILHFDQUFxQyx3Q0FBd0MsT0FBTyxzSkFBc0osUUFBUSx1Q0FBdUMsUUFBUSxpRkFBaUYsUUFBUSxrRUFBa0UsMFJBQTBSLDZEQUE2RCxxQ0FBcUMsMENBQTBDLHlUQUF5VCxnRkFBZ0YsZUFBZSxvSEFBb0gsb2JBQW9iLDBEQUEwRCxlQUFlLDBEQUEwRCxpQkFBaUIsTUFBTSxpQ0FBaUMscUNBQXFDLHdDQUF3Qyw2QkFBNkIsb0JBQW9CLHlCQUF5QiwyY0FBMmMsbUNBQW1DLHdCQUF3QixpQkFBaUIsZ0RBQWdELGlDQUFpQyx1QkFBdUIsbUJBQW1CLGVBQWUsa0VBQWtFLFdBQVcsMEZBQTBGLDBDQUEwQywyQ0FBMkMsT0FBTyxTQUFTLGtFQUFrRSxvQ0FBb0Msb05BQW9OLE9BQU8sU0FBUywwRUFBMEUsaUtBQWlLLCtEQUErRCw2Q0FBNkMsOEhBQThILDZDQUE2Qyx3Q0FBd0MsK0JBQStCLDJCQUEyQix1QkFBdUIsbUJBQW1CLG1DQUFtQyw0QkFBNEIsbUJBQW1CLHVSQUF1UiwwREFBMEQsZ0NBQWdDLG1CQUFtQixlQUFlLGdEQUFnRCwwQ0FBMEMsaUNBQWlDLGVBQWUsK0JBQStCLHdEQUF3RCw2Q0FBNkMsZUFBZSxXQUFXLHdCQUF3QixPQUFPLGtEQUFrRCw4QkFBOEIsZ09BQWdPLHNSQUFzUixrQ0FBa0MsZUFBZSx5RUFBeUUsWUFBWSxPQUFPLHlDQUF5QyxrQ0FBa0MsOENBQThDLFlBQVksT0FBTyxvQ0FBb0MsbUNBQW1DLHVDQUF1QyxZQUFZLE9BQU8sZ0NBQWdDLHVDQUF1Qyx1Q0FBdUMsbUNBQW1DLG9DQUFvQyxzQ0FBc0MsV0FBVyxzRUFBc0UsNENBQTRDLFdBQVcsK0JBQStCLE9BQU8saUxBQWlMLHlFQUF5RSwyQkFBMkIsZ0RBQWdELDREQUE0RCxXQUFXLGdDQUFnQyxPQUFPLGtNQUFrTSxxREFBcUQsT0FBTyxpT0FBaU8seUlBQXlJLDRCQUE0Qix5QkFBeUIsMERBQTBELHVDQUF1QyxXQUFXLHdEQUF3RCwrQ0FBK0MsZ0ZBQWdGLGdCQUFnQixNQUFNLDBEQUEwRCxlQUFlLFlBQVksTUFBTSxzREFBc0Qsd0NBQXdDLGdDQUFnQyw4QkFBOEIsMkJBQTJCLDJDQUEyQyxlQUFlLFdBQVcsaUZBQWlGLGtKQUFrSixRQUFRLG1DQUFtQyw4QkFBOEIsNEVBQTRFLFlBQVksT0FBTyxvQkFBb0Isb0NBQW9DLHVDQUF1QyxXQUFXLHFDQUFxQyxvQ0FBb0MsNkNBQTZDLDJCQUEyQixnQkFBZ0IsTUFBTSw0Q0FBNEMsRUFBRSxlQUFlLFdBQVcsb0NBQW9DLHNCQUFzQix3SkFBd0osV0FBVyxRQUFRLHlEQUF5RCx3SkFBd0osd0VBQXdFLDJDQUEyQywrSUFBK0ksNFFBQTRRLDBCQUEwQixpQkFBaUIsU0FBUyxtREFBbUQsa0NBQWtDLCtHQUErRyx1REFBdUQsb0JBQW9CLG1DQUFtQyx1R0FBdUcsMENBQTBDLG9CQUFvQixrQ0FBa0Msa0hBQWtILG9CQUFvQix3SkFBd0osaURBQWlELG9CQUFvQixpQkFBaUIseUZBQXlGLEVBQUUsaURBQWlELG9CQUFvQixNQUFNLG9FQUFvRSxtQkFBbUIsZUFBZSxpRkFBaUYsMkJBQTJCLG1WQUFtVix3REFBd0Qsb0JBQW9CLDBDQUEwQyx5R0FBeUcsbUJBQW1CLGVBQWUsWUFBWSxnQkFBZ0IsdUtBQXVLLFdBQVcsUUFBUSx3RkFBd0YsMkNBQTJDLG1DQUFtQyw2R0FBNkcsZUFBZSxrVEFBa1QsWUFBWSx3QkFBd0Isa0ZBQWtGLGdDQUFnQyxvREFBb0QsZUFBZSw4QkFBOEIseUJBQXlCLGVBQWUsc0NBQXNDLHlLQUF5SyxxQ0FBcUMsaUNBQWlDLGdCQUFnQixNQUFNLCtCQUErQixlQUFlLFdBQVcsb0ZBQW9GLHdJQUF3SSxrQ0FBa0MsOEJBQThCLFdBQVcsc0NBQXNDLDBCQUEwQixtREFBbUQsWUFBWSxNQUFNLDBoQkFBMGhCLHVEQUF1RCxlQUFlLEtBQUssV0FBVyx1QkFBdUIsUUFBUSxvS0FBb0ssMEJBQTBCLFFBQVEsZ0hBQWdILGtEQUFrRCx5Q0FBeUMsMkZBQTJGLFdBQVcsZ0ZBQWdGLHFMQUFxTCx3QkFBd0IsV0FBVyxxRUFBcUUscURBQXFELFdBQVcsUUFBUSxzQkFBc0IsOEJBQThCLEdBQUcsSUFBSSw2QkFBNkIscUJBQXFCLG1CQUFtQixHQUFHLEdBQUcsSUFBSSxvQ0FBb0MsRUFBRSwyRUFBMkUseUJBQXlCLG1EQUFtRCxtTkFBbU4sS0FBSyxnQkFBZ0IsR0FBRyxFQUFFLDhEQUE4RCxtQkFBbUIsd0RBQXdELHdCQUF3QixnQkFBZ0IscUNBQXFDLHNDQUFzQyxPQUFPLHFDQUFxQyw4Q0FBOEMsNENBQTRDLFNBQVMsT0FBTyx5REFBeUQsbURBQW1ELGtEQUFrRCwwQkFBMEIsTUFBTSxzQ0FBc0MscUNBQXFDLHlCQUF5Qix1Q0FBdUMsa0NBQWtDLHdDQUF3QyxtQkFBbUIsU0FBUyw2Q0FBNkMsbUJBQW1CLFNBQVMsbUNBQW1DLE9BQU8sdUJBQXVCLEtBQUssOERBQThELHdEQUF3RCxnREFBZ0Qsb0NBQW9DLDhDQUE4QyxxRUFBcUUsbUVBQW1FLDZCQUE2QixvRUFBb0UscUVBQXFFLFNBQVMsbURBQW1ELE9BQU8sNERBQTRELHlCQUF5QiwwQ0FBMEMsT0FBTyw2Q0FBNkMsd0JBQXdCLHlCQUF5QixNQUFNLDBDQUEwQyw2RkFBNkYsT0FBTyxrREFBa0QsMkhBQTJILHVEQUF1RCxnRUFBZ0UsU0FBUyxxRUFBcUUsOEJBQThCLGdEQUFnRCxvREFBb0QsMERBQTBELFVBQVUsUUFBUSx3QkFBd0IsNkJBQTZCLE1BQU0sa0RBQWtELG9GQUFvRixPQUFPLDhCQUE4QixNQUFNLG9DQUFvQywwQkFBMEIsTUFBTSw0REFBNEQsNENBQTRDLHNDQUFzQyw2Q0FBNkMsUUFBUSxNQUFNLDJDQUEyQyxPQUFPLE1BQU0sdURBQXVELHdDQUF3Qyw0Q0FBNEMsOENBQThDLDhFQUE4RSxvQkFBb0IsT0FBTyx5R0FBeUcsc0JBQXNCLEVBQUUsT0FBTyx5RkFBeUYsc0NBQXNDLHFFQUFxRSxPQUFPLG9DQUFvQyxvREFBb0QsT0FBTyxNQUFNLGtFQUFrRSw4Q0FBOEMsU0FBUyxNQUFNLHlDQUF5QyxPQUFPLE1BQU0sb0NBQW9DLCtDQUErQyxxQkFBcUIsd0JBQXdCLFlBQVksTUFBTSx3REFBd0QseUNBQXlDLE9BQU8scUJBQXFCLE1BQU0sNkNBQTZDLDBCQUEwQix1Q0FBdUMsUUFBUSxNQUFNLDRDQUE0QyxxQ0FBcUMsMENBQTBDLCtCQUErQixrQ0FBa0MsbUJBQW1CLFNBQVMsMEJBQTBCLGlCQUFpQixNQUFNLDRCQUE0Qix1S0FBdUssc0NBQXNDLGdDQUFnQyxXQUFXLHVDQUF1QywrQ0FBK0MsV0FBVyx1Q0FBdUMsU0FBUyxtQ0FBbUMsT0FBTyxvQkFBb0IsTUFBTSw4Q0FBOEMscVVBQXFVLHlDQUF5Qyx5Q0FBeUMsNklBQTZJLHFCQUFxQixPQUFPLCtEQUErRCxvQkFBb0IsT0FBTyxpR0FBaUcsTUFBTSw4Q0FBOEMsd0JBQXdCLHNCQUFzQixxQkFBcUIsb0JBQW9CLG9CQUFvQix1QkFBdUIsdUJBQXVCLHFCQUFxQixTQUFTLHNHQUFzRyxzQkFBc0IsT0FBTyw0RUFBNEUsaUNBQWlDLE9BQU8sRUFBRSxNQUFNLGdIQUFnSCxrTEFBa0wsMkJBQTJCLHlDQUF5Qyx3Q0FBd0MsU0FBUyxFQUFFLDRCQUE0QixPQUFPLGdDQUFnQyxNQUFNLDRGQUE0RixpQkFBaUIsbURBQW1ELGlSQUFpUiw4QkFBOEIsOERBQThELGlDQUFpQyw2REFBNkQsVUFBVSxNQUFNLHdEQUF3RCxvQ0FBb0MsU0FBUyxPQUFPLHVCQUF1QixNQUFNLHlEQUF5RCw2SUFBNkksK0JBQStCLCtCQUErQixPQUFPLHdDQUF3QyxNQUFNLGdEQUFnRCwyUEFBMlAsaUJBQWlCLGdDQUFnQyxnREFBZ0QsMkNBQTJDLFdBQVcsd0NBQXdDLDJDQUEyQyxzQ0FBc0MsMENBQTBDLE1BQU0saUNBQWlDLE9BQU8sTUFBTSw2Q0FBNkMsMkdBQTJHLHNDQUFzQyxpQ0FBaUMsT0FBTyxtREFBbUQsTUFBTSxtQkFBbUIsR0FBRyxFQUFFLHFGQUFxRix1REFBdUQsK0JBQStCLDhCQUE4Qiw2QkFBNkIsaURBQWlELEtBQUssOENBQThDLDhDQUE4QyxzR0FBc0csMkNBQTJDLHNEQUFzRCxPQUFPLGlDQUFpQyx3QkFBd0IsTUFBTSw2Q0FBNkMsNEJBQTRCLE1BQU0sNERBQTRELDBEQUEwRCxxQkFBcUIseUJBQXlCLHlJQUF5SSwyRUFBMkUsNEZBQTRGLDZEQUE2RCx1Q0FBdUMsTUFBTSxvREFBb0QsK0RBQStELE1BQU0sa0RBQWtELHlCQUF5QiwwQkFBMEIsZ0VBQWdFLG9EQUFvRCwyQ0FBMkMsMkNBQTJDLEVBQUUsU0FBUyxpQkFBaUIsT0FBTywrQ0FBK0Msd0JBQXdCLHlCQUF5QixNQUFNLG1DQUFtQywwQ0FBMEMsaUNBQWlDLE9BQU8sdUNBQXVDLE1BQU0sbUVBQW1FLGlFQUFpRSx5Q0FBeUMsTUFBTSxnREFBZ0QsOENBQThDLDRCQUE0QixNQUFNLDBEQUEwRCwyRkFBMkYsZ0VBQWdFLG1GQUFtRiw2R0FBNkcsUUFBUSxNQUFNLGdKQUFnSixPQUFPLHNDQUFzQyxNQUFNLGtEQUFrRCxzQkFBc0IsK0NBQStDLHdEQUF3RCxpQ0FBaUMsU0FBUyxFQUFFLGlHQUFpRyxxQ0FBcUMsZ0NBQWdDLG1EQUFtRCxrR0FBa0csNElBQTRJLGtEQUFrRCxZQUFZLE1BQU0sbURBQW1ELFdBQVcsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlEQUF5RCx5QkFBeUIsNEVBQTRFLHVCQUF1QixzRkFBc0YsMENBQTBDLCtDQUErQyx3Q0FBd0MsTUFBTSxtREFBbUQsc0RBQXNELE1BQU0sa0RBQWtELGdEQUFnRCxtREFBbUQscUJBQXFCLGlFQUFpRSxxS0FBcUssb0lBQW9JLHNDQUFzQyx3Q0FBd0MsT0FBTyw4QkFBOEIsc0NBQXNDLE9BQU8scUNBQXFDLG1DQUFtQyxPQUFPLHlCQUF5QixrQ0FBa0MsT0FBTyw0QkFBNEIsNkJBQTZCLHdDQUF3QyxzQ0FBc0MsT0FBTyxpQ0FBaUMsOEJBQThCLHlDQUF5QyxPQUFPLDRCQUE0QixnQ0FBZ0MsdURBQXVELG1EQUFtRCxnQ0FBZ0MsbUNBQW1DLDZCQUE2QiwwQkFBMEIsMEJBQTBCLE1BQU0sdUNBQXVDLDRDQUE0QyxtQ0FBbUMsU0FBUyxtREFBbUQsdUZBQXVGLEVBQUUsK0NBQStDLGdDQUFnQywyQ0FBMkMsUUFBUSxNQUFNLG9DQUFvQyxPQUFPLDhDQUE4QyxzQkFBc0IsTUFBTSxpRUFBaUUsc0JBQXNCLDJDQUEyQyxxQ0FBcUMsdURBQXVELHFCQUFxQixpQ0FBaUMsbUNBQW1DLDRCQUE0QixvQ0FBb0MsU0FBUyxPQUFPLEVBQUUsMERBQTBELGlDQUFpQyxtQ0FBbUMsNEJBQTRCLFNBQVMsT0FBTyxFQUFFLGlEQUFpRCw0QkFBNEIsaUNBQWlDLE9BQU8sRUFBRSw0Q0FBNEMsa0NBQWtDLGlCQUFpQixTQUFTLDRCQUE0QixzREFBc0Qsb0NBQW9DLFNBQVMsT0FBTyxFQUFFLDhDQUE4QyxrQ0FBa0MsaUJBQWlCLFNBQVMsNEJBQTRCLHNEQUFzRCxvQ0FBb0MsU0FBUyxPQUFPLEVBQUUsMENBQTBDLGdIQUFnSCxtREFBbUQsNEJBQTRCLHNDQUFzQyxPQUFPLEVBQUUsMkNBQTJDLG9IQUFvSCxrREFBa0QsMERBQTBELE9BQU8sRUFBRSxvREFBb0Qsd0RBQXdELDBDQUEwQyxpQkFBaUIsU0FBUywwQ0FBMEMsT0FBTyxFQUFFLG9EQUFvRCx3REFBd0QsMENBQTBDLGlCQUFpQixTQUFTLDREQUE0RCw2REFBNkQsa0NBQWtDLEVBQUUsVUFBVSxNQUFNLGtDQUFrQyxpQ0FBaUMsRUFBRSxTQUFTLE9BQU8sRUFBRSxzREFBc0Qsd0RBQXdELCtEQUErRCwwREFBMEQsOElBQThJLGlCQUFpQixTQUFTLDJDQUEyQyxpR0FBaUcsd0JBQXdCLFNBQVMsNkNBQTZDLHNDQUFzQyx5REFBeUQseUNBQXlDLCtFQUErRSxnQ0FBZ0MscUNBQXFDLFVBQVUsdUNBQXVDLDhDQUE4QyxTQUFTLE9BQU8sRUFBRSxrREFBa0Qsd0RBQXdELCtEQUErRCwwREFBMEQsMkNBQTJDLGdHQUFnRyxpQkFBaUIsU0FBUyw2Q0FBNkMsc0NBQXNDLHFHQUFxRyx1RUFBdUUsZ0ZBQWdGLGdDQUFnQyxxQ0FBcUMsVUFBVSxzQ0FBc0MsOENBQThDLFNBQVMsT0FBTyxFQUFFLHlEQUF5RCx3RUFBd0UsT0FBTyxFQUFFLDJEQUEyRCxvQ0FBb0MsT0FBTyxFQUFFLDhCQUE4QixxREFBcUQsOENBQThDLDRFQUE0RSw4REFBOEQsNEVBQTRFLDBCQUEwQix1Q0FBdUMsaUNBQWlDLGdDQUFnQyxZQUFZLHNCQUFzQiwwSEFBMEgsaUNBQWlDLGdDQUFnQyxXQUFXLFNBQVMsRUFBRSxPQUFPLHNHQUFzRyw0QkFBNEIsaURBQWlELHVEQUF1RCw2Q0FBNkMsc0NBQXNDLHNFQUFzRSxFQUFFLFlBQVksTUFBTSxvQ0FBb0MsRUFBRSxXQUFXLG1CQUFtQixTQUFTLGtDQUFrQywwREFBMEQsRUFBRSxPQUFPLEVBQUUseUdBQXlHLCtDQUErQyx1R0FBdUcseUNBQXlDLHdEQUF3RCxFQUFFLE9BQU8sRUFBRSxNQUFNLDZEQUE2RCwyRkFBMkYsNEJBQTRCLE1BQU0sK0NBQStDLDZCQUE2QixNQUFNLDhEQUE4RCxzREFBc0Qsd0NBQXdDLGVBQWUsT0FBTyw2REFBNkQsd0RBQXdELHVEQUF1RCw4Q0FBOEMsNkVBQTZFLGtEQUFrRCx3REFBd0QsZ0NBQWdDLG1DQUFtQyxRQUFRLHdFQUF3RSw0Q0FBNEMsT0FBTyxNQUFNLGlFQUFpRSx3REFBd0QsMERBQTBELGtEQUFrRCw4QkFBOEIseUNBQXlDLFFBQVEsdUNBQXVDLG9EQUFvRCxRQUFRLE1BQU0scUNBQXFDLE9BQU8sTUFBTSxxQkFBcUIsR0FBRyxFQUFFLGtEQUFrRCxnQkFBZ0IsK1FBQStRLGtCQUFrQixHQUFHLEVBQUUsaUhBQWlILGdEQUFnRCwrQkFBK0IsNkJBQTZCLHVEQUF1RCxLQUFLLG9EQUFvRCxvREFBb0QsOEtBQThLLDJCQUEyQixzRUFBc0UseUVBQXlFLFFBQVEsa0RBQWtELHdEQUF3RCxPQUFPLDhEQUE4RCxrREFBa0QsZ0RBQWdELHFDQUFxQywwQkFBMEIsTUFBTSx1RUFBdUUsc0JBQXNCLGtEQUFrRCxtQ0FBbUMsb0RBQW9ELG1DQUFtQyxPQUFPLEVBQUUsbURBQW1ELDhCQUE4QixPQUFPLEVBQUUsc0RBQXNELHNDQUFzQyx5Q0FBeUMsK0JBQStCLFNBQVMsT0FBTyxFQUFFLHlEQUF5RCw2RUFBNkUsT0FBTyxFQUFFLDREQUE0RCxpQ0FBaUMsT0FBTyxFQUFFLDBDQUEwQyxrSEFBa0gscURBQXFELDhDQUE4QyxPQUFPLEVBQUUsMkNBQTJDLHNIQUFzSCw0REFBNEQsZ0RBQWdELDJDQUEyQyw4Q0FBOEMsT0FBTyxFQUFFLDRDQUE0Qyx5REFBeUQsdURBQXVELE9BQU8sRUFBRSw2Q0FBNkMsK0NBQStDLHNEQUFzRCxPQUFPLEVBQUUsTUFBTSw0REFBNEQsc0JBQXNCLDJLQUEySywwTkFBME4saUJBQWlCLFNBQVMsb0NBQW9DLE9BQU8sS0FBSyxNQUFNLDBFQUEwRSwrRUFBK0Usa0NBQWtDLG9EQUFvRCwyREFBMkQsaUNBQWlDLG1DQUFtQyxtQkFBbUIsV0FBVywwREFBMEQsc0NBQXNDLFNBQVMsRUFBRSxPQUFPLEVBQUUsTUFBTSwwRUFBMEUsZ0VBQWdFLE1BQU0sNEVBQTRFLDhEQUE4RCw2Q0FBNkMsTUFBTSxxREFBcUQsK0NBQStDLE1BQU0sd0RBQXdELCtFQUErRSxNQUFNLDhIQUE4SCxNQUFNLGdEQUFnRCxPQUFPLHdGQUF3RixnQ0FBZ0MsTUFBTSxzR0FBc0csTUFBTSwrQ0FBK0MsT0FBTyw2RkFBNkYsMENBQTBDLE1BQU0sMkJBQTJCLEdBQUcsRUFBRSwrSUFBK0ksaUNBQWlDLG1FQUFtRSxLQUFLLG1EQUFtRCxzREFBc0QsbUVBQW1FLHlEQUF5RCxzT0FBc08sMEJBQTBCLE1BQU0seUVBQXlFLHNCQUFzQiw4REFBOEQsNkNBQTZDLDBKQUEwSixrREFBa0Qsd0RBQXdELG9FQUFvRSxpQkFBaUIsU0FBUyxrQ0FBa0MscUNBQXFDLEVBQUUsT0FBTyxFQUFFLG9EQUFvRCwrQ0FBK0MsRUFBRSxtREFBbUQsMENBQTBDLEVBQUUsOENBQThDLGtDQUFrQywyQ0FBMkMsU0FBUyxPQUFPLEVBQUUsTUFBTSxxREFBcUQsMkVBQTJFLHdCQUF3QixxQ0FBcUMsK0JBQStCLHNFQUFzRSwyREFBMkQsMERBQTBELHVEQUF1RCxNQUFNLGtFQUFrRSxnQ0FBZ0MsTUFBTSwwREFBMEQsOEJBQThCLHFCQUFxQixlQUFlLE9BQU8sZ0NBQWdDLDZFQUE2RSx5REFBeUQsNENBQTRDLHNEQUFzRCxvQkFBb0IsdUNBQXVDLFFBQVEsTUFBTSxzQ0FBc0MsT0FBTyxNQUFNLDZCQUE2QixHQUFHLEVBQUUsNkhBQTZILG9EQUFvRCxxRUFBcUUsS0FBSyxxREFBcUQsd0RBQXdELHFFQUFxRSwyREFBMkQseUZBQXlGLDBCQUEwQixNQUFNLDJFQUEyRSxzQkFBc0IsZ0VBQWdFLG9EQUFvRCxnQ0FBZ0MscUNBQXFDLEVBQUUsT0FBTyxFQUFFLGdIQUFnSCxpRkFBaUYsbUJBQW1CLFdBQVcsa0NBQWtDLDRDQUE0Qyw0REFBNEQsc0NBQXNDLGdFQUFnRSxFQUFFLFNBQVMsUUFBUSxNQUFNLHVEQUF1RCwyRUFBMkUsd0JBQXdCLG9DQUFvQyxNQUFNLHdFQUF3RSwyREFBMkQsMERBQTBELHVEQUF1RCxNQUFNLG9FQUFvRSx1TEFBdUwsK0NBQStDLDBCQUEwQixNQUFNLDREQUE0RCxtQkFBbUIsZ0NBQWdDLGVBQWUsT0FBTyw2QkFBNkIsd0JBQXdCLGlCQUFpQixNQUFNLGdDQUFnQyxxREFBcUQsNERBQTRELHVDQUF1Qyx3REFBd0Qsc0JBQXNCLDBDQUEwQyxTQUFTLDREQUE0RCx1Q0FBdUMsT0FBTyw2RUFBNkUsaURBQWlELE1BQU0sK0JBQStCLEdBQUcsRUFBRSxvRkFBb0YseURBQXlELCtFQUErRSxnREFBZ0QsS0FBSyw4RUFBOEUsNENBQTRDLHVCQUF1QixzREFBc0QsT0FBTywyQkFBMkIsTUFBTSxtRkFBbUYsbURBQW1ELHFEQUFxRCx5SEFBeUgsNEJBQTRCLE1BQU0saUVBQWlFLG9HQUFvRywrQ0FBK0Msc0RBQXNELDBDQUEwQyxPQUFPLHFCQUFxQixvRUFBb0Usa0ZBQWtGLE1BQU0seUJBQXlCLEdBQUcsRUFBRSx1SEFBdUgsOEJBQThCLCtFQUErRSxzQkFBc0Isb0RBQW9ELHVDQUF1QywyRUFBMkUsK0pBQStKLFNBQVMsT0FBTyw0RkFBNEYsaUNBQWlDLE9BQU8sRUFBRSxpREFBaUQsa0RBQWtELE9BQU8sRUFBRSxNQUFNLDZEQUE2RCx5RUFBeUUsZUFBZSxPQUFPLHVFQUF1RSx3RkFBd0YsZUFBZSxPQUFPLDhCQUE4QixvREFBb0QsOENBQThDLDZDQUE2Qyw0QkFBNEIsMEJBQTBCLDBDQUEwQyxtQ0FBbUMsdUNBQXVDLGVBQWUsT0FBTyx3QkFBd0IsaUJBQWlCLE1BQU0sd0JBQXdCLGlDQUFpQyxnSkFBZ0osaUdBQWlHLHlDQUF5QyxpQkFBaUIsU0FBUyxPQUFPLHlEQUF5RCxpQ0FBaUMsRUFBRSxNQUFNLGdGQUFnRiwrQkFBK0IsZUFBZSxPQUFPLHNFQUFzRSwrQkFBK0IsT0FBTyxNQUFNLGdFQUFnRSxpQ0FBaUMsK0dBQStHLGVBQWUsT0FBTywrRUFBK0UsNEhBQTRILDRCQUE0QixnREFBZ0QsOEVBQThFLE1BQU0sd0JBQXdCLEdBQUcsRUFBRSxtSEFBbUgsb0RBQW9ELDhDQUE4QyxLQUFLLHNEQUFzRCxvV0FBb1csd0NBQXdDLDJDQUEyQyw2Q0FBNkMsaUNBQWlDLHlCQUF5QixNQUFNLDJFQUEyRSxzQkFBc0Isa0RBQWtELG9EQUFvRCwwQ0FBMEMsc0RBQXNELHNDQUFzQyxPQUFPLEVBQUUsMkNBQTJDLDZCQUE2QixpREFBaUQseURBQXlELHNDQUFzQyxPQUFPLEVBQUUsNENBQTRDLDZDQUE2QyxtQ0FBbUMsT0FBTyxFQUFFLDZDQUE2Qyw0Q0FBNEMsT0FBTyxFQUFFLDhDQUE4QyxzQ0FBc0MsT0FBTyxFQUFFLHlEQUF5RCxvQ0FBb0MsNEVBQTRFLFVBQVUsTUFBTSwyREFBMkQsU0FBUyxPQUFPLEVBQUUsaUZBQWlGLG1DQUFtQyxPQUFPLEVBQUUsa0ZBQWtGLDhCQUE4QixPQUFPLEVBQUUsaUZBQWlGLDhCQUE4Qix3Q0FBd0MsMERBQTBELDhCQUE4QixvRUFBb0UscUdBQXFHLDZDQUE2QyxpRUFBaUUsNENBQTRDLG1DQUFtQyxXQUFXLFNBQVMsT0FBTyxFQUFFLCtFQUErRSxpQ0FBaUMsZ0NBQWdDLFNBQVMsT0FBTyxFQUFFLG9WQUFvVixrREFBa0Qsc1RBQXNULHdQQUF3UCxrRUFBa0UsbUJBQW1CLFdBQVcsZ0dBQWdHLFNBQVMsUUFBUSx5SEFBeUgsZ1JBQWdSLGtFQUFrRSxtQkFBbUIsV0FBVyxnQ0FBZ0Msc0lBQXNJLG1CQUFtQixXQUFXLGlHQUFpRyxtQkFBbUIsV0FBVyxtQ0FBbUMsU0FBUyxRQUFRLE1BQU0seVRBQXlULHNFQUFzRSw2Q0FBNkMsTUFBTSw4RUFBOEUseURBQXlELE1BQU0sNERBQTRELHFFQUFxRSw2Q0FBNkMsbUNBQW1DLGdIQUFnSCw0QkFBNEIsMkJBQTJCLHNDQUFzQyxPQUFPLE1BQU0sbURBQW1ELDBCQUEwQixvQ0FBb0MsdUNBQXVDLGlDQUFpQyw4QkFBOEIsRUFBRSxPQUFPLHFDQUFxQyxNQUFNLHdFQUF3RSxnQ0FBZ0MseUJBQXlCLEVBQUUsb0NBQW9DLDBCQUEwQixNQUFNLG1EQUFtRCx3Q0FBd0MsdUJBQXVCLHNEQUFzRCw2RUFBNkUsUUFBUSxNQUFNLHlEQUF5RCwrQ0FBK0MsT0FBTyx5Q0FBeUMsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLDZFQUE2RSw4QkFBOEIsK0VBQStFLHNCQUFzQixpTEFBaUwsNkdBQTZHLG9EQUFvRCxtREFBbUQscUdBQXFHLGlCQUFpQixTQUFTLG9GQUFvRiwwR0FBMEcsaUNBQWlDLEVBQUUscUNBQXFDLGlIQUFpSCxpQkFBaUIsU0FBUyxzREFBc0QsT0FBTyxFQUFFLE1BQU0sd0JBQXdCLEdBQUcsRUFBRSwyRkFBMkYsaUNBQWlDLDZCQUE2QixLQUFLLCtDQUErQyx1QkFBdUIsTUFBTSxrREFBa0QsNEJBQTRCLE1BQU0sNkRBQTZELDZCQUE2QixnQ0FBZ0MsTUFBTSx1REFBdUQsOENBQThDLDBDQUEwQyx5Q0FBeUMsa0RBQWtELE9BQU8seURBQXlELE1BQU0seUJBQXlCLEdBQUcsRUFBRSx3REFBd0Qsc0JBQXNCLGs4aUJBQWs4aUIsd0JBQXdCLEdBQUcsRUFBRSx3RUFBd0UsOENBQThDLG1EQUFtRCxLQUFLLGtEQUFrRCwyREFBMkQsZ0ZBQWdGLE1BQU0saUVBQWlFLDhFQUE4RSxNQUFNLHFFQUFxRSwrQ0FBK0MsbURBQW1ELCtDQUErQywyRUFBMkUseUNBQXlDLHFDQUFxQyw4QkFBOEIsdUNBQXVDLFFBQVEsTUFBTSwyQ0FBMkMsT0FBTyxnQkFBZ0IsTUFBTSx5QkFBeUIsR0FBRyxFQUFFLG9IQUFvSCxnREFBZ0QsK0JBQStCLDZCQUE2Qix1REFBdUQsS0FBSywrQ0FBK0MsNkRBQTZELG9CQUFvQixzQkFBc0IsMERBQTBELDhCQUE4QiwwQ0FBMEMsNEJBQTRCLE9BQU8sRUFBRSx1QkFBdUIsTUFBTSx3REFBd0Qsc0JBQXNCLDZCQUE2QixpR0FBaUcscUNBQXFDLDJEQUEyRCxpQkFBaUIsT0FBTyw2Q0FBNkMsNkNBQTZDLHVCQUF1QiwwQkFBMEIsNkNBQTZDLDRCQUE0QixpQkFBaUIsTUFBTSxnQ0FBZ0MsOENBQThDLDJCQUEyQixhQUFhLFdBQVcsbUNBQW1DLDJEQUEyRCxTQUFTLEVBQUUsUUFBUSxNQUFNLDBCQUEwQixpQ0FBaUMseURBQXlELE9BQU8sTUFBTSwwREFBMEQsc0JBQXNCLDhDQUE4QyxlQUFlLE9BQU8sOEJBQThCLDJDQUEyQyxzQ0FBc0MsMkRBQTJELGlCQUFpQixPQUFPLDZDQUE2QyxxQkFBcUIsMEJBQTBCLHdCQUF3QixNQUFNLHFDQUFxQyw4REFBOEQseUJBQXlCLFdBQVcsU0FBUyxpQ0FBaUMsMkRBQTJELE9BQU8sRUFBRSxNQUFNLHVFQUF1RSxzQkFBc0IsbUNBQW1DLGtEQUFrRCxpQ0FBaUMsT0FBTyxFQUFFLG9EQUFvRCxtQ0FBbUMsT0FBTyxFQUFFLE1BQU0scURBQXFELGdHQUFnRywrRUFBK0UsT0FBTyxFQUFFLE1BQU0sbUVBQW1FLG9CQUFvQixzQkFBc0IsZ0RBQWdELG1DQUFtQyw4QkFBOEIsaUVBQWlFLGlCQUFpQixTQUFTLDBDQUEwQyxxREFBcUQsaUNBQWlDLDZCQUE2QixTQUFTLE9BQU8sRUFBRSxrQkFBa0IsNEJBQTRCLEVBQUUsTUFBTSxnRUFBZ0UsZ0RBQWdELE1BQU0sd0RBQXdELGlCQUFpQiw0QkFBNEIsb0RBQW9ELGlDQUFpQyxRQUFRLE1BQU0sa0RBQWtELGlEQUFpRCx5Q0FBeUMsVUFBVSxNQUFNLHVDQUF1QyxTQUFTLE9BQU8sb0NBQW9DLCtCQUErQixPQUFPLDRCQUE0QiwrQkFBK0IsT0FBTyw0QkFBNEIsK0JBQStCLE9BQU8seUJBQXlCLGtDQUFrQyxPQUFPLGdDQUFnQyx1REFBdUQsc0NBQXNDLGtIQUFrSCx1QkFBdUIsTUFBTSx5REFBeUQsb0JBQW9CLGlEQUFpRCwyQkFBMkIsb0JBQW9CLE9BQU8sbUNBQW1DLGdCQUFnQixxTUFBcU0sUUFBUSxrQ0FBa0MsZ0JBQWdCLDZHQUE2RyxxREFBcUQsMEJBQTBCLDBCQUEwQixzQkFBc0IsTUFBTSx1Q0FBdUMsMENBQTBDLGlDQUFpQyxTQUFTLG1DQUFtQyxPQUFPLHlDQUF5QyxnQ0FBZ0Msa0RBQWtELG9CQUFvQixNQUFNLGdFQUFnRSxrQ0FBa0MsZ0JBQWdCLGlEQUFpRCxPQUFPLDBCQUEwQixHQUFHLHVCQUF1QixRQUFRLHdCQUF3Qix1REFBdUQsOEJBQThCLHFDQUFxQyxPQUFPLGdDQUFnQyx5Q0FBeUMsT0FBTywwRUFBMEUscUVBQXFFLE9BQU8sMEJBQTBCLGtCQUFrQixNQUFNLGlFQUFpRSxnREFBZ0QscUNBQXFDLE1BQU0sMkJBQTJCLEdBQUcsRUFBRSx1SEFBdUgsK0NBQStDLHNEQUFzRCx5RUFBeUUsS0FBSyxnREFBZ0Qsc0VBQXNFLG9FQUFvRSxvRUFBb0UsTUFBTSx1REFBdUQsMkVBQTJFLCtDQUErQyxPQUFPLEVBQUUsbUNBQW1DLG9DQUFvQyxtQ0FBbUMsT0FBTyx1REFBdUQsTUFBTSxpRUFBaUUsc0JBQXNCLHFEQUFxRCxtREFBbUQscUNBQXFDLE9BQU8sUUFBUSwwQkFBMEIseUdBQXlHLDRCQUE0QiwwQ0FBMEMsVUFBVSxPQUFPLHdCQUF3QixpQkFBaUIsTUFBTSxnREFBZ0QscUhBQXFILGlFQUFpRSwwREFBMEQseUNBQXlDLHNCQUFzQixrREFBa0Qsb0RBQW9ELHFCQUFxQixTQUFTLDBDQUEwQyw4QkFBOEIsK0RBQStELGlEQUFpRCxTQUFTLGlDQUFpQyxPQUFPLHdCQUF3QixNQUFNLDBCQUEwQixHQUFHLEVBQUUsb0hBQW9ILDhDQUE4QyxrRUFBa0Usc0RBQXNELDhEQUE4RCxPQUFPLHdFQUF3RSxLQUFLLDhDQUE4QyxpRUFBaUUsc0JBQXNCLGlDQUFpQyw0QkFBNEIsV0FBVyxxQ0FBcUMsRUFBRSxTQUFTLHlEQUF5RCx3Q0FBd0MsbUNBQW1DLGlDQUFpQyw0QkFBNEIsU0FBUyxRQUFRLDBCQUEwQiwyQkFBMkIsTUFBTSxpRUFBaUUscUJBQXFCLE1BQU0saUVBQWlFLHVCQUF1QixzQkFBc0Isb0NBQW9DLGtHQUFrRyxnQ0FBZ0MsU0FBUywrQkFBK0IsT0FBTyxnQ0FBZ0MsMEJBQTBCLG9CQUFvQixnREFBZ0QsOERBQThELE9BQU8saURBQWlELGdFQUFnRSxPQUFPLDZCQUE2QixtRUFBbUUsMERBQTBELCtFQUErRSwySkFBMkoseUtBQXlLLGFBQWEsV0FBVyw4QkFBOEIsU0FBUyxlQUFlLGlPQUFpTyxtQkFBbUIsV0FBVyw2Q0FBNkMsOENBQThDLEVBQUUsU0FBUyxFQUFFLG1DQUFtQyxPQUFPLDREQUE0RCxpQ0FBaUMsa0RBQWtELFNBQVMsa0ZBQWtGLFFBQVEsTUFBTSxrQkFBa0IsT0FBTyxNQUFNLHlCQUF5QixHQUFHLEVBQUUsa0VBQWtFLGtEQUFrRCxxQ0FBcUMsaURBQWlELHNDQUFzQyxtQ0FBbUMsT0FBTyxpREFBaUQsc0NBQXNDLHFDQUFxQyxPQUFPLGdEQUFnRCw4QkFBOEIsd0JBQXdCLGlCQUFpQixNQUFNLDRCQUE0Qiw4Q0FBOEMsNENBQTRDLDBDQUEwQyxTQUFTLE9BQU8sS0FBSyxxRUFBcUUsc0JBQXNCLDhCQUE4Qix5REFBeUQsK0NBQStDLGVBQWUsT0FBTyx1Q0FBdUMsK0JBQStCLDBCQUEwQixpQkFBaUIsTUFBTSwrQkFBK0IsNkZBQTZGLG1EQUFtRCxtQkFBbUIsK0RBQStELDZEQUE2RCxzREFBc0QsNkNBQTZDLHdCQUF3QiwyQkFBMkIsYUFBYSw4QkFBOEIsMEJBQTBCLHFCQUFxQixXQUFXLFNBQVMsc0JBQXNCLHNCQUFzQixTQUFTLDJDQUEyQyw0QkFBNEIseUNBQXlDLGlEQUFpRCx1Q0FBdUMsc0NBQXNDLFNBQVMsNkJBQTZCLHdCQUF3QixPQUFPLDhDQUE4QyxNQUFNLCtEQUErRCxxQ0FBcUMsMEJBQTBCLG9CQUFvQixPQUFPLGdCQUFnQiwyQ0FBMkMsTUFBTSwwREFBMEQsd0JBQXdCLE1BQU0sb0RBQW9ELG9FQUFvRSxtQ0FBbUMsNEJBQTRCLGlCQUFpQixTQUFTLDJCQUEyQixPQUFPLEVBQUUsTUFBTSxrQkFBa0IsR0FBRyxFQUFFLHVFQUF1RSx1REFBdUQsK0NBQStDLHNDQUFzQyxtQ0FBbUMsT0FBTyxnREFBZ0QsS0FBSyw4RUFBOEUsa0RBQWtELHNJQUFzSSxNQUFNLDBFQUEwRSxzQkFBc0IseUNBQXlDLDZHQUE2RywrS0FBK0ssMkNBQTJDLFNBQVMsRUFBRSxnSEFBZ0gsMENBQTBDLGlEQUFpRCxrQ0FBa0MscUNBQXFDLFNBQVMsNkZBQTZGLE9BQU8sZ0NBQWdDLGdDQUFnQyw2QkFBNkIsRUFBRSxPQUFPLHdDQUF3Qyw4RUFBOEUsNkNBQTZDLDhGQUE4RiwyQ0FBMkMsd0NBQXdDLFNBQVMsdUNBQXVDLE9BQU8sK0NBQStDLE1BQU0sK0VBQStFLDREQUE0RCw2QkFBNkIsZ0JBQWdCLDZEQUE2RCxnQkFBZ0IsK0RBQStELFFBQVEsaUNBQWlDLCtCQUErQix1REFBdUQsY0FBYyxxQkFBcUIsU0FBUyx1Q0FBdUMsb0NBQW9DLFdBQVcsNkJBQTZCLEVBQUUsMkNBQTJDLDZCQUE2QixjQUFjLG1CQUFtQixTQUFTLHlCQUF5Qix3R0FBd0csY0FBYyxPQUFPLGdCQUFnQiwwQkFBMEIsTUFBTSx1QkFBdUIsR0FBRyxFQUFFLHFFQUFxRSwwREFBMEQsa0VBQWtFLDBDQUEwQyxLQUFLLG1GQUFtRixzQ0FBc0MsMkRBQTJELHlDQUF5QyxvREFBb0QsaUhBQWlILFNBQVMsRUFBRSxpQkFBaUIsT0FBTywrQ0FBK0MsTUFBTSxnQ0FBZ0MsR0FBRyxFQUFFLHFFQUFxRSwwREFBMEQsa0VBQWtFLDBDQUEwQyxLQUFLLG1GQUFtRixzQ0FBc0MsbUdBQW1HLHlDQUF5QyxtREFBbUQsaUhBQWlILFNBQVMsRUFBRSxpQkFBaUIsT0FBTywrQ0FBK0MsTUFBTSxnQ0FBZ0MsR0FBRyxFQUFFLHdFQUF3RSw4REFBOEQsMEVBQTBFLDBDQUEwQyxLQUFLLGdHQUFnRyx3QkFBd0Isc0RBQXNELDhDQUE4Qyx5Q0FBeUMsU0FBUyxFQUFFLE1BQU0sNEZBQTRGLHdCQUF3QixvREFBb0QsaURBQWlELFNBQVMsRUFBRSxNQUFNLHFHQUFxRyx3QkFBd0IsK0NBQStDLG1FQUFtRSxtR0FBbUcsNkNBQTZDLDhEQUE4RCxtRUFBbUUsYUFBYSxFQUFFLG1CQUFtQixXQUFXLGtDQUFrQyw4QkFBOEIsV0FBVyxTQUFTLEVBQUUsTUFBTSxvQ0FBb0MsR0FBRyxFQUFFLHNGQUFzRiwyQ0FBMkMsK0JBQStCLDZCQUE2QixrREFBa0QsS0FBSywrQ0FBK0MsK0NBQStDLG1KQUFtSix1REFBdUQsbUNBQW1DLHlCQUF5QixNQUFNLDZDQUE2QyxrREFBa0Qsc0VBQXNFLGtEQUFrRCxnREFBZ0QsdUVBQXVFLE1BQU0sc0JBQXNCLEdBQUcsRUFBRSw4RkFBOEYsMEJBQTBCLHNEQUFzRCwyQ0FBMkMsNFdBQTRXLHdDQUF3QywyQ0FBMkMsbUNBQW1DLHlCQUF5QixNQUFNLDJFQUEyRSxzQkFBc0Isa0RBQWtELG9EQUFvRCxtREFBbUQsc0NBQXNDLDBEQUEwRCxPQUFPLEVBQUUsc1BBQXNQLDJFQUEyRSxPQUFPLEVBQUUsdURBQXVELCtCQUErQixPQUFPLEVBQUUsMENBQTBDLHlDQUF5QyxzREFBc0Qsd0NBQXdDLHlDQUF5Qyx3Q0FBd0MsU0FBUyxLQUFLLE9BQU8sRUFBRSwyQ0FBMkMsMENBQTBDLGlEQUFpRCx5REFBeUQsK0JBQStCLHFDQUFxQyxPQUFPLEVBQUUsMkNBQTJDLGtDQUFrQyx3Q0FBd0MsU0FBUyxPQUFPLEVBQUUsdURBQXVELG9FQUFvRSxtREFBbUQsNkJBQTZCLHNFQUFzRSxZQUFZLE1BQU0sbUVBQW1FLFdBQVcsU0FBUyxPQUFPLEVBQUUseURBQXlELG9DQUFvQyw0RUFBNEUsVUFBVSxNQUFNLDJEQUEyRCxTQUFTLE9BQU8sRUFBRSxNQUFNLHNEQUFzRCxrQ0FBa0MsdUNBQXVDLGlDQUFpQyw4QkFBOEIsRUFBRSxPQUFPLHFDQUFxQyxNQUFNLDBEQUEwRCxrQkFBa0IsTUFBTSxvQkFBb0IsR0FBRyxFQUFFLHNFQUFzRSwwRUFBMEUsK0VBQStFLDZEQUE2RCxLQUFLLHFFQUFxRSwwREFBMEQsbUNBQW1DLE1BQU0sa0ZBQWtGLDRDQUE0Qyx1QkFBdUIsc0RBQXNELE9BQU8sMkJBQTJCLE1BQU0sd0VBQXdFLHVDQUF1QyxzQ0FBc0MsUUFBUSxNQUFNLDJCQUEyQixnREFBZ0Qsb0NBQW9DLFNBQVMsT0FBTyw0QkFBNEIsTUFBTSw2QkFBNkIsR0FBRyxFQUFFLGdGQUFnRix5RUFBeUUsMkJBQTJCLDZEQUE2RCxxREFBcUQsMkJBQTJCLEtBQUssb0VBQW9FLGlDQUFpQywyQkFBMkIsbUNBQW1DLHlDQUF5QyxnREFBZ0QsZ0NBQWdDLE9BQU8sTUFBTSxtRkFBbUYsc0JBQXNCLG9EQUFvRCxpREFBaUQsaUNBQWlDLDRCQUE0QixPQUFPLEVBQUUsd0RBQXdELGlDQUFpQyw0QkFBNEIsT0FBTyxFQUFFLHFFQUFxRSxNQUFNLCtEQUErRCw4R0FBOEcsaURBQWlELGVBQWUsT0FBTyxpR0FBaUcsMkdBQTJHLHNEQUFzRCx3QkFBd0IsT0FBTyxNQUFNLHVEQUF1RCwwQkFBMEIsZ0NBQWdDLEdBQUcsUUFBUSxtQkFBbUIsc0JBQXNCLDZDQUE2QyxNQUFNLHFFQUFxRSxxREFBcUQsTUFBTSxnRUFBZ0Usb0xBQW9MLDBFQUEwRSwrQ0FBK0MsdUJBQXVCLE1BQU0sNEJBQTRCLEdBQUcsRUFBRSxrR0FBa0csd0RBQXdELCtFQUErRSxnREFBZ0QsS0FBSywrRUFBK0Usc0JBQXNCLG9EQUFvRCwwQ0FBMEMsNkJBQTZCLGtEQUFrRCwrSEFBK0gsT0FBTyxFQUFFLDJDQUEyQyw2QkFBNkIsa0RBQWtELE9BQU8sRUFBRSxnRUFBZ0UsOEJBQThCLE9BQU8sRUFBRSxNQUFNLDJEQUEyRCwyQkFBMkIseUNBQXlDLE1BQU0sbUZBQW1GLG1HQUFtRyx5Q0FBeUMsb0RBQW9ELHVCQUF1Qix3REFBd0QsRUFBRSxxQ0FBcUMsTUFBTSwwREFBMEQsMENBQTBDLDZDQUE2QyxtQ0FBbUMsNkNBQTZDLDBCQUEwQixNQUFNLGlFQUFpRSx1Q0FBdUMsTUFBTSxrR0FBa0csMEZBQTBGLGVBQWUsT0FBTyx3QkFBd0IsaURBQWlELGlDQUFpQywrQkFBK0IsT0FBTyxFQUFFLG9EQUFvRCxpQ0FBaUMsK0JBQStCLE9BQU8sRUFBRSxxREFBcUQsaUNBQWlDLCtCQUErQixPQUFPLEVBQUUsNENBQTRDLGlDQUFpQywrQkFBK0IsT0FBTyxFQUFFLDhDQUE4QyxpQ0FBaUMsK0JBQStCLE9BQU8sRUFBRSxtREFBbUQsTUFBTSwrRkFBK0Ysc0JBQXNCLDJEQUEyRCx5REFBeUQseUVBQXlFLDBFQUEwRSxrQ0FBa0MsMERBQTBELDJFQUEyRSxFQUFFLE9BQU8sRUFBRSxpREFBaUQsc0VBQXNFLHNDQUFzQyxPQUFPLEVBQUUsb0dBQW9HLGlDQUFpQywrQkFBK0IsT0FBTyxFQUFFLE1BQU0sK0ZBQStGLHlEQUF5RCx5REFBeUQseUVBQXlFLDBFQUEwRSxpQ0FBaUMsZ0ZBQWdGLE1BQU0sNERBQTRELDhCQUE4QixrRkFBa0YsZ0ZBQWdGLGdDQUFnQyw4Q0FBOEMsd0VBQXdFLHlCQUF5QiwwREFBMEQsbUNBQW1DLHVEQUF1RCx3QkFBd0IseURBQXlELHdCQUF3QiwrRkFBK0YsNEVBQTRFLGdGQUFnRixtQkFBbUIsK0RBQStELGdJQUFnSSx1S0FBdUsscURBQXFELE9BQU8sNEJBQTRCLHNDQUFzQyxpSEFBaUgsOENBQThDLE9BQU8sb0NBQW9DLG9DQUFvQyxxREFBcUQsK0JBQStCLE9BQU8sdUVBQXVFLCtCQUErQixRQUFRLG1FQUFtRSwrQkFBK0IsT0FBTywrRkFBK0YscUVBQXFFLE9BQU8sbUNBQW1DLHdKQUF3Siw0SkFBNEosT0FBTyx5Q0FBeUMsTUFBTSwwREFBMEQsaUJBQWlCLCtEQUErRCxvREFBb0QsaUNBQWlDLGtDQUFrQywyQkFBMkIsT0FBTyxnQ0FBZ0MsTUFBTSxpRUFBaUUsNkRBQTZELGlDQUFpQyw2QkFBNkIsTUFBTSx3QkFBd0IsR0FBRyxFQUFFLDhFQUE4RSxrQ0FBa0Msb0JBQW9CLHdCQUF3QixpQkFBaUIsTUFBTSwyQkFBMkIsOEJBQThCLCtDQUErQyxVQUFVLE1BQU0sa0JBQWtCLFNBQVMsT0FBTyxxQkFBcUIsS0FBSyxvRkFBb0YsNEVBQTRFLCtDQUErQyxnREFBZ0QsT0FBTyw2REFBNkQsS0FBSyxtRkFBbUYsNkVBQTZFLHFCQUFxQixPQUFPLDRDQUE0QyxNQUFNLHFDQUFxQyxHQUFHLEVBQUUscUZBQXFGLGlDQUFpQyxrRkFBa0Ysc0JBQXNCLG9EQUFvRCxpREFBaUQsMENBQTBDLE9BQU8sRUFBRSxNQUFNLDJFQUEyRSwwREFBMEQsZ0RBQWdELGlMQUFpTCxpQkFBaUIsU0FBUyxPQUFPLCtEQUErRCxxRkFBcUYsZUFBZSxPQUFPLGlFQUFpRSwrS0FBK0ssZUFBZSxPQUFPLGdDQUFnQywyQkFBMkIsRUFBRSxNQUFNLDJCQUEyQixHQUFHLEVBQUUsb0VBQW9FLGlDQUFpQyxrRkFBa0Ysc0JBQXNCLG9EQUFvRCwrQ0FBK0MsbUNBQW1DLE9BQU8sRUFBRSxpREFBaUQsbUNBQW1DLE9BQU8sRUFBRSxNQUFNLG9FQUFvRSw0Q0FBNEMscUlBQXFJLGVBQWUsT0FBTywrQkFBK0IsNkVBQTZFLEVBQUUsTUFBTSwyQkFBMkIsR0FBRyxFQUFFLGdEQUFnRCwwQkFBMEIsaUNBQWlDLGtEQUFrRCxPQUFPLHNDQUFzQyx5REFBeUQsb0VBQW9FLCtCQUErQix5QkFBeUIsU0FBUyx5QkFBeUIsT0FBTyx1Q0FBdUMsOERBQThELGlGQUFpRix5QkFBeUIsT0FBTyxpQ0FBaUMsdUNBQXVDLE9BQU8seUNBQXlDLHNFQUFzRSxrQ0FBa0MseUJBQXlCLFNBQVMseUJBQXlCLE9BQU8sK0JBQStCLGtDQUFrQyxPQUFPLCtCQUErQiw0QkFBNEIsT0FBTyxvQ0FBb0Msa0NBQWtDLE9BQU8sTUFBTSxHQUFHLEVBQUUsc3lDQUFzeUMsMEJBQTBCLG1CQUFtQixLQUFLLHFEQUFxRCxpQ0FBaUMsMEJBQTBCLDBDQUEwQyxtQ0FBbUMseUNBQXlDLFVBQVUsZ0NBQWdDLDBDQUEwQyxVQUFVLE1BQU0sMkNBQTJDLFNBQVMsK0NBQStDLHlIQUF5SCxTQUFTLCtDQUErQyx5SEFBeUgsU0FBUyxtREFBbUQsNkhBQTZILFNBQVMsNkJBQTZCLDBFQUEwRSxTQUFTLDZFQUE2RSxnSEFBZ0gsU0FBUyxzQ0FBc0MsZ0VBQWdFLDhHQUE4RyxTQUFTLDhDQUE4QyxnRkFBZ0Ysc0hBQXNILFNBQVMsT0FBTyw2Q0FBNkMsNkNBQTZDLHFDQUFxQywySEFBMkgsU0FBUyw0Q0FBNEMsNEhBQTRILFNBQVMsc0NBQXNDLDBIQUEwSCxTQUFTLE9BQU8sOENBQThDLCtCQUErQiw2Q0FBNkMsVUFBVSxNQUFNLDRFQUE0RSx5REFBeUQsU0FBUyxzREFBc0Qsc0lBQXNJLFNBQVMsc0NBQXNDLDRIQUE0SCxTQUFTLDZKQUE2Siw0RUFBNEUsNEhBQTRILFNBQVMsbUhBQW1ILE9BQU8sK0NBQStDLCtCQUErQix1REFBdUQsVUFBVSxNQUFNLHFEQUFxRCxTQUFTLCtHQUErRyw0SEFBNEgsU0FBUyxtQ0FBbUMsMkhBQTJILFNBQVMsaUNBQWlDLGdJQUFnSSxTQUFTLGdLQUFnSyw4RUFBOEUsK0hBQStILFNBQVMscUhBQXFILE9BQU8saU5BQWlOLHlHQUF5RyxpQ0FBaUMsd0JBQXdCLDZCQUE2QixNQUFNLDJDQUEyQyx5REFBeUQseUNBQXlDLFNBQVMsT0FBTywyQ0FBMkMsK0dBQStHLHVCQUF1QixNQUFNLDhDQUE4Qyx1Q0FBdUMsNEdBQTRHLG9DQUFvQyxTQUFTLDREQUE0RCxPQUFPLHlDQUF5QywyR0FBMkcsc0JBQXNCLFNBQVMsbUhBQW1ILDhLQUE4SyxRQUFRLDhGQUE4RixRQUFRLE1BQU0seUNBQXlDLG1EQUFtRCwwR0FBMEcsMENBQTBDLGFBQWEsV0FBVyx1R0FBdUcseUJBQXlCLFdBQVcsc0hBQXNILFNBQVMsa0VBQWtFLDhEQUE4RCwwRkFBMEYsc0JBQXNCLFNBQVMsc0ZBQXNGLE9BQU8seUJBQXlCLHdNQUF3TSwwUEFBMFAsc0JBQXNCLFNBQVMsNENBQTRDLDZCQUE2QixTQUFTLGtEQUFrRCxnQ0FBZ0MsU0FBUywwREFBMEQsTUFBTSwwRUFBMEUsNENBQTRDLG1EQUFtRCxrREFBa0QsbUVBQW1FLHFQQUFxUCxxQ0FBcUMsdUJBQXVCLE1BQU0saUVBQWlFLHNCQUFzQixrQkFBa0IsT0FBTyx3Q0FBd0Msa0JBQWtCLE9BQU8sd0NBQXdDLDBCQUEwQixPQUFPLHNCQUFzQixtQ0FBbUMsK0JBQStCLFFBQVEsTUFBTSw2QkFBNkIsT0FBTyxtQ0FBbUMsd0JBQXdCLHNCQUFzQixNQUFNLDZDQUE2QyxrRkFBa0YsbUhBQW1ILDhDQUE4QyxpREFBaUQsU0FBUyxPQUFPLGlDQUFpQyxNQUFNLDZFQUE2RSwyQ0FBMkMsd0JBQXdCLHNCQUFzQixNQUFNLDZDQUE2QyxzQ0FBc0MsNkNBQTZDLGVBQWUsOEdBQThHLFlBQVksV0FBVyxpQkFBaUIsMklBQTJJLDREQUE0RCxjQUFjLFlBQVksdVNBQXVTLGdOQUFnTixlQUFlLGFBQWEsV0FBVyxVQUFVLHFDQUFxQyxtREFBbUQsVUFBVSxNQUFNLGtDQUFrQyxTQUFTLDRDQUE0QyxPQUFPLDRCQUE0QixNQUFNLHNEQUFzRCxzQ0FBc0Msc0JBQXNCLDZCQUE2QixxREFBcUQscURBQXFELE1BQU0sb0NBQW9DLHNCQUFzQixHQUFHLEVBQUUsdUlBQXVJLDBDQUEwQyw2QkFBNkIsK0JBQStCLG1DQUFtQyxPQUFPLCtCQUErQix5RUFBeUUsT0FBTyxvREFBb0QsK0NBQStDLDRFQUE0RSxzSEFBc0gsT0FBTyxLQUFLLHFEQUFxRCxxQ0FBcUMsNENBQTRDLG9EQUFvRCxPQUFPLDRDQUE0QyxvREFBb0QsT0FBTyx1Q0FBdUMsNkJBQTZCLDRDQUE0QyxVQUFVLDJDQUEyQyw2REFBNkQsVUFBVSxNQUFNLG1DQUFtQyxTQUFTLE9BQU8sbURBQW1ELGlEQUFpRCxrREFBa0QsbUVBQW1FLDBQQUEwUCxTQUFTLDhFQUE4RSw2Q0FBNkMsT0FBTyw4Q0FBOEMsbUVBQW1FLDZPQUE2TyxTQUFTLGdFQUFnRSw0RUFBNEUsT0FBTyx5QkFBeUIsNkNBQTZDLG9DQUFvQyxPQUFPLGtHQUFrRyxnQ0FBZ0MsU0FBUyx3REFBd0QsNkJBQTZCLGlFQUFpRSw0SEFBNEgsb0xBQW9MLDBJQUEwSSxvSEFBb0gsU0FBUyxPQUFPLCtOQUErTixtQ0FBbUMsMEJBQTBCLE9BQU8sd0ZBQXdGLGlDQUFpQyx3Q0FBd0MsK0JBQStCLGdEQUFnRCxtQkFBbUIsU0FBUyxtREFBbUQsaURBQWlELFVBQVUsTUFBTSx3Q0FBd0MsU0FBUyxPQUFPLG9CQUFvQixNQUFNLDhDQUE4QywrQkFBK0IsTUFBTSxtREFBbUQsOEJBQThCLE1BQU0scUJBQXFCLEdBQUcsRUFBRSw4SEFBOEgsZ0RBQWdELDBEQUEwRCx3REFBd0QsT0FBTyxpQ0FBaUMsNkNBQTZDLGdDQUFnQyxzREFBc0QsaURBQWlELG9GQUFvRiw2REFBNkQsc0NBQXNDLG1HQUFtRyxpRUFBaUUsdUNBQXVDLHlDQUF5QyxvRUFBb0Usb0VBQW9FLGdEQUFnRCw2REFBNkQsa0VBQWtFLGtFQUFrRSw4Q0FBOEMsMkRBQTJELGdFQUFnRSxrRkFBa0YsNENBQTRDLDZEQUE2RCw4Q0FBOEMsK0VBQStFLDBFQUEwRSxnRkFBZ0Ysc0NBQXNDLHFDQUFxQyxvQ0FBb0MsNkJBQTZCLHVGQUF1RiwwQ0FBMEMsb0NBQW9DLEVBQUUsT0FBTyxFQUFFLHdGQUF3RiwyQ0FBMkMsNEVBQTRFLHNEQUFzRCw2R0FBNkcsTUFBTSw4Q0FBOEMsMkRBQTJELGtCQUFrQiwwQ0FBMEMsaUNBQWlDLFFBQVEseUNBQXlDLGtFQUFrRSxRQUFRLE1BQU0sb0NBQW9DLE9BQU8sa0RBQWtELDJCQUEyQixrQkFBa0IsTUFBTSxpRUFBaUUsNENBQTRDLGlGQUFpRiw0QkFBNEIsdUNBQXVDLE9BQU8sTUFBTSxxRUFBcUUsbUZBQW1GLGtDQUFrQywrREFBK0QsbUNBQW1DLDRCQUE0QixTQUFTLHlEQUF5RCxPQUFPLGtDQUFrQyxzREFBc0Qsa0NBQWtDLHdCQUF3QixTQUFTLHFDQUFxQyxPQUFPLGdDQUFnQywyQ0FBMkMsMkNBQTJDLHNCQUFzQixTQUFTLG9DQUFvQyxHQUFHLDRDQUE0QyxPQUFPLFlBQVksa0RBQWtELDBDQUEwQywwREFBMEQsOEJBQThCLFdBQVcsU0FBUyxzQkFBc0IsT0FBTyx3Q0FBd0MsaUVBQWlFLHFDQUFxQyxPQUFPLHNCQUFzQixNQUFNLHFEQUFxRCxtREFBbUQsaURBQWlELGtEQUFrRCwrQ0FBK0MsTUFBTSwwREFBMEQsc0JBQXNCLHdEQUF3RCxrREFBa0QsNENBQTRDLGlDQUFpQyxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsMERBQTBELG1DQUFtQyxPQUFPLEVBQUUsNkRBQTZELHdEQUF3RCwyQ0FBMkMsc0VBQXNFLE9BQU8sa0lBQWtJLCtCQUErQiw0REFBNEQsd0JBQXdCLHVDQUF1QyxTQUFTLEVBQUUsa0RBQWtELHNGQUFzRixFQUFFLFFBQVEsNkNBQTZDLHFIQUFxSCxxSEFBcUgsb0hBQW9ILE9BQU8sTUFBTSwyREFBMkQsc0JBQXNCLDBEQUEwRCxtQ0FBbUMsT0FBTyxFQUFFLE1BQU0sZ0VBQWdFLHNCQUFzQiwrQ0FBK0MsaURBQWlELDhCQUE4QixPQUFPLEVBQUUsc0RBQXNELDJCQUEyQixPQUFPLEVBQUUsd0RBQXdELHFEQUFxRCxpQkFBaUIsU0FBUyxxQ0FBcUMsT0FBTyxFQUFFLE1BQU0sK0RBQStELHNCQUFzQix1REFBdUQsbUNBQW1DLE9BQU8sRUFBRSxNQUFNLDhEQUE4RCxzQkFBc0Isc0RBQXNELG1DQUFtQyxPQUFPLEVBQUUsTUFBTSx1REFBdUQsc0JBQXNCLHFDQUFxQyw0REFBNEQsT0FBTyxFQUFFLHNDQUFzQywrREFBK0QsT0FBTyxFQUFFLHVDQUF1QyxtRUFBbUUsT0FBTyxFQUFFLHdDQUF3QyxnRUFBZ0UsT0FBTyxFQUFFLHFDQUFxQyxnRUFBZ0UsT0FBTyxFQUFFLDRDQUE0Qyw2QkFBNkIsaUNBQWlDLEVBQUUsU0FBUywwREFBMEQsdUNBQXVDLDJEQUEyRCxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsbURBQW1ELHdEQUF3RCwwQ0FBMEMsMkRBQTJELEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSw0Q0FBNEMsNEJBQTRCLDhCQUE4QixxR0FBcUcsNEJBQTRCLG1DQUFtQyxZQUFZLDhCQUE4Qiw2Q0FBNkMsRUFBRSxtQ0FBbUMsWUFBWSwrQ0FBK0MsNkNBQTZDLEVBQUUsbUNBQW1DLFlBQVksMkJBQTJCLCtDQUErQyxFQUFFLG1DQUFtQyxZQUFZLDZCQUE2QiwyQ0FBMkMsRUFBRSxtQ0FBbUMsV0FBVyxVQUFVLE1BQU0sMkdBQTJHLHdCQUF3QixtQ0FBbUMsV0FBVyxTQUFTLE9BQU8sRUFBRSxNQUFNLHVEQUF1RCxtRUFBbUUsZ0NBQWdDLDRCQUE0Qix1QkFBdUIsU0FBUyxvQ0FBb0MsRUFBRSxRQUFRLE1BQU0saUNBQWlDLEVBQUUsT0FBTyxNQUFNLHVFQUF1RSwwQkFBMEIsc0JBQXNCLHdTQUF3UyxlQUFlLE9BQU8seUJBQXlCLGdKQUFnSixRQUFRLG1FQUFtRSx3QkFBd0IsaUNBQWlDLE1BQU0sNkNBQTZDLGdDQUFnQywyQkFBMkIsV0FBVyxTQUFTLFFBQVEsdUVBQXVFLHVCQUF1QixRQUFRLGdDQUFnQyxtREFBbUQsc0RBQXNELDhIQUE4SCx5QkFBeUIsV0FBVyxTQUFTLEVBQUUsT0FBTyxxQkFBcUIsTUFBTSxrRUFBa0UsMkRBQTJELHNCQUFzQixrRkFBa0YseURBQXlELDRDQUE0Qyx3Q0FBd0MsRUFBRSxTQUFTLEVBQUUsT0FBTyxNQUFNLGdNQUFnTSxvREFBb0QsMkJBQTJCLHdKQUF3SixpQ0FBaUMsa0JBQWtCLE9BQU8sb0NBQW9DLGlEQUFpRCw4QkFBOEIsOEVBQThFLG1FQUFtRSx5Q0FBeUMsZ0NBQWdDLG1CQUFtQixTQUFTLE9BQU8sNkNBQTZDLE1BQU0sc0RBQXNELDhCQUE4QixlQUFlLE9BQU8sNEJBQTRCLHFCQUFxQixRQUFRLE1BQU0sb0JBQW9CLE9BQU8sTUFBTSw0Q0FBNEMsMEJBQTBCLGVBQWUsT0FBTyxnQ0FBZ0MsZUFBZSxPQUFPLGdDQUFnQyxFQUFFLE1BQU0sZ0RBQWdELDJCQUEyQixlQUFlLE9BQU8sZ0NBQWdDLHFCQUFxQixFQUFFLE1BQU0sOEhBQThILE1BQU0sZ0RBQWdELE9BQU8sa0ZBQWtGLGdDQUFnQyxNQUFNLHNHQUFzRyxNQUFNLCtDQUErQyxPQUFPLHVGQUF1RiwwQ0FBMEMsTUFBTSw4Q0FBOEMsaUVBQWlFLE1BQU0sZ0RBQWdELGtFQUFrRSxNQUFNLGlEQUFpRCxpR0FBaUcsZUFBZSxPQUFPLDZEQUE2RCw4QkFBOEIsRUFBRSxNQUFNLGtEQUFrRCx3RUFBd0UsNE5BQTROLE9BQU8sZ0RBQWdELHNCQUFzQixPQUFPLGdDQUFnQyxpREFBaUQsTUFBTSw0Q0FBNEMseUdBQXlHLDRMQUE0TCxPQUFPLHNCQUFzQix5REFBeUQsMkJBQTJCLE9BQU8sRUFBRSxvQkFBb0IsTUFBTSwrQ0FBK0Msd0VBQXdFLDhMQUE4TCxPQUFPLGdEQUFnRCxtQ0FBbUMsT0FBTyw2QkFBNkIsZ0NBQWdDLCtDQUErQyxnQ0FBZ0MsU0FBUyxFQUFFLE9BQU8scUVBQXFFLE1BQU0sK0NBQStDLCtCQUErQiwyQ0FBMkMsc0VBQXNFLE9BQU8scUNBQXFDLG9DQUFvQyw4QkFBOEIsUUFBUSxnREFBZ0QsOEZBQThGLDhGQUE4Riw2RkFBNkYsT0FBTywyQkFBMkIseUJBQXlCLHNDQUFzQywyRkFBMkYsK0RBQStELGlEQUFpRCx5Q0FBeUMsMENBQTBDLG1DQUFtQywrQkFBK0IsOEJBQThCLDZCQUE2QixnQ0FBZ0MsNEJBQTRCLDJCQUEyQiwwQkFBMEIsTUFBTSw4Q0FBOEMsa09BQWtPLHdEQUF3RCxxQ0FBcUMsb0ZBQW9GLGlFQUFpRSwwQkFBMEIsTUFBTSxxQkFBcUIsR0FBRyxFQUFFLGtFQUFrRSx1RUFBdUUsR0FBRyxFQUFFLDBMQUEwTCwrQkFBK0Isd0dBQXdHLDJDQUEyQyxnQ0FBZ0MsNENBQTRDLGlDQUFpQyxtREFBbUQsV0FBVyxtRUFBbUUsV0FBVyxFQUFFLHdCQUF3QixVQUFVLHVDQUF1QyxrQkFBa0IsOERBQThELG1DQUFtQywwREFBMEQsd0VBQXdFLCtLQUErSyxhQUFhLDREQUE0RCxXQUFXLEVBQUUsMEdBQTBHLHdCQUF3QixXQUFXLHVCQUF1QixVQUFVLE1BQU0sdUVBQXVFLFNBQVMsUUFBUSxLQUFLLDBDQUEwQyx1Q0FBdUMsS0FBSyxxQkFBcUIsR0FBRyxFQUFFLCtGQUErRix1REFBdUQsR0FBRyxJQUFJLDBKQUEwSixrT0FBa08sdUZBQXVGLEdBQUcsR0FBRzs7Ozs7Ozs7OztBQ0FqKzVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBLG1CQUFPLENBQUMsOEZBQW9GLEVBQUUsbUJBQU8sQ0FBQyw0UkFBaVE7Ozs7Ozs7Ozs7QUNBdlcsbUJBQU8sQ0FBQyw4RkFBb0YsRUFBRSxtQkFBTyxDQUFDLGdRQUFtUDs7Ozs7Ozs7OztBQ0F6VixtQkFBTyxDQUFDLDhGQUFvRixFQUFFLG1CQUFPLENBQUMsd1BBQStPOzs7Ozs7Ozs7Ozs7O0FDQXJWLHNKQUE4RTtBQUM5RSxNQUFNLENBQUUsUUFBUSxDQUFFLENBQUMsS0FBSyxDQUFFO0lBRXpCLE1BQU0sQ0FBRSx3QkFBd0IsQ0FBRSxDQUFDLElBQUksQ0FBRTtRQUV4QyxJQUFJLDZDQUFxQixDQUFFLE1BQU0sQ0FBRSxJQUFJLENBQUUsRUFBRSxNQUFNLENBQUUsSUFBSSxDQUFFLENBQUMsSUFBSSxFQUFFLENBQUUsQ0FBQztJQUNwRSxDQUFDLENBQUUsQ0FBQztJQUNMLHVFQUF1RTtJQUN2RSxJQUFJO0lBQ0osdUJBQXVCO0lBQ3ZCLHdCQUF3QjtJQUN4QiwrQ0FBK0M7SUFDL0MsRUFBRTtJQUNGLDJFQUEyRTtJQUMzRSxPQUFPO0lBQ1Asb0VBQW9FO0lBQ3BFLElBQUk7SUFDSix5RUFBeUU7SUFDekUsT0FBTztBQUNQLENBQUMsQ0FBRSxDQUFDOzs7Ozs7Ozs7OztBQ25CSixNQUFNLENBQUU7SUFDUCxNQUFNLENBQUUsTUFBTSxDQUFFLENBQUMsRUFBRSxDQUFFLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxVQUFFLENBQUM7UUFDakUsSUFBSSxjQUFjLEdBQUcsQ0FBQyxDQUFDLGFBQWEsQ0FBQztRQUNyQyxJQUFJLEdBQUcsR0FBYyxNQUFNLENBQUUsY0FBYyxDQUFDLE9BQU8sQ0FBRSx1QkFBdUIsQ0FBRSxDQUFFLENBQUM7UUFDakYsSUFBSSxPQUFPLEdBQVUsR0FBRyxDQUFDLElBQUksQ0FBRSxVQUFVLENBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNsRCxPQUFPLENBQUMsR0FBRyxDQUFFLE9BQU8sQ0FBRSxDQUFDO1FBQ3ZCLE1BQU0sQ0FBQyxJQUFJLENBQUUsR0FBRyxDQUFDLElBQUksQ0FBRSxVQUFVLENBQUUsRUFBRTtZQUNwQyxJQUFJLEVBQUk7Z0JBQ1AsT0FBTyxFQUFDLE9BQU87Z0JBQ2YsSUFBSSxFQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUUsSUFBSSxDQUFFO2FBQ3hCO1lBQ0QsT0FBTyxFQUFDLFVBQUUsTUFBTTtnQkFDZixPQUFPLENBQUMsR0FBRyxDQUFFLE1BQU0sQ0FBRSxDQUFDO2dCQUN0QixHQUFHLENBQUMsSUFBSSxDQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUUsQ0FBQztnQkFDeEIsT0FBTyxDQUFDLElBQUksQ0FBRSxNQUFNLENBQUMsUUFBUSxDQUFFLENBQUM7Z0JBQ2hDLFNBQVMsQ0FBRSxFQUFDLEVBQUUsRUFBQyxHQUFHLENBQUMsSUFBSSxDQUFFLElBQUksQ0FBRSxFQUFDLENBQUUsQ0FBQztnQkFDbkMsTUFBTSxDQUFDLGNBQWMsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFFLElBQUksQ0FBRSxDQUFDO1lBQzFDLENBQUM7WUFDRCxLQUFLLEVBQUcsZUFBSyxJQUFJLGNBQU8sQ0FBQyxLQUFLLENBQUUsS0FBSyxDQUFFLEVBQXRCLENBQXNCO1NBQ3ZDLENBQUUsQ0FBQztJQUNMLENBQUMsQ0FBRSxDQUFDO0FBQ0wsQ0FBQyxDQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDckJKLDRHQUFrRDtBQUVsRCxNQUFNLENBQUU7SUFDUCxNQUFNLENBQUUsMERBQTBELENBQUUsQ0FBQyxJQUFJLENBQUUsVUFBVSxDQUFDLEVBQUUsRUFBRTtRQUN6RixJQUFJLGlCQUFPLENBQUUsTUFBTSxDQUFFLEVBQUUsQ0FBRSxDQUFFLENBQUM7SUFDN0IsQ0FBQyxDQUFFLENBQUM7QUFDTCxDQUFDLENBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUNOSiw4SUFBc0U7QUFFdEU7SUFJQyxpQkFBYSxHQUFXO1FBQXhCLGlCQVFDO1FBTkEsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7UUFFaEIsb0ZBQW9GO1FBQ3BGLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFFLFFBQVEsRUFBRSwwQkFBMEIsRUFBRSxVQUFFLENBQUMsSUFBTSxZQUFJLENBQUMsS0FBSyxFQUFFLEVBQVosQ0FBWSxDQUFFLENBQUM7UUFDNUUsT0FBTyxDQUFDLEdBQUcsQ0FBRSxTQUFTLENBQUUsQ0FBQztRQUN6QixPQUFPLENBQUMsR0FBRyxDQUFFLE9BQU8sQ0FBRSxDQUFDO0lBQ3hCLENBQUM7SUFFTyx3QkFBTSxHQUFkLFVBQWdCLElBQUk7UUFFbkIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUUsSUFBSSxDQUFFLENBQUM7UUFDdkIsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUUsNkJBQTZCLENBQUUsQ0FBQyxJQUFJLENBQUU7WUFDckQsTUFBTSxDQUFFLElBQUksQ0FBRSxDQUFDLE9BQU8sQ0FBRSxNQUFNLENBQUUsSUFBSSxDQUFFLENBQUMsSUFBSSxFQUFFLENBQUUsQ0FBQztRQUNqRCxDQUFDLENBQUUsQ0FBQztRQUNKLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFFLGVBQWUsQ0FBRSxDQUFDLElBQUksQ0FBRTtZQUN2QyxNQUFNLENBQUUsSUFBSSxDQUFFLENBQUMsWUFBWSxDQUFFLE1BQU0sQ0FBRSxJQUFJLENBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBRSxDQUFDO1FBQ3RELENBQUMsQ0FBRSxDQUFDO1FBQ0osSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUUsd0JBQXdCLENBQUUsQ0FBQyxJQUFJLENBQUU7WUFDaEQsSUFBSSw2Q0FBcUIsQ0FBRSxNQUFNLENBQUUsSUFBSSxDQUFFLEVBQUUsTUFBTSxDQUFFLElBQUksQ0FBRSxDQUFDLElBQUksRUFBRSxDQUFFLENBQUM7UUFDcEUsQ0FBQyxDQUFFLENBQUM7SUFDTCxDQUFDO0lBRU8seUJBQU8sR0FBZjtRQUVDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFFLHlCQUF5QixDQUFFLENBQUMsSUFBSSxDQUFFLFVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDeEQsT0FBTyxDQUFDLEdBQUcsQ0FBRSxVQUFVLEVBQUUsTUFBTSxDQUFFLEVBQUUsQ0FBRSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUUsQ0FBRSxDQUFDO1lBQ3JELE9BQU8sQ0FBQyxNQUFNLENBQUUsR0FBRyxHQUFHLE1BQU0sQ0FBRSxFQUFFLENBQUUsQ0FBQyxJQUFJLENBQUUsSUFBSSxDQUFFLENBQUUsQ0FBQztZQUNyRCxnRkFBZ0Y7UUFDOUUsQ0FBQyxDQUFFLENBQUM7SUFDTCxDQUFDO0lBRU8sdUJBQUssR0FBYjtRQUFBLGlCQThCQztRQTVCQSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUNyQjtZQUNDLElBQUksT0FBTyxPQUFPLEtBQUssV0FBVyxFQUNsQztnQkFDQyxPQUFPLENBQUMsV0FBVyxFQUFFLENBQUM7YUFDdEI7WUFDRCxJQUFJLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBRSxJQUFJLENBQUMsS0FBSyxDQUFFLENBQUMsQ0FBRSxDQUFFLENBQUM7WUFDM0MsSUFBSSxDQUFDLE1BQU0sQ0FBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBRSxDQUFDO1lBQzdDLElBQUksQ0FBQyxNQUFNLENBQUUsT0FBTyxFQUFFLE9BQU8sQ0FBQyxVQUFVLENBQUUsQ0FBQztZQUMzQyxJQUFJLEdBQUcsR0FBVyxPQUFPLENBQUMsUUFBUSxHQUFHLE1BQU0sR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLFFBQVEsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO1lBQzdFLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDakIsSUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBRSxHQUFHLEVBQUU7Z0JBQ25DLElBQUksRUFBUSxJQUFJO2dCQUNoQixNQUFNLEVBQU0sTUFBTTtnQkFDbEIsV0FBVyxFQUFDLEtBQUs7Z0JBQ2pCLFdBQVcsRUFBQyxLQUFLO2dCQUNqQixPQUFPLEVBQUssVUFBRSxNQUFNO29CQUNuQixJQUFJLE1BQU0sRUFDVjt3QkFDQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO3dCQUNwQixJQUFJLFFBQVEsR0FBRyxNQUFNLENBQUUsTUFBTSxDQUFFLENBQUM7d0JBQ2hDLEtBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQzt3QkFDZixLQUFJLENBQUMsTUFBTSxDQUFFLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBRSxDQUFDO3FCQUMvQjtnQkFDRixDQUFDO2dCQUNELEtBQUssRUFBTyxnQkFBTSxJQUFJLGNBQU8sQ0FBQyxLQUFLLENBQUUsTUFBTSxDQUFFLEVBQXZCLENBQXVCO2FBQzdDLENBQUUsQ0FBQztTQUNKO0lBQ0YsQ0FBQztJQUdELHNCQUFJLHVCQUFFO1FBRE4saUJBQWlCO2FBQ2pCO1lBRUMsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUUsQ0FBQztRQUMvQixDQUFDOzs7T0FBQTtJQUVELHNCQUFJLDBCQUFLO2FBQVQ7WUFFQyxPQUFPLE1BQU0sQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBRSxNQUFNLENBQUUsQ0FBRSxDQUFDO1FBQzlDLENBQUM7OztPQUFBO0lBRUQsc0JBQUkseUJBQUk7YUFBUjtZQUVDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUUsaUJBQWlCLENBQUU7Z0JBQUcsT0FBTyxTQUFTLENBQUM7WUFDL0QsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBRSxzQkFBc0IsQ0FBRTtnQkFBRyxPQUFPLGNBQWMsQ0FBQztZQUN6RSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFFLGtCQUFrQixDQUFFO2dCQUFHLE9BQU8sVUFBVSxDQUFDO1FBQ2xFLENBQUM7OztPQUFBO0lBQ0YsY0FBQztBQUFELENBQUM7QUF0RlksMEJBQU87Ozs7Ozs7Ozs7Ozs7O0FDRnBCO0lBYUMsK0JBQWEsR0FBVyxFQUFFLE9BQWU7UUFBekMsaUJBb0JDO1FBOUJNLFlBQU8sR0FBa0M7WUFDL0MsR0FBRyxFQUFRLENBQUMsQ0FBQztZQUNiLEtBQUssRUFBTSxFQUFFO1lBQ2IsVUFBVSxFQUFDLEVBQUU7WUFDYixJQUFJLEVBQU8sSUFBSTtZQUNmLEtBQUssRUFBTSxRQUFRO1NBQ25CLENBQUM7UUFNRCxJQUFJLENBQUMsR0FBRyxHQUFRLEdBQUcsQ0FBQztRQUNwQixRQUFRO1FBQ1IsSUFBSSxDQUFDLE9BQU8sR0FBSSxNQUFNLENBQUMsTUFBTSxDQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBRSxDQUFDO1FBQzNELE9BQU87UUFDUCxJQUFJLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQyxRQUFRLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUUsOEJBQThCLENBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBRSxDQUFDO1FBQ3BGLElBQUksQ0FBQyxPQUFPLEdBQUksRUFBRSxDQUFDLEtBQUssQ0FBRTtZQUN6QixLQUFLLEVBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLO1lBQzNCLFFBQVEsRUFBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUs7WUFDcEUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFDLElBQUksRUFBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBQyxDQUFDLENBQUMsQ0FBQyxTQUFTO1lBQ2pFLE1BQU0sRUFBRyxFQUFDLElBQUksRUFBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQVUsRUFBQztZQUN2QyxLQUFLLEVBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLO1NBQzNCLENBQUUsQ0FBQztRQUNKLGFBQWE7UUFDYixJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBRSxRQUFRLEVBQUUsY0FBTSxZQUFJLENBQUMsZUFBZSxFQUFFLEVBQXRCLENBQXNCLENBQUUsQ0FBQztRQUMxRCxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLGNBQU0sWUFBSSxDQUFDLElBQUksRUFBRSxFQUFYLENBQVcsQ0FBRSxDQUFDO1FBQ3RELElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsVUFBRSxDQUFDLElBQU0sWUFBSSxDQUFDLGFBQWEsQ0FBRSxDQUFDLENBQUUsRUFBdkIsQ0FBdUIsQ0FBRSxDQUFDO1FBRXhFLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFFTSxzQ0FBTSxHQUFiO1FBRUMsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUM7WUFBRyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBRSxVQUFVLENBQUUsQ0FBQyxJQUFJLENBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBRSxDQUFDOztZQUNwSCxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBRSxVQUFVLENBQUUsQ0FBQyxJQUFJLENBQUUsVUFBVSxFQUFFLElBQUksQ0FBRSxDQUFDO0lBQzNELENBQUM7SUFFTSxvQ0FBSSxHQUFYO1FBRUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNyQixDQUFDO0lBQUEsQ0FBQztJQUVLLG1DQUFHLEdBQVYsVUFBWSxlQUF1QztRQUVsRCxJQUFJLE1BQU0sR0FBWSxJQUFJLENBQUM7UUFDM0IsZUFBZSxDQUFDLEdBQUcsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDO1FBQzNDLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSztZQUFHLGVBQWUsQ0FBQyxLQUFLLEdBQUcsRUFBRSxDQUFDO1FBQ3hELElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTTtZQUFHLGVBQWUsQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO1FBQzFELElBQUksZUFBZSxDQUFDLEtBQUssRUFDekI7WUFDQyxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLGVBQWUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFDMUU7Z0JBQ0MsZUFBZSxDQUFDLEdBQUcsR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUM7YUFDMUQ7aUJBQ0ksSUFBSSxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksSUFBSSxlQUFlLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQ3JFO2dCQUNDLGVBQWUsQ0FBQyxHQUFHLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDO2FBQ3JEO1NBQ0Q7UUFDRCxJQUFJLEdBQUcsR0FBRyxNQUFNLENBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBRSxlQUFlLENBQUUsQ0FBRSxDQUFDO1FBQ3JELElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFFLGFBQWEsQ0FBRSxDQUFDLE1BQU0sQ0FBRSxHQUFHLENBQUUsQ0FBQztJQUM5QyxDQUFDO0lBQUEsQ0FBQztJQUdGLHNCQUFXLHdDQUFLO1FBRGhCLGlCQUFpQjthQUNqQjtZQUVDLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUUsa0JBQWtCLENBQUUsQ0FBQyxNQUFNLENBQUM7UUFDbkQsQ0FBQzs7O09BQUE7SUFFRCxvQkFBb0I7SUFDWiwrQ0FBZSxHQUF2QjtRQUVDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFFLFdBQVcsQ0FBRSxDQUFDO1FBQ3hELElBQUksTUFBTSxHQUFNLElBQUksQ0FBQztRQUNyQixTQUFTLENBQUMsSUFBSSxDQUFFLFVBQVUsVUFBVTtZQUVuQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUMvRDtnQkFDQyxNQUFNLENBQUMsR0FBRyxDQUFFLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBRSxDQUFDO2FBQ2xDO1FBQ0YsQ0FBQyxDQUFFLENBQUM7UUFFSixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7SUFDZixDQUFDO0lBQUEsQ0FBQztJQUVNLDZDQUFhLEdBQXJCLFVBQXVCLENBQUM7UUFFdkIsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO1FBQ25CLElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBRSxDQUFDLENBQUMsYUFBYSxDQUFFLENBQUM7UUFDcEMsR0FBRyxDQUFDLE9BQU8sQ0FBRSxrQkFBa0IsQ0FBRSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzNDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFDRiw0QkFBQztBQUFELENBQUM7QUFoR1ksc0RBQXFCOzs7Ozs7O1VDQWxDO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBO1VBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdEJBLHlLQUE4QjtBQUM5QiwrSkFBc0Q7QUFDdEQsdUpBQWtEO0FBQ2xELDJMQUFvRTtBQUNwRSxxSEFBK0M7QUFDL0MsNkdBQTJDO0FBQzNDLDZGQUFtQztBQUVuQyxDQUFDLFVBQVUsQ0FBQztJQUVYLENBQUMsQ0FBRSxRQUFRLENBQUUsQ0FBQyxLQUFLLENBQUU7UUFFcEIsbUJBQW1CO1FBQ25CLENBQUMsQ0FBRSw2QkFBNkIsQ0FBRSxDQUFDLElBQUksQ0FBRTtZQUV4QyxDQUFDLENBQUUsSUFBSSxDQUFFLENBQUMsT0FBTyxDQUFFLENBQUMsQ0FBRSxJQUFJLENBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBRSxDQUFDO1FBQ3ZDLENBQUMsQ0FBRSxDQUFDO0lBQ0wsQ0FBQyxDQUFFLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBRSxNQUFNLENBQUUsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R1dG9tdmMvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXNlbGVjdC9kaXN0L2pzL2Jvb3RzdHJhcC1zZWxlY3QuanMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuanMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL25vZGVfbW9kdWxlcy9zZWxlY3QyL2Rpc3QvanMvc2VsZWN0Mi5qcyIsIndlYnBhY2s6Ly90dXRvbXZjLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzIiwid2VicGFjazovL3R1dG9tdmMvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwLXNlbGVjdC9kaXN0L2pzL2Jvb3RzdHJhcC1zZWxlY3QuanM/ZThmNiIsIndlYnBhY2s6Ly90dXRvbXZjLy4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5qcz9jYzE5Iiwid2VicGFjazovL3R1dG9tdmMvLi9ub2RlX21vZHVsZXMvc2VsZWN0Mi9kaXN0L2pzL3NlbGVjdDIuanM/NjJjMyIsIndlYnBhY2s6Ly90dXRvbXZjLy4vc3JjL3RzYy9wbHVnaW5zL2pRdWVyeVdQQXR0YWNobWVudEZvcm1JbnB1dC50cyIsIndlYnBhY2s6Ly90dXRvbXZjLy4vc3JjL3RzYy9wbHVnaW5zL2pRdWVyeVdQRWRpdG9yRm9ybUlucHV0LnRzIiwid2VicGFjazovL3R1dG9tdmMvLi9zcmMvdHNjL3BsdWdpbnMvalF1ZXJ5V1BNZXRhQm94LnRzIiwid2VicGFjazovL3R1dG9tdmMvLi9zcmMvdHNjL3dwL2Zvcm0vZ3JvdXBzL01ldGFCb3gudHMiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL3NyYy90c2Mvd3AvZm9ybS9pbnB1dHMvV1BBdHRhY2htZW50Rm9ybUlucHV0LnRzIiwid2VicGFjazovL3R1dG9tdmMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdHV0b212Yy8uL3NyYy90c2MvdHV0b212Yy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLyohXFxyXFxuICogQm9vdHN0cmFwLXNlbGVjdCB2MS4xMy4xOCAoaHR0cHM6Ly9kZXZlbG9wZXIuc25hcGFwcG9pbnRtZW50cy5jb20vYm9vdHN0cmFwLXNlbGVjdClcXHJcXG4gKlxcclxcbiAqIENvcHlyaWdodCAyMDEyLTIwMjAgU25hcEFwcG9pbnRtZW50cywgTExDXFxyXFxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vc25hcGFwcG9pbnRtZW50cy9ib290c3RyYXAtc2VsZWN0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXFxyXFxuICovXFxyXFxuXFxyXFxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XFxyXFxuICBpZiAocm9vdCA9PT0gdW5kZWZpbmVkICYmIHdpbmRvdyAhPT0gdW5kZWZpbmVkKSByb290ID0gd2luZG93O1xcclxcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcclxcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUgdW5sZXNzIGFtZE1vZHVsZUlkIGlzIHNldFxcclxcbiAgICBkZWZpbmUoW1xcXCJqcXVlcnlcXFwiXSwgZnVuY3Rpb24gKGEwKSB7XFxyXFxuICAgICAgcmV0dXJuIChmYWN0b3J5KGEwKSk7XFxyXFxuICAgIH0pO1xcclxcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xcclxcbiAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcXHJcXG4gICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXFxyXFxuICAgIC8vIGxpa2UgTm9kZS5cXHJcXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXFxcImpxdWVyeVxcXCIpKTtcXHJcXG4gIH0gZWxzZSB7XFxyXFxuICAgIGZhY3Rvcnkocm9vdFtcXFwialF1ZXJ5XFxcIl0pO1xcclxcbiAgfVxcclxcbn0odGhpcywgZnVuY3Rpb24gKGpRdWVyeSkge1xcclxcblxcclxcbihmdW5jdGlvbiAoJCkge1xcclxcbiAgJ3VzZSBzdHJpY3QnO1xcclxcblxcclxcbiAgdmFyIERJU0FMTE9XRURfQVRUUklCVVRFUyA9IFsnc2FuaXRpemUnLCAnd2hpdGVMaXN0JywgJ3Nhbml0aXplRm4nXTtcXHJcXG5cXHJcXG4gIHZhciB1cmlBdHRycyA9IFtcXHJcXG4gICAgJ2JhY2tncm91bmQnLFxcclxcbiAgICAnY2l0ZScsXFxyXFxuICAgICdocmVmJyxcXHJcXG4gICAgJ2l0ZW10eXBlJyxcXHJcXG4gICAgJ2xvbmdkZXNjJyxcXHJcXG4gICAgJ3Bvc3RlcicsXFxyXFxuICAgICdzcmMnLFxcclxcbiAgICAneGxpbms6aHJlZidcXHJcXG4gIF07XFxyXFxuXFxyXFxuICB2YXIgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFxcXHctXSokL2k7XFxyXFxuXFxyXFxuICB2YXIgRGVmYXVsdFdoaXRlbGlzdCA9IHtcXHJcXG4gICAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cXHJcXG4gICAgJyonOiBbJ2NsYXNzJywgJ2RpcicsICdpZCcsICdsYW5nJywgJ3JvbGUnLCAndGFiaW5kZXgnLCAnc3R5bGUnLCBBUklBX0FUVFJJQlVURV9QQVRURVJOXSxcXHJcXG4gICAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcXHJcXG4gICAgYXJlYTogW10sXFxyXFxuICAgIGI6IFtdLFxcclxcbiAgICBicjogW10sXFxyXFxuICAgIGNvbDogW10sXFxyXFxuICAgIGNvZGU6IFtdLFxcclxcbiAgICBkaXY6IFtdLFxcclxcbiAgICBlbTogW10sXFxyXFxuICAgIGhyOiBbXSxcXHJcXG4gICAgaDE6IFtdLFxcclxcbiAgICBoMjogW10sXFxyXFxuICAgIGgzOiBbXSxcXHJcXG4gICAgaDQ6IFtdLFxcclxcbiAgICBoNTogW10sXFxyXFxuICAgIGg2OiBbXSxcXHJcXG4gICAgaTogW10sXFxyXFxuICAgIGltZzogWydzcmMnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxcclxcbiAgICBsaTogW10sXFxyXFxuICAgIG9sOiBbXSxcXHJcXG4gICAgcDogW10sXFxyXFxuICAgIHByZTogW10sXFxyXFxuICAgIHM6IFtdLFxcclxcbiAgICBzbWFsbDogW10sXFxyXFxuICAgIHNwYW46IFtdLFxcclxcbiAgICBzdWI6IFtdLFxcclxcbiAgICBzdXA6IFtdLFxcclxcbiAgICBzdHJvbmc6IFtdLFxcclxcbiAgICB1OiBbXSxcXHJcXG4gICAgdWw6IFtdXFxyXFxuICB9XFxyXFxuXFxyXFxuICAvKipcXHJcXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cXHJcXG4gICAqXFxyXFxuICAgKiBTaG91dG91dCB0byBBbmd1bGFyIDcgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzcuMi40L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXFxyXFxuICAgKi9cXHJcXG4gIHZhciBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZSk6fFteJjovPyNdKig/OlsvPyNdfCQpKS9naTtcXHJcXG5cXHJcXG4gIC8qKlxcclxcbiAgICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXFxyXFxuICAgKlxcclxcbiAgICogU2hvdXRvdXQgdG8gQW5ndWxhciA3IGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi83LjIuNC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xcclxcbiAgICovXFxyXFxuICB2YXIgREFUQV9VUkxfUEFUVEVSTiA9IC9eZGF0YTooPzppbWFnZVxcXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFxcXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFthLXowLTkrL10rPSokL2k7XFxyXFxuXFxyXFxuICBmdW5jdGlvbiBhbGxvd2VkQXR0cmlidXRlIChhdHRyLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkge1xcclxcbiAgICB2YXIgYXR0ck5hbWUgPSBhdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKClcXHJcXG5cXHJcXG4gICAgaWYgKCQuaW5BcnJheShhdHRyTmFtZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpICE9PSAtMSkge1xcclxcbiAgICAgIGlmICgkLmluQXJyYXkoYXR0ck5hbWUsIHVyaUF0dHJzKSAhPT0gLTEpIHtcXHJcXG4gICAgICAgIHJldHVybiBCb29sZWFuKGF0dHIubm9kZVZhbHVlLm1hdGNoKFNBRkVfVVJMX1BBVFRFUk4pIHx8IGF0dHIubm9kZVZhbHVlLm1hdGNoKERBVEFfVVJMX1BBVFRFUk4pKVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICByZXR1cm4gdHJ1ZVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHZhciByZWdFeHAgPSAkKGFsbG93ZWRBdHRyaWJ1dGVMaXN0KS5maWx0ZXIoZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xcclxcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cFxcclxcbiAgICB9KVxcclxcblxcclxcbiAgICAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSByZWdFeHAubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxyXFxuICAgICAgaWYgKGF0dHJOYW1lLm1hdGNoKHJlZ0V4cFtpXSkpIHtcXHJcXG4gICAgICAgIHJldHVybiB0cnVlXFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHJldHVybiBmYWxzZVxcclxcbiAgfVxcclxcblxcclxcbiAgZnVuY3Rpb24gc2FuaXRpemVIdG1sICh1bnNhZmVFbGVtZW50cywgd2hpdGVMaXN0LCBzYW5pdGl6ZUZuKSB7XFxyXFxuICAgIGlmIChzYW5pdGl6ZUZuICYmIHR5cGVvZiBzYW5pdGl6ZUZuID09PSAnZnVuY3Rpb24nKSB7XFxyXFxuICAgICAgcmV0dXJuIHNhbml0aXplRm4odW5zYWZlRWxlbWVudHMpO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHZhciB3aGl0ZWxpc3RLZXlzID0gT2JqZWN0LmtleXMod2hpdGVMaXN0KTtcXHJcXG5cXHJcXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHVuc2FmZUVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgdmFyIGVsZW1lbnRzID0gdW5zYWZlRWxlbWVudHNbaV0ucXVlcnlTZWxlY3RvckFsbCgnKicpO1xcclxcblxcclxcbiAgICAgIGZvciAodmFyIGogPSAwLCBsZW4yID0gZWxlbWVudHMubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XFxyXFxuICAgICAgICB2YXIgZWwgPSBlbGVtZW50c1tqXTtcXHJcXG4gICAgICAgIHZhciBlbE5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcclxcblxcclxcbiAgICAgICAgaWYgKHdoaXRlbGlzdEtleXMuaW5kZXhPZihlbE5hbWUpID09PSAtMSkge1xcclxcbiAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcXHJcXG5cXHJcXG4gICAgICAgICAgY29udGludWU7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICB2YXIgYXR0cmlidXRlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZWwuYXR0cmlidXRlcyk7XFxyXFxuICAgICAgICB2YXIgd2hpdGVsaXN0ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KHdoaXRlTGlzdFsnKiddIHx8IFtdLCB3aGl0ZUxpc3RbZWxOYW1lXSB8fCBbXSk7XFxyXFxuXFxyXFxuICAgICAgICBmb3IgKHZhciBrID0gMCwgbGVuMyA9IGF0dHJpYnV0ZUxpc3QubGVuZ3RoOyBrIDwgbGVuMzsgaysrKSB7XFxyXFxuICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlTGlzdFtrXTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIHdoaXRlbGlzdGVkQXR0cmlidXRlcykpIHtcXHJcXG4gICAgICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoYXR0ci5ub2RlTmFtZSk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC8vIFBvbHlmaWxsIGZvciBicm93c2VycyB3aXRoIG5vIGNsYXNzTGlzdCBzdXBwb3J0XFxyXFxuICAvLyBSZW1vdmUgaW4gdjJcXHJcXG4gIGlmICghKCdjbGFzc0xpc3QnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ18nKSkpIHtcXHJcXG4gICAgKGZ1bmN0aW9uICh2aWV3KSB7XFxyXFxuICAgICAgaWYgKCEoJ0VsZW1lbnQnIGluIHZpZXcpKSByZXR1cm47XFxyXFxuXFxyXFxuICAgICAgdmFyIGNsYXNzTGlzdFByb3AgPSAnY2xhc3NMaXN0JyxcXHJcXG4gICAgICAgICAgcHJvdG9Qcm9wID0gJ3Byb3RvdHlwZScsXFxyXFxuICAgICAgICAgIGVsZW1DdHJQcm90byA9IHZpZXcuRWxlbWVudFtwcm90b1Byb3BdLFxcclxcbiAgICAgICAgICBvYmpDdHIgPSBPYmplY3QsXFxyXFxuICAgICAgICAgIGNsYXNzTGlzdEdldHRlciA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpO1xcclxcblxcclxcbiAgICAgICAgICAgIHJldHVybiB7XFxyXFxuICAgICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uIChjbGFzc2VzKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNsYXNzZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oJyAnKTtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbGVtLmFkZENsYXNzKGNsYXNzZXMpO1xcclxcbiAgICAgICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKGNsYXNzZXMpIHtcXHJcXG4gICAgICAgICAgICAgICAgY2xhc3NlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuam9pbignICcpO1xcclxcbiAgICAgICAgICAgICAgICByZXR1cm4gJGVsZW0ucmVtb3ZlQ2xhc3MoY2xhc3Nlcyk7XFxyXFxuICAgICAgICAgICAgICB9LFxcclxcbiAgICAgICAgICAgICAgdG9nZ2xlOiBmdW5jdGlvbiAoY2xhc3NlcywgZm9yY2UpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbGVtLnRvZ2dsZUNsYXNzKGNsYXNzZXMsIGZvcmNlKTtcXHJcXG4gICAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgICBjb250YWluczogZnVuY3Rpb24gKGNsYXNzZXMpIHtcXHJcXG4gICAgICAgICAgICAgICAgcmV0dXJuICRlbGVtLmhhc0NsYXNzKGNsYXNzZXMpO1xcclxcbiAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfTtcXHJcXG5cXHJcXG4gICAgICBpZiAob2JqQ3RyLmRlZmluZVByb3BlcnR5KSB7XFxyXFxuICAgICAgICB2YXIgY2xhc3NMaXN0UHJvcERlc2MgPSB7XFxyXFxuICAgICAgICAgIGdldDogY2xhc3NMaXN0R2V0dGVyLFxcclxcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcclxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcXHJcXG4gICAgICAgIH07XFxyXFxuICAgICAgICB0cnkge1xcclxcbiAgICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XFxyXFxuICAgICAgICB9IGNhdGNoIChleCkgeyAvLyBJRSA4IGRvZXNuJ3Qgc3VwcG9ydCBlbnVtZXJhYmxlOnRydWVcXHJcXG4gICAgICAgICAgLy8gYWRkaW5nIHVuZGVmaW5lZCB0byBmaWdodCB0aGlzIGlzc3VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGlncmV5L2NsYXNzTGlzdC5qcy9pc3N1ZXMvMzZcXHJcXG4gICAgICAgICAgLy8gbW9kZXJuaWUgSUU4LU1TVzcgbWFjaGluZSBoYXMgSUU4IDguMC42MDAxLjE4NzAyIGFuZCBpcyBhZmZlY3RlZFxcclxcbiAgICAgICAgICBpZiAoZXgubnVtYmVyID09PSB1bmRlZmluZWQgfHwgZXgubnVtYmVyID09PSAtMHg3RkY1RUM1NCkge1xcclxcbiAgICAgICAgICAgIGNsYXNzTGlzdFByb3BEZXNjLmVudW1lcmFibGUgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgICBvYmpDdHIuZGVmaW5lUHJvcGVydHkoZWxlbUN0clByb3RvLCBjbGFzc0xpc3RQcm9wLCBjbGFzc0xpc3RQcm9wRGVzYyk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9IGVsc2UgaWYgKG9iakN0cltwcm90b1Byb3BdLl9fZGVmaW5lR2V0dGVyX18pIHtcXHJcXG4gICAgICAgIGVsZW1DdHJQcm90by5fX2RlZmluZUdldHRlcl9fKGNsYXNzTGlzdFByb3AsIGNsYXNzTGlzdEdldHRlcik7XFxyXFxuICAgICAgfVxcclxcbiAgICB9KHdpbmRvdykpO1xcclxcbiAgfVxcclxcblxcclxcbiAgdmFyIHRlc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnXycpO1xcclxcblxcclxcbiAgdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnYzEnLCAnYzInKTtcXHJcXG5cXHJcXG4gIGlmICghdGVzdEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdjMicpKSB7XFxyXFxuICAgIHZhciBfYWRkID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5hZGQsXFxyXFxuICAgICAgICBfcmVtb3ZlID0gRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5yZW1vdmU7XFxyXFxuXFxyXFxuICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBfYWRkLmJpbmQodGhpcykpO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoYXJndW1lbnRzLCBfcmVtb3ZlLmJpbmQodGhpcykpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuXFxyXFxuICB0ZXN0RWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdjMycsIGZhbHNlKTtcXHJcXG5cXHJcXG4gIC8vIFBvbHlmaWxsIGZvciBJRSAxMCBhbmQgRmlyZWZveCA8MjQsIHdoZXJlIGNsYXNzTGlzdC50b2dnbGUgZG9lcyBub3RcXHJcXG4gIC8vIHN1cHBvcnQgdGhlIHNlY29uZCBhcmd1bWVudC5cXHJcXG4gIGlmICh0ZXN0RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2MzJykpIHtcXHJcXG4gICAgdmFyIF90b2dnbGUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZTtcXHJcXG5cXHJcXG4gICAgRE9NVG9rZW5MaXN0LnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbiAodG9rZW4sIGZvcmNlKSB7XFxyXFxuICAgICAgaWYgKDEgaW4gYXJndW1lbnRzICYmICF0aGlzLmNvbnRhaW5zKHRva2VuKSA9PT0gIWZvcmNlKSB7XFxyXFxuICAgICAgICByZXR1cm4gZm9yY2U7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHJldHVybiBfdG9nZ2xlLmNhbGwodGhpcywgdG9rZW4pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHRlc3RFbGVtZW50ID0gbnVsbDtcXHJcXG5cXHJcXG4gIC8vIHNoYWxsb3cgYXJyYXkgY29tcGFyaXNvblxcclxcbiAgZnVuY3Rpb24gaXNFcXVhbCAoYXJyYXkxLCBhcnJheTIpIHtcXHJcXG4gICAgcmV0dXJuIGFycmF5MS5sZW5ndGggPT09IGFycmF5Mi5sZW5ndGggJiYgYXJyYXkxLmV2ZXJ5KGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCkge1xcclxcbiAgICAgIHJldHVybiBlbGVtZW50ID09PSBhcnJheTJbaW5kZXhdO1xcclxcbiAgICB9KTtcXHJcXG4gIH07XFxyXFxuXFxyXFxuICAvLyA8ZWRpdG9yLWZvbGQgZGVzYz1cXFwiU2hpbXNcXFwiPlxcclxcbiAgaWYgKCFTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGgpIHtcXHJcXG4gICAgKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAndXNlIHN0cmljdCc7IC8vIG5lZWRlZCB0byBzdXBwb3J0IGBhcHBseWAvYGNhbGxgIHdpdGggYHVuZGVmaW5lZGAvYG51bGxgXFxyXFxuICAgICAgdmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIC8vIElFIDggb25seSBzdXBwb3J0cyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBvbiBET00gZWxlbWVudHNcXHJcXG4gICAgICAgIHRyeSB7XFxyXFxuICAgICAgICAgIHZhciBvYmplY3QgPSB7fTtcXHJcXG4gICAgICAgICAgdmFyICRkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcXHJcXG4gICAgICAgICAgdmFyIHJlc3VsdCA9ICRkZWZpbmVQcm9wZXJ0eShvYmplY3QsIG9iamVjdCwgb2JqZWN0KSAmJiAkZGVmaW5lUHJvcGVydHk7XFxyXFxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcXHJcXG4gICAgICB9KCkpO1xcclxcbiAgICAgIHZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xcclxcbiAgICAgIHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24gKHNlYXJjaCkge1xcclxcbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xcclxcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHRoaXMpO1xcclxcbiAgICAgICAgaWYgKHNlYXJjaCAmJiB0b1N0cmluZy5jYWxsKHNlYXJjaCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcXHJcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgICAgdmFyIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGg7XFxyXFxuICAgICAgICB2YXIgc2VhcmNoU3RyaW5nID0gU3RyaW5nKHNlYXJjaCk7XFxyXFxuICAgICAgICB2YXIgc2VhcmNoTGVuZ3RoID0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcXHJcXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xcclxcbiAgICAgICAgLy8gYFRvSW50ZWdlcmBcXHJcXG4gICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbiA/IE51bWJlcihwb3NpdGlvbikgOiAwO1xcclxcbiAgICAgICAgaWYgKHBvcyAhPSBwb3MpIHsgLy8gYmV0dGVyIGBpc05hTmBcXHJcXG4gICAgICAgICAgcG9zID0gMDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHZhciBzdGFydCA9IE1hdGgubWluKE1hdGgubWF4KHBvcywgMCksIHN0cmluZ0xlbmd0aCk7XFxyXFxuICAgICAgICAvLyBBdm9pZCB0aGUgYGluZGV4T2ZgIGNhbGwgaWYgbm8gbWF0Y2ggaXMgcG9zc2libGVcXHJcXG4gICAgICAgIGlmIChzZWFyY2hMZW5ndGggKyBzdGFydCA+IHN0cmluZ0xlbmd0aCkge1xcclxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgICB2YXIgaW5kZXggPSAtMTtcXHJcXG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgc2VhcmNoTGVuZ3RoKSB7XFxyXFxuICAgICAgICAgIGlmIChzdHJpbmcuY2hhckNvZGVBdChzdGFydCArIGluZGV4KSAhPSBzZWFyY2hTdHJpbmcuY2hhckNvZGVBdChpbmRleCkpIHtcXHJcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICAgIHJldHVybiB0cnVlO1xcclxcbiAgICAgIH07XFxyXFxuICAgICAgaWYgKGRlZmluZVByb3BlcnR5KSB7XFxyXFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eShTdHJpbmcucHJvdG90eXBlLCAnc3RhcnRzV2l0aCcsIHtcXHJcXG4gICAgICAgICAgJ3ZhbHVlJzogc3RhcnRzV2l0aCxcXHJcXG4gICAgICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXFxyXFxuICAgICAgICAgICd3cml0YWJsZSc6IHRydWVcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSgpKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGlmICghT2JqZWN0LmtleXMpIHtcXHJcXG4gICAgT2JqZWN0LmtleXMgPSBmdW5jdGlvbiAoXFxyXFxuICAgICAgbywgLy8gb2JqZWN0XFxyXFxuICAgICAgaywgLy8ga2V5XFxyXFxuICAgICAgciAgLy8gcmVzdWx0IGFycmF5XFxyXFxuICAgICkge1xcclxcbiAgICAgIC8vIGluaXRpYWxpemUgb2JqZWN0IGFuZCByZXN1bHRcXHJcXG4gICAgICByID0gW107XFxyXFxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXFxyXFxuICAgICAgZm9yIChrIGluIG8pIHtcXHJcXG4gICAgICAgIC8vIGZpbGwgcmVzdWx0IGFycmF5IHdpdGggbm9uLXByb3RvdHlwaWNhbCBrZXlzXFxyXFxuICAgICAgICByLmhhc093blByb3BlcnR5LmNhbGwobywgaykgJiYgci5wdXNoKGspO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICAvLyByZXR1cm4gcmVzdWx0XFxyXFxuICAgICAgcmV0dXJuIHI7XFxyXFxuICAgIH07XFxyXFxuICB9XFxyXFxuXFxyXFxuICBpZiAoSFRNTFNlbGVjdEVsZW1lbnQgJiYgIUhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnc2VsZWN0ZWRPcHRpb25zJykpIHtcXHJcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgJ3NlbGVjdGVkT3B0aW9ucycsIHtcXHJcXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9KTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGZ1bmN0aW9uIGdldFNlbGVjdGVkT3B0aW9ucyAoc2VsZWN0LCBpZ25vcmVEaXNhYmxlZCkge1xcclxcbiAgICB2YXIgc2VsZWN0ZWRPcHRpb25zID0gc2VsZWN0LnNlbGVjdGVkT3B0aW9ucyxcXHJcXG4gICAgICAgIG9wdGlvbnMgPSBbXSxcXHJcXG4gICAgICAgIG9wdDtcXHJcXG5cXHJcXG4gICAgaWYgKGlnbm9yZURpc2FibGVkKSB7XFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGVjdGVkT3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgICAgb3B0ID0gc2VsZWN0ZWRPcHRpb25zW2ldO1xcclxcblxcclxcbiAgICAgICAgaWYgKCEob3B0LmRpc2FibGVkIHx8IG9wdC5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdPUFRHUk9VUCcgJiYgb3B0LnBhcmVudE5vZGUuZGlzYWJsZWQpKSB7XFxyXFxuICAgICAgICAgIG9wdGlvbnMucHVzaChvcHQpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICByZXR1cm4gb3B0aW9ucztcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICByZXR1cm4gc2VsZWN0ZWRPcHRpb25zO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gbXVjaCBmYXN0ZXIgdGhhbiAkLnZhbCgpXFxyXFxuICBmdW5jdGlvbiBnZXRTZWxlY3RWYWx1ZXMgKHNlbGVjdCwgc2VsZWN0ZWRPcHRpb25zKSB7XFxyXFxuICAgIHZhciB2YWx1ZSA9IFtdLFxcclxcbiAgICAgICAgb3B0aW9ucyA9IHNlbGVjdGVkT3B0aW9ucyB8fCBzZWxlY3Quc2VsZWN0ZWRPcHRpb25zLFxcclxcbiAgICAgICAgb3B0O1xcclxcblxcclxcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcclxcbiAgICAgIG9wdCA9IG9wdGlvbnNbaV07XFxyXFxuXFxyXFxuICAgICAgaWYgKCEob3B0LmRpc2FibGVkIHx8IG9wdC5wYXJlbnROb2RlLnRhZ05hbWUgPT09ICdPUFRHUk9VUCcgJiYgb3B0LnBhcmVudE5vZGUuZGlzYWJsZWQpKSB7XFxyXFxuICAgICAgICB2YWx1ZS5wdXNoKG9wdC52YWx1ZSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIGlmICghc2VsZWN0Lm11bHRpcGxlKSB7XFxyXFxuICAgICAgcmV0dXJuICF2YWx1ZS5sZW5ndGggPyBudWxsIDogdmFsdWVbMF07XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgcmV0dXJuIHZhbHVlO1xcclxcbiAgfVxcclxcblxcclxcbiAgLy8gc2V0IGRhdGEtc2VsZWN0ZWQgb24gc2VsZWN0IGVsZW1lbnQgaWYgdGhlIHZhbHVlIGhhcyBiZWVuIHByb2dyYW1tYXRpY2FsbHkgc2VsZWN0ZWRcXHJcXG4gIC8vIHByaW9yIHRvIGluaXRpYWxpemF0aW9uIG9mIGJvb3RzdHJhcC1zZWxlY3RcXHJcXG4gIC8vICogY29uc2lkZXIgcmVtb3Zpbmcgb3IgcmVwbGFjaW5nIGFuIGFsdGVybmF0aXZlIG1ldGhvZCAqXFxyXFxuICB2YXIgdmFsSG9va3MgPSB7XFxyXFxuICAgIHVzZURlZmF1bHQ6IGZhbHNlLFxcclxcbiAgICBfc2V0OiAkLnZhbEhvb2tzLnNlbGVjdC5zZXRcXHJcXG4gIH07XFxyXFxuXFxyXFxuICAkLnZhbEhvb2tzLnNlbGVjdC5zZXQgPSBmdW5jdGlvbiAoZWxlbSwgdmFsdWUpIHtcXHJcXG4gICAgaWYgKHZhbHVlICYmICF2YWxIb29rcy51c2VEZWZhdWx0KSAkKGVsZW0pLmRhdGEoJ3NlbGVjdGVkJywgdHJ1ZSk7XFxyXFxuXFxyXFxuICAgIHJldHVybiB2YWxIb29rcy5fc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxyXFxuICB9O1xcclxcblxcclxcbiAgdmFyIGNoYW5nZWRBcmd1bWVudHMgPSBudWxsO1xcclxcblxcclxcbiAgdmFyIEV2ZW50SXNTdXBwb3J0ZWQgPSAoZnVuY3Rpb24gKCkge1xcclxcbiAgICB0cnkge1xcclxcbiAgICAgIG5ldyBFdmVudCgnY2hhbmdlJyk7XFxyXFxuICAgICAgcmV0dXJuIHRydWU7XFxyXFxuICAgIH0gY2F0Y2ggKGUpIHtcXHJcXG4gICAgICByZXR1cm4gZmFsc2U7XFxyXFxuICAgIH1cXHJcXG4gIH0pKCk7XFxyXFxuXFxyXFxuICAkLmZuLnRyaWdnZXJOYXRpdmUgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XFxyXFxuICAgIHZhciBlbCA9IHRoaXNbMF0sXFxyXFxuICAgICAgICBldmVudDtcXHJcXG5cXHJcXG4gICAgaWYgKGVsLmRpc3BhdGNoRXZlbnQpIHsgLy8gZm9yIG1vZGVybiBicm93c2VycyAmIElFOStcXHJcXG4gICAgICBpZiAoRXZlbnRJc1N1cHBvcnRlZCkge1xcclxcbiAgICAgICAgLy8gRm9yIG1vZGVybiBicm93c2Vyc1xcclxcbiAgICAgICAgZXZlbnQgPSBuZXcgRXZlbnQoZXZlbnROYW1lLCB7XFxyXFxuICAgICAgICAgIGJ1YmJsZXM6IHRydWVcXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAvLyBGb3IgSUUgc2luY2UgaXQgZG9lc24ndCBzdXBwb3J0IEV2ZW50IGNvbnN0cnVjdG9yXFxyXFxuICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xcclxcbiAgICAgICAgZXZlbnQuaW5pdEV2ZW50KGV2ZW50TmFtZSwgdHJ1ZSwgZmFsc2UpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBlbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcXHJcXG4gICAgfSBlbHNlIGlmIChlbC5maXJlRXZlbnQpIHsgLy8gZm9yIElFOFxcclxcbiAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnRPYmplY3QoKTtcXHJcXG4gICAgICBldmVudC5ldmVudFR5cGUgPSBldmVudE5hbWU7XFxyXFxuICAgICAgZWwuZmlyZUV2ZW50KCdvbicgKyBldmVudE5hbWUsIGV2ZW50KTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICAvLyBmYWxsIGJhY2sgdG8galF1ZXJ5LnRyaWdnZXJcXHJcXG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lKTtcXHJcXG4gICAgfVxcclxcbiAgfTtcXHJcXG4gIC8vIDwvZWRpdG9yLWZvbGQ+XFxyXFxuXFxyXFxuICBmdW5jdGlvbiBzdHJpbmdTZWFyY2ggKGxpLCBzZWFyY2hTdHJpbmcsIG1ldGhvZCwgbm9ybWFsaXplKSB7XFxyXFxuICAgIHZhciBzdHJpbmdUeXBlcyA9IFtcXHJcXG4gICAgICAgICAgJ2Rpc3BsYXknLFxcclxcbiAgICAgICAgICAnc3VidGV4dCcsXFxyXFxuICAgICAgICAgICd0b2tlbnMnXFxyXFxuICAgICAgICBdLFxcclxcbiAgICAgICAgc2VhcmNoU3VjY2VzcyA9IGZhbHNlO1xcclxcblxcclxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1R5cGVzLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgdmFyIHN0cmluZ1R5cGUgPSBzdHJpbmdUeXBlc1tpXSxcXHJcXG4gICAgICAgICAgc3RyaW5nID0gbGlbc3RyaW5nVHlwZV07XFxyXFxuXFxyXFxuICAgICAgaWYgKHN0cmluZykge1xcclxcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnRvU3RyaW5nKCk7XFxyXFxuXFxyXFxuICAgICAgICAvLyBTdHJpcCBIVE1MIHRhZ3MuIFRoaXMgaXNuJ3QgcGVyZmVjdCwgYnV0IGl0J3MgbXVjaCBmYXN0ZXIgdGhhbiBhbnkgb3RoZXIgbWV0aG9kXFxyXFxuICAgICAgICBpZiAoc3RyaW5nVHlwZSA9PT0gJ2Rpc3BsYXknKSB7XFxyXFxuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKC88W14+XSs+L2csICcnKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChub3JtYWxpemUpIHN0cmluZyA9IG5vcm1hbGl6ZVRvQmFzZShzdHJpbmcpO1xcclxcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnRvVXBwZXJDYXNlKCk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAobWV0aG9kID09PSAnY29udGFpbnMnKSB7XFxyXFxuICAgICAgICAgIHNlYXJjaFN1Y2Nlc3MgPSBzdHJpbmcuaW5kZXhPZihzZWFyY2hTdHJpbmcpID49IDA7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICBzZWFyY2hTdWNjZXNzID0gc3RyaW5nLnN0YXJ0c1dpdGgoc2VhcmNoU3RyaW5nKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChzZWFyY2hTdWNjZXNzKSBicmVhaztcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgcmV0dXJuIHNlYXJjaFN1Y2Nlc3M7XFxyXFxuICB9XFxyXFxuXFxyXFxuICBmdW5jdGlvbiB0b0ludGVnZXIgKHZhbHVlKSB7XFxyXFxuICAgIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApIHx8IDA7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAvLyBCb3Jyb3dlZCBmcm9tIExvZGFzaCAoXy5kZWJ1cnIpXFxyXFxuICAvKiogVXNlZCB0byBtYXAgTGF0aW4gVW5pY29kZSBsZXR0ZXJzIHRvIGJhc2ljIExhdGluIGxldHRlcnMuICovXFxyXFxuICB2YXIgZGVidXJyZWRMZXR0ZXJzID0ge1xcclxcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXFxyXFxuICAgICdcXFxceGMwJzogJ0EnLCAgJ1xcXFx4YzEnOiAnQScsICdcXFxceGMyJzogJ0EnLCAnXFxcXHhjMyc6ICdBJywgJ1xcXFx4YzQnOiAnQScsICdcXFxceGM1JzogJ0EnLFxcclxcbiAgICAnXFxcXHhlMCc6ICdhJywgICdcXFxceGUxJzogJ2EnLCAnXFxcXHhlMic6ICdhJywgJ1xcXFx4ZTMnOiAnYScsICdcXFxceGU0JzogJ2EnLCAnXFxcXHhlNSc6ICdhJyxcXHJcXG4gICAgJ1xcXFx4YzcnOiAnQycsICAnXFxcXHhlNyc6ICdjJyxcXHJcXG4gICAgJ1xcXFx4ZDAnOiAnRCcsICAnXFxcXHhmMCc6ICdkJyxcXHJcXG4gICAgJ1xcXFx4YzgnOiAnRScsICAnXFxcXHhjOSc6ICdFJywgJ1xcXFx4Y2EnOiAnRScsICdcXFxceGNiJzogJ0UnLFxcclxcbiAgICAnXFxcXHhlOCc6ICdlJywgICdcXFxceGU5JzogJ2UnLCAnXFxcXHhlYSc6ICdlJywgJ1xcXFx4ZWInOiAnZScsXFxyXFxuICAgICdcXFxceGNjJzogJ0knLCAgJ1xcXFx4Y2QnOiAnSScsICdcXFxceGNlJzogJ0knLCAnXFxcXHhjZic6ICdJJyxcXHJcXG4gICAgJ1xcXFx4ZWMnOiAnaScsICAnXFxcXHhlZCc6ICdpJywgJ1xcXFx4ZWUnOiAnaScsICdcXFxceGVmJzogJ2knLFxcclxcbiAgICAnXFxcXHhkMSc6ICdOJywgICdcXFxceGYxJzogJ24nLFxcclxcbiAgICAnXFxcXHhkMic6ICdPJywgICdcXFxceGQzJzogJ08nLCAnXFxcXHhkNCc6ICdPJywgJ1xcXFx4ZDUnOiAnTycsICdcXFxceGQ2JzogJ08nLCAnXFxcXHhkOCc6ICdPJyxcXHJcXG4gICAgJ1xcXFx4ZjInOiAnbycsICAnXFxcXHhmMyc6ICdvJywgJ1xcXFx4ZjQnOiAnbycsICdcXFxceGY1JzogJ28nLCAnXFxcXHhmNic6ICdvJywgJ1xcXFx4ZjgnOiAnbycsXFxyXFxuICAgICdcXFxceGQ5JzogJ1UnLCAgJ1xcXFx4ZGEnOiAnVScsICdcXFxceGRiJzogJ1UnLCAnXFxcXHhkYyc6ICdVJyxcXHJcXG4gICAgJ1xcXFx4ZjknOiAndScsICAnXFxcXHhmYSc6ICd1JywgJ1xcXFx4ZmInOiAndScsICdcXFxceGZjJzogJ3UnLFxcclxcbiAgICAnXFxcXHhkZCc6ICdZJywgICdcXFxceGZkJzogJ3knLCAnXFxcXHhmZic6ICd5JyxcXHJcXG4gICAgJ1xcXFx4YzYnOiAnQWUnLCAnXFxcXHhlNic6ICdhZScsXFxyXFxuICAgICdcXFxceGRlJzogJ1RoJywgJ1xcXFx4ZmUnOiAndGgnLFxcclxcbiAgICAnXFxcXHhkZic6ICdzcycsXFxyXFxuICAgIC8vIExhdGluIEV4dGVuZGVkLUEgYmxvY2suXFxyXFxuICAgICdcXFxcdTAxMDAnOiAnQScsICAnXFxcXHUwMTAyJzogJ0EnLCAnXFxcXHUwMTA0JzogJ0EnLFxcclxcbiAgICAnXFxcXHUwMTAxJzogJ2EnLCAgJ1xcXFx1MDEwMyc6ICdhJywgJ1xcXFx1MDEwNSc6ICdhJyxcXHJcXG4gICAgJ1xcXFx1MDEwNic6ICdDJywgICdcXFxcdTAxMDgnOiAnQycsICdcXFxcdTAxMGEnOiAnQycsICdcXFxcdTAxMGMnOiAnQycsXFxyXFxuICAgICdcXFxcdTAxMDcnOiAnYycsICAnXFxcXHUwMTA5JzogJ2MnLCAnXFxcXHUwMTBiJzogJ2MnLCAnXFxcXHUwMTBkJzogJ2MnLFxcclxcbiAgICAnXFxcXHUwMTBlJzogJ0QnLCAgJ1xcXFx1MDExMCc6ICdEJywgJ1xcXFx1MDEwZic6ICdkJywgJ1xcXFx1MDExMSc6ICdkJyxcXHJcXG4gICAgJ1xcXFx1MDExMic6ICdFJywgICdcXFxcdTAxMTQnOiAnRScsICdcXFxcdTAxMTYnOiAnRScsICdcXFxcdTAxMTgnOiAnRScsICdcXFxcdTAxMWEnOiAnRScsXFxyXFxuICAgICdcXFxcdTAxMTMnOiAnZScsICAnXFxcXHUwMTE1JzogJ2UnLCAnXFxcXHUwMTE3JzogJ2UnLCAnXFxcXHUwMTE5JzogJ2UnLCAnXFxcXHUwMTFiJzogJ2UnLFxcclxcbiAgICAnXFxcXHUwMTFjJzogJ0cnLCAgJ1xcXFx1MDExZSc6ICdHJywgJ1xcXFx1MDEyMCc6ICdHJywgJ1xcXFx1MDEyMic6ICdHJyxcXHJcXG4gICAgJ1xcXFx1MDExZCc6ICdnJywgICdcXFxcdTAxMWYnOiAnZycsICdcXFxcdTAxMjEnOiAnZycsICdcXFxcdTAxMjMnOiAnZycsXFxyXFxuICAgICdcXFxcdTAxMjQnOiAnSCcsICAnXFxcXHUwMTI2JzogJ0gnLCAnXFxcXHUwMTI1JzogJ2gnLCAnXFxcXHUwMTI3JzogJ2gnLFxcclxcbiAgICAnXFxcXHUwMTI4JzogJ0knLCAgJ1xcXFx1MDEyYSc6ICdJJywgJ1xcXFx1MDEyYyc6ICdJJywgJ1xcXFx1MDEyZSc6ICdJJywgJ1xcXFx1MDEzMCc6ICdJJyxcXHJcXG4gICAgJ1xcXFx1MDEyOSc6ICdpJywgICdcXFxcdTAxMmInOiAnaScsICdcXFxcdTAxMmQnOiAnaScsICdcXFxcdTAxMmYnOiAnaScsICdcXFxcdTAxMzEnOiAnaScsXFxyXFxuICAgICdcXFxcdTAxMzQnOiAnSicsICAnXFxcXHUwMTM1JzogJ2onLFxcclxcbiAgICAnXFxcXHUwMTM2JzogJ0snLCAgJ1xcXFx1MDEzNyc6ICdrJywgJ1xcXFx1MDEzOCc6ICdrJyxcXHJcXG4gICAgJ1xcXFx1MDEzOSc6ICdMJywgICdcXFxcdTAxM2InOiAnTCcsICdcXFxcdTAxM2QnOiAnTCcsICdcXFxcdTAxM2YnOiAnTCcsICdcXFxcdTAxNDEnOiAnTCcsXFxyXFxuICAgICdcXFxcdTAxM2EnOiAnbCcsICAnXFxcXHUwMTNjJzogJ2wnLCAnXFxcXHUwMTNlJzogJ2wnLCAnXFxcXHUwMTQwJzogJ2wnLCAnXFxcXHUwMTQyJzogJ2wnLFxcclxcbiAgICAnXFxcXHUwMTQzJzogJ04nLCAgJ1xcXFx1MDE0NSc6ICdOJywgJ1xcXFx1MDE0Nyc6ICdOJywgJ1xcXFx1MDE0YSc6ICdOJyxcXHJcXG4gICAgJ1xcXFx1MDE0NCc6ICduJywgICdcXFxcdTAxNDYnOiAnbicsICdcXFxcdTAxNDgnOiAnbicsICdcXFxcdTAxNGInOiAnbicsXFxyXFxuICAgICdcXFxcdTAxNGMnOiAnTycsICAnXFxcXHUwMTRlJzogJ08nLCAnXFxcXHUwMTUwJzogJ08nLFxcclxcbiAgICAnXFxcXHUwMTRkJzogJ28nLCAgJ1xcXFx1MDE0Zic6ICdvJywgJ1xcXFx1MDE1MSc6ICdvJyxcXHJcXG4gICAgJ1xcXFx1MDE1NCc6ICdSJywgICdcXFxcdTAxNTYnOiAnUicsICdcXFxcdTAxNTgnOiAnUicsXFxyXFxuICAgICdcXFxcdTAxNTUnOiAncicsICAnXFxcXHUwMTU3JzogJ3InLCAnXFxcXHUwMTU5JzogJ3InLFxcclxcbiAgICAnXFxcXHUwMTVhJzogJ1MnLCAgJ1xcXFx1MDE1Yyc6ICdTJywgJ1xcXFx1MDE1ZSc6ICdTJywgJ1xcXFx1MDE2MCc6ICdTJyxcXHJcXG4gICAgJ1xcXFx1MDE1Yic6ICdzJywgICdcXFxcdTAxNWQnOiAncycsICdcXFxcdTAxNWYnOiAncycsICdcXFxcdTAxNjEnOiAncycsXFxyXFxuICAgICdcXFxcdTAxNjInOiAnVCcsICAnXFxcXHUwMTY0JzogJ1QnLCAnXFxcXHUwMTY2JzogJ1QnLFxcclxcbiAgICAnXFxcXHUwMTYzJzogJ3QnLCAgJ1xcXFx1MDE2NSc6ICd0JywgJ1xcXFx1MDE2Nyc6ICd0JyxcXHJcXG4gICAgJ1xcXFx1MDE2OCc6ICdVJywgICdcXFxcdTAxNmEnOiAnVScsICdcXFxcdTAxNmMnOiAnVScsICdcXFxcdTAxNmUnOiAnVScsICdcXFxcdTAxNzAnOiAnVScsICdcXFxcdTAxNzInOiAnVScsXFxyXFxuICAgICdcXFxcdTAxNjknOiAndScsICAnXFxcXHUwMTZiJzogJ3UnLCAnXFxcXHUwMTZkJzogJ3UnLCAnXFxcXHUwMTZmJzogJ3UnLCAnXFxcXHUwMTcxJzogJ3UnLCAnXFxcXHUwMTczJzogJ3UnLFxcclxcbiAgICAnXFxcXHUwMTc0JzogJ1cnLCAgJ1xcXFx1MDE3NSc6ICd3JyxcXHJcXG4gICAgJ1xcXFx1MDE3Nic6ICdZJywgICdcXFxcdTAxNzcnOiAneScsICdcXFxcdTAxNzgnOiAnWScsXFxyXFxuICAgICdcXFxcdTAxNzknOiAnWicsICAnXFxcXHUwMTdiJzogJ1onLCAnXFxcXHUwMTdkJzogJ1onLFxcclxcbiAgICAnXFxcXHUwMTdhJzogJ3onLCAgJ1xcXFx1MDE3Yyc6ICd6JywgJ1xcXFx1MDE3ZSc6ICd6JyxcXHJcXG4gICAgJ1xcXFx1MDEzMic6ICdJSicsICdcXFxcdTAxMzMnOiAnaWonLFxcclxcbiAgICAnXFxcXHUwMTUyJzogJ09lJywgJ1xcXFx1MDE1Myc6ICdvZScsXFxyXFxuICAgICdcXFxcdTAxNDknOiBcXFwiJ25cXFwiLCAnXFxcXHUwMTdmJzogJ3MnXFxyXFxuICB9O1xcclxcblxcclxcbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXFxyXFxuICB2YXIgcmVMYXRpbiA9IC9bXFxcXHhjMC1cXFxceGQ2XFxcXHhkOC1cXFxceGY2XFxcXHhmOC1cXFxceGZmXFxcXHUwMTAwLVxcXFx1MDE3Zl0vZztcXHJcXG5cXHJcXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cXHJcXG4gIHZhciByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcXFxcXHUwMzAwLVxcXFxcXFxcdTAzNmYnLFxcclxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcXFxcXHVmZTIwLVxcXFxcXFxcdWZlMmYnLFxcclxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXFxcXFx1MjBkMC1cXFxcXFxcXHUyMGZmJyxcXHJcXG4gICAgICByc0NvbWJvTWFya3NFeHRlbmRlZFJhbmdlID0gJ1xcXFxcXFxcdTFhYjAtXFxcXFxcXFx1MWFmZicsXFxyXFxuICAgICAgcnNDb21ib01hcmtzU3VwcGxlbWVudFJhbmdlID0gJ1xcXFxcXFxcdTFkYzAtXFxcXFxcXFx1MWRmZicsXFxyXFxuICAgICAgcnNDb21ib1JhbmdlID0gcnNDb21ib01hcmtzUmFuZ2UgKyByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgKyByc0NvbWJvU3ltYm9sc1JhbmdlICsgcnNDb21ib01hcmtzRXh0ZW5kZWRSYW5nZSArIHJzQ29tYm9NYXJrc1N1cHBsZW1lbnRSYW5nZTtcXHJcXG5cXHJcXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cXHJcXG4gIHZhciByc0NvbWJvID0gJ1snICsgcnNDb21ib1JhbmdlICsgJ10nO1xcclxcblxcclxcbiAgLyoqXFxyXFxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXFxyXFxuICAgKiBbY29tYmluaW5nIGRpYWNyaXRpY2FsIG1hcmtzIGZvciBzeW1ib2xzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db21iaW5pbmdfRGlhY3JpdGljYWxfTWFya3NfZm9yX1N5bWJvbHMpLlxcclxcbiAgICovXFxyXFxuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcXHJcXG5cXHJcXG4gIGZ1bmN0aW9uIGRlYnVyckxldHRlciAoa2V5KSB7XFxyXFxuICAgIHJldHVybiBkZWJ1cnJlZExldHRlcnNba2V5XTtcXHJcXG4gIH07XFxyXFxuXFxyXFxuICBmdW5jdGlvbiBub3JtYWxpemVUb0Jhc2UgKHN0cmluZykge1xcclxcbiAgICBzdHJpbmcgPSBzdHJpbmcudG9TdHJpbmcoKTtcXHJcXG4gICAgcmV0dXJuIHN0cmluZyAmJiBzdHJpbmcucmVwbGFjZShyZUxhdGluLCBkZWJ1cnJMZXR0ZXIpLnJlcGxhY2UocmVDb21ib01hcmssICcnKTtcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXFxyXFxuICB2YXIgZXNjYXBlTWFwID0ge1xcclxcbiAgICAnJic6ICcmYW1wOycsXFxyXFxuICAgICc8JzogJyZsdDsnLFxcclxcbiAgICAnPic6ICcmZ3Q7JyxcXHJcXG4gICAgJ1xcXCInOiAnJnF1b3Q7JyxcXHJcXG4gICAgXFxcIidcXFwiOiAnJiN4Mjc7JyxcXHJcXG4gICAgJ2AnOiAnJiN4NjA7J1xcclxcbiAgfTtcXHJcXG5cXHJcXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cXHJcXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24gKG1hcCkge1xcclxcbiAgICB2YXIgZXNjYXBlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xcclxcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xcclxcbiAgICB9O1xcclxcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWQuXFxyXFxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIE9iamVjdC5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xcclxcbiAgICB2YXIgdGVzdFJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UpO1xcclxcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XFxyXFxuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XFxyXFxuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xcclxcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xcclxcbiAgICB9O1xcclxcbiAgfTtcXHJcXG5cXHJcXG4gIHZhciBodG1sRXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xcclxcblxcclxcbiAgLyoqXFxyXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXHJcXG4gICAqIENvbnN0YW50c1xcclxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxyXFxuICAgKi9cXHJcXG5cXHJcXG4gIHZhciBrZXlDb2RlTWFwID0ge1xcclxcbiAgICAzMjogJyAnLFxcclxcbiAgICA0ODogJzAnLFxcclxcbiAgICA0OTogJzEnLFxcclxcbiAgICA1MDogJzInLFxcclxcbiAgICA1MTogJzMnLFxcclxcbiAgICA1MjogJzQnLFxcclxcbiAgICA1MzogJzUnLFxcclxcbiAgICA1NDogJzYnLFxcclxcbiAgICA1NTogJzcnLFxcclxcbiAgICA1NjogJzgnLFxcclxcbiAgICA1NzogJzknLFxcclxcbiAgICA1OTogJzsnLFxcclxcbiAgICA2NTogJ0EnLFxcclxcbiAgICA2NjogJ0InLFxcclxcbiAgICA2NzogJ0MnLFxcclxcbiAgICA2ODogJ0QnLFxcclxcbiAgICA2OTogJ0UnLFxcclxcbiAgICA3MDogJ0YnLFxcclxcbiAgICA3MTogJ0cnLFxcclxcbiAgICA3MjogJ0gnLFxcclxcbiAgICA3MzogJ0knLFxcclxcbiAgICA3NDogJ0onLFxcclxcbiAgICA3NTogJ0snLFxcclxcbiAgICA3NjogJ0wnLFxcclxcbiAgICA3NzogJ00nLFxcclxcbiAgICA3ODogJ04nLFxcclxcbiAgICA3OTogJ08nLFxcclxcbiAgICA4MDogJ1AnLFxcclxcbiAgICA4MTogJ1EnLFxcclxcbiAgICA4MjogJ1InLFxcclxcbiAgICA4MzogJ1MnLFxcclxcbiAgICA4NDogJ1QnLFxcclxcbiAgICA4NTogJ1UnLFxcclxcbiAgICA4NjogJ1YnLFxcclxcbiAgICA4NzogJ1cnLFxcclxcbiAgICA4ODogJ1gnLFxcclxcbiAgICA4OTogJ1knLFxcclxcbiAgICA5MDogJ1onLFxcclxcbiAgICA5NjogJzAnLFxcclxcbiAgICA5NzogJzEnLFxcclxcbiAgICA5ODogJzInLFxcclxcbiAgICA5OTogJzMnLFxcclxcbiAgICAxMDA6ICc0JyxcXHJcXG4gICAgMTAxOiAnNScsXFxyXFxuICAgIDEwMjogJzYnLFxcclxcbiAgICAxMDM6ICc3JyxcXHJcXG4gICAgMTA0OiAnOCcsXFxyXFxuICAgIDEwNTogJzknXFxyXFxuICB9O1xcclxcblxcclxcbiAgdmFyIGtleUNvZGVzID0ge1xcclxcbiAgICBFU0NBUEU6IDI3LCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XFxyXFxuICAgIEVOVEVSOiAxMywgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRW50ZXIga2V5XFxyXFxuICAgIFNQQUNFOiAzMiwgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3Igc3BhY2Uga2V5XFxyXFxuICAgIFRBQjogOSwgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdGFiIGtleVxcclxcbiAgICBBUlJPV19VUDogMzgsIC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHVwIGFycm93IGtleVxcclxcbiAgICBBUlJPV19ET1dOOiA0MCAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBkb3duIGFycm93IGtleVxcclxcbiAgfVxcclxcblxcclxcbiAgdmFyIHZlcnNpb24gPSB7XFxyXFxuICAgIHN1Y2Nlc3M6IGZhbHNlLFxcclxcbiAgICBtYWpvcjogJzMnXFxyXFxuICB9O1xcclxcblxcclxcbiAgdHJ5IHtcXHJcXG4gICAgdmVyc2lvbi5mdWxsID0gKCQuZm4uZHJvcGRvd24uQ29uc3RydWN0b3IuVkVSU0lPTiB8fCAnJykuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpO1xcclxcbiAgICB2ZXJzaW9uLm1ham9yID0gdmVyc2lvbi5mdWxsWzBdO1xcclxcbiAgICB2ZXJzaW9uLnN1Y2Nlc3MgPSB0cnVlO1xcclxcbiAgfSBjYXRjaCAoZXJyKSB7XFxyXFxuICAgIC8vIGRvIG5vdGhpbmdcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHZhciBzZWxlY3RJZCA9IDA7XFxyXFxuXFxyXFxuICB2YXIgRVZFTlRfS0VZID0gJy5icy5zZWxlY3QnO1xcclxcblxcclxcbiAgdmFyIGNsYXNzTmFtZXMgPSB7XFxyXFxuICAgIERJU0FCTEVEOiAnZGlzYWJsZWQnLFxcclxcbiAgICBESVZJREVSOiAnZGl2aWRlcicsXFxyXFxuICAgIFNIT1c6ICdvcGVuJyxcXHJcXG4gICAgRFJPUFVQOiAnZHJvcHVwJyxcXHJcXG4gICAgTUVOVTogJ2Ryb3Bkb3duLW1lbnUnLFxcclxcbiAgICBNRU5VUklHSFQ6ICdkcm9wZG93bi1tZW51LXJpZ2h0JyxcXHJcXG4gICAgTUVOVUxFRlQ6ICdkcm9wZG93bi1tZW51LWxlZnQnLFxcclxcbiAgICAvLyB0by1kbzogcmVwbGFjZSB3aXRoIG1vcmUgYWR2YW5jZWQgdGVtcGxhdGUvY3VzdG9taXphdGlvbiBvcHRpb25zXFxyXFxuICAgIEJVVFRPTkNMQVNTOiAnYnRuLWRlZmF1bHQnLFxcclxcbiAgICBQT1BPVkVSSEVBREVSOiAncG9wb3Zlci10aXRsZScsXFxyXFxuICAgIElDT05CQVNFOiAnZ2x5cGhpY29uJyxcXHJcXG4gICAgVElDS0lDT046ICdnbHlwaGljb24tb2snXFxyXFxuICB9XFxyXFxuXFxyXFxuICB2YXIgU2VsZWN0b3IgPSB7XFxyXFxuICAgIE1FTlU6ICcuJyArIGNsYXNzTmFtZXMuTUVOVVxcclxcbiAgfVxcclxcblxcclxcbiAgdmFyIGVsZW1lbnRUZW1wbGF0ZXMgPSB7XFxyXFxuICAgIGRpdjogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXFxyXFxuICAgIHNwYW46IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKSxcXHJcXG4gICAgaTogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaScpLFxcclxcbiAgICBzdWJ0ZXh0OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzbWFsbCcpLFxcclxcbiAgICBhOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyksXFxyXFxuICAgIGxpOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpLFxcclxcbiAgICB3aGl0ZXNwYWNlOiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnXFxcXHUwMEEwJyksXFxyXFxuICAgIGZyYWdtZW50OiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcXHJcXG4gIH1cXHJcXG5cXHJcXG4gIGVsZW1lbnRUZW1wbGF0ZXMubm9SZXN1bHRzID0gZWxlbWVudFRlbXBsYXRlcy5saS5jbG9uZU5vZGUoZmFsc2UpO1xcclxcbiAgZWxlbWVudFRlbXBsYXRlcy5ub1Jlc3VsdHMuY2xhc3NOYW1lID0gJ25vLXJlc3VsdHMnO1xcclxcblxcclxcbiAgZWxlbWVudFRlbXBsYXRlcy5hLnNldEF0dHJpYnV0ZSgncm9sZScsICdvcHRpb24nKTtcXHJcXG4gIGVsZW1lbnRUZW1wbGF0ZXMuYS5jbGFzc05hbWUgPSAnZHJvcGRvd24taXRlbSc7XFxyXFxuXFxyXFxuICBlbGVtZW50VGVtcGxhdGVzLnN1YnRleHQuY2xhc3NOYW1lID0gJ3RleHQtbXV0ZWQnO1xcclxcblxcclxcbiAgZWxlbWVudFRlbXBsYXRlcy50ZXh0ID0gZWxlbWVudFRlbXBsYXRlcy5zcGFuLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuICBlbGVtZW50VGVtcGxhdGVzLnRleHQuY2xhc3NOYW1lID0gJ3RleHQnO1xcclxcblxcclxcbiAgZWxlbWVudFRlbXBsYXRlcy5jaGVja01hcmsgPSBlbGVtZW50VGVtcGxhdGVzLnNwYW4uY2xvbmVOb2RlKGZhbHNlKTtcXHJcXG5cXHJcXG4gIHZhciBSRUdFWFBfQVJST1cgPSBuZXcgUmVnRXhwKGtleUNvZGVzLkFSUk9XX1VQICsgJ3wnICsga2V5Q29kZXMuQVJST1dfRE9XTik7XFxyXFxuICB2YXIgUkVHRVhQX1RBQl9PUl9FU0NBUEUgPSBuZXcgUmVnRXhwKCdeJyArIGtleUNvZGVzLlRBQiArICckfCcgKyBrZXlDb2Rlcy5FU0NBUEUpO1xcclxcblxcclxcbiAgdmFyIGdlbmVyYXRlT3B0aW9uID0ge1xcclxcbiAgICBsaTogZnVuY3Rpb24gKGNvbnRlbnQsIGNsYXNzZXMsIG9wdGdyb3VwKSB7XFxyXFxuICAgICAgdmFyIGxpID0gZWxlbWVudFRlbXBsYXRlcy5saS5jbG9uZU5vZGUoZmFsc2UpO1xcclxcblxcclxcbiAgICAgIGlmIChjb250ZW50KSB7XFxyXFxuICAgICAgICBpZiAoY29udGVudC5ub2RlVHlwZSA9PT0gMSB8fCBjb250ZW50Lm5vZGVUeXBlID09PSAxMSkge1xcclxcbiAgICAgICAgICBsaS5hcHBlbmRDaGlsZChjb250ZW50KTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIGxpLmlubmVySFRNTCA9IGNvbnRlbnQ7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0eXBlb2YgY2xhc3NlcyAhPT0gJ3VuZGVmaW5lZCcgJiYgY2xhc3NlcyAhPT0gJycpIGxpLmNsYXNzTmFtZSA9IGNsYXNzZXM7XFxyXFxuICAgICAgaWYgKHR5cGVvZiBvcHRncm91cCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0Z3JvdXAgIT09IG51bGwpIGxpLmNsYXNzTGlzdC5hZGQoJ29wdGdyb3VwLScgKyBvcHRncm91cCk7XFxyXFxuXFxyXFxuICAgICAgcmV0dXJuIGxpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBhOiBmdW5jdGlvbiAodGV4dCwgY2xhc3NlcywgaW5saW5lKSB7XFxyXFxuICAgICAgdmFyIGEgPSBlbGVtZW50VGVtcGxhdGVzLmEuY2xvbmVOb2RlKHRydWUpO1xcclxcblxcclxcbiAgICAgIGlmICh0ZXh0KSB7XFxyXFxuICAgICAgICBpZiAodGV4dC5ub2RlVHlwZSA9PT0gMTEpIHtcXHJcXG4gICAgICAgICAgYS5hcHBlbmRDaGlsZCh0ZXh0KTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIGEuaW5zZXJ0QWRqYWNlbnRIVE1MKCdiZWZvcmVlbmQnLCB0ZXh0KTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHR5cGVvZiBjbGFzc2VzICE9PSAndW5kZWZpbmVkJyAmJiBjbGFzc2VzICE9PSAnJykgYS5jbGFzc0xpc3QuYWRkLmFwcGx5KGEuY2xhc3NMaXN0LCBjbGFzc2VzLnNwbGl0KC9cXFxccysvKSk7XFxyXFxuICAgICAgaWYgKGlubGluZSkgYS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgaW5saW5lKTtcXHJcXG5cXHJcXG4gICAgICByZXR1cm4gYTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgdGV4dDogZnVuY3Rpb24gKG9wdGlvbnMsIHVzZUZyYWdtZW50KSB7XFxyXFxuICAgICAgdmFyIHRleHRFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy50ZXh0LmNsb25lTm9kZShmYWxzZSksXFxyXFxuICAgICAgICAgIHN1YnRleHRFbGVtZW50LFxcclxcbiAgICAgICAgICBpY29uRWxlbWVudDtcXHJcXG5cXHJcXG4gICAgICBpZiAob3B0aW9ucy5jb250ZW50KSB7XFxyXFxuICAgICAgICB0ZXh0RWxlbWVudC5pbm5lckhUTUwgPSBvcHRpb25zLmNvbnRlbnQ7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHRleHRFbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9ucy50ZXh0O1xcclxcblxcclxcbiAgICAgICAgaWYgKG9wdGlvbnMuaWNvbikge1xcclxcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSA9IGVsZW1lbnRUZW1wbGF0ZXMud2hpdGVzcGFjZS5jbG9uZU5vZGUoZmFsc2UpO1xcclxcblxcclxcbiAgICAgICAgICAvLyBuZWVkIHRvIHVzZSA8aT4gZm9yIGljb25zIGluIHRoZSBidXR0b24gdG8gcHJldmVudCBhIGJyZWFraW5nIGNoYW5nZVxcclxcbiAgICAgICAgICAvLyBub3RlOiBzd2l0Y2ggdG8gc3BhbiBpbiBuZXh0IG1ham9yIHJlbGVhc2VcXHJcXG4gICAgICAgICAgaWNvbkVsZW1lbnQgPSAodXNlRnJhZ21lbnQgPT09IHRydWUgPyBlbGVtZW50VGVtcGxhdGVzLmkgOiBlbGVtZW50VGVtcGxhdGVzLnNwYW4pLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuICAgICAgICAgIGljb25FbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5pY29uQmFzZSArICcgJyArIG9wdGlvbnMuaWNvbjtcXHJcXG5cXHJcXG4gICAgICAgICAgZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5hcHBlbmRDaGlsZChpY29uRWxlbWVudCk7XFxyXFxuICAgICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQod2hpdGVzcGFjZSk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAob3B0aW9ucy5zdWJ0ZXh0KSB7XFxyXFxuICAgICAgICAgIHN1YnRleHRFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5zdWJ0ZXh0LmNsb25lTm9kZShmYWxzZSk7XFxyXFxuICAgICAgICAgIHN1YnRleHRFbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9ucy5zdWJ0ZXh0O1xcclxcbiAgICAgICAgICB0ZXh0RWxlbWVudC5hcHBlbmRDaGlsZChzdWJ0ZXh0RWxlbWVudCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh1c2VGcmFnbWVudCA9PT0gdHJ1ZSkge1xcclxcbiAgICAgICAgd2hpbGUgKHRleHRFbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xcclxcbiAgICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKHRleHRFbGVtZW50LmNoaWxkTm9kZXNbMF0pO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKHRleHRFbGVtZW50KTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgcmV0dXJuIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQ7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGxhYmVsOiBmdW5jdGlvbiAob3B0aW9ucykge1xcclxcbiAgICAgIHZhciB0ZXh0RWxlbWVudCA9IGVsZW1lbnRUZW1wbGF0ZXMudGV4dC5jbG9uZU5vZGUoZmFsc2UpLFxcclxcbiAgICAgICAgICBzdWJ0ZXh0RWxlbWVudCxcXHJcXG4gICAgICAgICAgaWNvbkVsZW1lbnQ7XFxyXFxuXFxyXFxuICAgICAgdGV4dEVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9ucy5kaXNwbGF5O1xcclxcblxcclxcbiAgICAgIGlmIChvcHRpb25zLmljb24pIHtcXHJcXG4gICAgICAgIHZhciB3aGl0ZXNwYWNlID0gZWxlbWVudFRlbXBsYXRlcy53aGl0ZXNwYWNlLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuXFxyXFxuICAgICAgICBpY29uRWxlbWVudCA9IGVsZW1lbnRUZW1wbGF0ZXMuc3Bhbi5jbG9uZU5vZGUoZmFsc2UpO1xcclxcbiAgICAgICAgaWNvbkVsZW1lbnQuY2xhc3NOYW1lID0gdGhpcy5vcHRpb25zLmljb25CYXNlICsgJyAnICsgb3B0aW9ucy5pY29uO1xcclxcblxcclxcbiAgICAgICAgZWxlbWVudFRlbXBsYXRlcy5mcmFnbWVudC5hcHBlbmRDaGlsZChpY29uRWxlbWVudCk7XFxyXFxuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50LmFwcGVuZENoaWxkKHdoaXRlc3BhY2UpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAob3B0aW9ucy5zdWJ0ZXh0KSB7XFxyXFxuICAgICAgICBzdWJ0ZXh0RWxlbWVudCA9IGVsZW1lbnRUZW1wbGF0ZXMuc3VidGV4dC5jbG9uZU5vZGUoZmFsc2UpO1xcclxcbiAgICAgICAgc3VidGV4dEVsZW1lbnQudGV4dENvbnRlbnQgPSBvcHRpb25zLnN1YnRleHQ7XFxyXFxuICAgICAgICB0ZXh0RWxlbWVudC5hcHBlbmRDaGlsZChzdWJ0ZXh0RWxlbWVudCk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGV4dEVsZW1lbnQpO1xcclxcblxcclxcbiAgICAgIHJldHVybiBlbGVtZW50VGVtcGxhdGVzLmZyYWdtZW50O1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuXFxyXFxuICBmdW5jdGlvbiBzaG93Tm9SZXN1bHRzIChzZWFyY2hNYXRjaCwgc2VhcmNoVmFsdWUpIHtcXHJcXG4gICAgaWYgKCFzZWFyY2hNYXRjaC5sZW5ndGgpIHtcXHJcXG4gICAgICBlbGVtZW50VGVtcGxhdGVzLm5vUmVzdWx0cy5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMubm9uZVJlc3VsdHNUZXh0LnJlcGxhY2UoJ3swfScsICdcXFwiJyArIGh0bWxFc2NhcGUoc2VhcmNoVmFsdWUpICsgJ1xcXCInKTtcXHJcXG4gICAgICB0aGlzLiRtZW51SW5uZXJbMF0uZmlyc3RDaGlsZC5hcHBlbmRDaGlsZChlbGVtZW50VGVtcGxhdGVzLm5vUmVzdWx0cyk7XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHZhciBTZWxlY3RwaWNrZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xcclxcbiAgICB2YXIgdGhhdCA9IHRoaXM7XFxyXFxuXFxyXFxuICAgIC8vIGJvb3RzdHJhcC1zZWxlY3QgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgLSByZXZlcnQgdmFsSG9va3Muc2VsZWN0LnNldCBiYWNrIHRvIGl0cyBvcmlnaW5hbCBmdW5jdGlvblxcclxcbiAgICBpZiAoIXZhbEhvb2tzLnVzZURlZmF1bHQpIHtcXHJcXG4gICAgICAkLnZhbEhvb2tzLnNlbGVjdC5zZXQgPSB2YWxIb29rcy5fc2V0O1xcclxcbiAgICAgIHZhbEhvb2tzLnVzZURlZmF1bHQgPSB0cnVlO1xcclxcbiAgICB9XFxyXFxuXFxyXFxuICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcclxcbiAgICB0aGlzLiRuZXdFbGVtZW50ID0gbnVsbDtcXHJcXG4gICAgdGhpcy4kYnV0dG9uID0gbnVsbDtcXHJcXG4gICAgdGhpcy4kbWVudSA9IG51bGw7XFxyXFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxyXFxuICAgIHRoaXMuc2VsZWN0cGlja2VyID0ge1xcclxcbiAgICAgIG1haW46IHt9LFxcclxcbiAgICAgIHNlYXJjaDoge30sXFxyXFxuICAgICAgY3VycmVudDoge30sIC8vIGN1cnJlbnQgY2hhbmdlcyBpZiBhIHNlYXJjaCBpcyBpbiBwcm9ncmVzc1xcclxcbiAgICAgIHZpZXc6IHt9LFxcclxcbiAgICAgIGlzU2VhcmNoaW5nOiBmYWxzZSxcXHJcXG4gICAgICBrZXlkb3duOiB7XFxyXFxuICAgICAgICBrZXlIaXN0b3J5OiAnJyxcXHJcXG4gICAgICAgIHJlc2V0S2V5SGlzdG9yeToge1xcclxcbiAgICAgICAgICBzdGFydDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeSA9ICcnO1xcclxcbiAgICAgICAgICAgIH0sIDgwMCk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH07XFxyXFxuXFxyXFxuICAgIHRoaXMuc2l6ZUluZm8gPSB7fTtcXHJcXG5cXHJcXG4gICAgLy8gSWYgd2UgaGF2ZSBubyB0aXRsZSB5ZXQsIHRyeSB0byBwdWxsIGl0IGZyb20gdGhlIGh0bWwgdGl0bGUgYXR0cmlidXRlIChqUXVlcnkgZG9lc250JyBwaWNrIGl0IHVwIGFzIGl0J3Mgbm90IGFcXHJcXG4gICAgLy8gZGF0YS1hdHRyaWJ1dGUpXFxyXFxuICAgIGlmICh0aGlzLm9wdGlvbnMudGl0bGUgPT09IG51bGwpIHtcXHJcXG4gICAgICB0aGlzLm9wdGlvbnMudGl0bGUgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ3RpdGxlJyk7XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgLy8gRm9ybWF0IHdpbmRvdyBwYWRkaW5nXFxyXFxuICAgIHZhciB3aW5QYWQgPSB0aGlzLm9wdGlvbnMud2luZG93UGFkZGluZztcXHJcXG4gICAgaWYgKHR5cGVvZiB3aW5QYWQgPT09ICdudW1iZXInKSB7XFxyXFxuICAgICAgdGhpcy5vcHRpb25zLndpbmRvd1BhZGRpbmcgPSBbd2luUGFkLCB3aW5QYWQsIHdpblBhZCwgd2luUGFkXTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICAvLyBFeHBvc2UgcHVibGljIG1ldGhvZHNcXHJcXG4gICAgdGhpcy52YWwgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnZhbDtcXHJcXG4gICAgdGhpcy5yZW5kZXIgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnJlbmRlcjtcXHJcXG4gICAgdGhpcy5yZWZyZXNoID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5yZWZyZXNoO1xcclxcbiAgICB0aGlzLnNldFN0eWxlID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5zZXRTdHlsZTtcXHJcXG4gICAgdGhpcy5zZWxlY3RBbGwgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnNlbGVjdEFsbDtcXHJcXG4gICAgdGhpcy5kZXNlbGVjdEFsbCA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUuZGVzZWxlY3RBbGw7XFxyXFxuICAgIHRoaXMuZGVzdHJveSA9IFNlbGVjdHBpY2tlci5wcm90b3R5cGUuZGVzdHJveTtcXHJcXG4gICAgdGhpcy5yZW1vdmUgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLnJlbW92ZTtcXHJcXG4gICAgdGhpcy5zaG93ID0gU2VsZWN0cGlja2VyLnByb3RvdHlwZS5zaG93O1xcclxcbiAgICB0aGlzLmhpZGUgPSBTZWxlY3RwaWNrZXIucHJvdG90eXBlLmhpZGU7XFxyXFxuXFxyXFxuICAgIHRoaXMuaW5pdCgpO1xcclxcbiAgfTtcXHJcXG5cXHJcXG4gIFNlbGVjdHBpY2tlci5WRVJTSU9OID0gJzEuMTMuMTgnO1xcclxcblxcclxcbiAgLy8gcGFydCBvZiB0aGlzIGlzIGR1cGxpY2F0ZWQgaW4gaTE4bi9kZWZhdWx0cy1lbl9VUy5qcy4gTWFrZSBzdXJlIHRvIHVwZGF0ZSBib3RoLlxcclxcbiAgU2VsZWN0cGlja2VyLkRFRkFVTFRTID0ge1xcclxcbiAgICBub25lU2VsZWN0ZWRUZXh0OiAnTm90aGluZyBzZWxlY3RlZCcsXFxyXFxuICAgIG5vbmVSZXN1bHRzVGV4dDogJ05vIHJlc3VsdHMgbWF0Y2hlZCB7MH0nLFxcclxcbiAgICBjb3VudFNlbGVjdGVkVGV4dDogZnVuY3Rpb24gKG51bVNlbGVjdGVkLCBudW1Ub3RhbCkge1xcclxcbiAgICAgIHJldHVybiAobnVtU2VsZWN0ZWQgPT0gMSkgPyAnezB9IGl0ZW0gc2VsZWN0ZWQnIDogJ3swfSBpdGVtcyBzZWxlY3RlZCc7XFxyXFxuICAgIH0sXFxyXFxuICAgIG1heE9wdGlvbnNUZXh0OiBmdW5jdGlvbiAobnVtQWxsLCBudW1Hcm91cCkge1xcclxcbiAgICAgIHJldHVybiBbXFxyXFxuICAgICAgICAobnVtQWxsID09IDEpID8gJ0xpbWl0IHJlYWNoZWQgKHtufSBpdGVtIG1heCknIDogJ0xpbWl0IHJlYWNoZWQgKHtufSBpdGVtcyBtYXgpJyxcXHJcXG4gICAgICAgIChudW1Hcm91cCA9PSAxKSA/ICdHcm91cCBsaW1pdCByZWFjaGVkICh7bn0gaXRlbSBtYXgpJyA6ICdHcm91cCBsaW1pdCByZWFjaGVkICh7bn0gaXRlbXMgbWF4KSdcXHJcXG4gICAgICBdO1xcclxcbiAgICB9LFxcclxcbiAgICBzZWxlY3RBbGxUZXh0OiAnU2VsZWN0IEFsbCcsXFxyXFxuICAgIGRlc2VsZWN0QWxsVGV4dDogJ0Rlc2VsZWN0IEFsbCcsXFxyXFxuICAgIGRvbmVCdXR0b246IGZhbHNlLFxcclxcbiAgICBkb25lQnV0dG9uVGV4dDogJ0Nsb3NlJyxcXHJcXG4gICAgbXVsdGlwbGVTZXBhcmF0b3I6ICcsICcsXFxyXFxuICAgIHN0eWxlQmFzZTogJ2J0bicsXFxyXFxuICAgIHN0eWxlOiBjbGFzc05hbWVzLkJVVFRPTkNMQVNTLFxcclxcbiAgICBzaXplOiAnYXV0bycsXFxyXFxuICAgIHRpdGxlOiBudWxsLFxcclxcbiAgICBzZWxlY3RlZFRleHRGb3JtYXQ6ICd2YWx1ZXMnLFxcclxcbiAgICB3aWR0aDogZmFsc2UsXFxyXFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXFxyXFxuICAgIGhpZGVEaXNhYmxlZDogZmFsc2UsXFxyXFxuICAgIHNob3dTdWJ0ZXh0OiBmYWxzZSxcXHJcXG4gICAgc2hvd0ljb246IHRydWUsXFxyXFxuICAgIHNob3dDb250ZW50OiB0cnVlLFxcclxcbiAgICBkcm9wdXBBdXRvOiB0cnVlLFxcclxcbiAgICBoZWFkZXI6IGZhbHNlLFxcclxcbiAgICBsaXZlU2VhcmNoOiBmYWxzZSxcXHJcXG4gICAgbGl2ZVNlYXJjaFBsYWNlaG9sZGVyOiBudWxsLFxcclxcbiAgICBsaXZlU2VhcmNoTm9ybWFsaXplOiBmYWxzZSxcXHJcXG4gICAgbGl2ZVNlYXJjaFN0eWxlOiAnY29udGFpbnMnLFxcclxcbiAgICBhY3Rpb25zQm94OiBmYWxzZSxcXHJcXG4gICAgaWNvbkJhc2U6IGNsYXNzTmFtZXMuSUNPTkJBU0UsXFxyXFxuICAgIHRpY2tJY29uOiBjbGFzc05hbWVzLlRJQ0tJQ09OLFxcclxcbiAgICBzaG93VGljazogZmFsc2UsXFxyXFxuICAgIHRlbXBsYXRlOiB7XFxyXFxuICAgICAgY2FyZXQ6ICc8c3BhbiBjbGFzcz1cXFwiY2FyZXRcXFwiPjwvc3Bhbj4nXFxyXFxuICAgIH0sXFxyXFxuICAgIG1heE9wdGlvbnM6IGZhbHNlLFxcclxcbiAgICBtb2JpbGU6IGZhbHNlLFxcclxcbiAgICBzZWxlY3RPblRhYjogZmFsc2UsXFxyXFxuICAgIGRyb3Bkb3duQWxpZ25SaWdodDogZmFsc2UsXFxyXFxuICAgIHdpbmRvd1BhZGRpbmc6IDAsXFxyXFxuICAgIHZpcnR1YWxTY3JvbGw6IDYwMCxcXHJcXG4gICAgZGlzcGxheTogZmFsc2UsXFxyXFxuICAgIHNhbml0aXplOiB0cnVlLFxcclxcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxcclxcbiAgICB3aGl0ZUxpc3Q6IERlZmF1bHRXaGl0ZWxpc3RcXHJcXG4gIH07XFxyXFxuXFxyXFxuICBTZWxlY3RwaWNrZXIucHJvdG90eXBlID0ge1xcclxcblxcclxcbiAgICBjb25zdHJ1Y3RvcjogU2VsZWN0cGlja2VyLFxcclxcblxcclxcbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICBpZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignaWQnKSxcXHJcXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnRbMF0sXFxyXFxuICAgICAgICAgIGZvcm0gPSBlbGVtZW50LmZvcm07XFxyXFxuXFxyXFxuICAgICAgc2VsZWN0SWQrKztcXHJcXG4gICAgICB0aGlzLnNlbGVjdElkID0gJ2JzLXNlbGVjdC0nICsgc2VsZWN0SWQ7XFxyXFxuXFxyXFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdicy1zZWxlY3QtaGlkZGVuJyk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy5tdWx0aXBsZSA9IHRoaXMuJGVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKTtcXHJcXG4gICAgICB0aGlzLmF1dG9mb2N1cyA9IHRoaXMuJGVsZW1lbnQucHJvcCgnYXV0b2ZvY3VzJyk7XFxyXFxuXFxyXFxuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdzaG93LXRpY2snKSkge1xcclxcbiAgICAgICAgdGhpcy5vcHRpb25zLnNob3dUaWNrID0gdHJ1ZTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbmV3RWxlbWVudCA9IHRoaXMuY3JlYXRlRHJvcGRvd24oKTtcXHJcXG4gICAgICB0aGlzLmJ1aWxkRGF0YSgpO1xcclxcbiAgICAgIHRoaXMuJGVsZW1lbnRcXHJcXG4gICAgICAgIC5hZnRlcih0aGlzLiRuZXdFbGVtZW50KVxcclxcbiAgICAgICAgLnByZXBlbmRUbyh0aGlzLiRuZXdFbGVtZW50KTtcXHJcXG5cXHJcXG4gICAgICAvLyBlbnN1cmUgc2VsZWN0IGlzIGFzc29jaWF0ZWQgd2l0aCBmb3JtIGVsZW1lbnQgaWYgaXQgZ290IHVubGlua2VkIGFmdGVyIG1vdmluZyBpdCBpbnNpZGUgbmV3RWxlbWVudFxcclxcbiAgICAgIGlmIChmb3JtICYmIGVsZW1lbnQuZm9ybSA9PT0gbnVsbCkge1xcclxcbiAgICAgICAgaWYgKCFmb3JtLmlkKSBmb3JtLmlkID0gJ2Zvcm0tJyArIHRoaXMuc2VsZWN0SWQ7XFxyXFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9ybScsIGZvcm0uaWQpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLiRidXR0b24gPSB0aGlzLiRuZXdFbGVtZW50LmNoaWxkcmVuKCdidXR0b24nKTtcXHJcXG4gICAgICB0aGlzLiRtZW51ID0gdGhpcy4kbmV3RWxlbWVudC5jaGlsZHJlbihTZWxlY3Rvci5NRU5VKTtcXHJcXG4gICAgICB0aGlzLiRtZW51SW5uZXIgPSB0aGlzLiRtZW51LmNoaWxkcmVuKCcuaW5uZXInKTtcXHJcXG4gICAgICB0aGlzLiRzZWFyY2hib3ggPSB0aGlzLiRtZW51LmZpbmQoJ2lucHV0Jyk7XFxyXFxuXFxyXFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdicy1zZWxlY3QtaGlkZGVuJyk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wZG93bkFsaWduUmlnaHQgPT09IHRydWUpIHRoaXMuJG1lbnVbMF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWVzLk1FTlVSSUdIVCk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcXHJcXG4gICAgICAgIHRoaXMuJGJ1dHRvbi5hdHRyKCdkYXRhLWlkJywgaWQpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLmNoZWNrRGlzYWJsZWQoKTtcXHJcXG4gICAgICB0aGlzLmNsaWNrTGlzdGVuZXIoKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgIHRoaXMubGl2ZVNlYXJjaExpc3RlbmVyKCk7XFxyXFxuICAgICAgICB0aGlzLmZvY3VzZWRQYXJlbnQgPSB0aGlzLiRzZWFyY2hib3hbMF07XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHRoaXMuZm9jdXNlZFBhcmVudCA9IHRoaXMuJG1lbnVJbm5lclswXTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zZXRTdHlsZSgpO1xcclxcbiAgICAgIHRoaXMucmVuZGVyKCk7XFxyXFxuICAgICAgdGhpcy5zZXRXaWR0aCgpO1xcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSB7XFxyXFxuICAgICAgICB0aGlzLnNlbGVjdFBvc2l0aW9uKCk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2hpZGUnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgIGlmICh0aGF0LmlzVmlydHVhbCgpKSB7XFxyXFxuICAgICAgICAgICAgLy8gZW1wdHkgbWVudSBvbiBjbG9zZVxcclxcbiAgICAgICAgICAgIHZhciBtZW51SW5uZXIgPSB0aGF0LiRtZW51SW5uZXJbMF0sXFxyXFxuICAgICAgICAgICAgICAgIGVtcHR5TWVudSA9IG1lbnVJbm5lci5maXJzdENoaWxkLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgVUwgd2l0aCBhbiBlbXB0eSBvbmUgLSB0aGlzIGlzIGZhc3RlciB0aGFuICQuZW1wdHkoKSBvciBpbm5lckhUTUwgPSAnJ1xcclxcbiAgICAgICAgICAgIG1lbnVJbm5lci5yZXBsYWNlQ2hpbGQoZW1wdHlNZW51LCBtZW51SW5uZXIuZmlyc3RDaGlsZCk7XFxyXFxuICAgICAgICAgICAgbWVudUlubmVyLnNjcm9sbFRvcCA9IDA7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0pO1xcclxcbiAgICAgIH1cXHJcXG4gICAgICB0aGlzLiRtZW51LmRhdGEoJ3RoaXMnLCB0aGlzKTtcXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50LmRhdGEoJ3RoaXMnLCB0aGlzKTtcXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLm1vYmlsZSkgdGhpcy5tb2JpbGUoKTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50Lm9uKHtcXHJcXG4gICAgICAgICdoaWRlLmJzLmRyb3Bkb3duJzogZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRlJyArIEVWRU5UX0tFWSwgZSk7XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgJ2hpZGRlbi5icy5kcm9wZG93bic6IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignaGlkZGVuJyArIEVWRU5UX0tFWSwgZSk7XFxyXFxuICAgICAgICB9LFxcclxcbiAgICAgICAgJ3Nob3cuYnMuZHJvcGRvd24nOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cnICsgRVZFTlRfS0VZLCBlKTtcXHJcXG4gICAgICAgIH0sXFxyXFxuICAgICAgICAnc2hvd24uYnMuZHJvcGRvd24nOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ3Nob3duJyArIEVWRU5UX0tFWSwgZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCdyZXF1aXJlZCcpKSB7XFxyXFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdpbnZhbGlkJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICB0aGF0LiRidXR0b25bMF0uY2xhc3NMaXN0LmFkZCgnYnMtaW52YWxpZCcpO1xcclxcblxcclxcbiAgICAgICAgICB0aGF0LiRlbGVtZW50XFxyXFxuICAgICAgICAgICAgLm9uKCdzaG93bicgKyBFVkVOVF9LRVkgKyAnLmludmFsaWQnLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgICB0aGF0LiRlbGVtZW50XFxyXFxuICAgICAgICAgICAgICAgIC52YWwodGhhdC4kZWxlbWVudC52YWwoKSkgLy8gc2V0IHRoZSB2YWx1ZSB0byBoaWRlIHRoZSB2YWxpZGF0aW9uIG1lc3NhZ2UgaW4gQ2hyb21lIHdoZW4gbWVudSBpcyBvcGVuZWRcXHJcXG4gICAgICAgICAgICAgICAgLm9mZignc2hvd24nICsgRVZFTlRfS0VZICsgJy5pbnZhbGlkJyk7XFxyXFxuICAgICAgICAgICAgfSlcXHJcXG4gICAgICAgICAgICAub24oJ3JlbmRlcmVkJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgLy8gaWYgc2VsZWN0IGlzIG5vIGxvbmdlciBpbnZhbGlkLCByZW1vdmUgdGhlIGJzLWludmFsaWQgY2xhc3NcXHJcXG4gICAgICAgICAgICAgIGlmICh0aGlzLnZhbGlkaXR5LnZhbGlkKSB0aGF0LiRidXR0b25bMF0uY2xhc3NMaXN0LnJlbW92ZSgnYnMtaW52YWxpZCcpO1xcclxcbiAgICAgICAgICAgICAgdGhhdC4kZWxlbWVudC5vZmYoJ3JlbmRlcmVkJyArIEVWRU5UX0tFWSk7XFxyXFxuICAgICAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuJGJ1dHRvbi5vbignYmx1cicgKyBFVkVOVF9LRVksIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJykudHJpZ2dlcignYmx1cicpO1xcclxcbiAgICAgICAgICAgIHRoYXQuJGJ1dHRvbi5vZmYoJ2JsdXInICsgRVZFTlRfS0VZKTtcXHJcXG4gICAgICAgICAgfSk7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICB0aGF0LmJ1aWxkTGlzdCgpO1xcclxcbiAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdsb2FkZWQnICsgRVZFTlRfS0VZKTtcXHJcXG4gICAgICB9KTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgY3JlYXRlRHJvcGRvd246IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAvLyBPcHRpb25zXFxyXFxuICAgICAgLy8gSWYgd2UgYXJlIG11bHRpcGxlIG9yIHNob3dUaWNrIG9wdGlvbiBpcyBzZXQsIHRoZW4gYWRkIHRoZSBzaG93LXRpY2sgY2xhc3NcXHJcXG4gICAgICB2YXIgc2hvd1RpY2sgPSAodGhpcy5tdWx0aXBsZSB8fCB0aGlzLm9wdGlvbnMuc2hvd1RpY2spID8gJyBzaG93LXRpY2snIDogJycsXFxyXFxuICAgICAgICAgIG11bHRpc2VsZWN0YWJsZSA9IHRoaXMubXVsdGlwbGUgPyAnIGFyaWEtbXVsdGlzZWxlY3RhYmxlPVxcXCJ0cnVlXFxcIicgOiAnJyxcXHJcXG4gICAgICAgICAgaW5wdXRHcm91cCA9ICcnLFxcclxcbiAgICAgICAgICBhdXRvZm9jdXMgPSB0aGlzLmF1dG9mb2N1cyA/ICcgYXV0b2ZvY3VzJyA6ICcnO1xcclxcblxcclxcbiAgICAgIGlmICh2ZXJzaW9uLm1ham9yIDwgNCAmJiB0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKCdpbnB1dC1ncm91cCcpKSB7XFxyXFxuICAgICAgICBpbnB1dEdyb3VwID0gJyBpbnB1dC1ncm91cC1idG4nO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAvLyBFbGVtZW50c1xcclxcbiAgICAgIHZhciBkcm9wLFxcclxcbiAgICAgICAgICBoZWFkZXIgPSAnJyxcXHJcXG4gICAgICAgICAgc2VhcmNoYm94ID0gJycsXFxyXFxuICAgICAgICAgIGFjdGlvbnNib3ggPSAnJyxcXHJcXG4gICAgICAgICAgZG9uZWJ1dHRvbiA9ICcnO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVyKSB7XFxyXFxuICAgICAgICBoZWFkZXIgPVxcclxcbiAgICAgICAgICAnPGRpdiBjbGFzcz1cXFwiJyArIGNsYXNzTmFtZXMuUE9QT1ZFUkhFQURFUiArICdcXFwiPicgK1xcclxcbiAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+JnRpbWVzOzwvYnV0dG9uPicgK1xcclxcbiAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmhlYWRlciArXFxyXFxuICAgICAgICAgICc8L2Rpdj4nO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgIHNlYXJjaGJveCA9XFxyXFxuICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCJicy1zZWFyY2hib3hcXFwiPicgK1xcclxcbiAgICAgICAgICAgICc8aW5wdXQgdHlwZT1cXFwic2VhcmNoXFxcIiBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBhdXRvY29tcGxldGU9XFxcIm9mZlxcXCInICtcXHJcXG4gICAgICAgICAgICAgIChcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxpdmVTZWFyY2hQbGFjZWhvbGRlciA9PT0gbnVsbCA/ICcnXFxyXFxuICAgICAgICAgICAgICAgIDpcXHJcXG4gICAgICAgICAgICAgICAgJyBwbGFjZWhvbGRlcj1cXFwiJyArIGh0bWxFc2NhcGUodGhpcy5vcHRpb25zLmxpdmVTZWFyY2hQbGFjZWhvbGRlcikgKyAnXFxcIidcXHJcXG4gICAgICAgICAgICAgICkgK1xcclxcbiAgICAgICAgICAgICAgJyByb2xlPVxcXCJjb21ib2JveFxcXCIgYXJpYS1sYWJlbD1cXFwiU2VhcmNoXFxcIiBhcmlhLWNvbnRyb2xzPVxcXCInICsgdGhpcy5zZWxlY3RJZCArICdcXFwiIGFyaWEtYXV0b2NvbXBsZXRlPVxcXCJsaXN0XFxcIj4nICtcXHJcXG4gICAgICAgICAgJzwvZGl2Pic7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5hY3Rpb25zQm94KSB7XFxyXFxuICAgICAgICBhY3Rpb25zYm94ID1cXHJcXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImJzLWFjdGlvbnNib3hcXFwiPicgK1xcclxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXAgYnRuLWdyb3VwLXNtIGJ0bi1ibG9ja1xcXCI+JyArXFxyXFxuICAgICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJhY3Rpb25zLWJ0biBicy1zZWxlY3QtYWxsIGJ0biAnICsgY2xhc3NOYW1lcy5CVVRUT05DTEFTUyArICdcXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc2VsZWN0QWxsVGV4dCArXFxyXFxuICAgICAgICAgICAgICAnPC9idXR0b24+JyArXFxyXFxuICAgICAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJhY3Rpb25zLWJ0biBicy1kZXNlbGVjdC1hbGwgYnRuICcgKyBjbGFzc05hbWVzLkJVVFRPTkNMQVNTICsgJ1xcXCI+JyArXFxyXFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kZXNlbGVjdEFsbFRleHQgK1xcclxcbiAgICAgICAgICAgICAgJzwvYnV0dG9uPicgK1xcclxcbiAgICAgICAgICAgICc8L2Rpdj4nICtcXHJcXG4gICAgICAgICAgJzwvZGl2Pic7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5kb25lQnV0dG9uKSB7XFxyXFxuICAgICAgICBkb25lYnV0dG9uID1cXHJcXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImJzLWRvbmVidXR0b25cXFwiPicgK1xcclxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCJidG4tZ3JvdXAgYnRuLWJsb2NrXFxcIj4nICtcXHJcXG4gICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gJyArIGNsYXNzTmFtZXMuQlVUVE9OQ0xBU1MgKyAnXFxcIj4nICtcXHJcXG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRvbmVCdXR0b25UZXh0ICtcXHJcXG4gICAgICAgICAgICAgICc8L2J1dHRvbj4nICtcXHJcXG4gICAgICAgICAgICAnPC9kaXY+JyArXFxyXFxuICAgICAgICAgICc8L2Rpdj4nO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBkcm9wID1cXHJcXG4gICAgICAgICc8ZGl2IGNsYXNzPVxcXCJkcm9wZG93biBib290c3RyYXAtc2VsZWN0JyArIHNob3dUaWNrICsgaW5wdXRHcm91cCArICdcXFwiPicgK1xcclxcbiAgICAgICAgICAnPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIHRhYmluZGV4PVxcXCItMVxcXCIgY2xhc3M9XFxcIicgKyB0aGlzLm9wdGlvbnMuc3R5bGVCYXNlICsgJyBkcm9wZG93bi10b2dnbGVcXFwiICcgKyAodGhpcy5vcHRpb25zLmRpc3BsYXkgPT09ICdzdGF0aWMnID8gJ2RhdGEtZGlzcGxheT1cXFwic3RhdGljXFxcIicgOiAnJykgKyAnZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIicgKyBhdXRvZm9jdXMgKyAnIHJvbGU9XFxcImNvbWJvYm94XFxcIiBhcmlhLW93bnM9XFxcIicgKyB0aGlzLnNlbGVjdElkICsgJ1xcXCIgYXJpYS1oYXNwb3B1cD1cXFwibGlzdGJveFxcXCIgYXJpYS1leHBhbmRlZD1cXFwiZmFsc2VcXFwiPicgK1xcclxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCJmaWx0ZXItb3B0aW9uXFxcIj4nICtcXHJcXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCJmaWx0ZXItb3B0aW9uLWlubmVyXFxcIj4nICtcXHJcXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XFxcImZpbHRlci1vcHRpb24taW5uZXItaW5uZXJcXFwiPjwvZGl2PicgK1xcclxcbiAgICAgICAgICAgICAgJzwvZGl2PiAnICtcXHJcXG4gICAgICAgICAgICAnPC9kaXY+JyArXFxyXFxuICAgICAgICAgICAgKFxcclxcbiAgICAgICAgICAgICAgdmVyc2lvbi5tYWpvciA9PT0gJzQnID8gJydcXHJcXG4gICAgICAgICAgICAgIDpcXHJcXG4gICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cXFwiYnMtY2FyZXRcXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudGVtcGxhdGUuY2FyZXQgK1xcclxcbiAgICAgICAgICAgICAgJzwvc3Bhbj4nXFxyXFxuICAgICAgICAgICAgKSArXFxyXFxuICAgICAgICAgICc8L2J1dHRvbj4nICtcXHJcXG4gICAgICAgICAgJzxkaXYgY2xhc3M9XFxcIicgKyBjbGFzc05hbWVzLk1FTlUgKyAnICcgKyAodmVyc2lvbi5tYWpvciA9PT0gJzQnID8gJycgOiBjbGFzc05hbWVzLlNIT1cpICsgJ1xcXCI+JyArXFxyXFxuICAgICAgICAgICAgaGVhZGVyICtcXHJcXG4gICAgICAgICAgICBzZWFyY2hib3ggK1xcclxcbiAgICAgICAgICAgIGFjdGlvbnNib3ggK1xcclxcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVxcXCJpbm5lciAnICsgY2xhc3NOYW1lcy5TSE9XICsgJ1xcXCIgcm9sZT1cXFwibGlzdGJveFxcXCIgaWQ9XFxcIicgKyB0aGlzLnNlbGVjdElkICsgJ1xcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIiAnICsgbXVsdGlzZWxlY3RhYmxlICsgJz4nICtcXHJcXG4gICAgICAgICAgICAgICAgJzx1bCBjbGFzcz1cXFwiJyArIGNsYXNzTmFtZXMuTUVOVSArICcgaW5uZXIgJyArICh2ZXJzaW9uLm1ham9yID09PSAnNCcgPyBjbGFzc05hbWVzLlNIT1cgOiAnJykgKyAnXFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPicgK1xcclxcbiAgICAgICAgICAgICAgICAnPC91bD4nICtcXHJcXG4gICAgICAgICAgICAnPC9kaXY+JyArXFxyXFxuICAgICAgICAgICAgZG9uZWJ1dHRvbiArXFxyXFxuICAgICAgICAgICc8L2Rpdj4nICtcXHJcXG4gICAgICAgICc8L2Rpdj4nO1xcclxcblxcclxcbiAgICAgIHJldHVybiAkKGRyb3ApO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBzZXRQb3NpdGlvbkRhdGE6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodCA9IFtdO1xcclxcbiAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuc2l6ZSA9IDA7XFxyXFxuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4ID0gZmFsc2U7XFxyXFxuXFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgIHZhciBsaSA9IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpXSxcXHJcXG4gICAgICAgICAgICBjYW5IaWdobGlnaHQgPSB0cnVlO1xcclxcblxcclxcbiAgICAgICAgaWYgKGxpLnR5cGUgPT09ICdkaXZpZGVyJykge1xcclxcbiAgICAgICAgICBjYW5IaWdobGlnaHQgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgbGkuaGVpZ2h0ID0gdGhpcy5zaXplSW5mby5kaXZpZGVySGVpZ2h0O1xcclxcbiAgICAgICAgfSBlbHNlIGlmIChsaS50eXBlID09PSAnb3B0Z3JvdXAtbGFiZWwnKSB7XFxyXFxuICAgICAgICAgIGNhbkhpZ2hsaWdodCA9IGZhbHNlO1xcclxcbiAgICAgICAgICBsaS5oZWlnaHQgPSB0aGlzLnNpemVJbmZvLmRyb3Bkb3duSGVhZGVySGVpZ2h0O1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgbGkuaGVpZ2h0ID0gdGhpcy5zaXplSW5mby5saUhlaWdodDtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChsaS5kaXNhYmxlZCkgY2FuSGlnaGxpZ2h0ID0gZmFsc2U7XFxyXFxuXFxyXFxuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5wdXNoKGNhbkhpZ2hsaWdodCk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoY2FuSGlnaGxpZ2h0KSB7XFxyXFxuICAgICAgICAgIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuc2l6ZSsrO1xcclxcbiAgICAgICAgICBsaS5wb3NpbnNldCA9IHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuc2l6ZTtcXHJcXG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuZmlyc3RIaWdobGlnaHRJbmRleCA9PT0gZmFsc2UpIHRoaXMuc2VsZWN0cGlja2VyLnZpZXcuZmlyc3RIaWdobGlnaHRJbmRleCA9IGk7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBsaS5wb3NpdGlvbiA9IChpID09PSAwID8gMCA6IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpIC0gMV0ucG9zaXRpb24pICsgbGkuaGVpZ2h0O1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgaXNWaXJ0dWFsOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgcmV0dXJuICh0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbCAhPT0gZmFsc2UpICYmICh0aGlzLnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzLmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMudmlydHVhbFNjcm9sbCkgfHwgdGhpcy5vcHRpb25zLnZpcnR1YWxTY3JvbGwgPT09IHRydWU7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGNyZWF0ZVZpZXc6IGZ1bmN0aW9uIChpc1NlYXJjaGluZywgc2V0U2l6ZSwgcmVmcmVzaCkge1xcclxcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcXHJcXG4gICAgICAgICAgc2Nyb2xsVG9wID0gMCxcXHJcXG4gICAgICAgICAgYWN0aXZlID0gW10sXFxyXFxuICAgICAgICAgIHNlbGVjdGVkLFxcclxcbiAgICAgICAgICBwcmV2QWN0aXZlO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2VsZWN0cGlja2VyLmlzU2VhcmNoaW5nID0gaXNTZWFyY2hpbmc7XFxyXFxuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudCA9IGlzU2VhcmNoaW5nID8gdGhpcy5zZWxlY3RwaWNrZXIuc2VhcmNoIDogdGhpcy5zZWxlY3RwaWNrZXIubWFpbjtcXHJcXG5cXHJcXG4gICAgICB0aGlzLnNldFBvc2l0aW9uRGF0YSgpO1xcclxcblxcclxcbiAgICAgIGlmIChzZXRTaXplKSB7XFxyXFxuICAgICAgICBpZiAocmVmcmVzaCkge1xcclxcbiAgICAgICAgICBzY3JvbGxUb3AgPSB0aGlzLiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wO1xcclxcbiAgICAgICAgfSBlbHNlIGlmICghdGhhdC5tdWx0aXBsZSkge1xcclxcbiAgICAgICAgICB2YXIgZWxlbWVudCA9IHRoYXQuJGVsZW1lbnRbMF0sXFxyXFxuICAgICAgICAgICAgICBzZWxlY3RlZEluZGV4ID0gKGVsZW1lbnQub3B0aW9uc1tlbGVtZW50LnNlbGVjdGVkSW5kZXhdIHx8IHt9KS5saUluZGV4O1xcclxcblxcclxcbiAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdGVkSW5kZXggPT09ICdudW1iZXInICYmIHRoYXQub3B0aW9ucy5zaXplICE9PSBmYWxzZSkge1xcclxcbiAgICAgICAgICAgIHZhciBzZWxlY3RlZERhdGEgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmRhdGFbc2VsZWN0ZWRJbmRleF0sXFxyXFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gc2VsZWN0ZWREYXRhICYmIHNlbGVjdGVkRGF0YS5wb3NpdGlvbjtcXHJcXG5cXHJcXG4gICAgICAgICAgICBpZiAocG9zaXRpb24pIHtcXHJcXG4gICAgICAgICAgICAgIHNjcm9sbFRvcCA9IHBvc2l0aW9uIC0gKCh0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodCArIHRoYXQuc2l6ZUluZm8ubGlIZWlnaHQpIC8gMik7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHNjcm9sbChzY3JvbGxUb3AsIHRydWUpO1xcclxcblxcclxcbiAgICAgIHRoaXMuJG1lbnVJbm5lci5vZmYoJ3Njcm9sbC5jcmVhdGVWaWV3Jykub24oJ3Njcm9sbC5jcmVhdGVWaWV3JywgZnVuY3Rpb24gKGUsIHVwZGF0ZVZhbHVlKSB7XFxyXFxuICAgICAgICBpZiAoIXRoYXQubm9TY3JvbGwpIHNjcm9sbCh0aGlzLnNjcm9sbFRvcCwgdXBkYXRlVmFsdWUpO1xcclxcbiAgICAgICAgdGhhdC5ub1Njcm9sbCA9IGZhbHNlO1xcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIGZ1bmN0aW9uIHNjcm9sbCAoc2Nyb2xsVG9wLCBpbml0KSB7XFxyXFxuICAgICAgICB2YXIgc2l6ZSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMubGVuZ3RoLFxcclxcbiAgICAgICAgICAgIGNodW5rcyA9IFtdLFxcclxcbiAgICAgICAgICAgIGNodW5rU2l6ZSxcXHJcXG4gICAgICAgICAgICBjaHVua0NvdW50LFxcclxcbiAgICAgICAgICAgIGZpcnN0Q2h1bmssXFxyXFxuICAgICAgICAgICAgbGFzdENodW5rLFxcclxcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuayxcXHJcXG4gICAgICAgICAgICBwcmV2UG9zaXRpb25zLFxcclxcbiAgICAgICAgICAgIHBvc2l0aW9uSXNEaWZmZXJlbnQsXFxyXFxuICAgICAgICAgICAgcHJldmlvdXNFbGVtZW50cyxcXHJcXG4gICAgICAgICAgICBtZW51SXNEaWZmZXJlbnQgPSB0cnVlLFxcclxcbiAgICAgICAgICAgIGlzVmlydHVhbCA9IHRoYXQuaXNWaXJ0dWFsKCk7XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcXHJcXG5cXHJcXG4gICAgICAgIGNodW5rU2l6ZSA9IE1hdGguY2VpbCh0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodCAvIHRoYXQuc2l6ZUluZm8ubGlIZWlnaHQgKiAxLjUpOyAvLyBudW1iZXIgb2Ygb3B0aW9ucyBpbiBhIGNodW5rXFxyXFxuICAgICAgICBjaHVua0NvdW50ID0gTWF0aC5yb3VuZChzaXplIC8gY2h1bmtTaXplKSB8fCAxOyAvLyBudW1iZXIgb2YgY2h1bmtzXFxyXFxuXFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNodW5rQ291bnQ7IGkrKykge1xcclxcbiAgICAgICAgICB2YXIgZW5kT2ZDaHVuayA9IChpICsgMSkgKiBjaHVua1NpemU7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChpID09PSBjaHVua0NvdW50IC0gMSkge1xcclxcbiAgICAgICAgICAgIGVuZE9mQ2h1bmsgPSBzaXplO1xcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIGNodW5rc1tpXSA9IFtcXHJcXG4gICAgICAgICAgICAoaSkgKiBjaHVua1NpemUgKyAoIWkgPyAwIDogMSksXFxyXFxuICAgICAgICAgICAgZW5kT2ZDaHVua1xcclxcbiAgICAgICAgICBdO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoIXNpemUpIGJyZWFrO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoY3VycmVudENodW5rID09PSB1bmRlZmluZWQgJiYgc2Nyb2xsVG9wIC0gMSA8PSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbZW5kT2ZDaHVuayAtIDFdLnBvc2l0aW9uIC0gdGhhdC5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQpIHtcXHJcXG4gICAgICAgICAgICBjdXJyZW50Q2h1bmsgPSBpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAoY3VycmVudENodW5rID09PSB1bmRlZmluZWQpIGN1cnJlbnRDaHVuayA9IDA7XFxyXFxuXFxyXFxuICAgICAgICBwcmV2UG9zaXRpb25zID0gW3RoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wLCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMV07XFxyXFxuXFxyXFxuICAgICAgICAvLyBhbHdheXMgZGlzcGxheSBwcmV2aW91cywgY3VycmVudCwgYW5kIG5leHQgY2h1bmtzXFxyXFxuICAgICAgICBmaXJzdENodW5rID0gTWF0aC5tYXgoMCwgY3VycmVudENodW5rIC0gMSk7XFxyXFxuICAgICAgICBsYXN0Q2h1bmsgPSBNYXRoLm1pbihjaHVua0NvdW50IC0gMSwgY3VycmVudENodW5rICsgMSk7XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCA9IGlzVmlydHVhbCA9PT0gZmFsc2UgPyAwIDogKE1hdGgubWF4KDAsIGNodW5rc1tmaXJzdENodW5rXVswXSkgfHwgMCk7XFxyXFxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMSA9IGlzVmlydHVhbCA9PT0gZmFsc2UgPyBzaXplIDogKE1hdGgubWluKHNpemUsIGNodW5rc1tsYXN0Q2h1bmtdWzFdKSB8fCAwKTtcXHJcXG5cXHJcXG4gICAgICAgIHBvc2l0aW9uSXNEaWZmZXJlbnQgPSBwcmV2UG9zaXRpb25zWzBdICE9PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCB8fCBwcmV2UG9zaXRpb25zWzFdICE9PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMTtcXHJcXG5cXHJcXG4gICAgICAgIGlmICh0aGF0LmFjdGl2ZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcXHJcXG4gICAgICAgICAgcHJldkFjdGl2ZSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbdGhhdC5wcmV2QWN0aXZlSW5kZXhdO1xcclxcbiAgICAgICAgICBhY3RpdmUgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzW3RoYXQuYWN0aXZlSW5kZXhdO1xcclxcbiAgICAgICAgICBzZWxlY3RlZCA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbdGhhdC5zZWxlY3RlZEluZGV4XTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKGluaXQpIHtcXHJcXG4gICAgICAgICAgICBpZiAodGhhdC5hY3RpdmVJbmRleCAhPT0gdGhhdC5zZWxlY3RlZEluZGV4KSB7XFxyXFxuICAgICAgICAgICAgICB0aGF0LmRlZm9jdXNJdGVtKGFjdGl2ZSk7XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIHRoYXQuYWN0aXZlSW5kZXggPSB1bmRlZmluZWQ7XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKHRoYXQuYWN0aXZlSW5kZXggJiYgdGhhdC5hY3RpdmVJbmRleCAhPT0gdGhhdC5zZWxlY3RlZEluZGV4KSB7XFxyXFxuICAgICAgICAgICAgdGhhdC5kZWZvY3VzSXRlbShzZWxlY3RlZCk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmICh0aGF0LnByZXZBY3RpdmVJbmRleCAhPT0gdW5kZWZpbmVkICYmIHRoYXQucHJldkFjdGl2ZUluZGV4ICE9PSB0aGF0LmFjdGl2ZUluZGV4ICYmIHRoYXQucHJldkFjdGl2ZUluZGV4ICE9PSB0aGF0LnNlbGVjdGVkSW5kZXgpIHtcXHJcXG4gICAgICAgICAgdGhhdC5kZWZvY3VzSXRlbShwcmV2QWN0aXZlKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChpbml0IHx8IHBvc2l0aW9uSXNEaWZmZXJlbnQpIHtcXHJcXG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50cyA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzID8gdGhhdC5zZWxlY3RwaWNrZXIudmlldy52aXNpYmxlRWxlbWVudHMuc2xpY2UoKSA6IFtdO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoaXNWaXJ0dWFsID09PSBmYWxzZSkge1xcclxcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cztcXHJcXG4gICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cyA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMuc2xpY2UodGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAsIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24xKTtcXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICB0aGF0LnNldE9wdGlvblN0YXR1cygpO1xcclxcblxcclxcbiAgICAgICAgICAvLyBpZiBzZWFyY2hpbmcsIGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGUgbGlzdCBoYXMgYWN0dWFsbHkgYmVlbiB1cGRhdGVkIGJlZm9yZSB1cGRhdGluZyBET01cXHJcXG4gICAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyB1bm5lY2Vzc2FyeSByZXBhaW50c1xcclxcbiAgICAgICAgICBpZiAoaXNTZWFyY2hpbmcgfHwgKGlzVmlydHVhbCA9PT0gZmFsc2UgJiYgaW5pdCkpIG1lbnVJc0RpZmZlcmVudCA9ICFpc0VxdWFsKHByZXZpb3VzRWxlbWVudHMsIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzKTtcXHJcXG5cXHJcXG4gICAgICAgICAgLy8gaWYgdmlydHVhbCBzY3JvbGwgaXMgZGlzYWJsZWQgYW5kIG5vdCBzZWFyY2hpbmcsXFxyXFxuICAgICAgICAgIC8vIG1lbnUgc2hvdWxkIG5ldmVyIG5lZWQgdG8gYmUgdXBkYXRlZCBtb3JlIHRoYW4gb25jZVxcclxcbiAgICAgICAgICBpZiAoKGluaXQgfHwgaXNWaXJ0dWFsID09PSB0cnVlKSAmJiBtZW51SXNEaWZmZXJlbnQpIHtcXHJcXG4gICAgICAgICAgICB2YXIgbWVudUlubmVyID0gdGhhdC4kbWVudUlubmVyWzBdLFxcclxcbiAgICAgICAgICAgICAgICBtZW51RnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXFxyXFxuICAgICAgICAgICAgICAgIGVtcHR5TWVudSA9IG1lbnVJbm5lci5maXJzdENoaWxkLmNsb25lTm9kZShmYWxzZSksXFxyXFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcCxcXHJcXG4gICAgICAgICAgICAgICAgbWFyZ2luQm90dG9tLFxcclxcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzLFxcclxcbiAgICAgICAgICAgICAgICB0b1Nhbml0aXplID0gW107XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgZXhpc3RpbmcgVUwgd2l0aCBhbiBlbXB0eSBvbmUgLSB0aGlzIGlzIGZhc3RlciB0aGFuICQuZW1wdHkoKVxcclxcbiAgICAgICAgICAgIG1lbnVJbm5lci5yZXBsYWNlQ2hpbGQoZW1wdHlNZW51LCBtZW51SW5uZXIuZmlyc3RDaGlsZCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHZpc2libGVFbGVtZW50c0xlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IHZpc2libGVFbGVtZW50c0xlbjsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldLFxcclxcbiAgICAgICAgICAgICAgICAgIGVsVGV4dCxcXHJcXG4gICAgICAgICAgICAgICAgICBlbGVtZW50RGF0YTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuc2FuaXRpemUpIHtcXHJcXG4gICAgICAgICAgICAgICAgZWxUZXh0ID0gZWxlbWVudC5sYXN0Q2hpbGQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmIChlbFRleHQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICBlbGVtZW50RGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpICsgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjBdO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RGF0YSAmJiBlbGVtZW50RGF0YS5jb250ZW50ICYmICFlbGVtZW50RGF0YS5zYW5pdGl6ZWQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRvU2FuaXRpemUucHVzaChlbFRleHQpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudERhdGEuc2FuaXRpemVkID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgIG1lbnVGcmFnbWVudC5hcHBlbmRDaGlsZChlbGVtZW50KTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zYW5pdGl6ZSAmJiB0b1Nhbml0aXplLmxlbmd0aCkge1xcclxcbiAgICAgICAgICAgICAgc2FuaXRpemVIdG1sKHRvU2FuaXRpemUsIHRoYXQub3B0aW9ucy53aGl0ZUxpc3QsIHRoYXQub3B0aW9ucy5zYW5pdGl6ZUZuKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGlzVmlydHVhbCA9PT0gdHJ1ZSkge1xcclxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wID09PSAwID8gMCA6IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVt0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMCAtIDFdLnBvc2l0aW9uKTtcXHJcXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9ICh0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMSA+IHNpemUgLSAxID8gMCA6IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtzaXplIC0gMV0ucG9zaXRpb24gLSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjEgLSAxXS5wb3NpdGlvbik7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICBtZW51SW5uZXIuZmlyc3RDaGlsZC5zdHlsZS5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3AgKyAncHgnO1xcclxcbiAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWFyZ2luQm90dG9tID0gbWFyZ2luQm90dG9tICsgJ3B4JztcXHJcXG4gICAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWFyZ2luVG9wID0gMDtcXHJcXG4gICAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLnN0eWxlLm1hcmdpbkJvdHRvbSA9IDA7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLmFwcGVuZENoaWxkKG1lbnVGcmFnbWVudCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gaWYgYW4gb3B0aW9uIGlzIGVuY291bnRlcmVkIHRoYXQgaXMgd2lkZXIgdGhhbiB0aGUgY3VycmVudCBtZW51IHdpZHRoLCB1cGRhdGUgdGhlIG1lbnUgd2lkdGggYWNjb3JkaW5nbHlcXHJcXG4gICAgICAgICAgICAvLyBzd2l0Y2ggdG8gUmVzaXplT2JzZXJ2ZXIgd2l0aCBpbmNyZWFzZWQgYnJvd3NlciBzdXBwb3J0XFxyXFxuICAgICAgICAgICAgaWYgKGlzVmlydHVhbCA9PT0gdHJ1ZSAmJiB0aGF0LnNpemVJbmZvLmhhc1Njcm9sbEJhcikge1xcclxcbiAgICAgICAgICAgICAgdmFyIG1lbnVJbm5lcklubmVyV2lkdGggPSBtZW51SW5uZXIuZmlyc3RDaGlsZC5vZmZzZXRXaWR0aDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgIGlmIChpbml0ICYmIG1lbnVJbm5lcklubmVyV2lkdGggPCB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggJiYgdGhhdC5zaXplSW5mby50b3RhbE1lbnVXaWR0aCA+IHRoYXQuc2l6ZUluZm8uc2VsZWN0V2lkdGgpIHtcXHJcXG4gICAgICAgICAgICAgICAgbWVudUlubmVyLmZpcnN0Q2hpbGQuc3R5bGUubWluV2lkdGggPSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lcklubmVyV2lkdGggKyAncHgnO1xcclxcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZW51SW5uZXJJbm5lcldpZHRoID4gdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoKSB7XFxyXFxuICAgICAgICAgICAgICAgIC8vIHNldCB0byAwIHRvIGdldCBhY3R1YWwgd2lkdGggb2YgbWVudVxcclxcbiAgICAgICAgICAgICAgICB0aGF0LiRtZW51WzBdLnN0eWxlLm1pbldpZHRoID0gMDtcXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgdmFyIGFjdHVhbE1lbnVXaWR0aCA9IG1lbnVJbm5lci5maXJzdENoaWxkLm9mZnNldFdpZHRoO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsTWVudVdpZHRoID4gdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoID0gYWN0dWFsTWVudVdpZHRoO1xcclxcbiAgICAgICAgICAgICAgICAgIG1lbnVJbm5lci5maXJzdENoaWxkLnN0eWxlLm1pbldpZHRoID0gdGhhdC5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoICsgJ3B4JztcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAvLyByZXNldCB0byBkZWZhdWx0IENTUyBzdHlsaW5nXFxyXFxuICAgICAgICAgICAgICAgIHRoYXQuJG1lbnVbMF0uc3R5bGUubWluV2lkdGggPSAnJztcXHJcXG4gICAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHRoYXQucHJldkFjdGl2ZUluZGV4ID0gdGhhdC5hY3RpdmVJbmRleDtcXHJcXG5cXHJcXG4gICAgICAgIGlmICghdGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKGlzU2VhcmNoaW5nICYmIGluaXQpIHtcXHJcXG4gICAgICAgICAgdmFyIGluZGV4ID0gMCxcXHJcXG4gICAgICAgICAgICAgIG5ld0FjdGl2ZTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKCF0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodFtpbmRleF0pIHtcXHJcXG4gICAgICAgICAgICBpbmRleCA9IDEgKyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5zbGljZSgxKS5pbmRleE9mKHRydWUpO1xcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIG5ld0FjdGl2ZSA9IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzW2luZGV4XTtcXHJcXG5cXHJcXG4gICAgICAgICAgdGhhdC5kZWZvY3VzSXRlbSh0aGF0LnNlbGVjdHBpY2tlci52aWV3LmN1cnJlbnRBY3RpdmUpO1xcclxcblxcclxcbiAgICAgICAgICB0aGF0LmFjdGl2ZUluZGV4ID0gKHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpbmRleF0gfHwge30pLmluZGV4O1xcclxcblxcclxcbiAgICAgICAgICB0aGF0LmZvY3VzSXRlbShuZXdBY3RpdmUpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAkKHdpbmRvdylcXHJcXG4gICAgICAgIC5vZmYoJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5jcmVhdGVWaWV3JylcXHJcXG4gICAgICAgIC5vbigncmVzaXplJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnLmNyZWF0ZVZpZXcnLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgIHZhciBpc0FjdGl2ZSA9IHRoYXQuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKGlzQWN0aXZlKSBzY3JvbGwodGhhdC4kbWVudUlubmVyWzBdLnNjcm9sbFRvcCk7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgZm9jdXNJdGVtOiBmdW5jdGlvbiAobGksIGxpRGF0YSwgbm9TdHlsZSkge1xcclxcbiAgICAgIGlmIChsaSkge1xcclxcbiAgICAgICAgbGlEYXRhID0gbGlEYXRhIHx8IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YVt0aGlzLmFjdGl2ZUluZGV4XTtcXHJcXG4gICAgICAgIHZhciBhID0gbGkuZmlyc3RDaGlsZDtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChhKSB7XFxyXFxuICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdhcmlhLXNldHNpemUnLCB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnNpemUpO1xcclxcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnYXJpYS1wb3NpbnNldCcsIGxpRGF0YS5wb3NpbnNldCk7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChub1N0eWxlICE9PSB0cnVlKSB7XFxyXFxuICAgICAgICAgICAgdGhpcy5mb2N1c2VkUGFyZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgYS5pZCk7XFxyXFxuICAgICAgICAgICAgbGkuY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XFxyXFxuICAgICAgICAgICAgYS5jbGFzc0xpc3QuYWRkKCdhY3RpdmUnKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgZGVmb2N1c0l0ZW06IGZ1bmN0aW9uIChsaSkge1xcclxcbiAgICAgIGlmIChsaSkge1xcclxcbiAgICAgICAgbGkuY2xhc3NMaXN0LnJlbW92ZSgnYWN0aXZlJyk7XFxyXFxuICAgICAgICBpZiAobGkuZmlyc3RDaGlsZCkgbGkuZmlyc3RDaGlsZC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNldFBsYWNlaG9sZGVyOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICB1cGRhdGVJbmRleCA9IGZhbHNlO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGl0bGUgJiYgIXRoaXMubXVsdGlwbGUpIHtcXHJcXG4gICAgICAgIGlmICghdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbikgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xcclxcblxcclxcbiAgICAgICAgLy8gdGhpcyBvcHRpb24gZG9lc24ndCBjcmVhdGUgYSBuZXcgPGxpPiBlbGVtZW50LCBidXQgZG9lcyBhZGQgYSBuZXcgb3B0aW9uIGF0IHRoZSBzdGFydCxcXHJcXG4gICAgICAgIC8vIHNvIHN0YXJ0SW5kZXggc2hvdWxkIGluY3JlYXNlIHRvIHByZXZlbnQgaGF2aW5nIHRvIGNoZWNrIGV2ZXJ5IG9wdGlvbiBmb3IgdGhlIGJzLXRpdGxlLW9wdGlvbiBjbGFzc1xcclxcbiAgICAgICAgdXBkYXRlSW5kZXggPSB0cnVlO1xcclxcblxcclxcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLiRlbGVtZW50WzBdLFxcclxcbiAgICAgICAgICAgIHNlbGVjdFRpdGxlT3B0aW9uID0gZmFsc2UsXFxyXFxuICAgICAgICAgICAgdGl0bGVOb3RBcHBlbmRlZCA9ICF0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLnBhcmVudE5vZGUsXFxyXFxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCA9IGVsZW1lbnQuc2VsZWN0ZWRJbmRleCxcXHJcXG4gICAgICAgICAgICBzZWxlY3RlZE9wdGlvbiA9IGVsZW1lbnQub3B0aW9uc1tzZWxlY3RlZEluZGV4XSxcXHJcXG4gICAgICAgICAgICBuYXZpZ2F0aW9uID0gd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5nZXRFbnRyaWVzQnlUeXBlKCduYXZpZ2F0aW9uJyksXFxyXFxuICAgICAgICAgICAgLy8gU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBnZXRFbnRyaWVzQnlUeXBlKCduYXZpZ2F0aW9uJykgLSBmYWxsIGJhY2sgdG8gcGVyZm9ybWFuY2UubmF2aWdhdGlvblxcclxcbiAgICAgICAgICAgIGlzTm90QmFja0ZvcndhcmQgPSAobmF2aWdhdGlvbiAmJiBuYXZpZ2F0aW9uLmxlbmd0aCkgPyBuYXZpZ2F0aW9uWzBdLnR5cGUgIT09ICdiYWNrX2ZvcndhcmQnIDogd2luZG93LnBlcmZvcm1hbmNlLm5hdmlnYXRpb24udHlwZSAhPT0gMjtcXHJcXG5cXHJcXG4gICAgICAgIGlmICh0aXRsZU5vdEFwcGVuZGVkKSB7XFxyXFxuICAgICAgICAgIC8vIFVzZSBuYXRpdmUgSlMgdG8gcHJlcGVuZCBvcHRpb24gKGZhc3RlcilcXHJcXG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi5jbGFzc05hbWUgPSAnYnMtdGl0bGUtb3B0aW9uJztcXHJcXG4gICAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi52YWx1ZSA9ICcnO1xcclxcblxcclxcbiAgICAgICAgICAvLyBDaGVjayBpZiBzZWxlY3RlZCBvciBkYXRhLXNlbGVjdGVkIGF0dHJpYnV0ZSBpcyBhbHJlYWR5IHNldCBvbiBhbiBvcHRpb24uIElmIG5vdCwgc2VsZWN0IHRoZSB0aXRsZU9wdGlvbiBvcHRpb24uXFxyXFxuICAgICAgICAgIC8vIHRoZSBzZWxlY3RlZCBpdGVtIG1heSBoYXZlIGJlZW4gY2hhbmdlZCBieSB1c2VyIG9yIHByb2dyYW1tYXRpY2FsbHkgYmVmb3JlIHRoZSBib290c3RyYXAgc2VsZWN0IHBsdWdpbiBydW5zLFxcclxcbiAgICAgICAgICAvLyBpZiBzbywgdGhlIHNlbGVjdCB3aWxsIGhhdmUgdGhlIGRhdGEtc2VsZWN0ZWQgYXR0cmlidXRlXFxyXFxuICAgICAgICAgIHNlbGVjdFRpdGxlT3B0aW9uID0gIXNlbGVjdGVkT3B0aW9uIHx8IChzZWxlY3RlZEluZGV4ID09PSAwICYmIHNlbGVjdGVkT3B0aW9uLmRlZmF1bHRTZWxlY3RlZCA9PT0gZmFsc2UgJiYgdGhpcy4kZWxlbWVudC5kYXRhKCdzZWxlY3RlZCcpID09PSB1bmRlZmluZWQpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKHRpdGxlTm90QXBwZW5kZWQgfHwgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi5pbmRleCAhPT0gMCkge1xcclxcbiAgICAgICAgICBlbGVtZW50Lmluc2VydEJlZm9yZSh0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLCBlbGVtZW50LmZpcnN0Q2hpbGQpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gU2V0IHNlbGVjdGVkICphZnRlciogYXBwZW5kaW5nIHRvIHNlbGVjdCxcXHJcXG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgb3B0aW9uIGRvZXNuJ3QgZ2V0IHNlbGVjdGVkIGluIElFXFxyXFxuICAgICAgICAvLyBzZXQgdXNpbmcgc2VsZWN0ZWRJbmRleCwgYXMgc2V0dGluZyB0aGUgc2VsZWN0ZWQgYXR0ciB0byB0cnVlIGhlcmUgZG9lc24ndCB3b3JrIGluIElFMTFcXHJcXG4gICAgICAgIGlmIChzZWxlY3RUaXRsZU9wdGlvbiAmJiBpc05vdEJhY2tGb3J3YXJkKSB7XFxyXFxuICAgICAgICAgIGVsZW1lbnQuc2VsZWN0ZWRJbmRleCA9IDA7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpIHtcXHJcXG4gICAgICAgICAgLy8gaWYgbmF2aWdhdGlvbiB0eXBlIGlzIGJhY2tfZm9yd2FyZCwgdGhlcmUncyBhIGNoYW5jZSB0aGUgc2VsZWN0IHdpbGwgaGF2ZSBpdHMgdmFsdWUgc2V0IGJ5IEJGQ2FjaGVcXHJcXG4gICAgICAgICAgLy8gd2FpdCBmb3IgdGhhdCB2YWx1ZSB0byBiZSBzZXQsIHRoZW4gcnVuIHJlbmRlciBhZ2FpblxcclxcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncGFnZXNob3cnLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuZGlzcGxheWVkVmFsdWUgIT09IGVsZW1lbnQudmFsdWUpIHRoYXQucmVuZGVyKCk7XFxyXFxuICAgICAgICAgIH0pO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICByZXR1cm4gdXBkYXRlSW5kZXg7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGJ1aWxkRGF0YTogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHZhciBvcHRpb25TZWxlY3RvciA9ICc6bm90KFtoaWRkZW5dKTpub3QoW2RhdGEtaGlkZGVuPVxcXCJ0cnVlXFxcIl0pJyxcXHJcXG4gICAgICAgICAgbWFpbkRhdGEgPSBbXSxcXHJcXG4gICAgICAgICAgb3B0SUQgPSAwLFxcclxcbiAgICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5zZXRQbGFjZWhvbGRlcigpID8gMSA6IDA7IC8vIGFwcGVuZCB0aGUgdGl0bGVPcHRpb24gaWYgbmVjZXNzYXJ5IGFuZCBza2lwIHRoZSBmaXJzdCBvcHRpb24gaW4gdGhlIGxvb3BcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCkgb3B0aW9uU2VsZWN0b3IgKz0gJzpub3QoOmRpc2FibGVkKSc7XFxyXFxuXFxyXFxuICAgICAgdmFyIHNlbGVjdE9wdGlvbnMgPSB0aGlzLiRlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCA+IConICsgb3B0aW9uU2VsZWN0b3IpO1xcclxcblxcclxcbiAgICAgIGZ1bmN0aW9uIGFkZERpdmlkZXIgKGNvbmZpZykge1xcclxcbiAgICAgICAgdmFyIHByZXZpb3VzRGF0YSA9IG1haW5EYXRhW21haW5EYXRhLmxlbmd0aCAtIDFdO1xcclxcblxcclxcbiAgICAgICAgLy8gZW5zdXJlIG9wdGdyb3VwIGRvZXNuJ3QgY3JlYXRlIGJhY2stdG8tYmFjayBkaXZpZGVyc1xcclxcbiAgICAgICAgaWYgKFxcclxcbiAgICAgICAgICBwcmV2aW91c0RhdGEgJiZcXHJcXG4gICAgICAgICAgcHJldmlvdXNEYXRhLnR5cGUgPT09ICdkaXZpZGVyJyAmJlxcclxcbiAgICAgICAgICAocHJldmlvdXNEYXRhLm9wdElEIHx8IGNvbmZpZy5vcHRJRClcXHJcXG4gICAgICAgICkge1xcclxcbiAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBjb25maWcgPSBjb25maWcgfHwge307XFxyXFxuICAgICAgICBjb25maWcudHlwZSA9ICdkaXZpZGVyJztcXHJcXG5cXHJcXG4gICAgICAgIG1haW5EYXRhLnB1c2goY29uZmlnKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZnVuY3Rpb24gYWRkT3B0aW9uIChvcHRpb24sIGNvbmZpZykge1xcclxcbiAgICAgICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xcclxcblxcclxcbiAgICAgICAgY29uZmlnLmRpdmlkZXIgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCdkYXRhLWRpdmlkZXInKSA9PT0gJ3RydWUnO1xcclxcblxcclxcbiAgICAgICAgaWYgKGNvbmZpZy5kaXZpZGVyKSB7XFxyXFxuICAgICAgICAgIGFkZERpdmlkZXIoe1xcclxcbiAgICAgICAgICAgIG9wdElEOiBjb25maWcub3B0SURcXHJcXG4gICAgICAgICAgfSk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICB2YXIgbGlJbmRleCA9IG1haW5EYXRhLmxlbmd0aCxcXHJcXG4gICAgICAgICAgICAgIGNzc1RleHQgPSBvcHRpb24uc3R5bGUuY3NzVGV4dCxcXHJcXG4gICAgICAgICAgICAgIGlubGluZVN0eWxlID0gY3NzVGV4dCA/IGh0bWxFc2NhcGUoY3NzVGV4dCkgOiAnJyxcXHJcXG4gICAgICAgICAgICAgIG9wdGlvbkNsYXNzID0gKG9wdGlvbi5jbGFzc05hbWUgfHwgJycpICsgKGNvbmZpZy5vcHRncm91cENsYXNzIHx8ICcnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKGNvbmZpZy5vcHRJRCkgb3B0aW9uQ2xhc3MgPSAnb3B0ICcgKyBvcHRpb25DbGFzcztcXHJcXG5cXHJcXG4gICAgICAgICAgY29uZmlnLm9wdGlvbkNsYXNzID0gb3B0aW9uQ2xhc3MudHJpbSgpO1xcclxcbiAgICAgICAgICBjb25maWcuaW5saW5lU3R5bGUgPSBpbmxpbmVTdHlsZTtcXHJcXG4gICAgICAgICAgY29uZmlnLnRleHQgPSBvcHRpb24udGV4dENvbnRlbnQ7XFxyXFxuXFxyXFxuICAgICAgICAgIGNvbmZpZy5jb250ZW50ID0gb3B0aW9uLmdldEF0dHJpYnV0ZSgnZGF0YS1jb250ZW50Jyk7XFxyXFxuICAgICAgICAgIGNvbmZpZy50b2tlbnMgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCdkYXRhLXRva2VucycpO1xcclxcbiAgICAgICAgICBjb25maWcuc3VidGV4dCA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3VidGV4dCcpO1xcclxcbiAgICAgICAgICBjb25maWcuaWNvbiA9IG9wdGlvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWNvbicpO1xcclxcblxcclxcbiAgICAgICAgICBvcHRpb24ubGlJbmRleCA9IGxpSW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICAgIGNvbmZpZy5kaXNwbGF5ID0gY29uZmlnLmNvbnRlbnQgfHwgY29uZmlnLnRleHQ7XFxyXFxuICAgICAgICAgIGNvbmZpZy50eXBlID0gJ29wdGlvbic7XFxyXFxuICAgICAgICAgIGNvbmZpZy5pbmRleCA9IGxpSW5kZXg7XFxyXFxuICAgICAgICAgIGNvbmZpZy5vcHRpb24gPSBvcHRpb247XFxyXFxuICAgICAgICAgIGNvbmZpZy5zZWxlY3RlZCA9ICEhb3B0aW9uLnNlbGVjdGVkO1xcclxcbiAgICAgICAgICBjb25maWcuZGlzYWJsZWQgPSBjb25maWcuZGlzYWJsZWQgfHwgISFvcHRpb24uZGlzYWJsZWQ7XFxyXFxuXFxyXFxuICAgICAgICAgIG1haW5EYXRhLnB1c2goY29uZmlnKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZnVuY3Rpb24gYWRkT3B0Z3JvdXAgKGluZGV4LCBzZWxlY3RPcHRpb25zKSB7XFxyXFxuICAgICAgICB2YXIgb3B0Z3JvdXAgPSBzZWxlY3RPcHRpb25zW2luZGV4XSxcXHJcXG4gICAgICAgICAgICAvLyBza2lwIHBsYWNlaG9sZGVyIG9wdGlvblxcclxcbiAgICAgICAgICAgIHByZXZpb3VzID0gaW5kZXggLSAxIDwgc3RhcnRJbmRleCA/IGZhbHNlIDogc2VsZWN0T3B0aW9uc1tpbmRleCAtIDFdLFxcclxcbiAgICAgICAgICAgIG5leHQgPSBzZWxlY3RPcHRpb25zW2luZGV4ICsgMV0sXFxyXFxuICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbicgKyBvcHRpb25TZWxlY3Rvcik7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIW9wdGlvbnMubGVuZ3RoKSByZXR1cm47XFxyXFxuXFxyXFxuICAgICAgICB2YXIgY29uZmlnID0ge1xcclxcbiAgICAgICAgICAgICAgZGlzcGxheTogaHRtbEVzY2FwZShvcHRncm91cC5sYWJlbCksXFxyXFxuICAgICAgICAgICAgICBzdWJ0ZXh0OiBvcHRncm91cC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3VidGV4dCcpLFxcclxcbiAgICAgICAgICAgICAgaWNvbjogb3B0Z3JvdXAuZ2V0QXR0cmlidXRlKCdkYXRhLWljb24nKSxcXHJcXG4gICAgICAgICAgICAgIHR5cGU6ICdvcHRncm91cC1sYWJlbCcsXFxyXFxuICAgICAgICAgICAgICBvcHRncm91cENsYXNzOiAnICcgKyAob3B0Z3JvdXAuY2xhc3NOYW1lIHx8ICcnKVxcclxcbiAgICAgICAgICAgIH0sXFxyXFxuICAgICAgICAgICAgaGVhZGVySW5kZXgsXFxyXFxuICAgICAgICAgICAgbGFzdEluZGV4O1xcclxcblxcclxcbiAgICAgICAgb3B0SUQrKztcXHJcXG5cXHJcXG4gICAgICAgIGlmIChwcmV2aW91cykge1xcclxcbiAgICAgICAgICBhZGREaXZpZGVyKHsgb3B0SUQ6IG9wdElEIH0pO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgY29uZmlnLm9wdElEID0gb3B0SUQ7XFxyXFxuXFxyXFxuICAgICAgICBtYWluRGF0YS5wdXNoKGNvbmZpZyk7XFxyXFxuXFxyXFxuICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gb3B0aW9ucy5sZW5ndGg7IGogPCBsZW47IGorKykge1xcclxcbiAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1tqXTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKGogPT09IDApIHtcXHJcXG4gICAgICAgICAgICBoZWFkZXJJbmRleCA9IG1haW5EYXRhLmxlbmd0aCAtIDE7XFxyXFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gaGVhZGVySW5kZXggKyBsZW47XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgYWRkT3B0aW9uKG9wdGlvbiwge1xcclxcbiAgICAgICAgICAgIGhlYWRlckluZGV4OiBoZWFkZXJJbmRleCxcXHJcXG4gICAgICAgICAgICBsYXN0SW5kZXg6IGxhc3RJbmRleCxcXHJcXG4gICAgICAgICAgICBvcHRJRDogY29uZmlnLm9wdElELFxcclxcbiAgICAgICAgICAgIG9wdGdyb3VwQ2xhc3M6IGNvbmZpZy5vcHRncm91cENsYXNzLFxcclxcbiAgICAgICAgICAgIGRpc2FibGVkOiBvcHRncm91cC5kaXNhYmxlZFxcclxcbiAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmIChuZXh0KSB7XFxyXFxuICAgICAgICAgIGFkZERpdmlkZXIoeyBvcHRJRDogb3B0SUQgfSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGZvciAodmFyIGxlbiA9IHNlbGVjdE9wdGlvbnMubGVuZ3RoLCBpID0gc3RhcnRJbmRleDsgaSA8IGxlbjsgaSsrKSB7XFxyXFxuICAgICAgICB2YXIgaXRlbSA9IHNlbGVjdE9wdGlvbnNbaV07XFxyXFxuXFxyXFxuICAgICAgICBpZiAoaXRlbS50YWdOYW1lICE9PSAnT1BUR1JPVVAnKSB7XFxyXFxuICAgICAgICAgIGFkZE9wdGlvbihpdGVtLCB7fSk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICBhZGRPcHRncm91cChpLCBzZWxlY3RPcHRpb25zKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5kYXRhID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhID0gbWFpbkRhdGE7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGJ1aWxkTGlzdDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcXHJcXG4gICAgICAgICAgc2VsZWN0RGF0YSA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YSxcXHJcXG4gICAgICAgICAgbWFpbkVsZW1lbnRzID0gW10sXFxyXFxuICAgICAgICAgIHdpZGVzdE9wdGlvbkxlbmd0aCA9IDA7XFxyXFxuXFxyXFxuICAgICAgaWYgKCh0aGF0Lm9wdGlvbnMuc2hvd1RpY2sgfHwgdGhhdC5tdWx0aXBsZSkgJiYgIWVsZW1lbnRUZW1wbGF0ZXMuY2hlY2tNYXJrLnBhcmVudE5vZGUpIHtcXHJcXG4gICAgICAgIGVsZW1lbnRUZW1wbGF0ZXMuY2hlY2tNYXJrLmNsYXNzTmFtZSA9IHRoaXMub3B0aW9ucy5pY29uQmFzZSArICcgJyArIHRoYXQub3B0aW9ucy50aWNrSWNvbiArICcgY2hlY2stbWFyayc7XFxyXFxuICAgICAgICBlbGVtZW50VGVtcGxhdGVzLmEuYXBwZW5kQ2hpbGQoZWxlbWVudFRlbXBsYXRlcy5jaGVja01hcmspO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBmdW5jdGlvbiBidWlsZEVsZW1lbnQgKGl0ZW0pIHtcXHJcXG4gICAgICAgIHZhciBsaUVsZW1lbnQsXFxyXFxuICAgICAgICAgICAgY29tYmluZWRMZW5ndGggPSAwO1xcclxcblxcclxcbiAgICAgICAgc3dpdGNoIChpdGVtLnR5cGUpIHtcXHJcXG4gICAgICAgICAgY2FzZSAnZGl2aWRlcic6XFxyXFxuICAgICAgICAgICAgbGlFbGVtZW50ID0gZ2VuZXJhdGVPcHRpb24ubGkoXFxyXFxuICAgICAgICAgICAgICBmYWxzZSxcXHJcXG4gICAgICAgICAgICAgIGNsYXNzTmFtZXMuRElWSURFUixcXHJcXG4gICAgICAgICAgICAgIChpdGVtLm9wdElEID8gaXRlbS5vcHRJRCArICdkaXYnIDogdW5kZWZpbmVkKVxcclxcbiAgICAgICAgICAgICk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuXFxyXFxuICAgICAgICAgIGNhc2UgJ29wdGlvbic6XFxyXFxuICAgICAgICAgICAgbGlFbGVtZW50ID0gZ2VuZXJhdGVPcHRpb24ubGkoXFxyXFxuICAgICAgICAgICAgICBnZW5lcmF0ZU9wdGlvbi5hKFxcclxcbiAgICAgICAgICAgICAgICBnZW5lcmF0ZU9wdGlvbi50ZXh0LmNhbGwodGhhdCwgaXRlbSksXFxyXFxuICAgICAgICAgICAgICAgIGl0ZW0ub3B0aW9uQ2xhc3MsXFxyXFxuICAgICAgICAgICAgICAgIGl0ZW0uaW5saW5lU3R5bGVcXHJcXG4gICAgICAgICAgICAgICksXFxyXFxuICAgICAgICAgICAgICAnJyxcXHJcXG4gICAgICAgICAgICAgIGl0ZW0ub3B0SURcXHJcXG4gICAgICAgICAgICApO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChsaUVsZW1lbnQuZmlyc3RDaGlsZCkge1xcclxcbiAgICAgICAgICAgICAgbGlFbGVtZW50LmZpcnN0Q2hpbGQuaWQgPSB0aGF0LnNlbGVjdElkICsgJy0nICsgaXRlbS5pbmRleDtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuXFxyXFxuICAgICAgICAgIGNhc2UgJ29wdGdyb3VwLWxhYmVsJzpcXHJcXG4gICAgICAgICAgICBsaUVsZW1lbnQgPSBnZW5lcmF0ZU9wdGlvbi5saShcXHJcXG4gICAgICAgICAgICAgIGdlbmVyYXRlT3B0aW9uLmxhYmVsLmNhbGwodGhhdCwgaXRlbSksXFxyXFxuICAgICAgICAgICAgICAnZHJvcGRvd24taGVhZGVyJyArIGl0ZW0ub3B0Z3JvdXBDbGFzcyxcXHJcXG4gICAgICAgICAgICAgIGl0ZW0ub3B0SURcXHJcXG4gICAgICAgICAgICApO1xcclxcblxcclxcbiAgICAgICAgICAgIGJyZWFrO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaXRlbS5lbGVtZW50ID0gbGlFbGVtZW50O1xcclxcbiAgICAgICAgbWFpbkVsZW1lbnRzLnB1c2gobGlFbGVtZW50KTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIGNvdW50IHRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBpbiB0aGUgb3B0aW9uIC0gbm90IHBlcmZlY3QsIGJ1dCBzaG91bGQgd29yayBpbiBtb3N0IGNhc2VzXFxyXFxuICAgICAgICBpZiAoaXRlbS5kaXNwbGF5KSBjb21iaW5lZExlbmd0aCArPSBpdGVtLmRpc3BsYXkubGVuZ3RoO1xcclxcbiAgICAgICAgaWYgKGl0ZW0uc3VidGV4dCkgY29tYmluZWRMZW5ndGggKz0gaXRlbS5zdWJ0ZXh0Lmxlbmd0aDtcXHJcXG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGljb24sIGVuc3VyZSB0aGlzIG9wdGlvbidzIHdpZHRoIGlzIGNoZWNrZWRcXHJcXG4gICAgICAgIGlmIChpdGVtLmljb24pIGNvbWJpbmVkTGVuZ3RoICs9IDE7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoY29tYmluZWRMZW5ndGggPiB3aWRlc3RPcHRpb25MZW5ndGgpIHtcXHJcXG4gICAgICAgICAgd2lkZXN0T3B0aW9uTGVuZ3RoID0gY29tYmluZWRMZW5ndGg7XFxyXFxuXFxyXFxuICAgICAgICAgIC8vIGd1ZXNzIHdoaWNoIG9wdGlvbiBpcyB0aGUgd2lkZXN0XFxyXFxuICAgICAgICAgIC8vIHVzZSB0aGlzIHdoZW4gY2FsY3VsYXRpbmcgbWVudSB3aWR0aFxcclxcbiAgICAgICAgICAvLyBub3QgcGVyZmVjdCwgYnV0IGl0J3MgZmFzdCwgYW5kIHRoZSB3aWR0aCB3aWxsIGJlIHVwZGF0aW5nIGFjY29yZGluZ2x5IHdoZW4gc2Nyb2xsaW5nXFxyXFxuICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcud2lkZXN0T3B0aW9uID0gbWFpbkVsZW1lbnRzW21haW5FbGVtZW50cy5sZW5ndGggLSAxXTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZm9yICh2YXIgbGVuID0gc2VsZWN0RGF0YS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIHZhciBpdGVtID0gc2VsZWN0RGF0YVtpXTtcXHJcXG5cXHJcXG4gICAgICAgIGJ1aWxkRWxlbWVudChpdGVtKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50cyA9IHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMgPSBtYWluRWxlbWVudHM7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGZpbmRMaXM6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICByZXR1cm4gdGhpcy4kbWVudUlubmVyLmZpbmQoJy5pbm5lciA+IGxpJyk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHZhciB0aGF0ID0gdGhpcyxcXHJcXG4gICAgICAgICAgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnRbMF0sXFxyXFxuICAgICAgICAgIC8vIGVuc3VyZSB0aXRsZU9wdGlvbiBpcyBhcHBlbmRlZCBhbmQgc2VsZWN0ZWQgKGlmIG5lY2Vzc2FyeSkgYmVmb3JlIGdldHRpbmcgc2VsZWN0ZWRPcHRpb25zXFxyXFxuICAgICAgICAgIHBsYWNlaG9sZGVyU2VsZWN0ZWQgPSB0aGlzLnNldFBsYWNlaG9sZGVyKCkgJiYgZWxlbWVudC5zZWxlY3RlZEluZGV4ID09PSAwLFxcclxcbiAgICAgICAgICBzZWxlY3RlZE9wdGlvbnMgPSBnZXRTZWxlY3RlZE9wdGlvbnMoZWxlbWVudCwgdGhpcy5vcHRpb25zLmhpZGVEaXNhYmxlZCksXFxyXFxuICAgICAgICAgIHNlbGVjdGVkQ291bnQgPSBzZWxlY3RlZE9wdGlvbnMubGVuZ3RoLFxcclxcbiAgICAgICAgICBidXR0b24gPSB0aGlzLiRidXR0b25bMF0sXFxyXFxuICAgICAgICAgIGJ1dHRvbklubmVyID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoJy5maWx0ZXItb3B0aW9uLWlubmVyLWlubmVyJyksXFxyXFxuICAgICAgICAgIG11bHRpcGxlU2VwYXJhdG9yID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5vcHRpb25zLm11bHRpcGxlU2VwYXJhdG9yKSxcXHJcXG4gICAgICAgICAgdGl0bGVGcmFnbWVudCA9IGVsZW1lbnRUZW1wbGF0ZXMuZnJhZ21lbnQuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgc2hvd0NvdW50LFxcclxcbiAgICAgICAgICBjb3VudE1heCxcXHJcXG4gICAgICAgICAgaGFzQ29udGVudCA9IGZhbHNlO1xcclxcblxcclxcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QudG9nZ2xlKCdicy1wbGFjZWhvbGRlcicsIHRoYXQubXVsdGlwbGUgPyAhc2VsZWN0ZWRDb3VudCA6ICFnZXRTZWxlY3RWYWx1ZXMoZWxlbWVudCwgc2VsZWN0ZWRPcHRpb25zKSk7XFxyXFxuXFxyXFxuICAgICAgaWYgKCF0aGF0Lm11bHRpcGxlICYmIHNlbGVjdGVkT3B0aW9ucy5sZW5ndGggPT09IDEpIHtcXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuZGlzcGxheWVkVmFsdWUgPSBnZXRTZWxlY3RWYWx1ZXMoZWxlbWVudCwgc2VsZWN0ZWRPcHRpb25zKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQgPT09ICdzdGF0aWMnKSB7XFxyXFxuICAgICAgICB0aXRsZUZyYWdtZW50ID0gZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHsgdGV4dDogdGhpcy5vcHRpb25zLnRpdGxlIH0sIHRydWUpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICBzaG93Q291bnQgPSB0aGlzLm11bHRpcGxlICYmIHRoaXMub3B0aW9ucy5zZWxlY3RlZFRleHRGb3JtYXQuaW5kZXhPZignY291bnQnKSAhPT0gLTEgJiYgc2VsZWN0ZWRDb3VudCA+IDE7XFxyXFxuXFxyXFxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgdGhlIG51bWJlciBvZiBzZWxlY3RlZCBvcHRpb25zIHdpbGwgYmUgc2hvd24gKHNob3dDb3VudCA9PT0gdHJ1ZSlcXHJcXG4gICAgICAgIGlmIChzaG93Q291bnQpIHtcXHJcXG4gICAgICAgICAgY291bnRNYXggPSB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRUZXh0Rm9ybWF0LnNwbGl0KCc+Jyk7XFxyXFxuICAgICAgICAgIHNob3dDb3VudCA9IChjb3VudE1heC5sZW5ndGggPiAxICYmIHNlbGVjdGVkQ291bnQgPiBjb3VudE1heFsxXSkgfHwgKGNvdW50TWF4Lmxlbmd0aCA9PT0gMSAmJiBzZWxlY3RlZENvdW50ID49IDIpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgLy8gb25seSBsb29wIHRocm91Z2ggYWxsIHNlbGVjdGVkIG9wdGlvbnMgaWYgdGhlIGNvdW50IHdvbid0IGJlIHNob3duXFxyXFxuICAgICAgICBpZiAoc2hvd0NvdW50ID09PSBmYWxzZSkge1xcclxcbiAgICAgICAgICBpZiAoIXBsYWNlaG9sZGVyU2VsZWN0ZWQpIHtcXHJcXG4gICAgICAgICAgICBmb3IgKHZhciBzZWxlY3RlZEluZGV4ID0gMDsgc2VsZWN0ZWRJbmRleCA8IHNlbGVjdGVkQ291bnQ7IHNlbGVjdGVkSW5kZXgrKykge1xcclxcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggPCA1MCkge1xcclxcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zW3NlbGVjdGVkSW5kZXhdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgdGhpc0RhdGEgPSB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmRhdGFbb3B0aW9uLmxpSW5kZXhdLFxcclxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGVPcHRpb25zID0ge307XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm11bHRpcGxlICYmIHNlbGVjdGVkSW5kZXggPiAwKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgdGl0bGVGcmFnbWVudC5hcHBlbmRDaGlsZChtdWx0aXBsZVNlcGFyYXRvci5jbG9uZU5vZGUoZmFsc2UpKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uLnRpdGxlKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgdGl0bGVPcHRpb25zLnRleHQgPSBvcHRpb24udGl0bGU7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpc0RhdGEpIHtcXHJcXG4gICAgICAgICAgICAgICAgICBpZiAodGhpc0RhdGEuY29udGVudCAmJiB0aGF0Lm9wdGlvbnMuc2hvd0NvbnRlbnQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlT3B0aW9ucy5jb250ZW50ID0gdGhpc0RhdGEuY29udGVudC50b1N0cmluZygpO1xcclxcbiAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudCA9IHRydWU7XFxyXFxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuc2hvd0ljb24pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgdGl0bGVPcHRpb25zLmljb24gPSB0aGlzRGF0YS5pY29uO1xcclxcbiAgICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5zaG93U3VidGV4dCAmJiAhdGhhdC5tdWx0aXBsZSAmJiB0aGlzRGF0YS5zdWJ0ZXh0KSB0aXRsZU9wdGlvbnMuc3VidGV4dCA9ICcgJyArIHRoaXNEYXRhLnN1YnRleHQ7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aXRsZU9wdGlvbnMudGV4dCA9IG9wdGlvbi50ZXh0Q29udGVudC50cmltKCk7XFxyXFxuICAgICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgIHRpdGxlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHRpdGxlT3B0aW9ucywgdHJ1ZSkpO1xcclxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgICAgICB9XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIC8vIGFkZCBlbGxpcHNpc1xcclxcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZENvdW50ID4gNDkpIHtcXHJcXG4gICAgICAgICAgICAgIHRpdGxlRnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy4uLicpKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHZhciBvcHRpb25TZWxlY3RvciA9ICc6bm90KFtoaWRkZW5dKTpub3QoW2RhdGEtaGlkZGVuPVxcXCJ0cnVlXFxcIl0pOm5vdChbZGF0YS1kaXZpZGVyPVxcXCJ0cnVlXFxcIl0pJztcXHJcXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWRlRGlzYWJsZWQpIG9wdGlvblNlbGVjdG9yICs9ICc6bm90KDpkaXNhYmxlZCknO1xcclxcblxcclxcbiAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbXVsdGlzZWxlY3QsIGFuZCBzZWxlY3RlZFRleHRGb3JtYXQgaXMgY291bnQsIHRoZW4gc2hvdyAxIG9mIDIgc2VsZWN0ZWQsIGV0Yy5cXHJcXG4gICAgICAgICAgdmFyIHRvdGFsQ291bnQgPSB0aGlzLiRlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJ3NlbGVjdCA+IG9wdGlvbicgKyBvcHRpb25TZWxlY3RvciArICcsIG9wdGdyb3VwJyArIG9wdGlvblNlbGVjdG9yICsgJyBvcHRpb24nICsgb3B0aW9uU2VsZWN0b3IpLmxlbmd0aCxcXHJcXG4gICAgICAgICAgICAgIHRyOG5UZXh0ID0gKHR5cGVvZiB0aGlzLm9wdGlvbnMuY291bnRTZWxlY3RlZFRleHQgPT09ICdmdW5jdGlvbicpID8gdGhpcy5vcHRpb25zLmNvdW50U2VsZWN0ZWRUZXh0KHNlbGVjdGVkQ291bnQsIHRvdGFsQ291bnQpIDogdGhpcy5vcHRpb25zLmNvdW50U2VsZWN0ZWRUZXh0O1xcclxcblxcclxcbiAgICAgICAgICB0aXRsZUZyYWdtZW50ID0gZ2VuZXJhdGVPcHRpb24udGV4dC5jYWxsKHRoaXMsIHtcXHJcXG4gICAgICAgICAgICB0ZXh0OiB0cjhuVGV4dC5yZXBsYWNlKCd7MH0nLCBzZWxlY3RlZENvdW50LnRvU3RyaW5nKCkpLnJlcGxhY2UoJ3sxfScsIHRvdGFsQ291bnQudG9TdHJpbmcoKSlcXHJcXG4gICAgICAgICAgfSwgdHJ1ZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGl0bGUgPT0gdW5kZWZpbmVkKSB7XFxyXFxuICAgICAgICAvLyB1c2UgLmF0dHIgdG8gZW5zdXJlIHVuZGVmaW5lZCBpcyByZXR1cm5lZCBpZiB0aXRsZSBhdHRyaWJ1dGUgaXMgbm90IHNldFxcclxcbiAgICAgICAgdGhpcy5vcHRpb25zLnRpdGxlID0gdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAvLyBJZiB0aGUgc2VsZWN0IGRvZXNuJ3QgaGF2ZSBhIHRpdGxlLCB0aGVuIHVzZSB0aGUgZGVmYXVsdCwgb3IgaWYgbm90aGluZyBpcyBzZXQgYXQgYWxsLCB1c2Ugbm9uZVNlbGVjdGVkVGV4dFxcclxcbiAgICAgIGlmICghdGl0bGVGcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCkge1xcclxcbiAgICAgICAgdGl0bGVGcmFnbWVudCA9IGdlbmVyYXRlT3B0aW9uLnRleHQuY2FsbCh0aGlzLCB7XFxyXFxuICAgICAgICAgIHRleHQ6IHR5cGVvZiB0aGlzLm9wdGlvbnMudGl0bGUgIT09ICd1bmRlZmluZWQnID8gdGhpcy5vcHRpb25zLnRpdGxlIDogdGhpcy5vcHRpb25zLm5vbmVTZWxlY3RlZFRleHRcXHJcXG4gICAgICAgIH0sIHRydWUpO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAvLyBzdHJpcCBhbGwgSFRNTCB0YWdzIGFuZCB0cmltIHRoZSByZXN1bHQsIHRoZW4gdW5lc2NhcGUgYW55IGVzY2FwZWQgdGFnc1xcclxcbiAgICAgIGJ1dHRvbi50aXRsZSA9IHRpdGxlRnJhZ21lbnQudGV4dENvbnRlbnQucmVwbGFjZSgvPFtePl0qPj8vZywgJycpLnRyaW0oKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnNhbml0aXplICYmIGhhc0NvbnRlbnQpIHtcXHJcXG4gICAgICAgIHNhbml0aXplSHRtbChbdGl0bGVGcmFnbWVudF0sIHRoYXQub3B0aW9ucy53aGl0ZUxpc3QsIHRoYXQub3B0aW9ucy5zYW5pdGl6ZUZuKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgYnV0dG9uSW5uZXIuaW5uZXJIVE1MID0gJyc7XFxyXFxuICAgICAgYnV0dG9uSW5uZXIuYXBwZW5kQ2hpbGQodGl0bGVGcmFnbWVudCk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPCA0ICYmIHRoaXMuJG5ld0VsZW1lbnRbMF0uY2xhc3NMaXN0LmNvbnRhaW5zKCdiczMtaGFzLWFkZG9uJykpIHtcXHJcXG4gICAgICAgIHZhciBmaWx0ZXJFeHBhbmQgPSBidXR0b24ucXVlcnlTZWxlY3RvcignLmZpbHRlci1leHBhbmQnKSxcXHJcXG4gICAgICAgICAgICBjbG9uZSA9IGJ1dHRvbklubmVyLmNsb25lTm9kZSh0cnVlKTtcXHJcXG5cXHJcXG4gICAgICAgIGNsb25lLmNsYXNzTmFtZSA9ICdmaWx0ZXItZXhwYW5kJztcXHJcXG5cXHJcXG4gICAgICAgIGlmIChmaWx0ZXJFeHBhbmQpIHtcXHJcXG4gICAgICAgICAgYnV0dG9uLnJlcGxhY2VDaGlsZChjbG9uZSwgZmlsdGVyRXhwYW5kKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIGJ1dHRvbi5hcHBlbmRDaGlsZChjbG9uZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncmVuZGVyZWQnICsgRVZFTlRfS0VZKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgLyoqXFxyXFxuICAgICAqIEBwYXJhbSBbc3R5bGVdXFxyXFxuICAgICAqIEBwYXJhbSBbc3RhdHVzXVxcclxcbiAgICAgKi9cXHJcXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uIChuZXdTdHlsZSwgc3RhdHVzKSB7XFxyXFxuICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuJGJ1dHRvblswXSxcXHJcXG4gICAgICAgICAgbmV3RWxlbWVudCA9IHRoaXMuJG5ld0VsZW1lbnRbMF0sXFxyXFxuICAgICAgICAgIHN0eWxlID0gdGhpcy5vcHRpb25zLnN0eWxlLnRyaW0oKSxcXHJcXG4gICAgICAgICAgYnV0dG9uQ2xhc3M7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKSkge1xcclxcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5hZGRDbGFzcyh0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZSgvc2VsZWN0cGlja2VyfG1vYmlsZS1kZXZpY2V8YnMtc2VsZWN0LWhpZGRlbnx2YWxpZGF0ZVxcXFxbLipcXFxcXS9naSwgJycpKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPCA0KSB7XFxyXFxuICAgICAgICBuZXdFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2JzMycpO1xcclxcblxcclxcbiAgICAgICAgaWYgKG5ld0VsZW1lbnQucGFyZW50Tm9kZS5jbGFzc0xpc3QgJiYgbmV3RWxlbWVudC5wYXJlbnROb2RlLmNsYXNzTGlzdC5jb250YWlucygnaW5wdXQtZ3JvdXAnKSAmJlxcclxcbiAgICAgICAgICAgIChuZXdFbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmcgfHwgbmV3RWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpICYmXFxyXFxuICAgICAgICAgICAgKG5ld0VsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZyB8fCBuZXdFbGVtZW50Lm5leHRFbGVtZW50U2libGluZykuY2xhc3NMaXN0LmNvbnRhaW5zKCdpbnB1dC1ncm91cC1hZGRvbicpXFxyXFxuICAgICAgICApIHtcXHJcXG4gICAgICAgICAgbmV3RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdiczMtaGFzLWFkZG9uJyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmIChuZXdTdHlsZSkge1xcclxcbiAgICAgICAgYnV0dG9uQ2xhc3MgPSBuZXdTdHlsZS50cmltKCk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGJ1dHRvbkNsYXNzID0gc3R5bGU7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmIChzdGF0dXMgPT0gJ2FkZCcpIHtcXHJcXG4gICAgICAgIGlmIChidXR0b25DbGFzcykgYnV0dG9uLmNsYXNzTGlzdC5hZGQuYXBwbHkoYnV0dG9uLmNsYXNzTGlzdCwgYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSk7XFxyXFxuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT0gJ3JlbW92ZScpIHtcXHJcXG4gICAgICAgIGlmIChidXR0b25DbGFzcykgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUuYXBwbHkoYnV0dG9uLmNsYXNzTGlzdCwgYnV0dG9uQ2xhc3Muc3BsaXQoJyAnKSk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGlmIChzdHlsZSkgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUuYXBwbHkoYnV0dG9uLmNsYXNzTGlzdCwgc3R5bGUuc3BsaXQoJyAnKSk7XFxyXFxuICAgICAgICBpZiAoYnV0dG9uQ2xhc3MpIGJ1dHRvbi5jbGFzc0xpc3QuYWRkLmFwcGx5KGJ1dHRvbi5jbGFzc0xpc3QsIGJ1dHRvbkNsYXNzLnNwbGl0KCcgJykpO1xcclxcbiAgICAgIH1cXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgbGlIZWlnaHQ6IGZ1bmN0aW9uIChyZWZyZXNoKSB7XFxyXFxuICAgICAgaWYgKCFyZWZyZXNoICYmICh0aGlzLm9wdGlvbnMuc2l6ZSA9PT0gZmFsc2UgfHwgT2JqZWN0LmtleXModGhpcy5zaXplSW5mbykubGVuZ3RoKSkgcmV0dXJuO1xcclxcblxcclxcbiAgICAgIHZhciBuZXdFbGVtZW50ID0gZWxlbWVudFRlbXBsYXRlcy5kaXYuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgbWVudSA9IGVsZW1lbnRUZW1wbGF0ZXMuZGl2LmNsb25lTm9kZShmYWxzZSksXFxyXFxuICAgICAgICAgIG1lbnVJbm5lciA9IGVsZW1lbnRUZW1wbGF0ZXMuZGl2LmNsb25lTm9kZShmYWxzZSksXFxyXFxuICAgICAgICAgIG1lbnVJbm5lcklubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSxcXHJcXG4gICAgICAgICAgZGl2aWRlciA9IGVsZW1lbnRUZW1wbGF0ZXMubGkuY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgZHJvcGRvd25IZWFkZXIgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSksXFxyXFxuICAgICAgICAgIGxpLFxcclxcbiAgICAgICAgICBhID0gZWxlbWVudFRlbXBsYXRlcy5hLmNsb25lTm9kZShmYWxzZSksXFxyXFxuICAgICAgICAgIHRleHQgPSBlbGVtZW50VGVtcGxhdGVzLnNwYW4uY2xvbmVOb2RlKGZhbHNlKSxcXHJcXG4gICAgICAgICAgaGVhZGVyID0gdGhpcy5vcHRpb25zLmhlYWRlciAmJiB0aGlzLiRtZW51LmZpbmQoJy4nICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSKS5sZW5ndGggPiAwID8gdGhpcy4kbWVudS5maW5kKCcuJyArIGNsYXNzTmFtZXMuUE9QT1ZFUkhFQURFUilbMF0uY2xvbmVOb2RlKHRydWUpIDogbnVsbCxcXHJcXG4gICAgICAgICAgc2VhcmNoID0gdGhpcy5vcHRpb25zLmxpdmVTZWFyY2ggPyBlbGVtZW50VGVtcGxhdGVzLmRpdi5jbG9uZU5vZGUoZmFsc2UpIDogbnVsbCxcXHJcXG4gICAgICAgICAgYWN0aW9ucyA9IHRoaXMub3B0aW9ucy5hY3Rpb25zQm94ICYmIHRoaXMubXVsdGlwbGUgJiYgdGhpcy4kbWVudS5maW5kKCcuYnMtYWN0aW9uc2JveCcpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoJy5icy1hY3Rpb25zYm94JylbMF0uY2xvbmVOb2RlKHRydWUpIDogbnVsbCxcXHJcXG4gICAgICAgICAgZG9uZUJ1dHRvbiA9IHRoaXMub3B0aW9ucy5kb25lQnV0dG9uICYmIHRoaXMubXVsdGlwbGUgJiYgdGhpcy4kbWVudS5maW5kKCcuYnMtZG9uZWJ1dHRvbicpLmxlbmd0aCA+IDAgPyB0aGlzLiRtZW51LmZpbmQoJy5icy1kb25lYnV0dG9uJylbMF0uY2xvbmVOb2RlKHRydWUpIDogbnVsbCxcXHJcXG4gICAgICAgICAgZmlyc3RPcHRpb24gPSB0aGlzLiRlbGVtZW50LmZpbmQoJ29wdGlvbicpWzBdO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2VsZWN0V2lkdGggPSB0aGlzLiRuZXdFbGVtZW50WzBdLm9mZnNldFdpZHRoO1xcclxcblxcclxcbiAgICAgIHRleHQuY2xhc3NOYW1lID0gJ3RleHQnO1xcclxcbiAgICAgIGEuY2xhc3NOYW1lID0gJ2Ryb3Bkb3duLWl0ZW0gJyArIChmaXJzdE9wdGlvbiA/IGZpcnN0T3B0aW9uLmNsYXNzTmFtZSA6ICcnKTtcXHJcXG4gICAgICBuZXdFbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuJG1lbnVbMF0ucGFyZW50Tm9kZS5jbGFzc05hbWUgKyAnICcgKyBjbGFzc05hbWVzLlNIT1c7XFxyXFxuICAgICAgbmV3RWxlbWVudC5zdHlsZS53aWR0aCA9IDA7IC8vIGVuc3VyZSBidXR0b24gd2lkdGggZG9lc24ndCBhZmZlY3QgbmF0dXJhbCB3aWR0aCBvZiBtZW51IHdoZW4gY2FsY3VsYXRpbmdcXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLndpZHRoID09PSAnYXV0bycpIG1lbnUuc3R5bGUubWluV2lkdGggPSAwO1xcclxcbiAgICAgIG1lbnUuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5NRU5VICsgJyAnICsgY2xhc3NOYW1lcy5TSE9XO1xcclxcbiAgICAgIG1lbnVJbm5lci5jbGFzc05hbWUgPSAnaW5uZXIgJyArIGNsYXNzTmFtZXMuU0hPVztcXHJcXG4gICAgICBtZW51SW5uZXJJbm5lci5jbGFzc05hbWUgPSBjbGFzc05hbWVzLk1FTlUgKyAnIGlubmVyICcgKyAodmVyc2lvbi5tYWpvciA9PT0gJzQnID8gY2xhc3NOYW1lcy5TSE9XIDogJycpO1xcclxcbiAgICAgIGRpdmlkZXIuY2xhc3NOYW1lID0gY2xhc3NOYW1lcy5ESVZJREVSO1xcclxcbiAgICAgIGRyb3Bkb3duSGVhZGVyLmNsYXNzTmFtZSA9ICdkcm9wZG93bi1oZWFkZXInO1xcclxcblxcclxcbiAgICAgIHRleHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcXFx1MjAwYicpKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhLmxlbmd0aCkge1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbaV07XFxyXFxuICAgICAgICAgIGlmIChkYXRhLnR5cGUgPT09ICdvcHRpb24nKSB7XFxyXFxuICAgICAgICAgICAgbGkgPSBkYXRhLmVsZW1lbnQ7XFxyXFxuICAgICAgICAgICAgYnJlYWs7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgbGkgPSBlbGVtZW50VGVtcGxhdGVzLmxpLmNsb25lTm9kZShmYWxzZSk7XFxyXFxuICAgICAgICBhLmFwcGVuZENoaWxkKHRleHQpO1xcclxcbiAgICAgICAgbGkuYXBwZW5kQ2hpbGQoYSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGRyb3Bkb3duSGVhZGVyLmFwcGVuZENoaWxkKHRleHQuY2xvbmVOb2RlKHRydWUpKTtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5zZWxlY3RwaWNrZXIudmlldy53aWRlc3RPcHRpb24pIHtcXHJcXG4gICAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcud2lkZXN0T3B0aW9uLmNsb25lTm9kZSh0cnVlKSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIG1lbnVJbm5lcklubmVyLmFwcGVuZENoaWxkKGxpKTtcXHJcXG4gICAgICBtZW51SW5uZXJJbm5lci5hcHBlbmRDaGlsZChkaXZpZGVyKTtcXHJcXG4gICAgICBtZW51SW5uZXJJbm5lci5hcHBlbmRDaGlsZChkcm9wZG93bkhlYWRlcik7XFxyXFxuICAgICAgaWYgKGhlYWRlcikgbWVudS5hcHBlbmRDaGlsZChoZWFkZXIpO1xcclxcbiAgICAgIGlmIChzZWFyY2gpIHtcXHJcXG4gICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XFxyXFxuICAgICAgICBzZWFyY2guY2xhc3NOYW1lID0gJ2JzLXNlYXJjaGJveCc7XFxyXFxuICAgICAgICBpbnB1dC5jbGFzc05hbWUgPSAnZm9ybS1jb250cm9sJztcXHJcXG4gICAgICAgIHNlYXJjaC5hcHBlbmRDaGlsZChpbnB1dCk7XFxyXFxuICAgICAgICBtZW51LmFwcGVuZENoaWxkKHNlYXJjaCk7XFxyXFxuICAgICAgfVxcclxcbiAgICAgIGlmIChhY3Rpb25zKSBtZW51LmFwcGVuZENoaWxkKGFjdGlvbnMpO1xcclxcbiAgICAgIG1lbnVJbm5lci5hcHBlbmRDaGlsZChtZW51SW5uZXJJbm5lcik7XFxyXFxuICAgICAgbWVudS5hcHBlbmRDaGlsZChtZW51SW5uZXIpO1xcclxcbiAgICAgIGlmIChkb25lQnV0dG9uKSBtZW51LmFwcGVuZENoaWxkKGRvbmVCdXR0b24pO1xcclxcbiAgICAgIG5ld0VsZW1lbnQuYXBwZW5kQ2hpbGQobWVudSk7XFxyXFxuXFxyXFxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcXHJcXG5cXHJcXG4gICAgICB2YXIgbGlIZWlnaHQgPSBsaS5vZmZzZXRIZWlnaHQsXFxyXFxuICAgICAgICAgIGRyb3Bkb3duSGVhZGVySGVpZ2h0ID0gZHJvcGRvd25IZWFkZXIgPyBkcm9wZG93bkhlYWRlci5vZmZzZXRIZWlnaHQgOiAwLFxcclxcbiAgICAgICAgICBoZWFkZXJIZWlnaHQgPSBoZWFkZXIgPyBoZWFkZXIub2Zmc2V0SGVpZ2h0IDogMCxcXHJcXG4gICAgICAgICAgc2VhcmNoSGVpZ2h0ID0gc2VhcmNoID8gc2VhcmNoLm9mZnNldEhlaWdodCA6IDAsXFxyXFxuICAgICAgICAgIGFjdGlvbnNIZWlnaHQgPSBhY3Rpb25zID8gYWN0aW9ucy5vZmZzZXRIZWlnaHQgOiAwLFxcclxcbiAgICAgICAgICBkb25lQnV0dG9uSGVpZ2h0ID0gZG9uZUJ1dHRvbiA/IGRvbmVCdXR0b24ub2Zmc2V0SGVpZ2h0IDogMCxcXHJcXG4gICAgICAgICAgZGl2aWRlckhlaWdodCA9ICQoZGl2aWRlcikub3V0ZXJIZWlnaHQodHJ1ZSksXFxyXFxuICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBqUXVlcnkgaWYgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBub3Qgc3VwcG9ydGVkXFxyXFxuICAgICAgICAgIG1lbnVTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlID8gd2luZG93LmdldENvbXB1dGVkU3R5bGUobWVudSkgOiBmYWxzZSxcXHJcXG4gICAgICAgICAgbWVudVdpZHRoID0gbWVudS5vZmZzZXRXaWR0aCxcXHJcXG4gICAgICAgICAgJG1lbnUgPSBtZW51U3R5bGUgPyBudWxsIDogJChtZW51KSxcXHJcXG4gICAgICAgICAgbWVudVBhZGRpbmcgPSB7XFxyXFxuICAgICAgICAgICAgdmVydDogdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5wYWRkaW5nVG9wIDogJG1lbnUuY3NzKCdwYWRkaW5nVG9wJykpICtcXHJcXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlID8gbWVudVN0eWxlLnBhZGRpbmdCb3R0b20gOiAkbWVudS5jc3MoJ3BhZGRpbmdCb3R0b20nKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUuYm9yZGVyVG9wV2lkdGggOiAkbWVudS5jc3MoJ2JvcmRlclRvcFdpZHRoJykpICtcXHJcXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlID8gbWVudVN0eWxlLmJvcmRlckJvdHRvbVdpZHRoIDogJG1lbnUuY3NzKCdib3JkZXJCb3R0b21XaWR0aCcpKSxcXHJcXG4gICAgICAgICAgICBob3JpejogdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5wYWRkaW5nTGVmdCA6ICRtZW51LmNzcygncGFkZGluZ0xlZnQnKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUucGFkZGluZ1JpZ2h0IDogJG1lbnUuY3NzKCdwYWRkaW5nUmlnaHQnKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUuYm9yZGVyTGVmdFdpZHRoIDogJG1lbnUuY3NzKCdib3JkZXJMZWZ0V2lkdGgnKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA6ICRtZW51LmNzcygnYm9yZGVyUmlnaHRXaWR0aCcpKVxcclxcbiAgICAgICAgICB9LFxcclxcbiAgICAgICAgICBtZW51RXh0cmFzID0ge1xcclxcbiAgICAgICAgICAgIHZlcnQ6IG1lbnVQYWRkaW5nLnZlcnQgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUubWFyZ2luVG9wIDogJG1lbnUuY3NzKCdtYXJnaW5Ub3AnKSkgK1xcclxcbiAgICAgICAgICAgICAgICAgIHRvSW50ZWdlcihtZW51U3R5bGUgPyBtZW51U3R5bGUubWFyZ2luQm90dG9tIDogJG1lbnUuY3NzKCdtYXJnaW5Cb3R0b20nKSkgKyAyLFxcclxcbiAgICAgICAgICAgIGhvcml6OiBtZW51UGFkZGluZy5ob3JpeiArXFxyXFxuICAgICAgICAgICAgICAgICAgdG9JbnRlZ2VyKG1lbnVTdHlsZSA/IG1lbnVTdHlsZS5tYXJnaW5MZWZ0IDogJG1lbnUuY3NzKCdtYXJnaW5MZWZ0JykpICtcXHJcXG4gICAgICAgICAgICAgICAgICB0b0ludGVnZXIobWVudVN0eWxlID8gbWVudVN0eWxlLm1hcmdpblJpZ2h0IDogJG1lbnUuY3NzKCdtYXJnaW5SaWdodCcpKSArIDJcXHJcXG4gICAgICAgICAgfSxcXHJcXG4gICAgICAgICAgc2Nyb2xsQmFyV2lkdGg7XFxyXFxuXFxyXFxuICAgICAgbWVudUlubmVyLnN0eWxlLm92ZXJmbG93WSA9ICdzY3JvbGwnO1xcclxcblxcclxcbiAgICAgIHNjcm9sbEJhcldpZHRoID0gbWVudS5vZmZzZXRXaWR0aCAtIG1lbnVXaWR0aDtcXHJcXG5cXHJcXG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5ld0VsZW1lbnQpO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8ubGlIZWlnaHQgPSBsaUhlaWdodDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLmRyb3Bkb3duSGVhZGVySGVpZ2h0ID0gZHJvcGRvd25IZWFkZXJIZWlnaHQ7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5oZWFkZXJIZWlnaHQgPSBoZWFkZXJIZWlnaHQ7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5zZWFyY2hIZWlnaHQgPSBzZWFyY2hIZWlnaHQ7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5hY3Rpb25zSGVpZ2h0ID0gYWN0aW9uc0hlaWdodDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLmRvbmVCdXR0b25IZWlnaHQgPSBkb25lQnV0dG9uSGVpZ2h0O1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uZGl2aWRlckhlaWdodCA9IGRpdmlkZXJIZWlnaHQ7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5tZW51UGFkZGluZyA9IG1lbnVQYWRkaW5nO1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcyA9IG1lbnVFeHRyYXM7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5tZW51V2lkdGggPSBtZW51V2lkdGg7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5tZW51SW5uZXJJbm5lcldpZHRoID0gbWVudVdpZHRoIC0gbWVudVBhZGRpbmcuaG9yaXo7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby50b3RhbE1lbnVXaWR0aCA9IHRoaXMuc2l6ZUluZm8ubWVudVdpZHRoO1xcclxcbiAgICAgIHRoaXMuc2l6ZUluZm8uc2Nyb2xsQmFyV2lkdGggPSBzY3JvbGxCYXJXaWR0aDtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdEhlaWdodCA9IHRoaXMuJG5ld0VsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0O1xcclxcblxcclxcbiAgICAgIHRoaXMuc2V0UG9zaXRpb25EYXRhKCk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGdldFNlbGVjdFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICAkd2luZG93ID0gJCh3aW5kb3cpLFxcclxcbiAgICAgICAgICBwb3MgPSB0aGF0LiRuZXdFbGVtZW50Lm9mZnNldCgpLFxcclxcbiAgICAgICAgICAkY29udGFpbmVyID0gJCh0aGF0Lm9wdGlvbnMuY29udGFpbmVyKSxcXHJcXG4gICAgICAgICAgY29udGFpbmVyUG9zO1xcclxcblxcclxcbiAgICAgIGlmICh0aGF0Lm9wdGlvbnMuY29udGFpbmVyICYmICRjb250YWluZXIubGVuZ3RoICYmICEkY29udGFpbmVyLmlzKCdib2R5JykpIHtcXHJcXG4gICAgICAgIGNvbnRhaW5lclBvcyA9ICRjb250YWluZXIub2Zmc2V0KCk7XFxyXFxuICAgICAgICBjb250YWluZXJQb3MudG9wICs9IHBhcnNlSW50KCRjb250YWluZXIuY3NzKCdib3JkZXJUb3BXaWR0aCcpKTtcXHJcXG4gICAgICAgIGNvbnRhaW5lclBvcy5sZWZ0ICs9IHBhcnNlSW50KCRjb250YWluZXIuY3NzKCdib3JkZXJMZWZ0V2lkdGgnKSk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGNvbnRhaW5lclBvcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHZhciB3aW5QYWQgPSB0aGF0Lm9wdGlvbnMud2luZG93UGFkZGluZztcXHJcXG5cXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFRvcCA9IHBvcy50b3AgLSBjb250YWluZXJQb3MudG9wIC0gJHdpbmRvdy5zY3JvbGxUb3AoKTtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldEJvdCA9ICR3aW5kb3cuaGVpZ2h0KCkgLSB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFRvcCAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0SGVpZ2h0IC0gY29udGFpbmVyUG9zLnRvcCAtIHdpblBhZFsyXTtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldExlZnQgPSBwb3MubGVmdCAtIGNvbnRhaW5lclBvcy5sZWZ0IC0gJHdpbmRvdy5zY3JvbGxMZWZ0KCk7XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRSaWdodCA9ICR3aW5kb3cud2lkdGgoKSAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0TGVmdCAtIHRoaXMuc2l6ZUluZm8uc2VsZWN0V2lkdGggLSBjb250YWluZXJQb3MubGVmdCAtIHdpblBhZFsxXTtcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFRvcCAtPSB3aW5QYWRbMF07XFxyXFxuICAgICAgdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRMZWZ0IC09IHdpblBhZFszXTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgc2V0TWVudVNpemU6IGZ1bmN0aW9uIChpc0F1dG8pIHtcXHJcXG4gICAgICB0aGlzLmdldFNlbGVjdFBvc2l0aW9uKCk7XFxyXFxuXFxyXFxuICAgICAgdmFyIHNlbGVjdFdpZHRoID0gdGhpcy5zaXplSW5mby5zZWxlY3RXaWR0aCxcXHJcXG4gICAgICAgICAgbGlIZWlnaHQgPSB0aGlzLnNpemVJbmZvLmxpSGVpZ2h0LFxcclxcbiAgICAgICAgICBoZWFkZXJIZWlnaHQgPSB0aGlzLnNpemVJbmZvLmhlYWRlckhlaWdodCxcXHJcXG4gICAgICAgICAgc2VhcmNoSGVpZ2h0ID0gdGhpcy5zaXplSW5mby5zZWFyY2hIZWlnaHQsXFxyXFxuICAgICAgICAgIGFjdGlvbnNIZWlnaHQgPSB0aGlzLnNpemVJbmZvLmFjdGlvbnNIZWlnaHQsXFxyXFxuICAgICAgICAgIGRvbmVCdXR0b25IZWlnaHQgPSB0aGlzLnNpemVJbmZvLmRvbmVCdXR0b25IZWlnaHQsXFxyXFxuICAgICAgICAgIGRpdkhlaWdodCA9IHRoaXMuc2l6ZUluZm8uZGl2aWRlckhlaWdodCxcXHJcXG4gICAgICAgICAgbWVudVBhZGRpbmcgPSB0aGlzLnNpemVJbmZvLm1lbnVQYWRkaW5nLFxcclxcbiAgICAgICAgICBtZW51SW5uZXJIZWlnaHQsXFxyXFxuICAgICAgICAgIG1lbnVIZWlnaHQsXFxyXFxuICAgICAgICAgIGRpdkxlbmd0aCA9IDAsXFxyXFxuICAgICAgICAgIG1pbkhlaWdodCxcXHJcXG4gICAgICAgICAgX21pbkhlaWdodCxcXHJcXG4gICAgICAgICAgbWF4SGVpZ2h0LFxcclxcbiAgICAgICAgICBtZW51SW5uZXJNaW5IZWlnaHQsXFxyXFxuICAgICAgICAgIGVzdGltYXRlLFxcclxcbiAgICAgICAgICBpc0Ryb3B1cDtcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3B1cEF1dG8pIHtcXHJcXG4gICAgICAgIC8vIEdldCB0aGUgZXN0aW1hdGVkIGhlaWdodCBvZiB0aGUgbWVudSB3aXRob3V0IHNjcm9sbGJhcnMuXFxyXFxuICAgICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBmb3Igc21hbGxlciBtZW51cywgd2hlcmUgdGhlcmUgbWlnaHQgYmUgcGxlbnR5IG9mIHJvb21cXHJcXG4gICAgICAgIC8vIGJlbG93IHRoZSBidXR0b24gd2l0aG91dCBzZXR0aW5nIGRyb3B1cCwgYnV0IHdlIGNhbid0IGtub3dcXHJcXG4gICAgICAgIC8vIHRoZSBleGFjdCBoZWlnaHQgb2YgdGhlIG1lbnUgdW50aWwgY3JlYXRlVmlldyBpcyBjYWxsZWQgbGF0ZXJcXHJcXG4gICAgICAgIGVzdGltYXRlID0gbGlIZWlnaHQgKiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzLmxlbmd0aCArIG1lbnVQYWRkaW5nLnZlcnQ7XFxyXFxuXFxyXFxuICAgICAgICBpc0Ryb3B1cCA9IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wIC0gdGhpcy5zaXplSW5mby5zZWxlY3RPZmZzZXRCb3QgPiB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMudmVydCAmJiBlc3RpbWF0ZSArIHRoaXMuc2l6ZUluZm8ubWVudUV4dHJhcy52ZXJ0ICsgNTAgPiB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldEJvdDtcXHJcXG5cXHJcXG4gICAgICAgIC8vIGVuc3VyZSBkcm9wdXAgZG9lc24ndCBjaGFuZ2Ugd2hpbGUgc2VhcmNoaW5nIChzbyBtZW51IGRvZXNuJ3QgYm91bmNlIGJhY2sgYW5kIGZvcnRoKVxcclxcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLmlzU2VhcmNoaW5nID09PSB0cnVlKSB7XFxyXFxuICAgICAgICAgIGlzRHJvcHVwID0gdGhpcy5zZWxlY3RwaWNrZXIuZHJvcHVwO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudC50b2dnbGVDbGFzcyhjbGFzc05hbWVzLkRST1BVUCwgaXNEcm9wdXApO1xcclxcbiAgICAgICAgdGhpcy5zZWxlY3RwaWNrZXIuZHJvcHVwID0gaXNEcm9wdXA7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSA9PT0gJ2F1dG8nKSB7XFxyXFxuICAgICAgICBfbWluSGVpZ2h0ID0gdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50cy5sZW5ndGggPiAzID8gdGhpcy5zaXplSW5mby5saUhlaWdodCAqIDMgKyB0aGlzLnNpemVJbmZvLm1lbnVFeHRyYXMudmVydCAtIDIgOiAwO1xcclxcbiAgICAgICAgbWVudUhlaWdodCA9IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0Qm90IC0gdGhpcy5zaXplSW5mby5tZW51RXh0cmFzLnZlcnQ7XFxyXFxuICAgICAgICBtaW5IZWlnaHQgPSBfbWluSGVpZ2h0ICsgaGVhZGVySGVpZ2h0ICsgc2VhcmNoSGVpZ2h0ICsgYWN0aW9uc0hlaWdodCArIGRvbmVCdXR0b25IZWlnaHQ7XFxyXFxuICAgICAgICBtZW51SW5uZXJNaW5IZWlnaHQgPSBNYXRoLm1heChfbWluSGVpZ2h0IC0gbWVudVBhZGRpbmcudmVydCwgMCk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAodGhpcy4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLkRST1BVUCkpIHtcXHJcXG4gICAgICAgICAgbWVudUhlaWdodCA9IHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0VG9wIC0gdGhpcy5zaXplSW5mby5tZW51RXh0cmFzLnZlcnQ7XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBtYXhIZWlnaHQgPSBtZW51SGVpZ2h0O1xcclxcbiAgICAgICAgbWVudUlubmVySGVpZ2h0ID0gbWVudUhlaWdodCAtIGhlYWRlckhlaWdodCAtIHNlYXJjaEhlaWdodCAtIGFjdGlvbnNIZWlnaHQgLSBkb25lQnV0dG9uSGVpZ2h0IC0gbWVudVBhZGRpbmcudmVydDtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zaXplICYmIHRoaXMub3B0aW9ucy5zaXplICE9ICdhdXRvJyAmJiB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzLmxlbmd0aCA+IHRoaXMub3B0aW9ucy5zaXplKSB7XFxyXFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3B0aW9ucy5zaXplOyBpKyspIHtcXHJcXG4gICAgICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpXS50eXBlID09PSAnZGl2aWRlcicpIGRpdkxlbmd0aCsrO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgbWVudUhlaWdodCA9IGxpSGVpZ2h0ICogdGhpcy5vcHRpb25zLnNpemUgKyBkaXZMZW5ndGggKiBkaXZIZWlnaHQgKyBtZW51UGFkZGluZy52ZXJ0O1xcclxcbiAgICAgICAgbWVudUlubmVySGVpZ2h0ID0gbWVudUhlaWdodCAtIG1lbnVQYWRkaW5nLnZlcnQ7XFxyXFxuICAgICAgICBtYXhIZWlnaHQgPSBtZW51SGVpZ2h0ICsgaGVhZGVySGVpZ2h0ICsgc2VhcmNoSGVpZ2h0ICsgYWN0aW9uc0hlaWdodCArIGRvbmVCdXR0b25IZWlnaHQ7XFxyXFxuICAgICAgICBtaW5IZWlnaHQgPSBtZW51SW5uZXJNaW5IZWlnaHQgPSAnJztcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbWVudS5jc3Moe1xcclxcbiAgICAgICAgJ21heC1oZWlnaHQnOiBtYXhIZWlnaHQgKyAncHgnLFxcclxcbiAgICAgICAgJ292ZXJmbG93JzogJ2hpZGRlbicsXFxyXFxuICAgICAgICAnbWluLWhlaWdodCc6IG1pbkhlaWdodCArICdweCdcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRtZW51SW5uZXIuY3NzKHtcXHJcXG4gICAgICAgICdtYXgtaGVpZ2h0JzogbWVudUlubmVySGVpZ2h0ICsgJ3B4JyxcXHJcXG4gICAgICAgICdvdmVyZmxvdy15JzogJ2F1dG8nLFxcclxcbiAgICAgICAgJ21pbi1oZWlnaHQnOiBtZW51SW5uZXJNaW5IZWlnaHQgKyAncHgnXFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgLy8gZW5zdXJlIG1lbnVJbm5lckhlaWdodCBpcyBhbHdheXMgYSBwb3NpdGl2ZSBudW1iZXIgdG8gcHJldmVudCBpc3N1ZXMgY2FsY3VsYXRpbmcgY2h1bmtTaXplIGluIGNyZWF0ZVZpZXdcXHJcXG4gICAgICB0aGlzLnNpemVJbmZvLm1lbnVJbm5lckhlaWdodCA9IE1hdGgubWF4KG1lbnVJbm5lckhlaWdodCwgMSk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGggJiYgdGhpcy5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW3RoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YS5sZW5ndGggLSAxXS5wb3NpdGlvbiA+IHRoaXMuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0KSB7XFxyXFxuICAgICAgICB0aGlzLnNpemVJbmZvLmhhc1Njcm9sbEJhciA9IHRydWU7XFxyXFxuICAgICAgICB0aGlzLnNpemVJbmZvLnRvdGFsTWVudVdpZHRoID0gdGhpcy5zaXplSW5mby5tZW51V2lkdGggKyB0aGlzLnNpemVJbmZvLnNjcm9sbEJhcldpZHRoO1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3Bkb3duQWxpZ25SaWdodCA9PT0gJ2F1dG8nKSB7XFxyXFxuICAgICAgICB0aGlzLiRtZW51LnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuTUVOVVJJR0hULCB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldExlZnQgPiB0aGlzLnNpemVJbmZvLnNlbGVjdE9mZnNldFJpZ2h0ICYmIHRoaXMuc2l6ZUluZm8uc2VsZWN0T2Zmc2V0UmlnaHQgPCAodGhpcy5zaXplSW5mby50b3RhbE1lbnVXaWR0aCAtIHNlbGVjdFdpZHRoKSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmICh0aGlzLmRyb3Bkb3duICYmIHRoaXMuZHJvcGRvd24uX3BvcHBlcikgdGhpcy5kcm9wZG93bi5fcG9wcGVyLnVwZGF0ZSgpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBzZXRTaXplOiBmdW5jdGlvbiAocmVmcmVzaCkge1xcclxcbiAgICAgIHRoaXMubGlIZWlnaHQocmVmcmVzaCk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXIpIHRoaXMuJG1lbnUuY3NzKCdwYWRkaW5nLXRvcCcsIDApO1xcclxcblxcclxcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSAhPT0gZmFsc2UpIHtcXHJcXG4gICAgICAgIHZhciB0aGF0ID0gdGhpcyxcXHJcXG4gICAgICAgICAgICAkd2luZG93ID0gJCh3aW5kb3cpO1xcclxcblxcclxcbiAgICAgICAgdGhpcy5zZXRNZW51U2l6ZSgpO1xcclxcblxcclxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXZlU2VhcmNoKSB7XFxyXFxuICAgICAgICAgIHRoaXMuJHNlYXJjaGJveFxcclxcbiAgICAgICAgICAgIC5vZmYoJ2lucHV0LnNldE1lbnVTaXplIHByb3BlcnR5Y2hhbmdlLnNldE1lbnVTaXplJylcXHJcXG4gICAgICAgICAgICAub24oJ2lucHV0LnNldE1lbnVTaXplIHByb3BlcnR5Y2hhbmdlLnNldE1lbnVTaXplJywgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2V0TWVudVNpemUoKTtcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2l6ZSA9PT0gJ2F1dG8nKSB7XFxyXFxuICAgICAgICAgICR3aW5kb3dcXHJcXG4gICAgICAgICAgICAub2ZmKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnICsgJyBzY3JvbGwnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcuc2V0TWVudVNpemUnKVxcclxcbiAgICAgICAgICAgIC5vbigncmVzaXplJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnLnNldE1lbnVTaXplJyArICcgc2Nyb2xsJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnLnNldE1lbnVTaXplJywgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuc2V0TWVudVNpemUoKTtcXHJcXG4gICAgICAgICAgICB9KTtcXHJcXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnNpemUgJiYgdGhpcy5vcHRpb25zLnNpemUgIT0gJ2F1dG8nICYmIHRoaXMuc2VsZWN0cGlja2VyLmN1cnJlbnQuZWxlbWVudHMubGVuZ3RoID4gdGhpcy5vcHRpb25zLnNpemUpIHtcXHJcXG4gICAgICAgICAgJHdpbmRvdy5vZmYoJ3Jlc2l6ZScgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScgKyAnIHNjcm9sbCcgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkICsgJy5zZXRNZW51U2l6ZScpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICB0aGlzLmNyZWF0ZVZpZXcoZmFsc2UsIHRydWUsIHJlZnJlc2gpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG5cXHJcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLndpZHRoID09PSAnYXV0bycpIHtcXHJcXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJG1lbnUuY3NzKCdtaW4td2lkdGgnLCAnMCcpO1xcclxcblxcclxcbiAgICAgICAgICB0aGF0LiRlbGVtZW50Lm9uKCdsb2FkZWQnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgICAgdGhhdC5saUhlaWdodCgpO1xcclxcbiAgICAgICAgICAgIHRoYXQuc2V0TWVudVNpemUoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAvLyBHZXQgY29ycmVjdCB3aWR0aCBpZiBlbGVtZW50IGlzIGhpZGRlblxcclxcbiAgICAgICAgICAgIHZhciAkc2VsZWN0Q2xvbmUgPSB0aGF0LiRuZXdFbGVtZW50LmNsb25lKCkuYXBwZW5kVG8oJ2JvZHknKSxcXHJcXG4gICAgICAgICAgICAgICAgYnRuV2lkdGggPSAkc2VsZWN0Q2xvbmUuY3NzKCd3aWR0aCcsICdhdXRvJykuY2hpbGRyZW4oJ2J1dHRvbicpLm91dGVyV2lkdGgoKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICAkc2VsZWN0Q2xvbmUucmVtb3ZlKCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gU2V0IHdpZHRoIHRvIHdoYXRldmVyJ3MgbGFyZ2VyLCBidXR0b24gdGl0bGUgb3IgbG9uZ2VzdCBvcHRpb25cXHJcXG4gICAgICAgICAgICB0aGF0LnNpemVJbmZvLnNlbGVjdFdpZHRoID0gTWF0aC5tYXgodGhhdC5zaXplSW5mby50b3RhbE1lbnVXaWR0aCwgYnRuV2lkdGgpO1xcclxcbiAgICAgICAgICAgIHRoYXQuJG5ld0VsZW1lbnQuY3NzKCd3aWR0aCcsIHRoYXQuc2l6ZUluZm8uc2VsZWN0V2lkdGggKyAncHgnKTtcXHJcXG4gICAgICAgICAgfSk7XFxyXFxuICAgICAgICB9KTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy53aWR0aCA9PT0gJ2ZpdCcpIHtcXHJcXG4gICAgICAgIC8vIFJlbW92ZSBpbmxpbmUgbWluLXdpZHRoIHNvIHdpZHRoIGNhbiBiZSBjaGFuZ2VkIGZyb20gJ2F1dG8nXFxyXFxuICAgICAgICB0aGlzLiRtZW51LmNzcygnbWluLXdpZHRoJywgJycpO1xcclxcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudC5jc3MoJ3dpZHRoJywgJycpLmFkZENsYXNzKCdmaXQtd2lkdGgnKTtcXHJcXG4gICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy53aWR0aCkge1xcclxcbiAgICAgICAgLy8gUmVtb3ZlIGlubGluZSBtaW4td2lkdGggc28gd2lkdGggY2FuIGJlIGNoYW5nZWQgZnJvbSAnYXV0bydcXHJcXG4gICAgICAgIHRoaXMuJG1lbnUuY3NzKCdtaW4td2lkdGgnLCAnJyk7XFxyXFxuICAgICAgICB0aGlzLiRuZXdFbGVtZW50LmNzcygnd2lkdGgnLCB0aGlzLm9wdGlvbnMud2lkdGgpO1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAvLyBSZW1vdmUgaW5saW5lIG1pbi13aWR0aC93aWR0aCBzbyB3aWR0aCBjYW4gYmUgY2hhbmdlZFxcclxcbiAgICAgICAgdGhpcy4kbWVudS5jc3MoJ21pbi13aWR0aCcsICcnKTtcXHJcXG4gICAgICAgIHRoaXMuJG5ld0VsZW1lbnQuY3NzKCd3aWR0aCcsICcnKTtcXHJcXG4gICAgICB9XFxyXFxuICAgICAgLy8gUmVtb3ZlIGZpdC13aWR0aCBjbGFzcyBpZiB3aWR0aCBpcyBjaGFuZ2VkIHByb2dyYW1tYXRpY2FsbHlcXHJcXG4gICAgICBpZiAodGhpcy4kbmV3RWxlbWVudC5oYXNDbGFzcygnZml0LXdpZHRoJykgJiYgdGhpcy5vcHRpb25zLndpZHRoICE9PSAnZml0Jykge1xcclxcbiAgICAgICAgdGhpcy4kbmV3RWxlbWVudFswXS5jbGFzc0xpc3QucmVtb3ZlKCdmaXQtd2lkdGgnKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNlbGVjdFBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdGhpcy4kYnNDb250YWluZXIgPSAkKCc8ZGl2IGNsYXNzPVxcXCJicy1jb250YWluZXJcXFwiIC8+Jyk7XFxyXFxuXFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICAkY29udGFpbmVyID0gJCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKSxcXHJcXG4gICAgICAgICAgcG9zLFxcclxcbiAgICAgICAgICBjb250YWluZXJQb3MsXFxyXFxuICAgICAgICAgIGFjdHVhbEhlaWdodCxcXHJcXG4gICAgICAgICAgZ2V0UGxhY2VtZW50ID0gZnVuY3Rpb24gKCRlbGVtZW50KSB7XFxyXFxuICAgICAgICAgICAgdmFyIGNvbnRhaW5lclBvc2l0aW9uID0ge30sXFxyXFxuICAgICAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBkcm9wZG93bidzIGRlZmF1bHQgZGlzcGxheSBzZXR0aW5nIGlmIGRpc3BsYXkgaXMgbm90IG1hbnVhbGx5IHNldFxcclxcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gdGhhdC5vcHRpb25zLmRpc3BsYXkgfHwgKFxcclxcbiAgICAgICAgICAgICAgICAgIC8vIEJvb3RzdHJhcCAzIGRvZXNuJ3QgaGF2ZSAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLkRlZmF1bHRcXHJcXG4gICAgICAgICAgICAgICAgICAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLkRlZmF1bHQgPyAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLkRlZmF1bHQuZGlzcGxheVxcclxcbiAgICAgICAgICAgICAgICAgIDogZmFsc2VcXHJcXG4gICAgICAgICAgICAgICAgKTtcXHJcXG5cXHJcXG4gICAgICAgICAgICB0aGF0LiRic0NvbnRhaW5lci5hZGRDbGFzcygkZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UoL2Zvcm0tY29udHJvbHxmaXQtd2lkdGgvZ2ksICcnKSkudG9nZ2xlQ2xhc3MoY2xhc3NOYW1lcy5EUk9QVVAsICRlbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuRFJPUFVQKSk7XFxyXFxuICAgICAgICAgICAgcG9zID0gJGVsZW1lbnQub2Zmc2V0KCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKCEkY29udGFpbmVyLmlzKCdib2R5JykpIHtcXHJcXG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvcyA9ICRjb250YWluZXIub2Zmc2V0KCk7XFxyXFxuICAgICAgICAgICAgICBjb250YWluZXJQb3MudG9wICs9IHBhcnNlSW50KCRjb250YWluZXIuY3NzKCdib3JkZXJUb3BXaWR0aCcpKSAtICRjb250YWluZXIuc2Nyb2xsVG9wKCk7XFxyXFxuICAgICAgICAgICAgICBjb250YWluZXJQb3MubGVmdCArPSBwYXJzZUludCgkY29udGFpbmVyLmNzcygnYm9yZGVyTGVmdFdpZHRoJykpIC0gJGNvbnRhaW5lci5zY3JvbGxMZWZ0KCk7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGFjdHVhbEhlaWdodCA9ICRlbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuRFJPUFVQKSA/IDAgOiAkZWxlbWVudFswXS5vZmZzZXRIZWlnaHQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgLy8gQm9vdHN0cmFwIDQrIHVzZXMgUG9wcGVyIGZvciBtZW51IHBvc2l0aW9uaW5nXFxyXFxuICAgICAgICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPCA0IHx8IGRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XFxyXFxuICAgICAgICAgICAgICBjb250YWluZXJQb3NpdGlvbi50b3AgPSBwb3MudG9wIC0gY29udGFpbmVyUG9zLnRvcCArIGFjdHVhbEhlaWdodDtcXHJcXG4gICAgICAgICAgICAgIGNvbnRhaW5lclBvc2l0aW9uLmxlZnQgPSBwb3MubGVmdCAtIGNvbnRhaW5lclBvcy5sZWZ0O1xcclxcbiAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICBjb250YWluZXJQb3NpdGlvbi53aWR0aCA9ICRlbGVtZW50WzBdLm9mZnNldFdpZHRoO1xcclxcblxcclxcbiAgICAgICAgICAgIHRoYXQuJGJzQ29udGFpbmVyLmNzcyhjb250YWluZXJQb3NpdGlvbik7XFxyXFxuICAgICAgICAgIH07XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kYnV0dG9uLm9uKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIGlmICh0aGF0LmlzRGlzYWJsZWQoKSkge1xcclxcbiAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBnZXRQbGFjZW1lbnQodGhhdC4kbmV3RWxlbWVudCk7XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LiRic0NvbnRhaW5lclxcclxcbiAgICAgICAgICAuYXBwZW5kVG8odGhhdC5vcHRpb25zLmNvbnRhaW5lcilcXHJcXG4gICAgICAgICAgLnRvZ2dsZUNsYXNzKGNsYXNzTmFtZXMuU0hPVywgIXRoYXQuJGJ1dHRvbi5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpKVxcclxcbiAgICAgICAgICAuYXBwZW5kKHRoYXQuJG1lbnUpO1xcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgICQod2luZG93KVxcclxcbiAgICAgICAgLm9mZigncmVzaXplJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQgKyAnIHNjcm9sbCcgKyBFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkKVxcclxcbiAgICAgICAgLm9uKCdyZXNpemUnICsgRVZFTlRfS0VZICsgJy4nICsgdGhpcy5zZWxlY3RJZCArICcgc2Nyb2xsJyArIEVWRU5UX0tFWSArICcuJyArIHRoaXMuc2VsZWN0SWQsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgdmFyIGlzQWN0aXZlID0gdGhhdC4kbmV3RWxlbWVudC5oYXNDbGFzcyhjbGFzc05hbWVzLlNIT1cpO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoaXNBY3RpdmUpIGdldFBsYWNlbWVudCh0aGF0LiRuZXdFbGVtZW50KTtcXHJcXG4gICAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2hpZGUnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICB0aGF0LiRtZW51LmRhdGEoJ2hlaWdodCcsIHRoYXQuJG1lbnUuaGVpZ2h0KCkpO1xcclxcbiAgICAgICAgdGhhdC4kYnNDb250YWluZXIuZGV0YWNoKCk7XFxyXFxuICAgICAgfSk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNldE9wdGlvblN0YXR1czogZnVuY3Rpb24gKHNlbGVjdGVkT25seSkge1xcclxcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG5cXHJcXG4gICAgICB0aGF0Lm5vU2Nyb2xsID0gZmFsc2U7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzICYmIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudmlzaWJsZUVsZW1lbnRzLmxlbmd0aCkge1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnZpc2libGVFbGVtZW50cy5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICB2YXIgbGlEYXRhID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2kgKyB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnBvc2l0aW9uMF0sXFxyXFxuICAgICAgICAgICAgICBvcHRpb24gPSBsaURhdGEub3B0aW9uO1xcclxcblxcclxcbiAgICAgICAgICBpZiAob3B0aW9uKSB7XFxyXFxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkT25seSAhPT0gdHJ1ZSkge1xcclxcbiAgICAgICAgICAgICAgdGhhdC5zZXREaXNhYmxlZChcXHJcXG4gICAgICAgICAgICAgICAgbGlEYXRhLmluZGV4LFxcclxcbiAgICAgICAgICAgICAgICBsaURhdGEuZGlzYWJsZWRcXHJcXG4gICAgICAgICAgICAgICk7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQoXFxyXFxuICAgICAgICAgICAgICBsaURhdGEuaW5kZXgsXFxyXFxuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWRcXHJcXG4gICAgICAgICAgICApO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBvcHRpb24gdGhhdCBpcyBiZWluZyBjaGFuZ2VkXFxyXFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWQgLSB0cnVlIGlmIHRoZSBvcHRpb24gaXMgYmVpbmcgc2VsZWN0ZWQsIGZhbHNlIGlmIGJlaW5nIGRlc2VsZWN0ZWRcXHJcXG4gICAgICovXFxyXFxuICAgIHNldFNlbGVjdGVkOiBmdW5jdGlvbiAoaW5kZXgsIHNlbGVjdGVkKSB7XFxyXFxuICAgICAgdmFyIGxpID0gdGhpcy5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50c1tpbmRleF0sXFxyXFxuICAgICAgICAgIGxpRGF0YSA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtpbmRleF0sXFxyXFxuICAgICAgICAgIGFjdGl2ZUluZGV4SXNTZXQgPSB0aGlzLmFjdGl2ZUluZGV4ICE9PSB1bmRlZmluZWQsXFxyXFxuICAgICAgICAgIHRoaXNJc0FjdGl2ZSA9IHRoaXMuYWN0aXZlSW5kZXggPT09IGluZGV4LFxcclxcbiAgICAgICAgICBwcmV2QWN0aXZlLFxcclxcbiAgICAgICAgICBhLFxcclxcbiAgICAgICAgICAvLyBpZiBjdXJyZW50IG9wdGlvbiBpcyBhbHJlYWR5IGFjdGl2ZVxcclxcbiAgICAgICAgICAvLyBPUlxcclxcbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBvcHRpb24gaXMgYmVpbmcgc2VsZWN0ZWQsIGl0J3MgTk9UIG11bHRpcGxlLCBhbmRcXHJcXG4gICAgICAgICAgLy8gYWN0aXZlSW5kZXggaXMgdW5kZWZpbmVkOlxcclxcbiAgICAgICAgICAvLyAgLSB3aGVuIHRoZSBtZW51IGlzIGZpcnN0IGJlaW5nIG9wZW5lZCwgT1JcXHJcXG4gICAgICAgICAgLy8gIC0gYWZ0ZXIgYSBzZWFyY2ggaGFzIGJlZW4gcGVyZm9ybWVkLCBPUlxcclxcbiAgICAgICAgICAvLyAgLSB3aGVuIHJldGFpbkFjdGl2ZSBpcyBmYWxzZSB3aGVuIHNlbGVjdGluZyBhIG5ldyBvcHRpb24gKGkuZS4gaW5kZXggb2YgdGhlIG5ld2x5IHNlbGVjdGVkIG9wdGlvbiBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgYWN0aXZlSW5kZXgpXFxyXFxuICAgICAgICAgIGtlZXBBY3RpdmUgPSB0aGlzSXNBY3RpdmUgfHwgKHNlbGVjdGVkICYmICF0aGlzLm11bHRpcGxlICYmICFhY3RpdmVJbmRleElzU2V0KTtcXHJcXG5cXHJcXG4gICAgICBsaURhdGEuc2VsZWN0ZWQgPSBzZWxlY3RlZDtcXHJcXG5cXHJcXG4gICAgICBhID0gbGkuZmlyc3RDaGlsZDtcXHJcXG5cXHJcXG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcXHJcXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IGluZGV4O1xcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICBsaS5jbGFzc0xpc3QudG9nZ2xlKCdzZWxlY3RlZCcsIHNlbGVjdGVkKTtcXHJcXG5cXHJcXG4gICAgICBpZiAoa2VlcEFjdGl2ZSkge1xcclxcbiAgICAgICAgdGhpcy5mb2N1c0l0ZW0obGksIGxpRGF0YSk7XFxyXFxuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LmN1cnJlbnRBY3RpdmUgPSBsaTtcXHJcXG4gICAgICAgIHRoaXMuYWN0aXZlSW5kZXggPSBpbmRleDtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdGhpcy5kZWZvY3VzSXRlbShsaSk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmIChhKSB7XFxyXFxuICAgICAgICBhLmNsYXNzTGlzdC50b2dnbGUoJ3NlbGVjdGVkJywgc2VsZWN0ZWQpO1xcclxcblxcclxcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XFxyXFxuICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xcclxcbiAgICAgICAgICAgIGEuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xcclxcbiAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIGEucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJyk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKCFrZWVwQWN0aXZlICYmICFhY3RpdmVJbmRleElzU2V0ICYmIHNlbGVjdGVkICYmIHRoaXMucHJldkFjdGl2ZUluZGV4ICE9PSB1bmRlZmluZWQpIHtcXHJcXG4gICAgICAgIHByZXZBY3RpdmUgPSB0aGlzLnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzW3RoaXMucHJldkFjdGl2ZUluZGV4XTtcXHJcXG5cXHJcXG4gICAgICAgIHRoaXMuZGVmb2N1c0l0ZW0ocHJldkFjdGl2ZSk7XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcblxcclxcbiAgICAvKipcXHJcXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBvcHRpb24gdGhhdCBpcyBiZWluZyBkaXNhYmxlZFxcclxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkIC0gdHJ1ZSBpZiB0aGUgb3B0aW9uIGlzIGJlaW5nIGRpc2FibGVkLCBmYWxzZSBpZiBiZWluZyBlbmFibGVkXFxyXFxuICAgICAqL1xcclxcbiAgICBzZXREaXNhYmxlZDogZnVuY3Rpb24gKGluZGV4LCBkaXNhYmxlZCkge1xcclxcbiAgICAgIHZhciBsaSA9IHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZWxlbWVudHNbaW5kZXhdLFxcclxcbiAgICAgICAgICBhO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtpbmRleF0uZGlzYWJsZWQgPSBkaXNhYmxlZDtcXHJcXG5cXHJcXG4gICAgICBhID0gbGkuZmlyc3RDaGlsZDtcXHJcXG5cXHJcXG4gICAgICBsaS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZXMuRElTQUJMRUQsIGRpc2FibGVkKTtcXHJcXG5cXHJcXG4gICAgICBpZiAoYSkge1xcclxcbiAgICAgICAgaWYgKHZlcnNpb24ubWFqb3IgPT09ICc0JykgYS5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZXMuRElTQUJMRUQsIGRpc2FibGVkKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChkaXNhYmxlZCkge1xcclxcbiAgICAgICAgICBhLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIGRpc2FibGVkKTtcXHJcXG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgYS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnKTtcXHJcXG4gICAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBpc0Rpc2FibGVkOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnRbMF0uZGlzYWJsZWQ7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGNoZWNrRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKCkpIHtcXHJcXG4gICAgICAgIHRoaXMuJG5ld0VsZW1lbnRbMF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWVzLkRJU0FCTEVEKTtcXHJcXG4gICAgICAgIHRoaXMuJGJ1dHRvbi5hZGRDbGFzcyhjbGFzc05hbWVzLkRJU0FCTEVEKS5hdHRyKCdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XFxyXFxuICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgIGlmICh0aGlzLiRidXR0b25bMF0uY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZXMuRElTQUJMRUQpKSB7XFxyXFxuICAgICAgICAgIHRoaXMuJG5ld0VsZW1lbnRbMF0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWVzLkRJU0FCTEVEKTtcXHJcXG4gICAgICAgICAgdGhpcy4kYnV0dG9uLnJlbW92ZUNsYXNzKGNsYXNzTmFtZXMuRElTQUJMRUQpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCBmYWxzZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBjbGlja0xpc3RlbmVyOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyIHRoYXQgPSB0aGlzLFxcclxcbiAgICAgICAgICAkZG9jdW1lbnQgPSAkKGRvY3VtZW50KTtcXHJcXG5cXHJcXG4gICAgICAkZG9jdW1lbnQuZGF0YSgnc3BhY2VTZWxlY3QnLCBmYWxzZSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kYnV0dG9uLm9uKCdrZXl1cCcsIGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICBpZiAoLygzMikvLnRlc3QoZS5rZXlDb2RlLnRvU3RyaW5nKDEwKSkgJiYgJGRvY3VtZW50LmRhdGEoJ3NwYWNlU2VsZWN0JykpIHtcXHJcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcbiAgICAgICAgICAkZG9jdW1lbnQuZGF0YSgnc3BhY2VTZWxlY3QnLCBmYWxzZSk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbmV3RWxlbWVudC5vbignc2hvdy5icy5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIGlmICh2ZXJzaW9uLm1ham9yID4gMyAmJiAhdGhhdC5kcm9wZG93bikge1xcclxcbiAgICAgICAgICB0aGF0LmRyb3Bkb3duID0gdGhhdC4kYnV0dG9uLmRhdGEoJ2JzLmRyb3Bkb3duJyk7XFxyXFxuICAgICAgICAgIHRoYXQuZHJvcGRvd24uX21lbnUgPSB0aGF0LiRtZW51WzBdO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJGJ1dHRvbi5vbignY2xpY2suYnMuZHJvcGRvd24uZGF0YS1hcGknLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICBpZiAoIXRoYXQuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKSkge1xcclxcbiAgICAgICAgICB0aGF0LnNldFNpemUoKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICBmdW5jdGlvbiBzZXRGb2N1cyAoKSB7XFxyXFxuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICB0aGF0LiRtZW51SW5uZXIudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgZnVuY3Rpb24gY2hlY2tQb3BwZXJFeGlzdHMgKCkge1xcclxcbiAgICAgICAgaWYgKHRoYXQuZHJvcGRvd24gJiYgdGhhdC5kcm9wZG93bi5fcG9wcGVyICYmIHRoYXQuZHJvcGRvd24uX3BvcHBlci5zdGF0ZS5pc0NyZWF0ZWQpIHtcXHJcXG4gICAgICAgICAgc2V0Rm9jdXMoKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVja1BvcHBlckV4aXN0cyk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Nob3duJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgaWYgKHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgIT09IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuc2Nyb2xsVG9wKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnNjcm9sbFRvcDtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGlmICh2ZXJzaW9uLm1ham9yID4gMykge1xcclxcbiAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hlY2tQb3BwZXJFeGlzdHMpO1xcclxcbiAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgc2V0Rm9jdXMoKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICAvLyBlbnN1cmUgcG9zaW5zZXQgYW5kIHNldHNpemUgYXJlIGNvcnJlY3QgYmVmb3JlIHNlbGVjdGluZyBhbiBvcHRpb24gdmlhIGEgY2xpY2tcXHJcXG4gICAgICB0aGlzLiRtZW51SW5uZXIub24oJ21vdXNlZW50ZXInLCAnbGkgYScsIGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICB2YXIgaG92ZXJMaSA9IHRoaXMucGFyZW50RWxlbWVudCxcXHJcXG4gICAgICAgICAgICBwb3NpdGlvbjAgPSB0aGF0LmlzVmlydHVhbCgpID8gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5wb3NpdGlvbjAgOiAwLFxcclxcbiAgICAgICAgICAgIGluZGV4ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChob3ZlckxpLnBhcmVudEVsZW1lbnQuY2hpbGRyZW4sIGhvdmVyTGkpLFxcclxcbiAgICAgICAgICAgIGhvdmVyRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVtpbmRleCArIHBvc2l0aW9uMF07XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmZvY3VzSXRlbShob3ZlckxpLCBob3ZlckRhdGEsIHRydWUpO1xcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJG1lbnVJbm5lci5vbignY2xpY2snLCAnbGkgYScsIGZ1bmN0aW9uIChlLCByZXRhaW5BY3RpdmUpIHtcXHJcXG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXFxyXFxuICAgICAgICAgICAgZWxlbWVudCA9IHRoYXQuJGVsZW1lbnRbMF0sXFxyXFxuICAgICAgICAgICAgcG9zaXRpb24wID0gdGhhdC5pc1ZpcnR1YWwoKSA/IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wIDogMCxcXHJcXG4gICAgICAgICAgICBjbGlja2VkRGF0YSA9IHRoYXQuc2VsZWN0cGlja2VyLmN1cnJlbnQuZGF0YVskdGhpcy5wYXJlbnQoKS5pbmRleCgpICsgcG9zaXRpb24wXSxcXHJcXG4gICAgICAgICAgICBjbGlja2VkSW5kZXggPSBjbGlja2VkRGF0YS5pbmRleCxcXHJcXG4gICAgICAgICAgICBwcmV2VmFsdWUgPSBnZXRTZWxlY3RWYWx1ZXMoZWxlbWVudCksXFxyXFxuICAgICAgICAgICAgcHJldkluZGV4ID0gZWxlbWVudC5zZWxlY3RlZEluZGV4LFxcclxcbiAgICAgICAgICAgIHByZXZPcHRpb24gPSBlbGVtZW50Lm9wdGlvbnNbcHJldkluZGV4XSxcXHJcXG4gICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gdHJ1ZTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIERvbid0IGNsb3NlIG9uIG11bHRpIGNob2ljZSBtZW51XFxyXFxuICAgICAgICBpZiAodGhhdC5tdWx0aXBsZSAmJiB0aGF0Lm9wdGlvbnMubWF4T3B0aW9ucyAhPT0gMSkge1xcclxcbiAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcblxcclxcbiAgICAgICAgLy8gRG9uJ3QgcnVuIGlmIHRoZSBzZWxlY3QgaXMgZGlzYWJsZWRcXHJcXG4gICAgICAgIGlmICghdGhhdC5pc0Rpc2FibGVkKCkgJiYgISR0aGlzLnBhcmVudCgpLmhhc0NsYXNzKGNsYXNzTmFtZXMuRElTQUJMRUQpKSB7XFxyXFxuICAgICAgICAgIHZhciBvcHRpb24gPSBjbGlja2VkRGF0YS5vcHRpb24sXFxyXFxuICAgICAgICAgICAgICAkb3B0aW9uID0gJChvcHRpb24pLFxcclxcbiAgICAgICAgICAgICAgc3RhdGUgPSBvcHRpb24uc2VsZWN0ZWQsXFxyXFxuICAgICAgICAgICAgICAkb3B0Z3JvdXAgPSAkb3B0aW9uLnBhcmVudCgnb3B0Z3JvdXAnKSxcXHJcXG4gICAgICAgICAgICAgICRvcHRncm91cE9wdGlvbnMgPSAkb3B0Z3JvdXAuZmluZCgnb3B0aW9uJyksXFxyXFxuICAgICAgICAgICAgICBtYXhPcHRpb25zID0gdGhhdC5vcHRpb25zLm1heE9wdGlvbnMsXFxyXFxuICAgICAgICAgICAgICBtYXhPcHRpb25zR3JwID0gJG9wdGdyb3VwLmRhdGEoJ21heE9wdGlvbnMnKSB8fCBmYWxzZTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKGNsaWNrZWRJbmRleCA9PT0gdGhhdC5hY3RpdmVJbmRleCkgcmV0YWluQWN0aXZlID0gdHJ1ZTtcXHJcXG5cXHJcXG4gICAgICAgICAgaWYgKCFyZXRhaW5BY3RpdmUpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LnByZXZBY3RpdmVJbmRleCA9IHRoYXQuYWN0aXZlSW5kZXg7XFxyXFxuICAgICAgICAgICAgdGhhdC5hY3RpdmVJbmRleCA9IHVuZGVmaW5lZDtcXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICBpZiAoIXRoYXQubXVsdGlwbGUpIHsgLy8gRGVzZWxlY3QgYWxsIG90aGVycyBpZiBub3QgbXVsdGkgc2VsZWN0IGJveFxcclxcbiAgICAgICAgICAgIGlmIChwcmV2T3B0aW9uKSBwcmV2T3B0aW9uLnNlbGVjdGVkID0gZmFsc2U7XFxyXFxuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKGNsaWNrZWRJbmRleCwgdHJ1ZSk7XFxyXFxuICAgICAgICAgIH0gZWxzZSB7IC8vIFRvZ2dsZSB0aGUgb25lIHdlIGhhdmUgY2hvc2VuIGlmIHdlIGFyZSBtdWx0aSBzZWxlY3QuXFxyXFxuICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gIXN0YXRlO1xcclxcblxcclxcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQoY2xpY2tlZEluZGV4LCAhc3RhdGUpO1xcclxcbiAgICAgICAgICAgIHRoYXQuZm9jdXNlZFBhcmVudC5mb2N1cygpO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChtYXhPcHRpb25zICE9PSBmYWxzZSB8fCBtYXhPcHRpb25zR3JwICE9PSBmYWxzZSkge1xcclxcbiAgICAgICAgICAgICAgdmFyIG1heFJlYWNoZWQgPSBtYXhPcHRpb25zIDwgZ2V0U2VsZWN0ZWRPcHRpb25zKGVsZW1lbnQpLmxlbmd0aCxcXHJcXG4gICAgICAgICAgICAgICAgICBtYXhSZWFjaGVkR3JwID0gbWF4T3B0aW9uc0dycCA8ICRvcHRncm91cC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKS5sZW5ndGg7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICBpZiAoKG1heE9wdGlvbnMgJiYgbWF4UmVhY2hlZCkgfHwgKG1heE9wdGlvbnNHcnAgJiYgbWF4UmVhY2hlZEdycCkpIHtcXHJcXG4gICAgICAgICAgICAgICAgaWYgKG1heE9wdGlvbnMgJiYgbWF4T3B0aW9ucyA9PSAxKSB7XFxyXFxuICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZWxlY3RlZEluZGV4ID0gLTE7XFxyXFxuICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICAgICAgICB0aGF0LnNldE9wdGlvblN0YXR1cyh0cnVlKTtcXHJcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXhPcHRpb25zR3JwICYmIG1heE9wdGlvbnNHcnAgPT0gMSkge1xcclxcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJG9wdGdyb3VwT3B0aW9ucy5sZW5ndGg7IGkrKykge1xcclxcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9vcHRpb24gPSAkb3B0Z3JvdXBPcHRpb25zW2ldO1xcclxcbiAgICAgICAgICAgICAgICAgICAgX29wdGlvbi5zZWxlY3RlZCA9IGZhbHNlO1xcclxcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3RlZChfb3B0aW9uLmxpSW5kZXgsIGZhbHNlKTtcXHJcXG4gICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgICAgICAgICB0aGF0LnNldFNlbGVjdGVkKGNsaWNrZWRJbmRleCwgdHJ1ZSk7XFxyXFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgICAgICAgdmFyIG1heE9wdGlvbnNUZXh0ID0gdHlwZW9mIHRoYXQub3B0aW9ucy5tYXhPcHRpb25zVGV4dCA9PT0gJ3N0cmluZycgPyBbdGhhdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0LCB0aGF0Lm9wdGlvbnMubWF4T3B0aW9uc1RleHRdIDogdGhhdC5vcHRpb25zLm1heE9wdGlvbnNUZXh0LFxcclxcbiAgICAgICAgICAgICAgICAgICAgICBtYXhPcHRpb25zQXJyID0gdHlwZW9mIG1heE9wdGlvbnNUZXh0ID09PSAnZnVuY3Rpb24nID8gbWF4T3B0aW9uc1RleHQobWF4T3B0aW9ucywgbWF4T3B0aW9uc0dycCkgOiBtYXhPcHRpb25zVGV4dCxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgbWF4VHh0ID0gbWF4T3B0aW9uc0FyclswXS5yZXBsYWNlKCd7bn0nLCBtYXhPcHRpb25zKSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgbWF4VHh0R3JwID0gbWF4T3B0aW9uc0FyclsxXS5yZXBsYWNlKCd7bn0nLCBtYXhPcHRpb25zR3JwKSxcXHJcXG4gICAgICAgICAgICAgICAgICAgICAgJG5vdGlmeSA9ICQoJzxkaXYgY2xhc3M9XFxcIm5vdGlmeVxcXCI+PC9kaXY+Jyk7XFxyXFxuICAgICAgICAgICAgICAgICAgLy8gSWYge3Zhcn0gaXMgc2V0IGluIGFycmF5LCByZXBsYWNlIGl0XFxyXFxuICAgICAgICAgICAgICAgICAgLyoqIEBkZXByZWNhdGVkICovXFxyXFxuICAgICAgICAgICAgICAgICAgaWYgKG1heE9wdGlvbnNBcnJbMl0pIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIG1heFR4dCA9IG1heFR4dC5yZXBsYWNlKCd7dmFyfScsIG1heE9wdGlvbnNBcnJbMl1bbWF4T3B0aW9ucyA+IDEgPyAwIDogMV0pO1xcclxcbiAgICAgICAgICAgICAgICAgICAgbWF4VHh0R3JwID0gbWF4VHh0R3JwLnJlcGxhY2UoJ3t2YXJ9JywgbWF4T3B0aW9uc0FyclsyXVttYXhPcHRpb25zR3JwID4gMSA/IDAgOiAxXSk7XFxyXFxuICAgICAgICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGZhbHNlO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgIHRoYXQuJG1lbnUuYXBwZW5kKCRub3RpZnkpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgIGlmIChtYXhPcHRpb25zICYmIG1heFJlYWNoZWQpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgICRub3RpZnkuYXBwZW5kKCQoJzxkaXY+JyArIG1heFR4dCArICc8L2Rpdj4nKSk7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyQ2hhbmdlID0gZmFsc2U7XFxyXFxuICAgICAgICAgICAgICAgICAgICB0aGF0LiRlbGVtZW50LnRyaWdnZXIoJ21heFJlYWNoZWQnICsgRVZFTlRfS0VZKTtcXHJcXG4gICAgICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICAgICAgaWYgKG1heE9wdGlvbnNHcnAgJiYgbWF4UmVhY2hlZEdycCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgJG5vdGlmeS5hcHBlbmQoJCgnPGRpdj4nICsgbWF4VHh0R3JwICsgJzwvZGl2PicpKTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJDaGFuZ2UgPSBmYWxzZTtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignbWF4UmVhY2hlZEdycCcgKyBFVkVOVF9LRVkpO1xcclxcbiAgICAgICAgICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0ZWQoY2xpY2tlZEluZGV4LCBmYWxzZSk7XFxyXFxuICAgICAgICAgICAgICAgICAgfSwgMTApO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgICRub3RpZnlbMF0uY2xhc3NMaXN0LmFkZCgnZmFkZU91dCcpO1xcclxcblxcclxcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICAgICAgICAgICAgJG5vdGlmeS5yZW1vdmUoKTtcXHJcXG4gICAgICAgICAgICAgICAgICB9LCAxMDUwKTtcXHJcXG4gICAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICBpZiAoIXRoYXQubXVsdGlwbGUgfHwgKHRoYXQubXVsdGlwbGUgJiYgdGhhdC5vcHRpb25zLm1heE9wdGlvbnMgPT09IDEpKSB7XFxyXFxuICAgICAgICAgICAgdGhhdC4kYnV0dG9uLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAvLyBUcmlnZ2VyIHNlbGVjdCAnY2hhbmdlJ1xcclxcbiAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZSkge1xcclxcbiAgICAgICAgICAgIGlmICh0aGF0Lm11bHRpcGxlIHx8IHByZXZJbmRleCAhPT0gZWxlbWVudC5zZWxlY3RlZEluZGV4KSB7XFxyXFxuICAgICAgICAgICAgICAvLyAkb3B0aW9uLnByb3AoJ3NlbGVjdGVkJykgaXMgY3VycmVudCBvcHRpb24gc3RhdGUgKHNlbGVjdGVkL3Vuc2VsZWN0ZWQpLiBwcmV2VmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWxlY3QgcHJpb3IgdG8gYmVpbmcgY2hhbmdlZC5cXHJcXG4gICAgICAgICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBbb3B0aW9uLmluZGV4LCAkb3B0aW9uLnByb3AoJ3NlbGVjdGVkJyksIHByZXZWYWx1ZV07XFxyXFxuICAgICAgICAgICAgICB0aGF0LiRlbGVtZW50XFxyXFxuICAgICAgICAgICAgICAgIC50cmlnZ2VyTmF0aXZlKCdjaGFuZ2UnKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRtZW51Lm9uKCdjbGljaycsICdsaS4nICsgY2xhc3NOYW1lcy5ESVNBQkxFRCArICcgYSwgLicgKyBjbGFzc05hbWVzLlBPUE9WRVJIRUFERVIgKyAnLCAuJyArIGNsYXNzTmFtZXMuUE9QT1ZFUkhFQURFUiArICcgOm5vdCguY2xvc2UpJywgZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgIGlmIChlLmN1cnJlbnRUYXJnZXQgPT0gdGhpcykge1xcclxcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuICAgICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCAmJiAhJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2Nsb3NlJykpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB0aGF0LiRidXR0b24udHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJG1lbnVJbm5lci5vbignY2xpY2snLCAnLmRpdmlkZXIsIC5kcm9wZG93bi1oZWFkZXInLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXHJcXG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0pO1xcclxcblxcclxcbiAgICAgIHRoaXMuJG1lbnUub24oJ2NsaWNrJywgJy4nICsgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSICsgJyAuY2xvc2UnLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICB0aGF0LiRidXR0b24udHJpZ2dlcignY2xpY2snKTtcXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRzZWFyY2hib3gub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kbWVudS5vbignY2xpY2snLCAnLmFjdGlvbnMtYnRuJywgZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMubGl2ZVNlYXJjaCkge1xcclxcbiAgICAgICAgICB0aGF0LiRzZWFyY2hib3gudHJpZ2dlcignZm9jdXMnKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcclxcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdicy1zZWxlY3QtYWxsJykpIHtcXHJcXG4gICAgICAgICAgdGhhdC5zZWxlY3RBbGwoKTtcXHJcXG4gICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgIHRoYXQuZGVzZWxlY3RBbGwoKTtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRidXR0b25cXHJcXG4gICAgICAgIC5vbignZm9jdXMnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgICAgICB2YXIgdGFiaW5kZXggPSB0aGF0LiRlbGVtZW50WzBdLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcXHJcXG5cXHJcXG4gICAgICAgICAgLy8gb25seSBjaGFuZ2Ugd2hlbiBidXR0b24gaXMgYWN0dWFsbHkgZm9jdXNlZFxcclxcbiAgICAgICAgICBpZiAodGFiaW5kZXggIT09IHVuZGVmaW5lZCAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmlzVHJ1c3RlZCkge1xcclxcbiAgICAgICAgICAgIC8vIGFwcGx5IHNlbGVjdCBlbGVtZW50J3MgdGFiaW5kZXggdG8gZW5zdXJlIGNvcnJlY3Qgb3JkZXIgaXMgZm9sbG93ZWQgd2hlbiB0YWJiaW5nIHRvIHRoZSBuZXh0IGVsZW1lbnRcXHJcXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0YWJpbmRleCk7XFxyXFxuICAgICAgICAgICAgLy8gc2V0IGVsZW1lbnQncyB0YWJpbmRleCB0byAtMSB0byBhbGxvdyBmb3IgcmV2ZXJzZSB0YWJiaW5nXFxyXFxuICAgICAgICAgICAgdGhhdC4kZWxlbWVudFswXS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpO1xcclxcbiAgICAgICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnZpZXcudGFiaW5kZXggPSB0YWJpbmRleDtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSlcXHJcXG4gICAgICAgIC5vbignYmx1cicgKyBFVkVOVF9LRVksIGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgICAgIC8vIHJldmVydCBldmVyeXRoaW5nIHRvIG9yaWdpbmFsIHRhYmluZGV4XFxyXFxuICAgICAgICAgIGlmICh0aGF0LnNlbGVjdHBpY2tlci52aWV3LnRhYmluZGV4ICE9PSB1bmRlZmluZWQgJiYgZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5pc1RydXN0ZWQpIHtcXHJcXG4gICAgICAgICAgICB0aGF0LiRlbGVtZW50WzBdLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGF0LnNlbGVjdHBpY2tlci52aWV3LnRhYmluZGV4KTtcXHJcXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XFxyXFxuICAgICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIudmlldy50YWJpbmRleCA9IHVuZGVmaW5lZDtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kZWxlbWVudFxcclxcbiAgICAgICAgLm9uKCdjaGFuZ2UnICsgRVZFTlRfS0VZLCBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgICAgIHRoYXQucmVuZGVyKCk7XFxyXFxuICAgICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignY2hhbmdlZCcgKyBFVkVOVF9LRVksIGNoYW5nZWRBcmd1bWVudHMpO1xcclxcbiAgICAgICAgICBjaGFuZ2VkQXJndW1lbnRzID0gbnVsbDtcXHJcXG4gICAgICAgIH0pXFxyXFxuICAgICAgICAub24oJ2ZvY3VzJyArIEVWRU5UX0tFWSwgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5tb2JpbGUpIHRoYXQuJGJ1dHRvblswXS5mb2N1cygpO1xcclxcbiAgICAgICAgfSk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGxpdmVTZWFyY2hMaXN0ZW5lcjogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRidXR0b24ub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xcclxcbiAgICAgICAgaWYgKCEhdGhhdC4kc2VhcmNoYm94LnZhbCgpKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC52YWwoJycpO1xcclxcbiAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2gucHJldmlvdXNWYWx1ZSA9IHVuZGVmaW5lZDtcXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9KTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRzZWFyY2hib3gub24oJ2NsaWNrLmJzLmRyb3Bkb3duLmRhdGEtYXBpIGZvY3VzLmJzLmRyb3Bkb3duLmRhdGEtYXBpIHRvdWNoZW5kLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgZnVuY3Rpb24gKGUpIHtcXHJcXG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuICAgICAgfSk7XFxyXFxuXFxyXFxuICAgICAgdGhpcy4kc2VhcmNoYm94Lm9uKCdpbnB1dCBwcm9wZXJ0eWNoYW5nZScsIGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAgIHZhciBzZWFyY2hWYWx1ZSA9IHRoYXQuJHNlYXJjaGJveFswXS52YWx1ZTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5lbGVtZW50cyA9IFtdO1xcclxcbiAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLmRhdGEgPSBbXTtcXHJcXG5cXHJcXG4gICAgICAgIGlmIChzZWFyY2hWYWx1ZSkge1xcclxcbiAgICAgICAgICB2YXIgaSxcXHJcXG4gICAgICAgICAgICAgIHNlYXJjaE1hdGNoID0gW10sXFxyXFxuICAgICAgICAgICAgICBxID0gc2VhcmNoVmFsdWUudG9VcHBlckNhc2UoKSxcXHJcXG4gICAgICAgICAgICAgIGNhY2hlID0ge30sXFxyXFxuICAgICAgICAgICAgICBjYWNoZUFyciA9IFtdLFxcclxcbiAgICAgICAgICAgICAgc2VhcmNoU3R5bGUgPSB0aGF0Ll9zZWFyY2hTdHlsZSgpLFxcclxcbiAgICAgICAgICAgICAgbm9ybWFsaXplU2VhcmNoID0gdGhhdC5vcHRpb25zLmxpdmVTZWFyY2hOb3JtYWxpemU7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChub3JtYWxpemVTZWFyY2gpIHEgPSBub3JtYWxpemVUb0Jhc2UocSk7XFxyXFxuXFxyXFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICAgICAgdmFyIGxpID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5kYXRhW2ldO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmICghY2FjaGVbaV0pIHtcXHJcXG4gICAgICAgICAgICAgIGNhY2hlW2ldID0gc3RyaW5nU2VhcmNoKGxpLCBxLCBzZWFyY2hTdHlsZSwgbm9ybWFsaXplU2VhcmNoKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKGNhY2hlW2ldICYmIGxpLmhlYWRlckluZGV4ICE9PSB1bmRlZmluZWQgJiYgY2FjaGVBcnIuaW5kZXhPZihsaS5oZWFkZXJJbmRleCkgPT09IC0xKSB7XFxyXFxuICAgICAgICAgICAgICBpZiAobGkuaGVhZGVySW5kZXggPiAwKSB7XFxyXFxuICAgICAgICAgICAgICAgIGNhY2hlW2xpLmhlYWRlckluZGV4IC0gMV0gPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgICBjYWNoZUFyci5wdXNoKGxpLmhlYWRlckluZGV4IC0gMSk7XFxyXFxuICAgICAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgICAgICBjYWNoZVtsaS5oZWFkZXJJbmRleF0gPSB0cnVlO1xcclxcbiAgICAgICAgICAgICAgY2FjaGVBcnIucHVzaChsaS5oZWFkZXJJbmRleCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgICBjYWNoZVtsaS5sYXN0SW5kZXggKyAxXSA9IHRydWU7XFxyXFxuICAgICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICAgIGlmIChjYWNoZVtpXSAmJiBsaS50eXBlICE9PSAnb3B0Z3JvdXAtbGFiZWwnKSBjYWNoZUFyci5wdXNoKGkpO1xcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBjYWNoZUxlbiA9IGNhY2hlQXJyLmxlbmd0aDsgaSA8IGNhY2hlTGVuOyBpKyspIHtcXHJcXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBjYWNoZUFycltpXSxcXHJcXG4gICAgICAgICAgICAgICAgcHJldkluZGV4ID0gY2FjaGVBcnJbaSAtIDFdLFxcclxcbiAgICAgICAgICAgICAgICBsaSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtpbmRleF0sXFxyXFxuICAgICAgICAgICAgICAgIGxpUHJldiA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtwcmV2SW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgICAgIGlmIChsaS50eXBlICE9PSAnZGl2aWRlcicgfHwgKGxpLnR5cGUgPT09ICdkaXZpZGVyJyAmJiBsaVByZXYgJiYgbGlQcmV2LnR5cGUgIT09ICdkaXZpZGVyJyAmJiBjYWNoZUxlbiAtIDEgIT09IGkpKSB7XFxyXFxuICAgICAgICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5zZWFyY2guZGF0YS5wdXNoKGxpKTtcXHJcXG4gICAgICAgICAgICAgIHNlYXJjaE1hdGNoLnB1c2godGhhdC5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50c1tpbmRleF0pO1xcclxcbiAgICAgICAgICAgIH1cXHJcXG4gICAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgICB0aGF0LmFjdGl2ZUluZGV4ID0gdW5kZWZpbmVkO1xcclxcbiAgICAgICAgICB0aGF0Lm5vU2Nyb2xsID0gdHJ1ZTtcXHJcXG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyLnNjcm9sbFRvcCgwKTtcXHJcXG4gICAgICAgICAgdGhhdC5zZWxlY3RwaWNrZXIuc2VhcmNoLmVsZW1lbnRzID0gc2VhcmNoTWF0Y2g7XFxyXFxuICAgICAgICAgIHRoYXQuY3JlYXRlVmlldyh0cnVlKTtcXHJcXG4gICAgICAgICAgc2hvd05vUmVzdWx0cy5jYWxsKHRoYXQsIHNlYXJjaE1hdGNoLCBzZWFyY2hWYWx1ZSk7XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5wcmV2aW91c1ZhbHVlKSB7IC8vIGZvciBJRTExICgjMjQwMilcXHJcXG4gICAgICAgICAgdGhhdC4kbWVudUlubmVyLnNjcm9sbFRvcCgwKTtcXHJcXG4gICAgICAgICAgdGhhdC5jcmVhdGVWaWV3KGZhbHNlKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLnNlYXJjaC5wcmV2aW91c1ZhbHVlID0gIHNlYXJjaFZhbHVlO1xcclxcbiAgICAgIH0pO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBfc2VhcmNoU3R5bGU6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxpdmVTZWFyY2hTdHlsZSB8fCAnY29udGFpbnMnO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICB2YWw6IGZ1bmN0aW9uICh2YWx1ZSkge1xcclxcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy4kZWxlbWVudFswXTtcXHJcXG5cXHJcXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xcclxcbiAgICAgICAgdmFyIHByZXZWYWx1ZSA9IGdldFNlbGVjdFZhbHVlcyhlbGVtZW50KTtcXHJcXG5cXHJcXG4gICAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBbbnVsbCwgbnVsbCwgcHJldlZhbHVlXTtcXHJcXG5cXHJcXG4gICAgICAgIHRoaXMuJGVsZW1lbnRcXHJcXG4gICAgICAgICAgLnZhbCh2YWx1ZSlcXHJcXG4gICAgICAgICAgLnRyaWdnZXIoJ2NoYW5nZWQnICsgRVZFTlRfS0VZLCBjaGFuZ2VkQXJndW1lbnRzKTtcXHJcXG5cXHJcXG4gICAgICAgIGlmICh0aGlzLiRuZXdFbGVtZW50Lmhhc0NsYXNzKGNsYXNzTmFtZXMuU0hPVykpIHtcXHJcXG4gICAgICAgICAgaWYgKHRoaXMubXVsdGlwbGUpIHtcXHJcXG4gICAgICAgICAgICB0aGlzLnNldE9wdGlvblN0YXR1cyh0cnVlKTtcXHJcXG4gICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB2YXIgbGlTZWxlY3RlZEluZGV4ID0gKGVsZW1lbnQub3B0aW9uc1tlbGVtZW50LnNlbGVjdGVkSW5kZXhdIHx8IHt9KS5saUluZGV4O1xcclxcblxcclxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlTZWxlY3RlZEluZGV4ID09PSAnbnVtYmVyJykge1xcclxcbiAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZCh0aGlzLnNlbGVjdGVkSW5kZXgsIGZhbHNlKTtcXHJcXG4gICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWQobGlTZWxlY3RlZEluZGV4LCB0cnVlKTtcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIHRoaXMucmVuZGVyKCk7XFxyXFxuXFxyXFxuICAgICAgICBjaGFuZ2VkQXJndW1lbnRzID0gbnVsbDtcXHJcXG5cXHJcXG4gICAgICAgIHJldHVybiB0aGlzLiRlbGVtZW50O1xcclxcbiAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICByZXR1cm4gdGhpcy4kZWxlbWVudC52YWwoKTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIGNoYW5nZUFsbDogZnVuY3Rpb24gKHN0YXR1cykge1xcclxcbiAgICAgIGlmICghdGhpcy5tdWx0aXBsZSkgcmV0dXJuO1xcclxcbiAgICAgIGlmICh0eXBlb2Ygc3RhdHVzID09PSAndW5kZWZpbmVkJykgc3RhdHVzID0gdHJ1ZTtcXHJcXG5cXHJcXG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMuJGVsZW1lbnRbMF0sXFxyXFxuICAgICAgICAgIHByZXZpb3VzU2VsZWN0ZWQgPSAwLFxcclxcbiAgICAgICAgICBjdXJyZW50U2VsZWN0ZWQgPSAwLFxcclxcbiAgICAgICAgICBwcmV2VmFsdWUgPSBnZXRTZWxlY3RWYWx1ZXMoZWxlbWVudCk7XFxyXFxuXFxyXFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdicy1zZWxlY3QtaGlkZGVuJyk7XFxyXFxuXFxyXFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGRhdGEgPSB0aGlzLnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXHJcXG4gICAgICAgIHZhciBsaURhdGEgPSBkYXRhW2ldLFxcclxcbiAgICAgICAgICAgIG9wdGlvbiA9IGxpRGF0YS5vcHRpb247XFxyXFxuXFxyXFxuICAgICAgICBpZiAob3B0aW9uICYmICFsaURhdGEuZGlzYWJsZWQgJiYgbGlEYXRhLnR5cGUgIT09ICdkaXZpZGVyJykge1xcclxcbiAgICAgICAgICBpZiAobGlEYXRhLnNlbGVjdGVkKSBwcmV2aW91c1NlbGVjdGVkKys7XFxyXFxuICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHN0YXR1cztcXHJcXG4gICAgICAgICAgaWYgKHN0YXR1cyA9PT0gdHJ1ZSkgY3VycmVudFNlbGVjdGVkKys7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnYnMtc2VsZWN0LWhpZGRlbicpO1xcclxcblxcclxcbiAgICAgIGlmIChwcmV2aW91c1NlbGVjdGVkID09PSBjdXJyZW50U2VsZWN0ZWQpIHJldHVybjtcXHJcXG5cXHJcXG4gICAgICB0aGlzLnNldE9wdGlvblN0YXR1cygpO1xcclxcblxcclxcbiAgICAgIGNoYW5nZWRBcmd1bWVudHMgPSBbbnVsbCwgbnVsbCwgcHJldlZhbHVlXTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRlbGVtZW50XFxyXFxuICAgICAgICAudHJpZ2dlck5hdGl2ZSgnY2hhbmdlJyk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHJldHVybiB0aGlzLmNoYW5nZUFsbCh0cnVlKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgZGVzZWxlY3RBbGw6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICByZXR1cm4gdGhpcy5jaGFuZ2VBbGwoZmFsc2UpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICB0b2dnbGU6IGZ1bmN0aW9uIChlKSB7XFxyXFxuICAgICAgZSA9IGUgfHwgd2luZG93LmV2ZW50O1xcclxcblxcclxcbiAgICAgIGlmIChlKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xcclxcblxcclxcbiAgICAgIHRoaXMuJGJ1dHRvbi50cmlnZ2VyKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBrZXlkb3duOiBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXFxyXFxuICAgICAgICAgIGlzVG9nZ2xlID0gJHRoaXMuaGFzQ2xhc3MoJ2Ryb3Bkb3duLXRvZ2dsZScpLFxcclxcbiAgICAgICAgICAkcGFyZW50ID0gaXNUb2dnbGUgPyAkdGhpcy5jbG9zZXN0KCcuZHJvcGRvd24nKSA6ICR0aGlzLmNsb3Nlc3QoU2VsZWN0b3IuTUVOVSksXFxyXFxuICAgICAgICAgIHRoYXQgPSAkcGFyZW50LmRhdGEoJ3RoaXMnKSxcXHJcXG4gICAgICAgICAgJGl0ZW1zID0gdGhhdC5maW5kTGlzKCksXFxyXFxuICAgICAgICAgIGluZGV4LFxcclxcbiAgICAgICAgICBpc0FjdGl2ZSxcXHJcXG4gICAgICAgICAgbGlBY3RpdmUsXFxyXFxuICAgICAgICAgIGFjdGl2ZUxpLFxcclxcbiAgICAgICAgICBvZmZzZXQsXFxyXFxuICAgICAgICAgIHVwZGF0ZVNjcm9sbCA9IGZhbHNlLFxcclxcbiAgICAgICAgICBkb3duT25UYWIgPSBlLndoaWNoID09PSBrZXlDb2Rlcy5UQUIgJiYgIWlzVG9nZ2xlICYmICF0aGF0Lm9wdGlvbnMuc2VsZWN0T25UYWIsXFxyXFxuICAgICAgICAgIGlzQXJyb3dLZXkgPSBSRUdFWFBfQVJST1cudGVzdChlLndoaWNoKSB8fCBkb3duT25UYWIsXFxyXFxuICAgICAgICAgIHNjcm9sbFRvcCA9IHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AsXFxyXFxuICAgICAgICAgIGlzVmlydHVhbCA9IHRoYXQuaXNWaXJ0dWFsKCksXFxyXFxuICAgICAgICAgIHBvc2l0aW9uMCA9IGlzVmlydHVhbCA9PT0gdHJ1ZSA/IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcucG9zaXRpb24wIDogMDtcXHJcXG5cXHJcXG4gICAgICAvLyBkbyBub3RoaW5nIGlmIGEgZnVuY3Rpb24ga2V5IGlzIHByZXNzZWRcXHJcXG4gICAgICBpZiAoZS53aGljaCA+PSAxMTIgJiYgZS53aGljaCA8PSAxMjMpIHJldHVybjtcXHJcXG5cXHJcXG4gICAgICBpc0FjdGl2ZSA9IHRoYXQuJG5ld0VsZW1lbnQuaGFzQ2xhc3MoY2xhc3NOYW1lcy5TSE9XKTtcXHJcXG5cXHJcXG4gICAgICBpZiAoXFxyXFxuICAgICAgICAhaXNBY3RpdmUgJiZcXHJcXG4gICAgICAgIChcXHJcXG4gICAgICAgICAgaXNBcnJvd0tleSB8fFxcclxcbiAgICAgICAgICAoZS53aGljaCA+PSA0OCAmJiBlLndoaWNoIDw9IDU3KSB8fFxcclxcbiAgICAgICAgICAoZS53aGljaCA+PSA5NiAmJiBlLndoaWNoIDw9IDEwNSkgfHxcXHJcXG4gICAgICAgICAgKGUud2hpY2ggPj0gNjUgJiYgZS53aGljaCA8PSA5MClcXHJcXG4gICAgICAgIClcXHJcXG4gICAgICApIHtcXHJcXG4gICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScpO1xcclxcblxcclxcbiAgICAgICAgaWYgKHRoYXQub3B0aW9ucy5saXZlU2VhcmNoKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJHNlYXJjaGJveC50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgICByZXR1cm47XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmIChlLndoaWNoID09PSBrZXlDb2Rlcy5FU0NBUEUgJiYgaXNBY3RpdmUpIHtcXHJcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG4gICAgICAgIHRoYXQuJGJ1dHRvbi50cmlnZ2VyKCdjbGljay5icy5kcm9wZG93bi5kYXRhLWFwaScpLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIGlmIChpc0Fycm93S2V5KSB7IC8vIGlmIHVwIG9yIGRvd25cXHJcXG4gICAgICAgIGlmICghJGl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xcclxcblxcclxcbiAgICAgICAgbGlBY3RpdmUgPSB0aGF0LnNlbGVjdHBpY2tlci5tYWluLmVsZW1lbnRzW3RoYXQuYWN0aXZlSW5kZXhdO1xcclxcbiAgICAgICAgaW5kZXggPSBsaUFjdGl2ZSA/IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobGlBY3RpdmUucGFyZW50RWxlbWVudC5jaGlsZHJlbiwgbGlBY3RpdmUpIDogLTE7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XFxyXFxuICAgICAgICAgIHRoYXQuZGVmb2N1c0l0ZW0obGlBY3RpdmUpO1xcclxcbiAgICAgICAgfVxcclxcblxcclxcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX1VQKSB7IC8vIHVwXFxyXFxuICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIGluZGV4LS07XFxyXFxuICAgICAgICAgIGlmIChpbmRleCArIHBvc2l0aW9uMCA8IDApIGluZGV4ICs9ICRpdGVtcy5sZW5ndGg7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICghdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHRbaW5kZXggKyBwb3NpdGlvbjBdKSB7XFxyXFxuICAgICAgICAgICAgaW5kZXggPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5zbGljZSgwLCBpbmRleCArIHBvc2l0aW9uMCkubGFzdEluZGV4T2YodHJ1ZSkgLSBwb3NpdGlvbjA7XFxyXFxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgaW5kZXggPSAkaXRlbXMubGVuZ3RoIC0gMTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSBrZXlDb2Rlcy5BUlJPV19ET1dOIHx8IGRvd25PblRhYikgeyAvLyBkb3duXFxyXFxuICAgICAgICAgIGluZGV4Kys7XFxyXFxuICAgICAgICAgIGlmIChpbmRleCArIHBvc2l0aW9uMCA+PSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmNhbkhpZ2hsaWdodC5sZW5ndGgpIGluZGV4ID0gdGhhdC5zZWxlY3RwaWNrZXIudmlldy5maXJzdEhpZ2hsaWdodEluZGV4O1xcclxcblxcclxcbiAgICAgICAgICBpZiAoIXRoYXQuc2VsZWN0cGlja2VyLnZpZXcuY2FuSGlnaGxpZ2h0W2luZGV4ICsgcG9zaXRpb24wXSkge1xcclxcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxICsgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHQuc2xpY2UoaW5kZXggKyBwb3NpdGlvbjAgKyAxKS5pbmRleE9mKHRydWUpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuXFxyXFxuICAgICAgICB2YXIgbGlBY3RpdmVJbmRleCA9IHBvc2l0aW9uMCArIGluZGV4O1xcclxcblxcclxcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX1VQKSB7IC8vIHVwXFxyXFxuICAgICAgICAgIC8vIHNjcm9sbCB0byBib3R0b20gYW5kIGhpZ2hsaWdodCBsYXN0IG9wdGlvblxcclxcbiAgICAgICAgICBpZiAocG9zaXRpb24wID09PSAwICYmIGluZGV4ID09PSAkaXRlbXMubGVuZ3RoIC0gMSkge1xcclxcbiAgICAgICAgICAgIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSB0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsSGVpZ2h0O1xcclxcblxcclxcbiAgICAgICAgICAgIGxpQWN0aXZlSW5kZXggPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmVsZW1lbnRzLmxlbmd0aCAtIDE7XFxyXFxuICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgYWN0aXZlTGkgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbbGlBY3RpdmVJbmRleF07XFxyXFxuICAgICAgICAgICAgb2Zmc2V0ID0gYWN0aXZlTGkucG9zaXRpb24gLSBhY3RpdmVMaS5oZWlnaHQ7XFxyXFxuXFxyXFxuICAgICAgICAgICAgdXBkYXRlU2Nyb2xsID0gb2Zmc2V0IDwgc2Nyb2xsVG9wO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IGtleUNvZGVzLkFSUk9XX0RPV04gfHwgZG93bk9uVGFiKSB7IC8vIGRvd25cXHJcXG4gICAgICAgICAgLy8gc2Nyb2xsIHRvIHRvcCBhbmQgaGlnaGxpZ2h0IGZpcnN0IG9wdGlvblxcclxcbiAgICAgICAgICBpZiAoaW5kZXggPT09IHRoYXQuc2VsZWN0cGlja2VyLnZpZXcuZmlyc3RIaWdobGlnaHRJbmRleCkge1xcclxcbiAgICAgICAgICAgIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSAwO1xcclxcblxcclxcbiAgICAgICAgICAgIGxpQWN0aXZlSW5kZXggPSB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmZpcnN0SGlnaGxpZ2h0SW5kZXg7XFxyXFxuICAgICAgICAgIH0gZWxzZSB7XFxyXFxuICAgICAgICAgICAgYWN0aXZlTGkgPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbbGlBY3RpdmVJbmRleF07XFxyXFxuICAgICAgICAgICAgb2Zmc2V0ID0gYWN0aXZlTGkucG9zaXRpb24gLSB0aGF0LnNpemVJbmZvLm1lbnVJbm5lckhlaWdodDtcXHJcXG5cXHJcXG4gICAgICAgICAgICB1cGRhdGVTY3JvbGwgPSBvZmZzZXQgPiBzY3JvbGxUb3A7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIGxpQWN0aXZlID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5lbGVtZW50c1tsaUFjdGl2ZUluZGV4XTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuYWN0aXZlSW5kZXggPSB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGFbbGlBY3RpdmVJbmRleF0uaW5kZXg7XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LmZvY3VzSXRlbShsaUFjdGl2ZSk7XFxyXFxuXFxyXFxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci52aWV3LmN1cnJlbnRBY3RpdmUgPSBsaUFjdGl2ZTtcXHJcXG5cXHJcXG4gICAgICAgIGlmICh1cGRhdGVTY3JvbGwpIHRoYXQuJG1lbnVJbm5lclswXS5zY3JvbGxUb3AgPSBvZmZzZXQ7XFxyXFxuXFxyXFxuICAgICAgICBpZiAodGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgICAgdGhhdC4kc2VhcmNoYm94LnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH0gZWxzZSBpZiAoXFxyXFxuICAgICAgICAoISR0aGlzLmlzKCdpbnB1dCcpICYmICFSRUdFWFBfVEFCX09SX0VTQ0FQRS50ZXN0KGUud2hpY2gpKSB8fFxcclxcbiAgICAgICAgKGUud2hpY2ggPT09IGtleUNvZGVzLlNQQUNFICYmIHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeSlcXHJcXG4gICAgICApIHtcXHJcXG4gICAgICAgIHZhciBzZWFyY2hNYXRjaCxcXHJcXG4gICAgICAgICAgICBtYXRjaGVzID0gW10sXFxyXFxuICAgICAgICAgICAga2V5SGlzdG9yeTtcXHJcXG5cXHJcXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG5cXHJcXG4gICAgICAgIHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeSArPSBrZXlDb2RlTWFwW2Uud2hpY2hdO1xcclxcblxcclxcbiAgICAgICAgaWYgKHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ucmVzZXRLZXlIaXN0b3J5LmNhbmNlbCkgY2xlYXJUaW1lb3V0KHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ucmVzZXRLZXlIaXN0b3J5LmNhbmNlbCk7XFxyXFxuICAgICAgICB0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLnJlc2V0S2V5SGlzdG9yeS5jYW5jZWwgPSB0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLnJlc2V0S2V5SGlzdG9yeS5zdGFydCgpO1xcclxcblxcclxcbiAgICAgICAga2V5SGlzdG9yeSA9IHRoYXQuc2VsZWN0cGlja2VyLmtleWRvd24ua2V5SGlzdG9yeTtcXHJcXG5cXHJcXG4gICAgICAgIC8vIGlmIGFsbCBsZXR0ZXJzIGFyZSB0aGUgc2FtZSwgc2V0IGtleUhpc3RvcnkgdG8ganVzdCB0aGUgZmlyc3QgY2hhcmFjdGVyIHdoZW4gc2VhcmNoaW5nXFxyXFxuICAgICAgICBpZiAoL14oLilcXFxcMSskLy50ZXN0KGtleUhpc3RvcnkpKSB7XFxyXFxuICAgICAgICAgIGtleUhpc3RvcnkgPSBrZXlIaXN0b3J5LmNoYXJBdCgwKTtcXHJcXG4gICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgIC8vIGZpbmQgbWF0Y2hlc1xcclxcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0LnNlbGVjdHBpY2tlci5jdXJyZW50LmRhdGEubGVuZ3RoOyBpKyspIHtcXHJcXG4gICAgICAgICAgdmFyIGxpID0gdGhhdC5zZWxlY3RwaWNrZXIuY3VycmVudC5kYXRhW2ldLFxcclxcbiAgICAgICAgICAgICAgaGFzTWF0Y2g7XFxyXFxuXFxyXFxuICAgICAgICAgIGhhc01hdGNoID0gc3RyaW5nU2VhcmNoKGxpLCBrZXlIaXN0b3J5LCAnc3RhcnRzV2l0aCcsIHRydWUpO1xcclxcblxcclxcbiAgICAgICAgICBpZiAoaGFzTWF0Y2ggJiYgdGhhdC5zZWxlY3RwaWNrZXIudmlldy5jYW5IaWdobGlnaHRbaV0pIHtcXHJcXG4gICAgICAgICAgICBtYXRjaGVzLnB1c2gobGkuaW5kZXgpO1xcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGgpIHtcXHJcXG4gICAgICAgICAgdmFyIG1hdGNoSW5kZXggPSAwO1xcclxcblxcclxcbiAgICAgICAgICAkaXRlbXMucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpLmZpbmQoJ2EnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XFxyXFxuXFxyXFxuICAgICAgICAgIC8vIGVpdGhlciBvbmx5IG9uZSBrZXkgaGFzIGJlZW4gcHJlc3NlZCBvciB0aGV5IGFyZSBhbGwgdGhlIHNhbWUga2V5XFxyXFxuICAgICAgICAgIGlmIChrZXlIaXN0b3J5Lmxlbmd0aCA9PT0gMSkge1xcclxcbiAgICAgICAgICAgIG1hdGNoSW5kZXggPSBtYXRjaGVzLmluZGV4T2YodGhhdC5hY3RpdmVJbmRleCk7XFxyXFxuXFxyXFxuICAgICAgICAgICAgaWYgKG1hdGNoSW5kZXggPT09IC0xIHx8IG1hdGNoSW5kZXggPT09IG1hdGNoZXMubGVuZ3RoIC0gMSkge1xcclxcbiAgICAgICAgICAgICAgbWF0Y2hJbmRleCA9IDA7XFxyXFxuICAgICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICAgIG1hdGNoSW5kZXgrKztcXHJcXG4gICAgICAgICAgICB9XFxyXFxuICAgICAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAgICAgc2VhcmNoTWF0Y2ggPSBtYXRjaGVzW21hdGNoSW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgICBhY3RpdmVMaSA9IHRoYXQuc2VsZWN0cGlja2VyLm1haW4uZGF0YVtzZWFyY2hNYXRjaF07XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChzY3JvbGxUb3AgLSBhY3RpdmVMaS5wb3NpdGlvbiA+IDApIHtcXHJcXG4gICAgICAgICAgICBvZmZzZXQgPSBhY3RpdmVMaS5wb3NpdGlvbiAtIGFjdGl2ZUxpLmhlaWdodDtcXHJcXG4gICAgICAgICAgICB1cGRhdGVTY3JvbGwgPSB0cnVlO1xcclxcbiAgICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICAgIG9mZnNldCA9IGFjdGl2ZUxpLnBvc2l0aW9uIC0gdGhhdC5zaXplSW5mby5tZW51SW5uZXJIZWlnaHQ7XFxyXFxuICAgICAgICAgICAgLy8gaWYgdGhlIG9wdGlvbiBpcyBhbHJlYWR5IHZpc2libGUgYXQgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uLCBqdXN0IGtlZXAgaXQgdGhlIHNhbWVcXHJcXG4gICAgICAgICAgICB1cGRhdGVTY3JvbGwgPSBhY3RpdmVMaS5wb3NpdGlvbiA+IHNjcm9sbFRvcCArIHRoYXQuc2l6ZUluZm8ubWVudUlubmVySGVpZ2h0O1xcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIGxpQWN0aXZlID0gdGhhdC5zZWxlY3RwaWNrZXIubWFpbi5lbGVtZW50c1tzZWFyY2hNYXRjaF07XFxyXFxuXFxyXFxuICAgICAgICAgIHRoYXQuYWN0aXZlSW5kZXggPSBtYXRjaGVzW21hdGNoSW5kZXhdO1xcclxcblxcclxcbiAgICAgICAgICB0aGF0LmZvY3VzSXRlbShsaUFjdGl2ZSk7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmIChsaUFjdGl2ZSkgbGlBY3RpdmUuZmlyc3RDaGlsZC5mb2N1cygpO1xcclxcblxcclxcbiAgICAgICAgICBpZiAodXBkYXRlU2Nyb2xsKSB0aGF0LiRtZW51SW5uZXJbMF0uc2Nyb2xsVG9wID0gb2Zmc2V0O1xcclxcblxcclxcbiAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdmb2N1cycpO1xcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG5cXHJcXG4gICAgICAvLyBTZWxlY3QgZm9jdXNlZCBvcHRpb24gaWYgXFxcIkVudGVyXFxcIiwgXFxcIlNwYWNlYmFyXFxcIiBvciBcXFwiVGFiXFxcIiAod2hlbiBzZWxlY3RPblRhYiBpcyB0cnVlKSBhcmUgcHJlc3NlZCBpbnNpZGUgdGhlIG1lbnUuXFxyXFxuICAgICAgaWYgKFxcclxcbiAgICAgICAgaXNBY3RpdmUgJiZcXHJcXG4gICAgICAgIChcXHJcXG4gICAgICAgICAgKGUud2hpY2ggPT09IGtleUNvZGVzLlNQQUNFICYmICF0aGF0LnNlbGVjdHBpY2tlci5rZXlkb3duLmtleUhpc3RvcnkpIHx8XFxyXFxuICAgICAgICAgIGUud2hpY2ggPT09IGtleUNvZGVzLkVOVEVSIHx8XFxyXFxuICAgICAgICAgIChlLndoaWNoID09PSBrZXlDb2Rlcy5UQUIgJiYgdGhhdC5vcHRpb25zLnNlbGVjdE9uVGFiKVxcclxcbiAgICAgICAgKVxcclxcbiAgICAgICkge1xcclxcbiAgICAgICAgaWYgKGUud2hpY2ggIT09IGtleUNvZGVzLlNQQUNFKSBlLnByZXZlbnREZWZhdWx0KCk7XFxyXFxuXFxyXFxuICAgICAgICBpZiAoIXRoYXQub3B0aW9ucy5saXZlU2VhcmNoIHx8IGUud2hpY2ggIT09IGtleUNvZGVzLlNQQUNFKSB7XFxyXFxuICAgICAgICAgIHRoYXQuJG1lbnVJbm5lci5maW5kKCcuYWN0aXZlIGEnKS50cmlnZ2VyKCdjbGljaycsIHRydWUpOyAvLyByZXRhaW4gYWN0aXZlIGNsYXNzXFxyXFxuICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2ZvY3VzJyk7XFxyXFxuXFxyXFxuICAgICAgICAgIGlmICghdGhhdC5vcHRpb25zLmxpdmVTZWFyY2gpIHtcXHJcXG4gICAgICAgICAgICAvLyBQcmV2ZW50IHNjcmVlbiBmcm9tIHNjcm9sbGluZyBpZiB0aGUgdXNlciBoaXRzIHRoZSBzcGFjZWJhclxcclxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXHJcXG4gICAgICAgICAgICAvLyBGaXhlcyBzcGFjZWJhciBzZWxlY3Rpb24gb2YgZHJvcGRvd24gaXRlbXMgaW4gRkYgJiBJRVxcclxcbiAgICAgICAgICAgICQoZG9jdW1lbnQpLmRhdGEoJ3NwYWNlU2VsZWN0JywgdHJ1ZSk7XFxyXFxuICAgICAgICAgIH1cXHJcXG4gICAgICAgIH1cXHJcXG4gICAgICB9XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIG1vYmlsZTogZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIC8vIGVuc3VyZSBtb2JpbGUgaXMgc2V0IHRvIHRydWUgaWYgbW9iaWxlIGZ1bmN0aW9uIGlzIGNhbGxlZCBhZnRlciBpbml0XFxyXFxuICAgICAgdGhpcy5vcHRpb25zLm1vYmlsZSA9IHRydWU7XFxyXFxuICAgICAgdGhpcy4kZWxlbWVudFswXS5jbGFzc0xpc3QuYWRkKCdtb2JpbGUtZGV2aWNlJyk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICAvLyB1cGRhdGUgb3B0aW9ucyBpZiBkYXRhIGF0dHJpYnV0ZXMgaGF2ZSBiZWVuIGNoYW5nZWRcXHJcXG4gICAgICB2YXIgY29uZmlnID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgdGhpcy4kZWxlbWVudC5kYXRhKCkpO1xcclxcbiAgICAgIHRoaXMub3B0aW9ucyA9IGNvbmZpZztcXHJcXG5cXHJcXG4gICAgICB0aGlzLmNoZWNrRGlzYWJsZWQoKTtcXHJcXG4gICAgICB0aGlzLmJ1aWxkRGF0YSgpO1xcclxcbiAgICAgIHRoaXMuc2V0U3R5bGUoKTtcXHJcXG4gICAgICB0aGlzLnJlbmRlcigpO1xcclxcbiAgICAgIHRoaXMuYnVpbGRMaXN0KCk7XFxyXFxuICAgICAgdGhpcy5zZXRXaWR0aCgpO1xcclxcblxcclxcbiAgICAgIHRoaXMuc2V0U2l6ZSh0cnVlKTtcXHJcXG5cXHJcXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3JlZnJlc2hlZCcgKyBFVkVOVF9LRVkpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBoaWRlOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdGhpcy4kbmV3RWxlbWVudC5oaWRlKCk7XFxyXFxuICAgIH0sXFxyXFxuXFxyXFxuICAgIHNob3c6IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgICB0aGlzLiRuZXdFbGVtZW50LnNob3coKTtcXHJcXG4gICAgfSxcXHJcXG5cXHJcXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdGhpcy4kbmV3RWxlbWVudC5yZW1vdmUoKTtcXHJcXG4gICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZSgpO1xcclxcbiAgICB9LFxcclxcblxcclxcbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdGhpcy4kbmV3RWxlbWVudC5iZWZvcmUodGhpcy4kZWxlbWVudCkucmVtb3ZlKCk7XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMuJGJzQ29udGFpbmVyKSB7XFxyXFxuICAgICAgICB0aGlzLiRic0NvbnRhaW5lci5yZW1vdmUoKTtcXHJcXG4gICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgdGhpcy4kbWVudS5yZW1vdmUoKTtcXHJcXG4gICAgICB9XFxyXFxuXFxyXFxuICAgICAgaWYgKHRoaXMuc2VsZWN0cGlja2VyLnZpZXcudGl0bGVPcHRpb24gJiYgdGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbi5wYXJlbnROb2RlKSB7XFxyXFxuICAgICAgICB0aGlzLnNlbGVjdHBpY2tlci52aWV3LnRpdGxlT3B0aW9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zZWxlY3RwaWNrZXIudmlldy50aXRsZU9wdGlvbik7XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHRoaXMuJGVsZW1lbnRcXHJcXG4gICAgICAgIC5vZmYoRVZFTlRfS0VZKVxcclxcbiAgICAgICAgLnJlbW92ZURhdGEoJ3NlbGVjdHBpY2tlcicpXFxyXFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ2JzLXNlbGVjdC1oaWRkZW4gc2VsZWN0cGlja2VyJyk7XFxyXFxuXFxyXFxuICAgICAgJCh3aW5kb3cpLm9mZihFVkVOVF9LRVkgKyAnLicgKyB0aGlzLnNlbGVjdElkKTtcXHJcXG4gICAgfVxcclxcbiAgfTtcXHJcXG5cXHJcXG4gIC8vIFNFTEVDVFBJQ0tFUiBQTFVHSU4gREVGSU5JVElPTlxcclxcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XFxyXFxuICBmdW5jdGlvbiBQbHVnaW4gKG9wdGlvbikge1xcclxcbiAgICAvLyBnZXQgdGhlIGFyZ3Mgb2YgdGhlIG91dGVyIGZ1bmN0aW9uLi5cXHJcXG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxyXFxuICAgIC8vIFRoZSBhcmd1bWVudHMgb2YgdGhlIGZ1bmN0aW9uIGFyZSBleHBsaWNpdGx5IHJlLWRlZmluZWQgZnJvbSB0aGUgYXJndW1lbnQgbGlzdCwgYmVjYXVzZSB0aGUgc2hpZnQgY2F1c2VzIHRoZW1cXHJcXG4gICAgLy8gdG8gZ2V0IGxvc3QvY29ycnVwdGVkIGluIGFuZHJvaWQgMi4zIGFuZCBJRTkgIzcxNSAjNzc1XFxyXFxuICAgIHZhciBfb3B0aW9uID0gb3B0aW9uO1xcclxcblxcclxcbiAgICBbXS5zaGlmdC5hcHBseShhcmdzKTtcXHJcXG5cXHJcXG4gICAgLy8gaWYgdGhlIHZlcnNpb24gd2FzIG5vdCBzZXQgc3VjY2Vzc2Z1bGx5XFxyXFxuICAgIGlmICghdmVyc2lvbi5zdWNjZXNzKSB7XFxyXFxuICAgICAgLy8gdHJ5IHRvIHJldHJlaXZlIGl0IGFnYWluXFxyXFxuICAgICAgdHJ5IHtcXHJcXG4gICAgICAgIHZlcnNpb24uZnVsbCA9ICgkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLlZFUlNJT04gfHwgJycpLnNwbGl0KCcgJylbMF0uc3BsaXQoJy4nKTtcXHJcXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXHJcXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB1c2UgQm9vdHN0cmFwVmVyc2lvbiBpZiBzZXRcXHJcXG4gICAgICAgIGlmIChTZWxlY3RwaWNrZXIuQm9vdHN0cmFwVmVyc2lvbikge1xcclxcbiAgICAgICAgICB2ZXJzaW9uLmZ1bGwgPSBTZWxlY3RwaWNrZXIuQm9vdHN0cmFwVmVyc2lvbi5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJyk7XFxyXFxuICAgICAgICB9IGVsc2Uge1xcclxcbiAgICAgICAgICB2ZXJzaW9uLmZ1bGwgPSBbdmVyc2lvbi5tYWpvciwgJzAnLCAnMCddO1xcclxcblxcclxcbiAgICAgICAgICBjb25zb2xlLndhcm4oXFxyXFxuICAgICAgICAgICAgJ1RoZXJlIHdhcyBhbiBpc3N1ZSByZXRyaWV2aW5nIEJvb3RzdHJhcFxcXFwncyB2ZXJzaW9uLiAnICtcXHJcXG4gICAgICAgICAgICAnRW5zdXJlIEJvb3RzdHJhcCBpcyBiZWluZyBsb2FkZWQgYmVmb3JlIGJvb3RzdHJhcC1zZWxlY3QgYW5kIHRoZXJlIGlzIG5vIG5hbWVzcGFjZSBjb2xsaXNpb24uICcgK1xcclxcbiAgICAgICAgICAgICdJZiBsb2FkaW5nIEJvb3RzdHJhcCBhc3luY2hyb25vdXNseSwgdGhlIHZlcnNpb24gbWF5IG5lZWQgdG8gYmUgbWFudWFsbHkgc3BlY2lmaWVkIHZpYSAkLmZuLnNlbGVjdHBpY2tlci5Db25zdHJ1Y3Rvci5Cb290c3RyYXBWZXJzaW9uLicsXFxyXFxuICAgICAgICAgICAgZXJyXFxyXFxuICAgICAgICAgICk7XFxyXFxuICAgICAgICB9XFxyXFxuICAgICAgfVxcclxcblxcclxcbiAgICAgIHZlcnNpb24ubWFqb3IgPSB2ZXJzaW9uLmZ1bGxbMF07XFxyXFxuICAgICAgdmVyc2lvbi5zdWNjZXNzID0gdHJ1ZTtcXHJcXG4gICAgfVxcclxcblxcclxcbiAgICBpZiAodmVyc2lvbi5tYWpvciA9PT0gJzQnKSB7XFxyXFxuICAgICAgLy8gc29tZSBkZWZhdWx0cyBuZWVkIHRvIGJlIGNoYW5nZWQgaWYgdXNpbmcgQm9vdHN0cmFwIDRcXHJcXG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhleSBoYXZlIGFscmVhZHkgYmVlbiBtYW51YWxseSBjaGFuZ2VkIGJlZm9yZSBmb3JjaW5nIHRoZW0gdG8gdXBkYXRlXFxyXFxuICAgICAgdmFyIHRvVXBkYXRlID0gW107XFxyXFxuXFxyXFxuICAgICAgaWYgKFNlbGVjdHBpY2tlci5ERUZBVUxUUy5zdHlsZSA9PT0gY2xhc3NOYW1lcy5CVVRUT05DTEFTUykgdG9VcGRhdGUucHVzaCh7IG5hbWU6ICdzdHlsZScsIGNsYXNzTmFtZTogJ0JVVFRPTkNMQVNTJyB9KTtcXHJcXG4gICAgICBpZiAoU2VsZWN0cGlja2VyLkRFRkFVTFRTLmljb25CYXNlID09PSBjbGFzc05hbWVzLklDT05CQVNFKSB0b1VwZGF0ZS5wdXNoKHsgbmFtZTogJ2ljb25CYXNlJywgY2xhc3NOYW1lOiAnSUNPTkJBU0UnIH0pO1xcclxcbiAgICAgIGlmIChTZWxlY3RwaWNrZXIuREVGQVVMVFMudGlja0ljb24gPT09IGNsYXNzTmFtZXMuVElDS0lDT04pIHRvVXBkYXRlLnB1c2goeyBuYW1lOiAndGlja0ljb24nLCBjbGFzc05hbWU6ICdUSUNLSUNPTicgfSk7XFxyXFxuXFxyXFxuICAgICAgY2xhc3NOYW1lcy5ESVZJREVSID0gJ2Ryb3Bkb3duLWRpdmlkZXInO1xcclxcbiAgICAgIGNsYXNzTmFtZXMuU0hPVyA9ICdzaG93JztcXHJcXG4gICAgICBjbGFzc05hbWVzLkJVVFRPTkNMQVNTID0gJ2J0bi1saWdodCc7XFxyXFxuICAgICAgY2xhc3NOYW1lcy5QT1BPVkVSSEVBREVSID0gJ3BvcG92ZXItaGVhZGVyJztcXHJcXG4gICAgICBjbGFzc05hbWVzLklDT05CQVNFID0gJyc7XFxyXFxuICAgICAgY2xhc3NOYW1lcy5USUNLSUNPTiA9ICdicy1vay1kZWZhdWx0JztcXHJcXG5cXHJcXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvVXBkYXRlLmxlbmd0aDsgaSsrKSB7XFxyXFxuICAgICAgICB2YXIgb3B0aW9uID0gdG9VcGRhdGVbaV07XFxyXFxuICAgICAgICBTZWxlY3RwaWNrZXIuREVGQVVMVFNbb3B0aW9uLm5hbWVdID0gY2xhc3NOYW1lc1tvcHRpb24uY2xhc3NOYW1lXTtcXHJcXG4gICAgICB9XFxyXFxuICAgIH1cXHJcXG5cXHJcXG4gICAgdmFyIHZhbHVlO1xcclxcbiAgICB2YXIgY2hhaW4gPSB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcclxcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XFxyXFxuICAgICAgaWYgKCR0aGlzLmlzKCdzZWxlY3QnKSkge1xcclxcbiAgICAgICAgdmFyIGRhdGEgPSAkdGhpcy5kYXRhKCdzZWxlY3RwaWNrZXInKSxcXHJcXG4gICAgICAgICAgICBvcHRpb25zID0gdHlwZW9mIF9vcHRpb24gPT0gJ29iamVjdCcgJiYgX29wdGlvbjtcXHJcXG5cXHJcXG4gICAgICAgIGlmICghZGF0YSkge1xcclxcbiAgICAgICAgICB2YXIgZGF0YUF0dHJpYnV0ZXMgPSAkdGhpcy5kYXRhKCk7XFxyXFxuXFxyXFxuICAgICAgICAgIGZvciAodmFyIGRhdGFBdHRyIGluIGRhdGFBdHRyaWJ1dGVzKSB7XFxyXFxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhQXR0cmlidXRlcywgZGF0YUF0dHIpICYmICQuaW5BcnJheShkYXRhQXR0ciwgRElTQUxMT1dFRF9BVFRSSUJVVEVTKSAhPT0gLTEpIHtcXHJcXG4gICAgICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cl07XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICAgIHZhciBjb25maWcgPSAkLmV4dGVuZCh7fSwgU2VsZWN0cGlja2VyLkRFRkFVTFRTLCAkLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cyB8fCB7fSwgZGF0YUF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xcclxcbiAgICAgICAgICBjb25maWcudGVtcGxhdGUgPSAkLmV4dGVuZCh7fSwgU2VsZWN0cGlja2VyLkRFRkFVTFRTLnRlbXBsYXRlLCAoJC5mbi5zZWxlY3RwaWNrZXIuZGVmYXVsdHMgPyAkLmZuLnNlbGVjdHBpY2tlci5kZWZhdWx0cy50ZW1wbGF0ZSA6IHt9KSwgZGF0YUF0dHJpYnV0ZXMudGVtcGxhdGUsIG9wdGlvbnMudGVtcGxhdGUpO1xcclxcbiAgICAgICAgICAkdGhpcy5kYXRhKCdzZWxlY3RwaWNrZXInLCAoZGF0YSA9IG5ldyBTZWxlY3RwaWNrZXIodGhpcywgY29uZmlnKSkpO1xcclxcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zKSB7XFxyXFxuICAgICAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xcclxcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgaSkpIHtcXHJcXG4gICAgICAgICAgICAgIGRhdGEub3B0aW9uc1tpXSA9IG9wdGlvbnNbaV07XFxyXFxuICAgICAgICAgICAgfVxcclxcbiAgICAgICAgICB9XFxyXFxuICAgICAgICB9XFxyXFxuXFxyXFxuICAgICAgICBpZiAodHlwZW9mIF9vcHRpb24gPT0gJ3N0cmluZycpIHtcXHJcXG4gICAgICAgICAgaWYgKGRhdGFbX29wdGlvbl0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xcclxcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YVtfb3B0aW9uXS5hcHBseShkYXRhLCBhcmdzKTtcXHJcXG4gICAgICAgICAgfSBlbHNlIHtcXHJcXG4gICAgICAgICAgICB2YWx1ZSA9IGRhdGEub3B0aW9uc1tfb3B0aW9uXTtcXHJcXG4gICAgICAgICAgfVxcclxcbiAgICAgICAgfVxcclxcbiAgICAgIH1cXHJcXG4gICAgfSk7XFxyXFxuXFxyXFxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XFxyXFxuICAgICAgLy8gbm9pbnNwZWN0aW9uIEpTVW51c2VkQXNzaWdubWVudFxcclxcbiAgICAgIHJldHVybiB2YWx1ZTtcXHJcXG4gICAgfSBlbHNlIHtcXHJcXG4gICAgICByZXR1cm4gY2hhaW47XFxyXFxuICAgIH1cXHJcXG4gIH1cXHJcXG5cXHJcXG4gIHZhciBvbGQgPSAkLmZuLnNlbGVjdHBpY2tlcjtcXHJcXG4gICQuZm4uc2VsZWN0cGlja2VyID0gUGx1Z2luO1xcclxcbiAgJC5mbi5zZWxlY3RwaWNrZXIuQ29uc3RydWN0b3IgPSBTZWxlY3RwaWNrZXI7XFxyXFxuXFxyXFxuICAvLyBTRUxFQ1RQSUNLRVIgTk8gQ09ORkxJQ1RcXHJcXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxcclxcbiAgJC5mbi5zZWxlY3RwaWNrZXIubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcXHJcXG4gICAgJC5mbi5zZWxlY3RwaWNrZXIgPSBvbGQ7XFxyXFxuICAgIHJldHVybiB0aGlzO1xcclxcbiAgfTtcXHJcXG5cXHJcXG4gIC8vIGdldCBCb290c3RyYXAncyBrZXlkb3duIGV2ZW50IGhhbmRsZXIgZm9yIGVpdGhlciBCb290c3RyYXAgNCBvciBCb290c3RyYXAgM1xcclxcbiAgZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIgKCkge1xcclxcbiAgICBpZiAoJC5mbi5kcm9wZG93bikge1xcclxcbiAgICAgIC8vIHdhaXQgdG8gZGVmaW5lIHVudGlsIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbiBjYXNlIEJvb3RzdHJhcCBpc24ndCBsb2FkZWQgeWV0XFxyXFxuICAgICAgdmFyIGJvb3RzdHJhcEtleWRvd24gPSAkLmZuLmRyb3Bkb3duLkNvbnN0cnVjdG9yLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIgfHwgJC5mbi5kcm9wZG93bi5Db25zdHJ1Y3Rvci5wcm90b3R5cGUua2V5ZG93bjtcXHJcXG4gICAgICByZXR1cm4gYm9vdHN0cmFwS2V5ZG93bi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcclxcbiAgICB9XFxyXFxuICB9XFxyXFxuXFxyXFxuICAkKGRvY3VtZW50KVxcclxcbiAgICAub2ZmKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJylcXHJcXG4gICAgLm9uKCdrZXlkb3duLmJzLmRyb3Bkb3duLmRhdGEtYXBpJywgJzpub3QoLmJvb3RzdHJhcC1zZWxlY3QpID4gW2RhdGEtdG9nZ2xlPVxcXCJkcm9wZG93blxcXCJdJywga2V5ZG93bkhhbmRsZXIpXFxyXFxuICAgIC5vbigna2V5ZG93bi5icy5kcm9wZG93bi5kYXRhLWFwaScsICc6bm90KC5ib290c3RyYXAtc2VsZWN0KSA+IC5kcm9wZG93bi1tZW51Jywga2V5ZG93bkhhbmRsZXIpXFxyXFxuICAgIC5vbigna2V5ZG93bicgKyBFVkVOVF9LRVksICcuYm9vdHN0cmFwLXNlbGVjdCBbZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIl0sIC5ib290c3RyYXAtc2VsZWN0IFtyb2xlPVxcXCJsaXN0Ym94XFxcIl0sIC5ib290c3RyYXAtc2VsZWN0IC5icy1zZWFyY2hib3ggaW5wdXQnLCBTZWxlY3RwaWNrZXIucHJvdG90eXBlLmtleWRvd24pXFxyXFxuICAgIC5vbignZm9jdXNpbi5tb2RhbCcsICcuYm9vdHN0cmFwLXNlbGVjdCBbZGF0YS10b2dnbGU9XFxcImRyb3Bkb3duXFxcIl0sIC5ib290c3RyYXAtc2VsZWN0IFtyb2xlPVxcXCJsaXN0Ym94XFxcIl0sIC5ib290c3RyYXAtc2VsZWN0IC5icy1zZWFyY2hib3ggaW5wdXQnLCBmdW5jdGlvbiAoZSkge1xcclxcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxyXFxuICAgIH0pO1xcclxcblxcclxcbiAgLy8gU0VMRUNUUElDS0VSIERBVEEtQVBJXFxyXFxuICAvLyA9PT09PT09PT09PT09PT09PT09PT1cXHJcXG4gICQod2luZG93KS5vbignbG9hZCcgKyBFVkVOVF9LRVkgKyAnLmRhdGEtYXBpJywgZnVuY3Rpb24gKCkge1xcclxcbiAgICAkKCcuc2VsZWN0cGlja2VyJykuZWFjaChmdW5jdGlvbiAoKSB7XFxyXFxuICAgICAgdmFyICRzZWxlY3RwaWNrZXIgPSAkKHRoaXMpO1xcclxcbiAgICAgIFBsdWdpbi5jYWxsKCRzZWxlY3RwaWNrZXIsICRzZWxlY3RwaWNrZXIuZGF0YSgpKTtcXHJcXG4gICAgfSlcXHJcXG4gIH0pO1xcclxcbn0pKGpRdWVyeSk7XFxyXFxuXFxyXFxuXFxyXFxufSkpO1xcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAgKiBCb290c3RyYXAgdjUuMi4wIChodHRwczovL2dldGJvb3RzdHJhcC5jb20vKVxcbiAgKiBDb3B5cmlnaHQgMjAxMS0yMDIyIFRoZSBCb290c3RyYXAgQXV0aG9ycyAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2dyYXBocy9jb250cmlidXRvcnMpXFxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgKi9cXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ0Bwb3BwZXJqcy9jb3JlJykpIDpcXG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ0Bwb3BwZXJqcy9jb3JlJ10sIGZhY3RvcnkpIDpcXG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5ib290c3RyYXAgPSBmYWN0b3J5KGdsb2JhbC5Qb3BwZXIpKTtcXG59KSh0aGlzLCAoZnVuY3Rpb24gKFBvcHBlcikgeyAndXNlIHN0cmljdCc7XFxuXFxuICBmdW5jdGlvbiBfaW50ZXJvcE5hbWVzcGFjZShlKSB7XFxuICAgIGlmIChlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XFxuICAgIGNvbnN0IG4gPSBPYmplY3QuY3JlYXRlKG51bGwsIHsgW1N5bWJvbC50b1N0cmluZ1RhZ106IHsgdmFsdWU6ICdNb2R1bGUnIH0gfSk7XFxuICAgIGlmIChlKSB7XFxuICAgICAgZm9yIChjb25zdCBrIGluIGUpIHtcXG4gICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcXG4gICAgICAgICAgY29uc3QgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XFxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcXG4gICAgICAgICAgICBnZXQ6ICgpID0+IGVba11cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuICAgIG4uZGVmYXVsdCA9IGU7XFxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xcbiAgfVxcblxcbiAgY29uc3QgUG9wcGVyX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoUG9wcGVyKTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogdXRpbC9pbmRleC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICBjb25zdCBNQVhfVUlEID0gMTAwMDAwMDtcXG4gIGNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcXG4gIGNvbnN0IFRSQU5TSVRJT05fRU5EID0gJ3RyYW5zaXRpb25lbmQnOyAvLyBTaG91dC1vdXQgQW5ndXMgQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcXG5cXG4gIGNvbnN0IHRvVHlwZSA9IG9iamVjdCA9PiB7XFxuICAgIGlmIChvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm4gYCR7b2JqZWN0fWA7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpLm1hdGNoKC9cXFxccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XFxuICB9O1xcbiAgLyoqXFxuICAgKiBQdWJsaWMgVXRpbCBBUElcXG4gICAqL1xcblxcblxcbiAgY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcXG4gICAgZG8ge1xcbiAgICAgIHByZWZpeCArPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKTtcXG4gICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XFxuXFxuICAgIHJldHVybiBwcmVmaXg7XFxuICB9O1xcblxcbiAgY29uc3QgZ2V0U2VsZWN0b3IgPSBlbGVtZW50ID0+IHtcXG4gICAgbGV0IHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtdGFyZ2V0Jyk7XFxuXFxuICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xcbiAgICAgIGxldCBocmVmQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTsgLy8gVGhlIG9ubHkgdmFsaWQgY29udGVudCB0aGF0IGNvdWxkIGRvdWJsZSBhcyBhIHNlbGVjdG9yIGFyZSBJRHMgb3IgY2xhc3NlcyxcXG4gICAgICAvLyBzbyBldmVyeXRoaW5nIHN0YXJ0aW5nIHdpdGggYCNgIG9yIGAuYC4gSWYgYSBcXFwicmVhbFxcXCIgVVJMIGlzIHVzZWQgYXMgdGhlIHNlbGVjdG9yLFxcbiAgICAgIC8vIGBkb2N1bWVudC5xdWVyeVNlbGVjdG9yYCB3aWxsIHJpZ2h0ZnVsbHkgY29tcGxhaW4gaXQgaXMgaW52YWxpZC5cXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8zMjI3M1xcblxcbiAgICAgIGlmICghaHJlZkF0dHJpYnV0ZSB8fCAhaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJy4nKSkge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgfSAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcXG5cXG5cXG4gICAgICBpZiAoaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJyMnKSkge1xcbiAgICAgICAgaHJlZkF0dHJpYnV0ZSA9IGAjJHtocmVmQXR0cmlidXRlLnNwbGl0KCcjJylbMV19YDtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZWN0b3IgPSBocmVmQXR0cmlidXRlICYmIGhyZWZBdHRyaWJ1dGUgIT09ICcjJyA/IGhyZWZBdHRyaWJ1dGUudHJpbSgpIDogbnVsbDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gc2VsZWN0b3I7XFxuICB9O1xcblxcbiAgY29uc3QgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCA9IGVsZW1lbnQgPT4ge1xcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xcblxcbiAgICBpZiAoc2VsZWN0b3IpIHtcXG4gICAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcikgPyBzZWxlY3RvciA6IG51bGw7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcblxcbiAgY29uc3QgZ2V0RWxlbWVudEZyb21TZWxlY3RvciA9IGVsZW1lbnQgPT4ge1xcbiAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IG51bGw7XFxuICB9O1xcblxcbiAgY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcXG4gICAgaWYgKCFlbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIDA7XFxuICAgIH0gLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcXG5cXG5cXG4gICAgbGV0IHtcXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24sXFxuICAgICAgdHJhbnNpdGlvbkRlbGF5XFxuICAgIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcXG4gICAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pO1xcbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EZWxheSA9IE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcXG5cXG4gICAgaWYgKCFmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiAmJiAhZmxvYXRUcmFuc2l0aW9uRGVsYXkpIHtcXG4gICAgICByZXR1cm4gMDtcXG4gICAgfSAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XFxuXFxuXFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdO1xcbiAgICB0cmFuc2l0aW9uRGVsYXkgPSB0cmFuc2l0aW9uRGVsYXkuc3BsaXQoJywnKVswXTtcXG4gICAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcXG4gIH07XFxuXFxuICBjb25zdCB0cmlnZ2VyVHJhbnNpdGlvbkVuZCA9IGVsZW1lbnQgPT4ge1xcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XFxuICB9O1xcblxcbiAgY29uc3QgaXNFbGVtZW50ID0gb2JqZWN0ID0+IHtcXG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBvYmplY3QuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIG9iamVjdCA9IG9iamVjdFswXTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdC5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XFxuICB9O1xcblxcbiAgY29uc3QgZ2V0RWxlbWVudCA9IG9iamVjdCA9PiB7XFxuICAgIC8vIGl0J3MgYSBqUXVlcnkgb2JqZWN0IG9yIGEgbm9kZSBlbGVtZW50XFxuICAgIGlmIChpc0VsZW1lbnQob2JqZWN0KSkge1xcbiAgICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0O1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyAmJiBvYmplY3QubGVuZ3RoID4gMCkge1xcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9iamVjdCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG51bGw7XFxuICB9O1xcblxcbiAgY29uc3QgaXNWaXNpYmxlID0gZWxlbWVudCA9PiB7XFxuICAgIGlmICghaXNFbGVtZW50KGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7IC8vIEhhbmRsZSBgZGV0YWlsc2AgZWxlbWVudCBhcyBpdHMgY29udGVudCBtYXkgZmFsc2llIGFwcGVhciB2aXNpYmxlIHdoZW4gaXQgaXMgY2xvc2VkXFxuXFxuICAgIGNvbnN0IGNsb3NlZERldGFpbHMgPSBlbGVtZW50LmNsb3Nlc3QoJ2RldGFpbHM6bm90KFtvcGVuXSknKTtcXG5cXG4gICAgaWYgKCFjbG9zZWREZXRhaWxzKSB7XFxuICAgICAgcmV0dXJuIGVsZW1lbnRJc1Zpc2libGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKGNsb3NlZERldGFpbHMgIT09IGVsZW1lbnQpIHtcXG4gICAgICBjb25zdCBzdW1tYXJ5ID0gZWxlbWVudC5jbG9zZXN0KCdzdW1tYXJ5Jyk7XFxuXFxuICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChzdW1tYXJ5ID09PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xcbiAgfTtcXG5cXG4gIGNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcXG4gICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgIHJldHVybiBlbGVtZW50LmRpc2FibGVkO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJztcXG4gIH07XFxuXFxuICBjb25zdCBmaW5kU2hhZG93Um9vdCA9IGVsZW1lbnQgPT4ge1xcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfSAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcXG5cXG5cXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgY29uc3Qgcm9vdCA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcXG4gICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbDtcXG4gICAgfVxcblxcbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcXG4gICAgICByZXR1cm4gZWxlbWVudDtcXG4gICAgfSAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxcblxcblxcbiAgICBpZiAoIWVsZW1lbnQucGFyZW50Tm9kZSkge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBmaW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpO1xcbiAgfTtcXG5cXG4gIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcXG4gIC8qKlxcbiAgICogVHJpY2sgdG8gcmVzdGFydCBhbiBlbGVtZW50J3MgYW5pbWF0aW9uXFxuICAgKlxcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxcbiAgICogQHJldHVybiB2b2lkXFxuICAgKlxcbiAgICogQHNlZSBodHRwczovL3d3dy5jaGFyaXN0aGVvLmlvL2Jsb2cvMjAyMS8wMi9yZXN0YXJ0LWEtY3NzLWFuaW1hdGlvbi13aXRoLWphdmFzY3JpcHQvI3Jlc3RhcnRpbmctYS1jc3MtYW5pbWF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIGNvbnN0IHJlZmxvdyA9IGVsZW1lbnQgPT4ge1xcbiAgICBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcXG4gIH07XFxuXFxuICBjb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XFxuICAgIGlmICh3aW5kb3cualF1ZXJ5ICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZSgnZGF0YS1icy1uby1qcXVlcnknKSkge1xcbiAgICAgIHJldHVybiB3aW5kb3cualF1ZXJ5O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBudWxsO1xcbiAgfTtcXG5cXG4gIGNvbnN0IERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MgPSBbXTtcXG5cXG4gIGNvbnN0IG9uRE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xcbiAgICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXFxuICAgICAgaWYgKCFET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcXG4gICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzKSB7XFxuICAgICAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2FsbGJhY2soKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIGNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XFxuXFxuICBjb25zdCBkZWZpbmVKUXVlcnlQbHVnaW4gPSBwbHVnaW4gPT4ge1xcbiAgICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xcbiAgICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cXG5cXG4gICAgICBpZiAoJCkge1xcbiAgICAgICAgY29uc3QgbmFtZSA9IHBsdWdpbi5OQU1FO1xcbiAgICAgICAgY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltuYW1lXTtcXG4gICAgICAgICQuZm5bbmFtZV0gPSBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xcbiAgICAgICAgJC5mbltuYW1lXS5Db25zdHJ1Y3RvciA9IHBsdWdpbjtcXG5cXG4gICAgICAgICQuZm5bbmFtZV0ubm9Db25mbGljdCA9ICgpID0+IHtcXG4gICAgICAgICAgJC5mbltuYW1lXSA9IEpRVUVSWV9OT19DT05GTElDVDtcXG4gICAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XFxuICAgICAgICB9O1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcblxcbiAgY29uc3QgZXhlY3V0ZSA9IGNhbGxiYWNrID0+IHtcXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIGNhbGxiYWNrKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBjb25zdCBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uID0gKGNhbGxiYWNrLCB0cmFuc2l0aW9uRWxlbWVudCwgd2FpdEZvclRyYW5zaXRpb24gPSB0cnVlKSA9PiB7XFxuICAgIGlmICghd2FpdEZvclRyYW5zaXRpb24pIHtcXG4gICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZHVyYXRpb25QYWRkaW5nID0gNTtcXG4gICAgY29uc3QgZW11bGF0ZWREdXJhdGlvbiA9IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRyYW5zaXRpb25FbGVtZW50KSArIGR1cmF0aW9uUGFkZGluZztcXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xcblxcbiAgICBjb25zdCBoYW5kbGVyID0gKHtcXG4gICAgICB0YXJnZXRcXG4gICAgfSkgPT4ge1xcbiAgICAgIGlmICh0YXJnZXQgIT09IHRyYW5zaXRpb25FbGVtZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNhbGxlZCA9IHRydWU7XFxuICAgICAgdHJhbnNpdGlvbkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XFxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgIH07XFxuXFxuICAgIHRyYW5zaXRpb25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGhhbmRsZXIpO1xcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICBpZiAoIWNhbGxlZCkge1xcbiAgICAgICAgdHJpZ2dlclRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkVsZW1lbnQpO1xcbiAgICAgIH1cXG4gICAgfSwgZW11bGF0ZWREdXJhdGlvbik7XFxuICB9O1xcbiAgLyoqXFxuICAgKiBSZXR1cm4gdGhlIHByZXZpb3VzL25leHQgZWxlbWVudCBvZiBhIGxpc3QuXFxuICAgKlxcbiAgICogQHBhcmFtIHthcnJheX0gbGlzdCAgICBUaGUgbGlzdCBvZiBlbGVtZW50c1xcbiAgICogQHBhcmFtIGFjdGl2ZUVsZW1lbnQgICBUaGUgYWN0aXZlIGVsZW1lbnRcXG4gICAqIEBwYXJhbSBzaG91bGRHZXROZXh0ICAgQ2hvb3NlIHRvIGdldCBuZXh0IG9yIHByZXZpb3VzIGVsZW1lbnRcXG4gICAqIEBwYXJhbSBpc0N5Y2xlQWxsb3dlZFxcbiAgICogQHJldHVybiB7RWxlbWVudHxlbGVtfSBUaGUgcHJvcGVyIGVsZW1lbnRcXG4gICAqL1xcblxcblxcbiAgY29uc3QgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQgPSAobGlzdCwgYWN0aXZlRWxlbWVudCwgc2hvdWxkR2V0TmV4dCwgaXNDeWNsZUFsbG93ZWQpID0+IHtcXG4gICAgY29uc3QgbGlzdExlbmd0aCA9IGxpc3QubGVuZ3RoO1xcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YoYWN0aXZlRWxlbWVudCk7IC8vIGlmIHRoZSBlbGVtZW50IGRvZXMgbm90IGV4aXN0IGluIHRoZSBsaXN0IHJldHVybiBhbiBlbGVtZW50XFxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIGFuZCBpZiBjeWNsZSBpcyBhbGxvd2VkXFxuXFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcXG4gICAgICByZXR1cm4gIXNob3VsZEdldE5leHQgJiYgaXNDeWNsZUFsbG93ZWQgPyBsaXN0W2xpc3RMZW5ndGggLSAxXSA6IGxpc3RbMF07XFxuICAgIH1cXG5cXG4gICAgaW5kZXggKz0gc2hvdWxkR2V0TmV4dCA/IDEgOiAtMTtcXG5cXG4gICAgaWYgKGlzQ3ljbGVBbGxvd2VkKSB7XFxuICAgICAgaW5kZXggPSAoaW5kZXggKyBsaXN0TGVuZ3RoKSAlIGxpc3RMZW5ndGg7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGxpc3RbTWF0aC5tYXgoMCwgTWF0aC5taW4oaW5kZXgsIGxpc3RMZW5ndGggLSAxKSldO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogZG9tL2V2ZW50LWhhbmRsZXIuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgbmFtZXNwYWNlUmVnZXggPSAvW14uXSooPz1cXFxcLi4qKVxcXFwufC4qLztcXG4gIGNvbnN0IHN0cmlwTmFtZVJlZ2V4ID0gL1xcXFwuLiovO1xcbiAgY29uc3Qgc3RyaXBVaWRSZWdleCA9IC86OlxcXFxkKyQvO1xcbiAgY29uc3QgZXZlbnRSZWdpc3RyeSA9IHt9OyAvLyBFdmVudHMgc3RvcmFnZVxcblxcbiAgbGV0IHVpZEV2ZW50ID0gMTtcXG4gIGNvbnN0IGN1c3RvbUV2ZW50cyA9IHtcXG4gICAgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsXFxuICAgIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcXG4gIH07XFxuICBjb25zdCBuYXRpdmVFdmVudHMgPSBuZXcgU2V0KFsnY2xpY2snLCAnZGJsY2xpY2snLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnY29udGV4dG1lbnUnLCAnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnbW91c2Vtb3ZlJywgJ3NlbGVjdHN0YXJ0JywgJ3NlbGVjdGVuZCcsICdrZXlkb3duJywgJ2tleXByZXNzJywgJ2tleXVwJywgJ29yaWVudGF0aW9uY2hhbmdlJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJywgJ3RvdWNoY2FuY2VsJywgJ3BvaW50ZXJkb3duJywgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVybGVhdmUnLCAncG9pbnRlcmNhbmNlbCcsICdnZXN0dXJlc3RhcnQnLCAnZ2VzdHVyZWNoYW5nZScsICdnZXN0dXJlZW5kJywgJ2ZvY3VzJywgJ2JsdXInLCAnY2hhbmdlJywgJ3Jlc2V0JywgJ3NlbGVjdCcsICdzdWJtaXQnLCAnZm9jdXNpbicsICdmb2N1c291dCcsICdsb2FkJywgJ3VubG9hZCcsICdiZWZvcmV1bmxvYWQnLCAncmVzaXplJywgJ21vdmUnLCAnRE9NQ29udGVudExvYWRlZCcsICdyZWFkeXN0YXRlY2hhbmdlJywgJ2Vycm9yJywgJ2Fib3J0JywgJ3Njcm9sbCddKTtcXG4gIC8qKlxcbiAgICogUHJpdmF0ZSBtZXRob2RzXFxuICAgKi9cXG5cXG4gIGZ1bmN0aW9uIG1ha2VFdmVudFVpZChlbGVtZW50LCB1aWQpIHtcXG4gICAgcmV0dXJuIHVpZCAmJiBgJHt1aWR9Ojoke3VpZEV2ZW50Kyt9YCB8fCBlbGVtZW50LnVpZEV2ZW50IHx8IHVpZEV2ZW50Kys7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpIHtcXG4gICAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGVsZW1lbnQpO1xcbiAgICBlbGVtZW50LnVpZEV2ZW50ID0gdWlkO1xcbiAgICBldmVudFJlZ2lzdHJ5W3VpZF0gPSBldmVudFJlZ2lzdHJ5W3VpZF0gfHwge307XFxuICAgIHJldHVybiBldmVudFJlZ2lzdHJ5W3VpZF07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGZuKSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XFxuICAgICAgaHlkcmF0ZU9iaihldmVudCwge1xcbiAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IGVsZW1lbnRcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgZXZlbnQudHlwZSwgZm4pO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gZm4uYXBwbHkoZWxlbWVudCwgW2V2ZW50XSk7XFxuICAgIH07XFxuICB9XFxuXFxuICBmdW5jdGlvbiBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBzZWxlY3RvciwgZm4pIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGhhbmRsZXIoZXZlbnQpIHtcXG4gICAgICBjb25zdCBkb21FbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XFxuXFxuICAgICAgZm9yIChsZXQge1xcbiAgICAgICAgdGFyZ2V0XFxuICAgICAgfSA9IGV2ZW50OyB0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzOyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xcbiAgICAgICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvbUVsZW1lbnRzKSB7XFxuICAgICAgICAgIGlmIChkb21FbGVtZW50ICE9PSB0YXJnZXQpIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7XFxuICAgICAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IHRhcmdldFxcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XFxuICAgICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBzZWxlY3RvciwgZm4pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0YXJnZXQsIFtldmVudF0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGZpbmRIYW5kbGVyKGV2ZW50cywgY2FsbGFibGUsIGRlbGVnYXRpb25TZWxlY3RvciA9IG51bGwpIHtcXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZXZlbnRzKS5maW5kKGV2ZW50ID0+IGV2ZW50LmNhbGxhYmxlID09PSBjYWxsYWJsZSAmJiBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGRlbGVnYXRpb25TZWxlY3Rvcik7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcXG4gICAgY29uc3QgaXNEZWxlZ2F0ZWQgPSB0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZyc7IC8vIHRvZG86IHRvb2x0aXAgcGFzc2VzIGBmYWxzZWAgaW5zdGVhZCBvZiBzZWxlY3Rvciwgc28gd2UgbmVlZCB0byBjaGVja1xcblxcbiAgICBjb25zdCBjYWxsYWJsZSA9IGlzRGVsZWdhdGVkID8gZGVsZWdhdGlvbkZ1bmN0aW9uIDogaGFuZGxlciB8fCBkZWxlZ2F0aW9uRnVuY3Rpb247XFxuICAgIGxldCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQob3JpZ2luYWxUeXBlRXZlbnQpO1xcblxcbiAgICBpZiAoIW5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KSkge1xcbiAgICAgIHR5cGVFdmVudCA9IG9yaWdpbmFsVHlwZUV2ZW50O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYWRkSGFuZGxlcihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uLCBvbmVPZmYpIHtcXG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgbGV0IFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pOyAvLyBpbiBjYXNlIG9mIG1vdXNlZW50ZXIgb3IgbW91c2VsZWF2ZSB3cmFwIHRoZSBoYW5kbGVyIHdpdGhpbiBhIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIGZvciBpdHMgRE9NIHBvc2l0aW9uXFxuICAgIC8vIHRoaXMgcHJldmVudHMgdGhlIGhhbmRsZXIgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRoZSBzYW1lIHdheSBhcyBtb3VzZW92ZXIgb3IgbW91c2VvdXQgZG9lc1xcblxcbiAgICBpZiAob3JpZ2luYWxUeXBlRXZlbnQgaW4gY3VzdG9tRXZlbnRzKSB7XFxuICAgICAgY29uc3Qgd3JhcEZ1bmN0aW9uID0gZm4gPT4ge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgICAgICBpZiAoIWV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQucmVsYXRlZFRhcmdldCAhPT0gZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgIWV2ZW50LmRlbGVnYXRlVGFyZ2V0LmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcbiAgICAgIH07XFxuXFxuICAgICAgY2FsbGFibGUgPSB3cmFwRnVuY3Rpb24oY2FsbGFibGUpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XFxuICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xcbiAgICBjb25zdCBwcmV2aW91c0Z1bmN0aW9uID0gZmluZEhhbmRsZXIoaGFuZGxlcnMsIGNhbGxhYmxlLCBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsKTtcXG5cXG4gICAgaWYgKHByZXZpb3VzRnVuY3Rpb24pIHtcXG4gICAgICBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiA9IHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmICYmIG9uZU9mZjtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGNhbGxhYmxlLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpO1xcbiAgICBjb25zdCBmbiA9IGlzRGVsZWdhdGVkID8gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgY2FsbGFibGUpIDogYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBjYWxsYWJsZSk7XFxuICAgIGZuLmRlbGVnYXRpb25TZWxlY3RvciA9IGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGw7XFxuICAgIGZuLmNhbGxhYmxlID0gY2FsbGFibGU7XFxuICAgIGZuLm9uZU9mZiA9IG9uZU9mZjtcXG4gICAgZm4udWlkRXZlbnQgPSB1aWQ7XFxuICAgIGhhbmRsZXJzW3VpZF0gPSBmbjtcXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIGlzRGVsZWdhdGVkKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcikge1xcbiAgICBjb25zdCBmbiA9IGZpbmRIYW5kbGVyKGV2ZW50c1t0eXBlRXZlbnRdLCBoYW5kbGVyLCBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xcblxcbiAgICBpZiAoIWZuKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBCb29sZWFuKGRlbGVnYXRpb25TZWxlY3RvcikpO1xcbiAgICBkZWxldGUgZXZlbnRzW3R5cGVFdmVudF1bZm4udWlkRXZlbnRdO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBuYW1lc3BhY2UpIHtcXG4gICAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcXG5cXG4gICAgZm9yIChjb25zdCBoYW5kbGVyS2V5IG9mIE9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xcbiAgICAgIGlmIChoYW5kbGVyS2V5LmluY2x1ZGVzKG5hbWVzcGFjZSkpIHtcXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gc3RvcmVFbGVtZW50RXZlbnRbaGFuZGxlcktleV07XFxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdldFR5cGVFdmVudChldmVudCkge1xcbiAgICAvLyBhbGxvdyB0byBnZXQgdGhlIG5hdGl2ZSBldmVudHMgZnJvbSBuYW1lc3BhY2VkIGV2ZW50cyAoJ2NsaWNrLmJzLmJ1dHRvbicgLS0+ICdjbGljaycpXFxuICAgIGV2ZW50ID0gZXZlbnQucmVwbGFjZShzdHJpcE5hbWVSZWdleCwgJycpO1xcbiAgICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudDtcXG4gIH1cXG5cXG4gIGNvbnN0IEV2ZW50SGFuZGxlciA9IHtcXG4gICAgb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xcbiAgICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgZmFsc2UpO1xcbiAgICB9LFxcblxcbiAgICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xcbiAgICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgdHJ1ZSk7XFxuICAgIH0sXFxuXFxuICAgIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XFxuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbik7XFxuICAgICAgY29uc3QgaW5OYW1lc3BhY2UgPSB0eXBlRXZlbnQgIT09IG9yaWdpbmFsVHlwZUV2ZW50O1xcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XFxuICAgICAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcXG4gICAgICBjb25zdCBpc05hbWVzcGFjZSA9IG9yaWdpbmFsVHlwZUV2ZW50LnN0YXJ0c1dpdGgoJy4nKTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNhbGxhYmxlICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgLy8gU2ltcGxlc3QgY2FzZTogaGFuZGxlciBpcyBwYXNzZWQsIHJlbW92ZSB0aGF0IGxpc3RlbmVyIE9OTFkuXFxuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHN0b3JlRWxlbWVudEV2ZW50KS5sZW5ndGgpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmVtb3ZlSGFuZGxlcihlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNOYW1lc3BhY2UpIHtcXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudEV2ZW50IG9mIE9iamVjdC5rZXlzKGV2ZW50cykpIHtcXG4gICAgICAgICAgcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgZWxlbWVudEV2ZW50LCBvcmlnaW5hbFR5cGVFdmVudC5zbGljZSgxKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoY29uc3Qga2V5SGFuZGxlcnMgb2YgT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XFxuICAgICAgICBjb25zdCBoYW5kbGVyS2V5ID0ga2V5SGFuZGxlcnMucmVwbGFjZShzdHJpcFVpZFJlZ2V4LCAnJyk7XFxuXFxuICAgICAgICBpZiAoIWluTmFtZXNwYWNlIHx8IG9yaWdpbmFsVHlwZUV2ZW50LmluY2x1ZGVzKGhhbmRsZXJLZXkpKSB7XFxuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gc3RvcmVFbGVtZW50RXZlbnRba2V5SGFuZGxlcnNdO1xcbiAgICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0sXFxuXFxuICAgIHRyaWdnZXIoZWxlbWVudCwgZXZlbnQsIGFyZ3MpIHtcXG4gICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcXG4gICAgICBjb25zdCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQoZXZlbnQpO1xcbiAgICAgIGNvbnN0IGluTmFtZXNwYWNlID0gZXZlbnQgIT09IHR5cGVFdmVudDtcXG4gICAgICBsZXQgalF1ZXJ5RXZlbnQgPSBudWxsO1xcbiAgICAgIGxldCBidWJibGVzID0gdHJ1ZTtcXG4gICAgICBsZXQgbmF0aXZlRGlzcGF0Y2ggPSB0cnVlO1xcbiAgICAgIGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XFxuXFxuICAgICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcXG4gICAgICAgIGpRdWVyeUV2ZW50ID0gJC5FdmVudChldmVudCwgYXJncyk7XFxuICAgICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoalF1ZXJ5RXZlbnQpO1xcbiAgICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xcbiAgICAgICAgbmF0aXZlRGlzcGF0Y2ggPSAhalF1ZXJ5RXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKTtcXG4gICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBqUXVlcnlFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgbGV0IGV2dCA9IG5ldyBFdmVudChldmVudCwge1xcbiAgICAgICAgYnViYmxlcyxcXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcXG4gICAgICB9KTtcXG4gICAgICBldnQgPSBoeWRyYXRlT2JqKGV2dCwgYXJncyk7XFxuXFxuICAgICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAobmF0aXZlRGlzcGF0Y2gpIHtcXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgJiYgalF1ZXJ5RXZlbnQpIHtcXG4gICAgICAgIGpRdWVyeUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBldnQ7XFxuICAgIH1cXG5cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBoeWRyYXRlT2JqKG9iaiwgbWV0YSkge1xcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhIHx8IHt9KSkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXFxuXFxuICAgICAgICAgIGdldCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gb2JqO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBkb20vZGF0YS5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuICBjb25zdCBlbGVtZW50TWFwID0gbmV3IE1hcCgpO1xcbiAgY29uc3QgRGF0YSA9IHtcXG4gICAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcXG4gICAgICBpZiAoIWVsZW1lbnRNYXAuaGFzKGVsZW1lbnQpKSB7XFxuICAgICAgICBlbGVtZW50TWFwLnNldChlbGVtZW50LCBuZXcgTWFwKCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpOyAvLyBtYWtlIGl0IGNsZWFyIHdlIG9ubHkgd2FudCBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnRcXG4gICAgICAvLyBjYW4gYmUgcmVtb3ZlZCBsYXRlciB3aGVuIG11bHRpcGxlIGtleS9pbnN0YW5jZXMgYXJlIGZpbmUgdG8gYmUgdXNlZFxcblxcbiAgICAgIGlmICghaW5zdGFuY2VNYXAuaGFzKGtleSkgJiYgaW5zdGFuY2VNYXAuc2l6ZSAhPT0gMCkge1xcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcXG4gICAgfSxcXG5cXG4gICAgZ2V0KGVsZW1lbnQsIGtleSkge1xcbiAgICAgIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpLmdldChrZXkpIHx8IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9LFxcblxcbiAgICByZW1vdmUoZWxlbWVudCwga2V5KSB7XFxuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpO1xcbiAgICAgIGluc3RhbmNlTWFwLmRlbGV0ZShrZXkpOyAvLyBmcmVlIHVwIGVsZW1lbnQgcmVmZXJlbmNlcyBpZiB0aGVyZSBhcmUgbm8gaW5zdGFuY2VzIGxlZnQgZm9yIGFuIGVsZW1lbnRcXG5cXG4gICAgICBpZiAoaW5zdGFuY2VNYXAuc2l6ZSA9PT0gMCkge1xcbiAgICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBkb20vbWFuaXB1bGF0b3IuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh2YWx1ZSkge1xcbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAodmFsdWUgPT09IE51bWJlcih2YWx1ZSkudG9TdHJpbmcoKSkge1xcbiAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xcbiAgICB9XFxuXFxuICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09ICdudWxsJykge1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgcmV0dXJuIHZhbHVlO1xcbiAgICB9XFxuXFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XFxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcXG4gICAgICByZXR1cm4gdmFsdWU7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZURhdGFLZXkoa2V5KSB7XFxuICAgIHJldHVybiBrZXkucmVwbGFjZSgvW0EtWl0vZywgY2hyID0+IGAtJHtjaHIudG9Mb3dlckNhc2UoKX1gKTtcXG4gIH1cXG5cXG4gIGNvbnN0IE1hbmlwdWxhdG9yID0ge1xcbiAgICBzZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSwgdmFsdWUpIHtcXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XFxuICAgIH0sXFxuXFxuICAgIHJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XFxuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCk7XFxuICAgIH0sXFxuXFxuICAgIGdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybiB7fTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xcbiAgICAgIGNvbnN0IGJzS2V5cyA9IE9iamVjdC5rZXlzKGVsZW1lbnQuZGF0YXNldCkuZmlsdGVyKGtleSA9PiBrZXkuc3RhcnRzV2l0aCgnYnMnKSAmJiAha2V5LnN0YXJ0c1dpdGgoJ2JzQ29uZmlnJykpO1xcblxcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGJzS2V5cykge1xcbiAgICAgICAgbGV0IHB1cmVLZXkgPSBrZXkucmVwbGFjZSgvXmJzLywgJycpO1xcbiAgICAgICAgcHVyZUtleSA9IHB1cmVLZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBwdXJlS2V5LnNsaWNlKDEsIHB1cmVLZXkubGVuZ3RoKTtcXG4gICAgICAgIGF0dHJpYnV0ZXNbcHVyZUtleV0gPSBub3JtYWxpemVEYXRhKGVsZW1lbnQuZGF0YXNldFtrZXldKTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XFxuICAgIH0sXFxuXFxuICAgIGdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XFxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZURhdGEoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCkpO1xcbiAgICB9XFxuXFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL2NvbmZpZy5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgQ29uZmlnIHtcXG4gICAgLy8gR2V0dGVyc1xcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIHt9O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIHt9O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcXFwiTkFNRVxcXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnKTtcXG4gICAgfVxcblxcbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XFxuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xcblxcbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xcblxcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfVxcblxcbiAgICBfbWVyZ2VDb25maWdPYmooY29uZmlnLCBlbGVtZW50KSB7XFxuICAgICAgY29uc3QganNvbkNvbmZpZyA9IGlzRWxlbWVudChlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgJ2NvbmZpZycpIDoge307IC8vIHRyeSB0byBwYXJzZVxcblxcbiAgICAgIHJldHVybiB7IC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcXG4gICAgICAgIC4uLih0eXBlb2YganNvbkNvbmZpZyA9PT0gJ29iamVjdCcgPyBqc29uQ29uZmlnIDoge30pLFxcbiAgICAgICAgLi4uKGlzRWxlbWVudChlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIDoge30pLFxcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDoge30pXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZywgY29uZmlnVHlwZXMgPSB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKSB7XFxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBPYmplY3Qua2V5cyhjb25maWdUeXBlcykpIHtcXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV07XFxuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XFxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSBpc0VsZW1lbnQodmFsdWUpID8gJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKTtcXG5cXG4gICAgICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUUudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcXFwiJHtwcm9wZXJ0eX1cXFwiIHByb3ZpZGVkIHR5cGUgXFxcIiR7dmFsdWVUeXBlfVxcXCIgYnV0IGV4cGVjdGVkIHR5cGUgXFxcIiR7ZXhwZWN0ZWRUeXBlc31cXFwiLmApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBiYXNlLWNvbXBvbmVudC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBWRVJTSU9OID0gJzUuMi4wJztcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBCYXNlQ29tcG9uZW50IGV4dGVuZHMgQ29uZmlnIHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgc3VwZXIoKTtcXG4gICAgICBlbGVtZW50ID0gZ2V0RWxlbWVudChlbGVtZW50KTtcXG5cXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XFxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgICAgRGF0YS5zZXQodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgRGF0YS5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XFxuXFxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG4gICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9xdWV1ZUNhbGxiYWNrKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkID0gdHJ1ZSkge1xcbiAgICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnLCB0aGlzLl9lbGVtZW50KTtcXG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XFxuXFxuICAgICAgdGhpcy5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XFxuXFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gRGF0YS5nZXQoZ2V0RWxlbWVudChlbGVtZW50KSwgdGhpcy5EQVRBX0tFWSk7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgY29uZmlnID0ge30pIHtcXG4gICAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZShlbGVtZW50KSB8fCBuZXcgdGhpcyhlbGVtZW50LCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGwpO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcXG4gICAgICByZXR1cm4gVkVSU0lPTjtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xcbiAgICAgIHJldHVybiBgYnMuJHt0aGlzLk5BTUV9YDtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcXG4gICAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZXZlbnROYW1lKG5hbWUpIHtcXG4gICAgICByZXR1cm4gYCR7bmFtZX0ke3RoaXMuRVZFTlRfS0VZfWA7XFxuICAgIH1cXG5cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG5cXG4gIGNvbnN0IGVuYWJsZURpc21pc3NUcmlnZ2VyID0gKGNvbXBvbmVudCwgbWV0aG9kID0gJ2hpZGUnKSA9PiB7XFxuICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBgY2xpY2suZGlzbWlzcyR7Y29tcG9uZW50LkVWRU5UX0tFWX1gO1xcbiAgICBjb25zdCBuYW1lID0gY29tcG9uZW50Lk5BTUU7XFxuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgY2xpY2tFdmVudCwgYFtkYXRhLWJzLWRpc21pc3M9XFxcIiR7bmFtZX1cXFwiXWAsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHRhcmdldCA9IGdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcykgfHwgdGhpcy5jbG9zZXN0KGAuJHtuYW1lfWApO1xcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY29tcG9uZW50LmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTsgLy8gTWV0aG9kIGFyZ3VtZW50IGlzIGxlZnQsIGZvciBBbGVydCBhbmQgb25seSwgYXMgaXQgZG9lc24ndCBpbXBsZW1lbnQgdGhlICdoaWRlJyBtZXRob2RcXG5cXG4gICAgICBpbnN0YW5jZVttZXRob2RdKCk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogYWxlcnQuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSRmID0gJ2FsZXJ0JztcXG4gIGNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYWxlcnQnO1xcbiAgY29uc3QgRVZFTlRfS0VZJGIgPSBgLiR7REFUQV9LRVkkYX1gO1xcbiAgY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRifWA7XFxuICBjb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVkkYn1gO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDUgPSAnZmFkZSc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckOCA9ICdzaG93JztcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBBbGVydCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICAvLyBHZXR0ZXJzXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSRmO1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBjbG9zZSgpIHtcXG4gICAgICBjb25zdCBjbG9zZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0UpO1xcblxcbiAgICAgIGlmIChjbG9zZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ4KTtcXG5cXG4gICAgICBjb25zdCBpc0FuaW1hdGVkID0gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDUpO1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4gdGhpcy5fZGVzdHJveUVsZW1lbnQoKSwgdGhpcy5fZWxlbWVudCwgaXNBbmltYXRlZCk7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfZGVzdHJveUVsZW1lbnQoKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcXG5cXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9DTE9TRUQpO1xcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY29uc3QgZGF0YSA9IEFsZXJ0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKEFsZXJ0LCAnY2xvc2UnKTtcXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihBbGVydCk7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IGJ1dHRvbi5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJGUgPSAnYnV0dG9uJztcXG4gIGNvbnN0IERBVEFfS0VZJDkgPSAnYnMuYnV0dG9uJztcXG4gIGNvbnN0IEVWRU5UX0tFWSRhID0gYC4ke0RBVEFfS0VZJDl9YDtcXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ2ID0gJy5kYXRhLWFwaSc7XFxuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwiYnV0dG9uXFxcIl0nO1xcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiA9IGBjbGljayR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIEJ1dHRvbiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICAvLyBHZXR0ZXJzXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSRlO1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICB0b2dnbGUoKSB7XFxuICAgICAgLy8gVG9nZ2xlIGNsYXNzIGFuZCBzeW5jIHRoZSBgYXJpYS1wcmVzc2VkYCBhdHRyaWJ1dGUgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBgLnRvZ2dsZSgpYCBtZXRob2RcXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQUNUSVZFJDMpKTtcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcXG5cXG4gICAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XFxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSwgZXZlbnQgPT4ge1xcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBjb25zdCBidXR0b24gPSBldmVudC50YXJnZXQuY2xvc2VzdChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1KTtcXG4gICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKGJ1dHRvbik7XFxuICAgIGRhdGEudG9nZ2xlKCk7XFxuICB9KTtcXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihCdXR0b24pO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBkb20vc2VsZWN0b3ItZW5naW5lLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IFNlbGVjdG9yRW5naW5lID0ge1xcbiAgICBmaW5kKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpKTtcXG4gICAgfSxcXG5cXG4gICAgZmluZE9uZShzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xcbiAgICAgIHJldHVybiBFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xcbiAgICB9LFxcblxcbiAgICBjaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uZWxlbWVudC5jaGlsZHJlbikuZmlsdGVyKGNoaWxkID0+IGNoaWxkLm1hdGNoZXMoc2VsZWN0b3IpKTtcXG4gICAgfSxcXG5cXG4gICAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcXG4gICAgICBsZXQgYW5jZXN0b3IgPSBlbGVtZW50LnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XFxuXFxuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XFxuICAgICAgICBwYXJlbnRzLnB1c2goYW5jZXN0b3IpO1xcbiAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcGFyZW50cztcXG4gICAgfSxcXG5cXG4gICAgcHJldihlbGVtZW50LCBzZWxlY3Rvcikge1xcbiAgICAgIGxldCBwcmV2aW91cyA9IGVsZW1lbnQucHJldmlvdXNFbGVtZW50U2libGluZztcXG5cXG4gICAgICB3aGlsZSAocHJldmlvdXMpIHtcXG4gICAgICAgIGlmIChwcmV2aW91cy5tYXRjaGVzKHNlbGVjdG9yKSkge1xcbiAgICAgICAgICByZXR1cm4gW3ByZXZpb3VzXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIFtdO1xcbiAgICB9LFxcblxcbiAgICAvLyBUT0RPOiB0aGlzIGlzIG5vdyB1bnVzZWQ7IHJlbW92ZSBsYXRlciBhbG9uZyB3aXRoIHByZXYoKVxcbiAgICBuZXh0KGVsZW1lbnQsIHNlbGVjdG9yKSB7XFxuICAgICAgbGV0IG5leHQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcXG5cXG4gICAgICB3aGlsZSAobmV4dCkge1xcbiAgICAgICAgaWYgKG5leHQubWF0Y2hlcyhzZWxlY3RvcikpIHtcXG4gICAgICAgICAgcmV0dXJuIFtuZXh0XTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRFbGVtZW50U2libGluZztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIFtdO1xcbiAgICB9LFxcblxcbiAgICBmb2N1c2FibGVDaGlsZHJlbihlbGVtZW50KSB7XFxuICAgICAgY29uc3QgZm9jdXNhYmxlcyA9IFsnYScsICdidXR0b24nLCAnaW5wdXQnLCAndGV4dGFyZWEnLCAnc2VsZWN0JywgJ2RldGFpbHMnLCAnW3RhYmluZGV4XScsICdbY29udGVudGVkaXRhYmxlPVxcXCJ0cnVlXFxcIl0nXS5tYXAoc2VsZWN0b3IgPT4gYCR7c2VsZWN0b3J9Om5vdChbdGFiaW5kZXhePVxcXCItXFxcIl0pYCkuam9pbignLCcpO1xcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcXG4gICAgfVxcblxcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogdXRpbC9zd2lwZS5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJGQgPSAnc3dpcGUnO1xcbiAgY29uc3QgRVZFTlRfS0VZJDkgPSAnLmJzLnN3aXBlJztcXG4gIGNvbnN0IEVWRU5UX1RPVUNIU1RBUlQgPSBgdG91Y2hzdGFydCR7RVZFTlRfS0VZJDl9YDtcXG4gIGNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWSQ5fWA7XFxuICBjb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZJDl9YDtcXG4gIGNvbnN0IEVWRU5UX1BPSU5URVJET1dOID0gYHBvaW50ZXJkb3duJHtFVkVOVF9LRVkkOX1gO1xcbiAgY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZJDl9YDtcXG4gIGNvbnN0IFBPSU5URVJfVFlQRV9UT1VDSCA9ICd0b3VjaCc7XFxuICBjb25zdCBQT0lOVEVSX1RZUEVfUEVOID0gJ3Blbic7XFxuICBjb25zdCBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCc7XFxuICBjb25zdCBTV0lQRV9USFJFU0hPTEQgPSA0MDtcXG4gIGNvbnN0IERlZmF1bHQkYyA9IHtcXG4gICAgZW5kQ2FsbGJhY2s6IG51bGwsXFxuICAgIGxlZnRDYWxsYmFjazogbnVsbCxcXG4gICAgcmlnaHRDYWxsYmFjazogbnVsbFxcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRUeXBlJGMgPSB7XFxuICAgIGVuZENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcXG4gICAgbGVmdENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcXG4gICAgcmlnaHRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKSdcXG4gIH07XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgU3dpcGUgZXh0ZW5kcyBDb25maWcge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcigpO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xcblxcbiAgICAgIGlmICghZWxlbWVudCB8fCAhU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcXG4gICAgICB0aGlzLl9kZWx0YVggPSAwO1xcbiAgICAgIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50KTtcXG5cXG4gICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkYztcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRjO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSRkO1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBkaXNwb3NlKCkge1xcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZJDkpO1xcbiAgICB9IC8vIFByaXZhdGVcXG5cXG5cXG4gICAgX3N0YXJ0KGV2ZW50KSB7XFxuICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cykge1xcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcXG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFg7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9lbmQoZXZlbnQpIHtcXG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcXG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2hhbmRsZVN3aXBlKCk7XFxuXFxuICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuZW5kQ2FsbGJhY2spO1xcbiAgICB9XFxuXFxuICAgIF9tb3ZlKGV2ZW50KSB7XFxuICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYIC0gdGhpcy5fZGVsdGFYO1xcbiAgICB9XFxuXFxuICAgIF9oYW5kbGVTd2lwZSgpIHtcXG4gICAgICBjb25zdCBhYnNEZWx0YVggPSBNYXRoLmFicyh0aGlzLl9kZWx0YVgpO1xcblxcbiAgICAgIGlmIChhYnNEZWx0YVggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFic0RlbHRhWCAvIHRoaXMuX2RlbHRhWDtcXG4gICAgICB0aGlzLl9kZWx0YVggPSAwO1xcblxcbiAgICAgIGlmICghZGlyZWN0aW9uKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGV4ZWN1dGUoZGlyZWN0aW9uID4gMCA/IHRoaXMuX2NvbmZpZy5yaWdodENhbGxiYWNrIDogdGhpcy5fY29uZmlnLmxlZnRDYWxsYmFjayk7XFxuICAgIH1cXG5cXG4gICAgX2luaXRFdmVudHMoKSB7XFxuICAgICAgaWYgKHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzKSB7XFxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUkRPV04sIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSk7XFxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcXG5cXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IHRoaXMuX21vdmUoZXZlbnQpKTtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSEVORCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzICYmIChldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1BFTiB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1RPVUNIKTtcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGlzU3VwcG9ydGVkKCkge1xcbiAgICAgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBjYXJvdXNlbC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJGMgPSAnY2Fyb3VzZWwnO1xcbiAgY29uc3QgREFUQV9LRVkkOCA9ICdicy5jYXJvdXNlbCc7XFxuICBjb25zdCBFVkVOVF9LRVkkOCA9IGAuJHtEQVRBX0tFWSQ4fWA7XFxuICBjb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xcbiAgY29uc3QgQVJST1dfTEVGVF9LRVkkMSA9ICdBcnJvd0xlZnQnO1xcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZJDEgPSAnQXJyb3dSaWdodCc7XFxuICBjb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcXG5cXG4gIGNvbnN0IE9SREVSX05FWFQgPSAnbmV4dCc7XFxuICBjb25zdCBPUkRFUl9QUkVWID0gJ3ByZXYnO1xcbiAgY29uc3QgRElSRUNUSU9OX0xFRlQgPSAnbGVmdCc7XFxuICBjb25zdCBESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xcbiAgY29uc3QgRVZFTlRfU0xJREUgPSBgc2xpZGUke0VWRU5UX0tFWSQ4fWA7XFxuICBjb25zdCBFVkVOVF9TTElEID0gYHNsaWQke0VWRU5UX0tFWSQ4fWA7XFxuICBjb25zdCBFVkVOVF9LRVlET1dOJDEgPSBga2V5ZG93biR7RVZFTlRfS0VZJDh9YDtcXG4gIGNvbnN0IEVWRU5UX01PVVNFRU5URVIkMSA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkOH1gO1xcbiAgY29uc3QgRVZFTlRfTU9VU0VMRUFWRSQxID0gYG1vdXNlbGVhdmUke0VWRU5UX0tFWSQ4fWA7XFxuICBjb25zdCBFVkVOVF9EUkFHX1NUQVJUID0gYGRyYWdzdGFydCR7RVZFTlRfS0VZJDh9YDtcXG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMyA9IGBsb2FkJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XFxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1ID0gYGNsaWNrJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XFxuICBjb25zdCBDTEFTU19OQU1FX0NBUk9VU0VMID0gJ2Nhcm91c2VsJztcXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDIgPSAnYWN0aXZlJztcXG4gIGNvbnN0IENMQVNTX05BTUVfU0xJREUgPSAnc2xpZGUnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9FTkQgPSAnY2Fyb3VzZWwtaXRlbS1lbmQnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFSVCA9ICdjYXJvdXNlbC1pdGVtLXN0YXJ0JztcXG4gIGNvbnN0IENMQVNTX05BTUVfTkVYVCA9ICdjYXJvdXNlbC1pdGVtLW5leHQnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9QUkVWID0gJ2Nhcm91c2VsLWl0ZW0tcHJldic7XFxuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XFxuICBjb25zdCBTRUxFQ1RPUl9JVEVNID0gJy5jYXJvdXNlbC1pdGVtJztcXG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRV9JVEVNID0gU0VMRUNUT1JfQUNUSVZFICsgU0VMRUNUT1JfSVRFTTtcXG4gIGNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZyc7XFxuICBjb25zdCBTRUxFQ1RPUl9JTkRJQ0FUT1JTID0gJy5jYXJvdXNlbC1pbmRpY2F0b3JzJztcXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtYnMtc2xpZGVdLCBbZGF0YS1icy1zbGlkZS10b10nO1xcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLWJzLXJpZGU9XFxcImNhcm91c2VsXFxcIl0nO1xcbiAgY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcXG4gICAgW0FSUk9XX0xFRlRfS0VZJDFdOiBESVJFQ1RJT05fUklHSFQsXFxuICAgIFtBUlJPV19SSUdIVF9LRVkkMV06IERJUkVDVElPTl9MRUZUXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdCRiID0ge1xcbiAgICBpbnRlcnZhbDogNTAwMCxcXG4gICAga2V5Ym9hcmQ6IHRydWUsXFxuICAgIHBhdXNlOiAnaG92ZXInLFxcbiAgICByaWRlOiBmYWxzZSxcXG4gICAgdG91Y2g6IHRydWUsXFxuICAgIHdyYXA6IHRydWVcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSRiID0ge1xcbiAgICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxcbiAgICAvLyBUT0RPOnY2IHJlbW92ZSBib29sZWFuIHN1cHBvcnRcXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcXG4gICAgcGF1c2U6ICcoc3RyaW5nfGJvb2xlYW4pJyxcXG4gICAgcmlkZTogJyhib29sZWFufHN0cmluZyknLFxcbiAgICB0b3VjaDogJ2Jvb2xlYW4nLFxcbiAgICB3cmFwOiAnYm9vbGVhbidcXG4gIH07XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgQ2Fyb3VzZWwgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XFxuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGw7XFxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XFxuICAgICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsO1xcbiAgICAgIHRoaXMuX3N3aXBlSGVscGVyID0gbnVsbDtcXG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ESUNBVE9SUywgdGhpcy5fZWxlbWVudCk7XFxuXFxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJpZGUgPT09IENMQVNTX05BTUVfQ0FST1VTRUwpIHtcXG4gICAgICAgIHRoaXMuY3ljbGUoKTtcXG4gICAgICB9XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkYjtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRiO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSRjO1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBuZXh0KCkge1xcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xcbiAgICB9XFxuXFxuICAgIG5leHRXaGVuVmlzaWJsZSgpIHtcXG4gICAgICAvLyBGSVhNRSBUT0RPIHVzZSBgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlYFxcbiAgICAgIC8vIERvbid0IGNhbGwgbmV4dCB3aGVuIHRoZSBwYWdlIGlzbid0IHZpc2libGVcXG4gICAgICAvLyBvciB0aGUgY2Fyb3VzZWwgb3IgaXRzIHBhcmVudCBpc24ndCB2aXNpYmxlXFxuICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiYgaXNWaXNpYmxlKHRoaXMuX2VsZW1lbnQpKSB7XFxuICAgICAgICB0aGlzLm5leHQoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcHJldigpIHtcXG4gICAgICB0aGlzLl9zbGlkZShPUkRFUl9QUkVWKTtcXG4gICAgfVxcblxcbiAgICBwYXVzZSgpIHtcXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XFxuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xcbiAgICB9XFxuXFxuICAgIGN5Y2xlKCkge1xcbiAgICAgIHRoaXMuX2NsZWFySW50ZXJ2YWwoKTtcXG5cXG4gICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpO1xcblxcbiAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gdGhpcy5uZXh0V2hlblZpc2libGUoKSwgdGhpcy5fY29uZmlnLmludGVydmFsKTtcXG4gICAgfVxcblxcbiAgICBfbWF5YmVFbmFibGVDeWNsZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5yaWRlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy5jeWNsZSgpKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5jeWNsZSgpO1xcbiAgICB9XFxuXFxuICAgIHRvKGluZGV4KSB7XFxuICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLl9nZXRJdGVtcygpO1xcblxcbiAgICAgIGlmIChpbmRleCA+IGl0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfU0xJRCwgKCkgPT4gdGhpcy50byhpbmRleCkpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9nZXRBY3RpdmUoKSk7XFxuXFxuICAgICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBvcmRlciA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcXG5cXG4gICAgICB0aGlzLl9zbGlkZShvcmRlciwgaXRlbXNbaW5kZXhdKTtcXG4gICAgfVxcblxcbiAgICBkaXNwb3NlKCkge1xcbiAgICAgIGlmICh0aGlzLl9zd2lwZUhlbHBlcikge1xcbiAgICAgICAgdGhpcy5fc3dpcGVIZWxwZXIuZGlzcG9zZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcXG4gICAgICBjb25maWcuZGVmYXVsdEludGVydmFsID0gY29uZmlnLmludGVydmFsO1xcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xcbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOJDEsIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRU5URVIkMSwgKCkgPT4gdGhpcy5wYXVzZSgpKTtcXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUxFQVZFJDEsICgpID0+IHRoaXMuX21heWJlRW5hYmxlQ3ljbGUoKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcudG91Y2ggJiYgU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xcbiAgICAgICAgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfYWRkVG91Y2hFdmVudExpc3RlbmVycygpIHtcXG4gICAgICBmb3IgKGNvbnN0IGltZyBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lURU1fSU1HLCB0aGlzLl9lbGVtZW50KSkge1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGltZywgRVZFTlRfRFJBR19TVEFSVCwgZXZlbnQgPT4gZXZlbnQucHJldmVudERlZmF1bHQoKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGVuZENhbGxCYWNrID0gKCkgPT4ge1xcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSAhPT0gJ2hvdmVyJykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9IC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxcbiAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcXG4gICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXFxuICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxcbiAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxcbiAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXFxuXFxuXFxuICAgICAgICB0aGlzLnBhdXNlKCk7XFxuXFxuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudG91Y2hUaW1lb3V0KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xcbiAgICAgIH07XFxuXFxuICAgICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XFxuICAgICAgICBsZWZ0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX0xFRlQpKSxcXG4gICAgICAgIHJpZ2h0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX1JJR0hUKSksXFxuICAgICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcXG4gICAgICB9O1xcbiAgICAgIHRoaXMuX3N3aXBlSGVscGVyID0gbmV3IFN3aXBlKHRoaXMuX2VsZW1lbnQsIHN3aXBlQ29uZmlnKTtcXG4gICAgfVxcblxcbiAgICBfa2V5ZG93bihldmVudCkge1xcbiAgICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBLRVlfVE9fRElSRUNUSU9OW2V2ZW50LmtleV07XFxuXFxuICAgICAgaWYgKGRpcmVjdGlvbikge1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgIHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9nZXRJdGVtSW5kZXgoZWxlbWVudCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtcygpLmluZGV4T2YoZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoaW5kZXgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XFxuICAgICAgYWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XFxuICAgICAgYWN0aXZlSW5kaWNhdG9yLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50Jyk7XFxuICAgICAgY29uc3QgbmV3QWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShgW2RhdGEtYnMtc2xpZGUtdG89XFxcIiR7aW5kZXh9XFxcIl1gLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XFxuXFxuICAgICAgaWYgKG5ld0FjdGl2ZUluZGljYXRvcikge1xcbiAgICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XFxuICAgICAgICBuZXdBY3RpdmVJbmRpY2F0b3Iuc2V0QXR0cmlidXRlKCdhcmlhLWN1cnJlbnQnLCAndHJ1ZScpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfdXBkYXRlSW50ZXJ2YWwoKSB7XFxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQgfHwgdGhpcy5fZ2V0QWN0aXZlKCk7XFxuXFxuICAgICAgaWYgKCFlbGVtZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGVsZW1lbnRJbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1pbnRlcnZhbCcpLCAxMCk7XFxuICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gZWxlbWVudEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWw7XFxuICAgIH1cXG5cXG4gICAgX3NsaWRlKG9yZGVyLCBlbGVtZW50ID0gbnVsbCkge1xcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHRoaXMuX2dldEFjdGl2ZSgpO1xcblxcbiAgICAgIGNvbnN0IGlzTmV4dCA9IG9yZGVyID09PSBPUkRFUl9ORVhUO1xcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRJdGVtcygpLCBhY3RpdmVFbGVtZW50LCBpc05leHQsIHRoaXMuX2NvbmZpZy53cmFwKTtcXG5cXG4gICAgICBpZiAobmV4dEVsZW1lbnQgPT09IGFjdGl2ZUVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgbmV4dEVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChuZXh0RWxlbWVudCk7XFxuXFxuICAgICAgY29uc3QgdHJpZ2dlckV2ZW50ID0gZXZlbnROYW1lID0+IHtcXG4gICAgICAgIHJldHVybiBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBldmVudE5hbWUsIHtcXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogbmV4dEVsZW1lbnQsXFxuICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5fb3JkZXJUb0RpcmVjdGlvbihvcmRlciksXFxuICAgICAgICAgIGZyb206IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KSxcXG4gICAgICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuXFxuICAgICAgY29uc3Qgc2xpZGVFdmVudCA9IHRyaWdnZXJFdmVudChFVkVOVF9TTElERSk7XFxuXFxuICAgICAgaWYgKHNsaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XFxuICAgICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcXG4gICAgICAgIC8vIHRvZG86IGNoYW5nZSB0ZXN0cyB0aGF0IHVzZSBlbXB0eSBkaXZzIHRvIGF2b2lkIHRoaXMgY2hlY2tcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbCk7XFxuICAgICAgdGhpcy5wYXVzZSgpO1xcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudChuZXh0RWxlbWVudEluZGV4KTtcXG5cXG4gICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbmV4dEVsZW1lbnQ7XFxuICAgICAgY29uc3QgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX1NUQVJUIDogQ0xBU1NfTkFNRV9FTkQ7XFxuICAgICAgY29uc3Qgb3JkZXJDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX05FWFQgOiBDTEFTU19OQU1FX1BSRVY7XFxuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChvcmRlckNsYXNzTmFtZSk7XFxuICAgICAgcmVmbG93KG5leHRFbGVtZW50KTtcXG4gICAgICBhY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZGlyZWN0aW9uYWxDbGFzc05hbWUpO1xcblxcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XFxuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGRpcmVjdGlvbmFsQ2xhc3NOYW1lLCBvcmRlckNsYXNzTmFtZSk7XFxuICAgICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDIpO1xcbiAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XFxuICAgICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcXG4gICAgICAgIHRyaWdnZXJFdmVudChFVkVOVF9TTElEKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgYWN0aXZlRWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcXG5cXG4gICAgICBpZiAoaXNDeWNsaW5nKSB7XFxuICAgICAgICB0aGlzLmN5Y2xlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9pc0FuaW1hdGVkKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NMSURFKTtcXG4gICAgfVxcblxcbiAgICBfZ2V0QWN0aXZlKCkge1xcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0FDVElWRV9JVEVNLCB0aGlzLl9lbGVtZW50KTtcXG4gICAgfVxcblxcbiAgICBfZ2V0SXRlbXMoKSB7XFxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSVRFTSwgdGhpcy5fZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgX2NsZWFySW50ZXJ2YWwoKSB7XFxuICAgICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XFxuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcXG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSB7XFxuICAgICAgaWYgKGlzUlRMKCkpIHtcXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfUFJFViA6IE9SREVSX05FWFQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9MRUZUID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVY7XFxuICAgIH1cXG5cXG4gICAgX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpIHtcXG4gICAgICBpZiAoaXNSVEwoKSkge1xcbiAgICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9SSUdIVCA6IERJUkVDVElPTl9MRUZUO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY29uc3QgZGF0YSA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgICBkYXRhLnRvKGNvbmZpZyk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxcbiAgICovXFxuXFxuXFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUsIFNFTEVDVE9SX0RBVEFfU0xJREUsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xcblxcbiAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0NBUk9VU0VMKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBjb25zdCBjYXJvdXNlbCA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcXG4gICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLXNsaWRlLXRvJyk7XFxuXFxuICAgIGlmIChzbGlkZUluZGV4KSB7XFxuICAgICAgY2Fyb3VzZWwudG8oc2xpZGVJbmRleCk7XFxuXFxuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUodGhpcywgJ3NsaWRlJykgPT09ICduZXh0Jykge1xcbiAgICAgIGNhcm91c2VsLm5leHQoKTtcXG5cXG4gICAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xcblxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBjYXJvdXNlbC5wcmV2KCk7XFxuXFxuICAgIGNhcm91c2VsLl9tYXliZUVuYWJsZUN5Y2xlKCk7XFxuICB9KTtcXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMywgKCkgPT4ge1xcbiAgICBjb25zdCBjYXJvdXNlbHMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfUklERSk7XFxuXFxuICAgIGZvciAoY29uc3QgY2Fyb3VzZWwgb2YgY2Fyb3VzZWxzKSB7XFxuICAgICAgQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZShjYXJvdXNlbCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKENhcm91c2VsKTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogY29sbGFwc2UuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSRiID0gJ2NvbGxhcHNlJztcXG4gIGNvbnN0IERBVEFfS0VZJDcgPSAnYnMuY29sbGFwc2UnO1xcbiAgY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xcbiAgY29uc3QgREFUQV9BUElfS0VZJDQgPSAnLmRhdGEtYXBpJztcXG4gIGNvbnN0IEVWRU5UX1NIT1ckNiA9IGBzaG93JHtFVkVOVF9LRVkkN31gO1xcbiAgY29uc3QgRVZFTlRfU0hPV04kNiA9IGBzaG93biR7RVZFTlRfS0VZJDd9YDtcXG4gIGNvbnN0IEVWRU5UX0hJREUkNiA9IGBoaWRlJHtFVkVOVF9LRVkkN31gO1xcbiAgY29uc3QgRVZFTlRfSElEREVOJDYgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDcgPSAnc2hvdyc7XFxuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFID0gJ2NvbGxhcHNlJztcXG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcXG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XFxuICBjb25zdCBDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiA9IGA6c2NvcGUgLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX0gLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX1gO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnO1xcbiAgY29uc3QgV0lEVEggPSAnd2lkdGgnO1xcbiAgY29uc3QgSEVJR0hUID0gJ2hlaWdodCc7XFxuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5jb2xsYXBzZS5zaG93LCAuY29sbGFwc2UuY29sbGFwc2luZyc7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0ID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXSc7XFxuICBjb25zdCBEZWZhdWx0JGEgPSB7XFxuICAgIHBhcmVudDogbnVsbCxcXG4gICAgdG9nZ2xlOiB0cnVlXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkYSA9IHtcXG4gICAgcGFyZW50OiAnKG51bGx8ZWxlbWVudCknLFxcbiAgICB0b2dnbGU6ICdib29sZWFuJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBDb2xsYXBzZSBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdO1xcbiAgICAgIGNvbnN0IHRvZ2dsZUxpc3QgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xcblxcbiAgICAgIGZvciAoY29uc3QgZWxlbSBvZiB0b2dnbGVMaXN0KSB7XFxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XFxuICAgICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikuZmlsdGVyKGZvdW5kRWxlbWVudCA9PiBmb3VuZEVsZW1lbnQgPT09IHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsICYmIGZpbHRlckVsZW1lbnQubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGVsZW0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKTtcXG5cXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcXG4gICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl90cmlnZ2VyQXJyYXksIHRoaXMuX2lzU2hvd24oKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcudG9nZ2xlKSB7XFxuICAgICAgICB0aGlzLnRvZ2dsZSgpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCRhO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGE7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJGI7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIHRvZ2dsZSgpIHtcXG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XFxuICAgICAgICB0aGlzLmhpZGUoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5zaG93KCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHNob3coKSB7XFxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCB0aGlzLl9pc1Nob3duKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgbGV0IGFjdGl2ZUNoaWxkcmVuID0gW107IC8vIGZpbmQgYWN0aXZlIGNoaWxkcmVuXFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcXG4gICAgICAgIGFjdGl2ZUNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0FDVElWRVMpLmZpbHRlcihlbGVtZW50ID0+IGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQpLm1hcChlbGVtZW50ID0+IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwge1xcbiAgICAgICAgICB0b2dnbGU6IGZhbHNlXFxuICAgICAgICB9KSk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChhY3RpdmVDaGlsZHJlbi5sZW5ndGggJiYgYWN0aXZlQ2hpbGRyZW5bMF0uX2lzVHJhbnNpdGlvbmluZykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ2KTtcXG5cXG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoY29uc3QgYWN0aXZlSW5zdGFuY2Ugb2YgYWN0aXZlQ2hpbGRyZW4pIHtcXG4gICAgICAgIGFjdGl2ZUluc3RhbmNlLmhpZGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDA7XFxuXFxuICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XFxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ2KTtcXG4gICAgICB9O1xcblxcbiAgICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSk7XFxuICAgICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGBzY3JvbGwke2NhcGl0YWxpemVkRGltZW5zaW9ufWA7XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGA7XFxuICAgIH1cXG5cXG4gICAgaGlkZSgpIHtcXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICF0aGlzLl9pc1Nob3duKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNik7XFxuXFxuICAgICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgO1xcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xcblxcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0aGlzLl90cmlnZ2VyQXJyYXkpIHtcXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRyaWdnZXIpO1xcblxcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXRoaXMuX2lzU2hvd24oZWxlbWVudCkpIHtcXG4gICAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKFt0cmlnZ2VyXSwgZmFsc2UpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xcblxcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcXG5cXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFKTtcXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ2KTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xcbiAgICB9XFxuXFxuICAgIF9pc1Nob3duKGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50KSB7XFxuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xcbiAgICAgIGNvbmZpZy50b2dnbGUgPSBCb29sZWFuKGNvbmZpZy50b2dnbGUpOyAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xcblxcbiAgICAgIGNvbmZpZy5wYXJlbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5wYXJlbnQpO1xcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2dldERpbWVuc2lvbigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9IT1JJWk9OVEFMKSA/IFdJRFRIIDogSEVJR0hUO1xcbiAgICB9XFxuXFxuICAgIF9pbml0aWFsaXplQ2hpbGRyZW4oKSB7XFxuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdGhpcy5fZ2V0Rmlyc3RMZXZlbENoaWxkcmVuKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQpO1xcblxcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBjaGlsZHJlbikge1xcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBnZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpO1xcblxcbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XFxuICAgICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZWxlbWVudF0sIHRoaXMuX2lzU2hvd24oc2VsZWN0ZWQpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2dldEZpcnN0TGV2ZWxDaGlsZHJlbihzZWxlY3Rvcikge1xcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gU2VsZWN0b3JFbmdpbmUuZmluZChDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiwgdGhpcy5fY29uZmlnLnBhcmVudCk7IC8vIHJlbW92ZSBjaGlsZHJlbiBpZiBncmVhdGVyIGRlcHRoXFxuXFxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcihlbGVtZW50ID0+ICFjaGlsZHJlbi5pbmNsdWRlcyhlbGVtZW50KSk7XFxuICAgIH1cXG5cXG4gICAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0cmlnZ2VyQXJyYXksIGlzT3Blbikge1xcbiAgICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlckFycmF5KSB7XFxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9DT0xMQVBTRUQsICFpc09wZW4pO1xcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pO1xcbiAgICAgIH1cXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICBjb25zdCBfY29uZmlnID0ge307XFxuXFxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xcbiAgICAgICAgX2NvbmZpZy50b2dnbGUgPSBmYWxzZTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBfY29uZmlnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxcbiAgICovXFxuXFxuXFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICAvLyBwcmV2ZW50RGVmYXVsdCBvbmx5IGZvciA8YT4gZWxlbWVudHMgKHdoaWNoIGNoYW5nZSB0aGUgVVJMKSBub3QgaW5zaWRlIHRoZSBjb2xsYXBzaWJsZSBlbGVtZW50XFxuICAgIGlmIChldmVudC50YXJnZXQudGFnTmFtZSA9PT0gJ0EnIHx8IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmIGV2ZW50LmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09ICdBJykge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG5cXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpO1xcbiAgICBjb25zdCBzZWxlY3RvckVsZW1lbnRzID0gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3Rvcik7XFxuXFxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBzZWxlY3RvckVsZW1lbnRzKSB7XFxuICAgICAgQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XFxuICAgICAgICB0b2dnbGU6IGZhbHNlXFxuICAgICAgfSkudG9nZ2xlKCk7XFxuICAgIH1cXG4gIH0pO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKENvbGxhcHNlKTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogZHJvcGRvd24uanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSRhID0gJ2Ryb3Bkb3duJztcXG4gIGNvbnN0IERBVEFfS0VZJDYgPSAnYnMuZHJvcGRvd24nO1xcbiAgY29uc3QgRVZFTlRfS0VZJDYgPSBgLiR7REFUQV9LRVkkNn1gO1xcbiAgY29uc3QgREFUQV9BUElfS0VZJDMgPSAnLmRhdGEtYXBpJztcXG4gIGNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xcbiAgY29uc3QgVEFCX0tFWSQxID0gJ1RhYic7XFxuICBjb25zdCBBUlJPV19VUF9LRVkkMSA9ICdBcnJvd1VwJztcXG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZJDEgPSAnQXJyb3dEb3duJztcXG4gIGNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTiA9IDI7IC8vIE1vdXNlRXZlbnQuYnV0dG9uIHZhbHVlIGZvciB0aGUgc2Vjb25kYXJ5IGJ1dHRvbiwgdXN1YWxseSB0aGUgcmlnaHQgYnV0dG9uXFxuXFxuICBjb25zdCBFVkVOVF9ISURFJDUgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ1ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDZ9YDtcXG4gIGNvbnN0IEVWRU5UX1NIT1ckNSA9IGBzaG93JHtFVkVOVF9LRVkkNn1gO1xcbiAgY29uc3QgRVZFTlRfU0hPV04kNSA9IGBzaG93biR7RVZFTlRfS0VZJDZ9YDtcXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMgPSBgY2xpY2ske0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcXG4gIGNvbnN0IEVWRU5UX0tFWURPV05fREFUQV9BUEkgPSBga2V5ZG93biR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xcbiAgY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ2ID0gJ3Nob3cnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJztcXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUEVORCA9ICdkcm9wZW5kJztcXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFNUQVJUID0gJ2Ryb3BzdGFydCc7XFxuICBjb25zdCBDTEFTU19OQU1FX0RST1BVUF9DRU5URVIgPSAnZHJvcHVwLWNlbnRlcic7XFxuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiA9ICdkcm9wZG93bi1jZW50ZXInO1xcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMyA9ICdbZGF0YS1icy10b2dnbGU9XFxcImRyb3Bkb3duXFxcIl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknO1xcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04gPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzfS4ke0NMQVNTX05BTUVfU0hPVyQ2fWA7XFxuICBjb25zdCBTRUxFQ1RPUl9NRU5VID0gJy5kcm9wZG93bi1tZW51JztcXG4gIGNvbnN0IFNFTEVDVE9SX05BVkJBUiA9ICcubmF2YmFyJztcXG4gIGNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnO1xcbiAgY29uc3QgU0VMRUNUT1JfVklTSUJMRV9JVEVNUyA9ICcuZHJvcGRvd24tbWVudSAuZHJvcGRvd24taXRlbTpub3QoLmRpc2FibGVkKTpub3QoOmRpc2FibGVkKSc7XFxuICBjb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnO1xcbiAgY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9IGlzUlRMKCkgPyAndG9wLXN0YXJ0JyA6ICd0b3AtZW5kJztcXG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT00gPSBpc1JUTCgpID8gJ2JvdHRvbS1lbmQnIDogJ2JvdHRvbS1zdGFydCc7XFxuICBjb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnO1xcbiAgY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gaXNSVEwoKSA/ICdsZWZ0LXN0YXJ0JyA6ICdyaWdodC1zdGFydCc7XFxuICBjb25zdCBQTEFDRU1FTlRfTEVGVCA9IGlzUlRMKCkgPyAncmlnaHQtc3RhcnQnIDogJ2xlZnQtc3RhcnQnO1xcbiAgY29uc3QgUExBQ0VNRU5UX1RPUENFTlRFUiA9ICd0b3AnO1xcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiA9ICdib3R0b20nO1xcbiAgY29uc3QgRGVmYXVsdCQ5ID0ge1xcbiAgICBhdXRvQ2xvc2U6IHRydWUsXFxuICAgIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcXG4gICAgZGlzcGxheTogJ2R5bmFtaWMnLFxcbiAgICBvZmZzZXQ6IFswLCAyXSxcXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsLFxcbiAgICByZWZlcmVuY2U6ICd0b2dnbGUnXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcXG4gICAgYXV0b0Nsb3NlOiAnKGJvb2xlYW58c3RyaW5nKScsXFxuICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXFxuICAgIGRpc3BsYXk6ICdzdHJpbmcnLFxcbiAgICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXFxuICAgIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxcbiAgICByZWZlcmVuY2U6ICcoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KSdcXG4gIH07XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgRHJvcGRvd24gZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcXG4gICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTsgLy8gZHJvcGRvd24gd3JhcHBlclxcblxcbiAgICAgIHRoaXMuX21lbnUgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX01FTlUsIHRoaXMuX3BhcmVudCk7XFxuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCQ5O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDk7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJGE7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIHRvZ2dsZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcXG4gICAgfVxcblxcbiAgICBzaG93KCkge1xcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24oKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxcbiAgICAgIH07XFxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ1LCByZWxhdGVkVGFyZ2V0KTtcXG5cXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fY3JlYXRlUG9wcGVyKCk7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xcbiAgICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXFxuICAgICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXFxuXFxuXFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhdGhpcy5fcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XFxuXFxuICAgICAgdGhpcy5fbWVudS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xcblxcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUsIHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuXFxuICAgIGhpZGUoKSB7XFxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xcbiAgICB9XFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG4gICAgICB9XFxuXFxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xcbiAgICB9XFxuXFxuICAgIHVwZGF0ZSgpIHtcXG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xcblxcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcXG4gICAgICAgIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcXG4gICAgICB9XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDUsIHJlbGF0ZWRUYXJnZXQpO1xcblxcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxcblxcblxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcXG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNik7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ2KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xcblxcbiAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicpO1xcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ1LCByZWxhdGVkVGFyZ2V0KTtcXG4gICAgfVxcblxcbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xcbiAgICAgIGNvbmZpZyA9IHN1cGVyLl9nZXRDb25maWcoY29uZmlnKTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnICYmICFpc0VsZW1lbnQoY29uZmlnLnJlZmVyZW5jZSkgJiYgdHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAvLyBQb3BwZXIgdmlydHVhbCBlbGVtZW50cyByZXF1aXJlIGEgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG1ldGhvZFxcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtOQU1FJGEudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcXFwicmVmZXJlbmNlXFxcIiBwcm92aWRlZCB0eXBlIFxcXCJvYmplY3RcXFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcXFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XFxcIiBtZXRob2QuYCk7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2NyZWF0ZVBvcHBlcigpIHtcXG4gICAgICBpZiAodHlwZW9mIFBvcHBlcl9fbmFtZXNwYWNlID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFxcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBsZXQgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fcGFyZW50O1xcbiAgICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpKSB7XFxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gZ2V0RWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKTtcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2U7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHBvcHBlckNvbmZpZyA9IHRoaXMuX2dldFBvcHBlckNvbmZpZygpO1xcblxcbiAgICAgIHRoaXMuX3BvcHBlciA9IFBvcHBlcl9fbmFtZXNwYWNlLmNyZWF0ZVBvcHBlcihyZWZlcmVuY2VFbGVtZW50LCB0aGlzLl9tZW51LCBwb3BwZXJDb25maWcpO1xcbiAgICB9XFxuXFxuICAgIF9pc1Nob3duKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9tZW51LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNik7XFxuICAgIH1cXG5cXG4gICAgX2dldFBsYWNlbWVudCgpIHtcXG4gICAgICBjb25zdCBwYXJlbnREcm9wZG93biA9IHRoaXMuX3BhcmVudDtcXG5cXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUEVORCkpIHtcXG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfUklHSFQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QU1RBUlQpKSB7XFxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0xFRlQ7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSKSkge1xcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9UT1BDRU5URVI7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9DRU5URVIpKSB7XFxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX0JPVFRPTUNFTlRFUjtcXG4gICAgICB9IC8vIFdlIG5lZWQgdG8gdHJpbSB0aGUgdmFsdWUgYmVjYXVzZSBjdXN0b20gcHJvcGVydGllcyBjYW4gYWxzbyBpbmNsdWRlIHNwYWNlc1xcblxcblxcbiAgICAgIGNvbnN0IGlzRW5kID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZW51KS5nZXRQcm9wZXJ0eVZhbHVlKCctLWJzLXBvc2l0aW9uJykudHJpbSgpID09PSAnZW5kJztcXG5cXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQKSkge1xcbiAgICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX1RPUEVORCA6IFBMQUNFTUVOVF9UT1A7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9CT1RUT01FTkQgOiBQTEFDRU1FTlRfQk9UVE9NO1xcbiAgICB9XFxuXFxuICAgIF9kZXRlY3ROYXZiYXIoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVIpICE9PSBudWxsO1xcbiAgICB9XFxuXFxuICAgIF9nZXRPZmZzZXQoKSB7XFxuICAgICAgY29uc3Qge1xcbiAgICAgICAgb2Zmc2V0XFxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcXG5cXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2Zmc2V0O1xcbiAgICB9XFxuXFxuICAgIF9nZXRQb3BwZXJDb25maWcoKSB7XFxuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xcbiAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcXG4gICAgICAgIG1vZGlmaWVyczogW3tcXG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXFxuICAgICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXFxuICAgICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXFxuICAgICAgICAgIH1cXG4gICAgICAgIH1dXFxuICAgICAgfTsgLy8gRGlzYWJsZSBQb3BwZXIgaWYgd2UgaGF2ZSBhIHN0YXRpYyBkaXNwbGF5IG9yIERyb3Bkb3duIGlzIGluIE5hdmJhclxcblxcbiAgICAgIGlmICh0aGlzLl9pbk5hdmJhciB8fCB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcXG4gICAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicsICdzdGF0aWMnKTsgLy8gdG9kbzp2NiByZW1vdmVcXG5cXG4gICAgICAgIGRlZmF1bHRCc1BvcHBlckNvbmZpZy5tb2RpZmllcnMgPSBbe1xcbiAgICAgICAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxcbiAgICAgICAgfV07XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB7IC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcXG4gICAgICAgIC4uLih0eXBlb2YgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcoZGVmYXVsdEJzUG9wcGVyQ29uZmlnKSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcpXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBfc2VsZWN0TWVudUl0ZW0oe1xcbiAgICAgIGtleSxcXG4gICAgICB0YXJnZXRcXG4gICAgfSkge1xcbiAgICAgIGNvbnN0IGl0ZW1zID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TLCB0aGlzLl9tZW51KS5maWx0ZXIoZWxlbWVudCA9PiBpc1Zpc2libGUoZWxlbWVudCkpO1xcblxcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBpZiB0YXJnZXQgaXNuJ3QgaW5jbHVkZWQgaW4gaXRlbXMgKGUuZy4gd2hlbiBleHBhbmRpbmcgdGhlIGRyb3Bkb3duKVxcbiAgICAgIC8vIGFsbG93IGN5Y2xpbmcgdG8gZ2V0IHRoZSBsYXN0IGl0ZW0gaW4gY2FzZSBrZXkgZXF1YWxzIEFSUk9XX1VQX0tFWVxcblxcblxcbiAgICAgIGdldE5leHRBY3RpdmVFbGVtZW50KGl0ZW1zLCB0YXJnZXQsIGtleSA9PT0gQVJST1dfRE9XTl9LRVkkMSwgIWl0ZW1zLmluY2x1ZGVzKHRhcmdldCkpLmZvY3VzKCk7XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBjbGVhck1lbnVzKGV2ZW50KSB7XFxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gUklHSFRfTU9VU0VfQlVUVE9OIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZJDEpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3Qgb3BlblRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOKTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IHRvZ2dsZSBvZiBvcGVuVG9nZ2xlcykge1xcbiAgICAgICAgY29uc3QgY29udGV4dCA9IERyb3Bkb3duLmdldEluc3RhbmNlKHRvZ2dsZSk7XFxuXFxuICAgICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcXG4gICAgICAgIGNvbnN0IGlzTWVudVRhcmdldCA9IGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9tZW51KTtcXG5cXG4gICAgICAgIGlmIChjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fZWxlbWVudCkgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gJ2luc2lkZScgJiYgIWlzTWVudVRhcmdldCB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnb3V0c2lkZScgJiYgaXNNZW51VGFyZ2V0KSB7XFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfSAvLyBUYWIgbmF2aWdhdGlvbiB0aHJvdWdoIHRoZSBkcm9wZG93biBtZW51IG9yIGV2ZW50cyBmcm9tIGNvbnRhaW5lZCBpbnB1dHMgc2hvdWxkbid0IGNsb3NlIHRoZSBtZW51XFxuXFxuXFxuICAgICAgICBpZiAoY29udGV4dC5fbWVudS5jb250YWlucyhldmVudC50YXJnZXQpICYmIChldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSA9PT0gVEFCX0tFWSQxIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcXG4gICAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb250ZXh0Ll9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBkYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcXG4gICAgICAvLyBJZiBub3QgYW4gVVAgfCBET1dOIHwgRVNDQVBFIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXFxuICAgICAgLy8gSWYgaW5wdXQvdGV4dGFyZWEgJiYgaWYga2V5IGlzIG90aGVyIHRoYW4gRVNDQVBFID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcXG4gICAgICBjb25zdCBpc0lucHV0ID0gL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSk7XFxuICAgICAgY29uc3QgaXNFc2NhcGVFdmVudCA9IGV2ZW50LmtleSA9PT0gRVNDQVBFX0tFWSQyO1xcbiAgICAgIGNvbnN0IGlzVXBPckRvd25FdmVudCA9IFtBUlJPV19VUF9LRVkkMSwgQVJST1dfRE9XTl9LRVkkMV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcXG5cXG4gICAgICBpZiAoIWlzVXBPckRvd25FdmVudCAmJiAhaXNFc2NhcGVFdmVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaXNJbnB1dCAmJiAhaXNFc2NhcGVFdmVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgIGNvbnN0IGdldFRvZ2dsZUJ1dHRvbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZXZlbnQuZGVsZWdhdGVUYXJnZXQucGFyZW50Tm9kZSk7XFxuICAgICAgY29uc3QgaW5zdGFuY2UgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKGdldFRvZ2dsZUJ1dHRvbik7XFxuXFxuICAgICAgaWYgKGlzVXBPckRvd25FdmVudCkge1xcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICBpbnN0YW5jZS5zaG93KCk7XFxuXFxuICAgICAgICBpbnN0YW5jZS5fc2VsZWN0TWVudUl0ZW0oZXZlbnQpO1xcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoaW5zdGFuY2UuX2lzU2hvd24oKSkge1xcbiAgICAgICAgLy8gZWxzZSBpcyBlc2NhcGUgYW5kIHdlIGNoZWNrIGlmIGl0IGlzIHNob3duXFxuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIGluc3RhbmNlLmhpZGUoKTtcXG4gICAgICAgIGdldFRvZ2dsZUJ1dHRvbi5mb2N1cygpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxcbiAgICovXFxuXFxuXFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX01FTlUsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIERyb3Bkb3duLmNsZWFyTWVudXMpO1xcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlVUF9EQVRBX0FQSSwgRHJvcGRvd24uY2xlYXJNZW51cyk7XFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIGZ1bmN0aW9uIChldmVudCkge1xcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnRvZ2dsZSgpO1xcbiAgfSk7XFxuICAvKipcXG4gICAqIGpRdWVyeVxcbiAgICovXFxuXFxuICBkZWZpbmVKUXVlcnlQbHVnaW4oRHJvcGRvd24pO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL3Njcm9sbEJhci5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBTRUxFQ1RPUl9GSVhFRF9DT05URU5UID0gJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnO1xcbiAgY29uc3QgU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQgPSAnLnN0aWNreS10b3AnO1xcbiAgY29uc3QgUFJPUEVSVFlfUEFERElORyA9ICdwYWRkaW5nLXJpZ2h0JztcXG4gIGNvbnN0IFBST1BFUlRZX01BUkdJTiA9ICdtYXJnaW4tcmlnaHQnO1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIFNjcm9sbEJhckhlbHBlciB7XFxuICAgIGNvbnN0cnVjdG9yKCkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBnZXRXaWR0aCgpIHtcXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2lubmVyV2lkdGgjdXNhZ2Vfbm90ZXNcXG4gICAgICBjb25zdCBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xcbiAgICAgIHJldHVybiBNYXRoLmFicyh3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50V2lkdGgpO1xcbiAgICB9XFxuXFxuICAgIGhpZGUoKSB7XFxuICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLmdldFdpZHRoKCk7XFxuXFxuICAgICAgdGhpcy5fZGlzYWJsZU92ZXJGbG93KCk7IC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2UgdGhlIGhpZGRlbiBzY3JvbGxiYXIgd2lkdGhcXG5cXG5cXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpOyAvLyB0cmljazogV2UgYWRqdXN0IHBvc2l0aXZlIHBhZGRpbmdSaWdodCBhbmQgbmVnYXRpdmUgbWFyZ2luUmlnaHQgdG8gc3RpY2t5LXRvcCBlbGVtZW50cyB0byBrZWVwIHNob3dpbmcgZnVsbHdpZHRoXFxuXFxuXFxuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcXG5cXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gd2lkdGgpO1xcbiAgICB9XFxuXFxuICAgIHJlc2V0KCkge1xcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XFxuXFxuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBQUk9QRVJUWV9QQURESU5HKTtcXG5cXG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsIFBST1BFUlRZX1BBRERJTkcpO1xcblxcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTik7XFxuICAgIH1cXG5cXG4gICAgaXNPdmVyZmxvd2luZygpIHtcXG4gICAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9kaXNhYmxlT3ZlckZsb3coKSB7XFxuICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUodGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xcbiAgICB9XFxuXFxuICAgIF9zZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wZXJ0eSwgY2FsbGJhY2spIHtcXG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcXG5cXG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xcbiAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX2VsZW1lbnQgJiYgd2luZG93LmlubmVyV2lkdGggPiBlbGVtZW50LmNsaWVudFdpZHRoICsgc2Nyb2xsYmFyV2lkdGgpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XFxuXFxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xcbiAgICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShzdHlsZVByb3BlcnR5LCBgJHtjYWxsYmFjayhOdW1iZXIucGFyc2VGbG9hdChjYWxjdWxhdGVkVmFsdWUpKX1weGApO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xcbiAgICB9XFxuXFxuICAgIF9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KSB7XFxuICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XFxuXFxuICAgICAgaWYgKGFjdHVhbFZhbHVlKSB7XFxuICAgICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHksIGFjdHVhbFZhbHVlKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHkpIHtcXG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xcbiAgICAgICAgY29uc3QgdmFsdWUgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpOyAvLyBXZSBvbmx5IHdhbnQgdG8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgdmFsdWUgaXMgYG51bGxgOyB0aGUgdmFsdWUgY2FuIGFsc28gYmUgemVyb1xcblxcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XFxuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wZXJ0eSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XFxuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIHZhbHVlKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcXG4gICAgfVxcblxcbiAgICBfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgY2FsbEJhY2spIHtcXG4gICAgICBpZiAoaXNFbGVtZW50KHNlbGVjdG9yKSkge1xcbiAgICAgICAgY2FsbEJhY2soc2VsZWN0b3IpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKGNvbnN0IHNlbCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yLCB0aGlzLl9lbGVtZW50KSkge1xcbiAgICAgICAgY2FsbEJhY2soc2VsKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogdXRpbC9iYWNrZHJvcC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJDkgPSAnYmFja2Ryb3AnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDQgPSAnZmFkZSc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcXG4gIGNvbnN0IEVWRU5UX01PVVNFRE9XTiA9IGBtb3VzZWRvd24uYnMuJHtOQU1FJDl9YDtcXG4gIGNvbnN0IERlZmF1bHQkOCA9IHtcXG4gICAgY2xhc3NOYW1lOiAnbW9kYWwtYmFja2Ryb3AnLFxcbiAgICBjbGlja0NhbGxiYWNrOiBudWxsLFxcbiAgICBpc0FuaW1hdGVkOiBmYWxzZSxcXG4gICAgaXNWaXNpYmxlOiB0cnVlLFxcbiAgICAvLyBpZiBmYWxzZSwgd2UgdXNlIHRoZSBiYWNrZHJvcCBoZWxwZXIgd2l0aG91dCBhZGRpbmcgYW55IGVsZW1lbnQgdG8gdGhlIGRvbVxcbiAgICByb290RWxlbWVudDogJ2JvZHknIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcXG5cXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSQ4ID0ge1xcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxcbiAgICBjbGlja0NhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcXG4gICAgaXNBbmltYXRlZDogJ2Jvb2xlYW4nLFxcbiAgICBpc1Zpc2libGU6ICdib29sZWFuJyxcXG4gICAgcm9vdEVsZW1lbnQ6ICcoZWxlbWVudHxzdHJpbmcpJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBCYWNrZHJvcCBleHRlbmRzIENvbmZpZyB7XFxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICAgIHN1cGVyKCk7XFxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0JDg7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkODtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgICAgcmV0dXJuIE5BTUUkOTtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgc2hvdyhjYWxsYmFjaykge1xcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2FwcGVuZCgpO1xcblxcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XFxuICAgICAgICByZWZsb3coZWxlbWVudCk7XFxuICAgICAgfVxcblxcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNSk7XFxuXFxuICAgICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XFxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBoaWRlKGNhbGxiYWNrKSB7XFxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuaXNWaXNpYmxlKSB7XFxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDUpO1xcblxcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XFxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBkaXNwb3NlKCkge1xcbiAgICAgIGlmICghdGhpcy5faXNBcHBlbmRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTik7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcXG5cXG4gICAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfZ2V0RWxlbWVudCgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcXG4gICAgICAgIGNvbnN0IGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgICBiYWNrZHJvcC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lO1xcblxcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKSB7XFxuICAgICAgICAgIGJhY2tkcm9wLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudCA9IGJhY2tkcm9wO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcXG4gICAgfVxcblxcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcXG4gICAgICAvLyB1c2UgZ2V0RWxlbWVudCgpIHdpdGggdGhlIGRlZmF1bHQgXFxcImJvZHlcXFwiIHRvIGdldCBhIGZyZXNoIEVsZW1lbnQgb24gZWFjaCBpbnN0YW50aWF0aW9uXFxuICAgICAgY29uZmlnLnJvb3RFbGVtZW50ID0gZ2V0RWxlbWVudChjb25maWcucm9vdEVsZW1lbnQpO1xcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2FwcGVuZCgpIHtcXG4gICAgICBpZiAodGhpcy5faXNBcHBlbmRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fZ2V0RWxlbWVudCgpO1xcblxcbiAgICAgIHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xcbiAgICAgICAgZXhlY3V0ZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgX2VtdWxhdGVBbmltYXRpb24oY2FsbGJhY2spIHtcXG4gICAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCB0aGlzLl9nZXRFbGVtZW50KCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKTtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL2ZvY3VzdHJhcC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FJDggPSAnZm9jdXN0cmFwJztcXG4gIGNvbnN0IERBVEFfS0VZJDUgPSAnYnMuZm9jdXN0cmFwJztcXG4gIGNvbnN0IEVWRU5UX0tFWSQ1ID0gYC4ke0RBVEFfS0VZJDV9YDtcXG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4kMiA9IGBmb2N1c2luJHtFVkVOVF9LRVkkNX1gO1xcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9UQUIgPSBga2V5ZG93bi50YWIke0VWRU5UX0tFWSQ1fWA7XFxuICBjb25zdCBUQUJfS0VZID0gJ1RhYic7XFxuICBjb25zdCBUQUJfTkFWX0ZPUldBUkQgPSAnZm9yd2FyZCc7XFxuICBjb25zdCBUQUJfTkFWX0JBQ0tXQVJEID0gJ2JhY2t3YXJkJztcXG4gIGNvbnN0IERlZmF1bHQkNyA9IHtcXG4gICAgYXV0b2ZvY3VzOiB0cnVlLFxcbiAgICB0cmFwRWxlbWVudDogbnVsbCAvLyBUaGUgZWxlbWVudCB0byB0cmFwIGZvY3VzIGluc2lkZSBvZlxcblxcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRUeXBlJDcgPSB7XFxuICAgIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxcbiAgICB0cmFwRWxlbWVudDogJ2VsZW1lbnQnXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIEZvY3VzVHJhcCBleHRlbmRzIENvbmZpZyB7XFxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xcbiAgICAgIHN1cGVyKCk7XFxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XFxuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gbnVsbDtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCQ3O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJDg7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIGFjdGl2YXRlKCkge1xcbiAgICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmF1dG9mb2N1cykge1xcbiAgICAgICAgdGhpcy5fY29uZmlnLnRyYXBFbGVtZW50LmZvY3VzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTsgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUZvY3VzaW4oZXZlbnQpKTtcXG4gICAgICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fVEFCLCBldmVudCA9PiB0aGlzLl9oYW5kbGVLZXlkb3duKGV2ZW50KSk7XFxuICAgICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGRlYWN0aXZhdGUoKSB7XFxuICAgICAgaWYgKCF0aGlzLl9pc0FjdGl2ZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9oYW5kbGVGb2N1c2luKGV2ZW50KSB7XFxuICAgICAgY29uc3Qge1xcbiAgICAgICAgdHJhcEVsZW1lbnRcXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xcblxcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGRvY3VtZW50IHx8IGV2ZW50LnRhcmdldCA9PT0gdHJhcEVsZW1lbnQgfHwgdHJhcEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBlbGVtZW50cyA9IFNlbGVjdG9yRW5naW5lLmZvY3VzYWJsZUNoaWxkcmVuKHRyYXBFbGVtZW50KTtcXG5cXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICB0cmFwRWxlbWVudC5mb2N1cygpO1xcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9PT0gVEFCX05BVl9CQUNLV0FSRCkge1xcbiAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZWxlbWVudHNbMF0uZm9jdXMoKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQpIHtcXG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBUQUJfS0VZKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBldmVudC5zaGlmdEtleSA/IFRBQl9OQVZfQkFDS1dBUkQgOiBUQUJfTkFWX0ZPUldBUkQ7XFxuICAgIH1cXG5cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogbW9kYWwuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSQ3ID0gJ21vZGFsJztcXG4gIGNvbnN0IERBVEFfS0VZJDQgPSAnYnMubW9kYWwnO1xcbiAgY29uc3QgRVZFTlRfS0VZJDQgPSBgLiR7REFUQV9LRVkkNH1gO1xcbiAgY29uc3QgREFUQV9BUElfS0VZJDIgPSAnLmRhdGEtYXBpJztcXG4gIGNvbnN0IEVTQ0FQRV9LRVkkMSA9ICdFc2NhcGUnO1xcbiAgY29uc3QgRVZFTlRfSElERSQ0ID0gYGhpZGUke0VWRU5UX0tFWSQ0fWA7XFxuICBjb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCQxID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQ0fWA7XFxuICBjb25zdCBFVkVOVF9ISURERU4kNCA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ0fWA7XFxuICBjb25zdCBFVkVOVF9TSE9XJDQgPSBgc2hvdyR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDQgPSBgc2hvd24ke0VWRU5UX0tFWSQ0fWA7XFxuICBjb25zdCBFVkVOVF9SRVNJWkUkMSA9IGByZXNpemUke0VWRU5UX0tFWSQ0fWA7XFxuICBjb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyQxID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIgPSBgY2xpY2ske0VWRU5UX0tFWSQ0fSR7REFUQV9BUElfS0VZJDJ9YDtcXG4gIGNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDQgPSAnc2hvdyc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnO1xcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiQxID0gJy5tb2RhbC5zaG93JztcXG4gIGNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcXG4gIGNvbnN0IFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknO1xcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS1icy10b2dnbGU9XFxcIm1vZGFsXFxcIl0nO1xcbiAgY29uc3QgRGVmYXVsdCQ2ID0ge1xcbiAgICBiYWNrZHJvcDogdHJ1ZSxcXG4gICAgZm9jdXM6IHRydWUsXFxuICAgIGtleWJvYXJkOiB0cnVlXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkNiA9IHtcXG4gICAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcXG4gICAgZm9jdXM6ICdib29sZWFuJyxcXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBNb2RhbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xcbiAgICAgIHRoaXMuX2RpYWxvZyA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRElBTE9HLCB0aGlzLl9lbGVtZW50KTtcXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XFxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XFxuICAgICAgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IFNjcm9sbEJhckhlbHBlcigpO1xcblxcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkNjtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ2O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSQ3O1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XFxuICAgIH1cXG5cXG4gICAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XFxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNCwge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldFxcbiAgICAgIH0pO1xcblxcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xcblxcbiAgICAgIHRoaXMuX3Njcm9sbEJhci5oaWRlKCk7XFxuXFxuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTik7XFxuXFxuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XFxuXFxuICAgICAgdGhpcy5fYmFja2Ryb3Auc2hvdygoKSA9PiB0aGlzLl9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSk7XFxuICAgIH1cXG5cXG4gICAgaGlkZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNCk7XFxuXFxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSB0cnVlO1xcblxcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ0KTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xcbiAgICB9XFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgZm9yIChjb25zdCBodG1sRWxlbWVudCBvZiBbd2luZG93LCB0aGlzLl9kaWFsb2ddKSB7XFxuICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGh0bWxFbGVtZW50LCBFVkVOVF9LRVkkNCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcXG5cXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xcblxcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgfVxcblxcbiAgICBoYW5kbGVVcGRhdGUoKSB7XFxuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xcbiAgICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xcbiAgICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCksXFxuICAgICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWUsXFxuICAgICAgICBpc0FuaW1hdGVkOiB0aGlzLl9pc0FuaW1hdGVkKClcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcXG4gICAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XFxuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XFxuICAgICAgLy8gdHJ5IHRvIGFwcGVuZCBkeW5hbWljIG1vZGFsXFxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpKSB7XFxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcsIHRydWUpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcXG4gICAgICBjb25zdCBtb2RhbEJvZHkgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX01PREFMX0JPRFksIHRoaXMuX2RpYWxvZyk7XFxuXFxuICAgICAgaWYgKG1vZGFsQm9keSkge1xcbiAgICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XFxuICAgICAgfVxcblxcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDQpO1xcblxcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25Db21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcXG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDQsIHtcXG4gICAgICAgICAgcmVsYXRlZFRhcmdldFxcbiAgICAgICAgfSk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKHRyYW5zaXRpb25Db21wbGV0ZSwgdGhpcy5fZGlhbG9nLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xcbiAgICB9XFxuXFxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEsIGV2ZW50ID0+IHtcXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkkMSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XFxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XFxuICAgICAgfSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFJDEsICgpID0+IHtcXG4gICAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmICF0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcXG4gICAgICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XFxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSBldmVudC5jdXJyZW50VGFyZ2V0KSB7XFxuICAgICAgICAgIC8vIGNsaWNrIGlzIGluc2lkZSBtb2RhbC1kaWFsb2dcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcXG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xcblxcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XFxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIF9oaWRlTW9kYWwoKSB7XFxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcXG5cXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcXG5cXG4gICAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX09QRU4pO1xcblxcbiAgICAgICAgdGhpcy5fcmVzZXRBZGp1c3RtZW50cygpO1xcblxcbiAgICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XFxuXFxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgX2lzQW5pbWF0ZWQoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQzKTtcXG4gICAgfVxcblxcbiAgICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCQxKTtcXG5cXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xcbiAgICAgIGNvbnN0IGluaXRpYWxPdmVyZmxvd1kgPSB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WTsgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXFxuXFxuICAgICAgaWYgKGluaXRpYWxPdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU1RBVElDKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU1RBVElDKTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NUQVRJQyk7XFxuXFxuICAgICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHtcXG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBpbml0aWFsT3ZlcmZsb3dZO1xcbiAgICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcXG4gICAgICB9LCB0aGlzLl9kaWFsb2cpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogVGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcXG4gICAgICovXFxuXFxuXFxuICAgIF9hZGp1c3REaWFsb2coKSB7XFxuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xcblxcbiAgICAgIGNvbnN0IHNjcm9sbGJhcldpZHRoID0gdGhpcy5fc2Nyb2xsQmFyLmdldFdpZHRoKCk7XFxuXFxuICAgICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDA7XFxuXFxuICAgICAgaWYgKGlzQm9keU92ZXJmbG93aW5nICYmICFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcXG4gICAgICAgIGNvbnN0IHByb3BlcnR5ID0gaXNSVEwoKSA/ICdwYWRkaW5nTGVmdCcgOiAncGFkZGluZ1JpZ2h0JztcXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdSaWdodCcgOiAncGFkZGluZ0xlZnQnO1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtwcm9wZXJ0eV0gPSBgJHtzY3JvbGxiYXJXaWR0aH1weGA7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9yZXNldEFkanVzdG1lbnRzKCkge1xcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSAnJztcXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gIH1cXG4gIC8qKlxcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cXG4gICAqL1xcblxcblxcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQyLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcXG5cXG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX1NIT1ckNCwgc2hvd0V2ZW50ID0+IHtcXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQ0LCAoKSA9PiB7XFxuICAgICAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XFxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSk7IC8vIGF2b2lkIGNvbmZsaWN0IHdoZW4gY2xpY2tpbmcgbW9kYWwgdG9nZ2xlciB3aGlsZSBhbm90aGVyIG9uZSBpcyBvcGVuXFxuXFxuICAgIGNvbnN0IGFscmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SJDEpO1xcblxcbiAgICBpZiAoYWxyZWFkeU9wZW4pIHtcXG4gICAgICBNb2RhbC5nZXRJbnN0YW5jZShhbHJlYWR5T3BlbikuaGlkZSgpO1xcbiAgICB9XFxuXFxuICAgIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XFxuICAgIGRhdGEudG9nZ2xlKHRoaXMpO1xcbiAgfSk7XFxuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihNb2RhbCk7XFxuICAvKipcXG4gICAqIGpRdWVyeVxcbiAgICovXFxuXFxuICBkZWZpbmVKUXVlcnlQbHVnaW4oTW9kYWwpO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiBvZmZjYW52YXMuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSQ2ID0gJ29mZmNhbnZhcyc7XFxuICBjb25zdCBEQVRBX0tFWSQzID0gJ2JzLm9mZmNhbnZhcyc7XFxuICBjb25zdCBFVkVOVF9LRVkkMyA9IGAuJHtEQVRBX0tFWSQzfWA7XFxuICBjb25zdCBEQVRBX0FQSV9LRVkkMSA9ICcuZGF0YS1hcGknO1xcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQyID0gYGxvYWQke0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcXG4gIGNvbnN0IEVTQ0FQRV9LRVkgPSAnRXNjYXBlJztcXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQzID0gJ3Nob3cnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HJDEgPSAnc2hvd2luZyc7XFxuICBjb25zdCBDTEFTU19OQU1FX0hJRElORyA9ICdoaWRpbmcnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdvZmZjYW52YXMtYmFja2Ryb3AnO1xcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnO1xcbiAgY29uc3QgRVZFTlRfU0hPVyQzID0gYHNob3cke0VWRU5UX0tFWSQzfWA7XFxuICBjb25zdCBFVkVOVF9TSE9XTiQzID0gYHNob3duJHtFVkVOVF9LRVkkM31gO1xcbiAgY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQzfWA7XFxuICBjb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkM31gO1xcbiAgY29uc3QgRVZFTlRfSElEREVOJDMgPSBgaGlkZGVuJHtFVkVOVF9LRVkkM31gO1xcbiAgY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDN9YDtcXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDEgPSBgY2xpY2ske0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcXG4gIGNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQzfWA7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxID0gJ1tkYXRhLWJzLXRvZ2dsZT1cXFwib2ZmY2FudmFzXFxcIl0nO1xcbiAgY29uc3QgRGVmYXVsdCQ1ID0ge1xcbiAgICBiYWNrZHJvcDogdHJ1ZSxcXG4gICAga2V5Ym9hcmQ6IHRydWUsXFxuICAgIHNjcm9sbDogZmFsc2VcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0VHlwZSQ1ID0ge1xcbiAgICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxcbiAgICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxcbiAgICBzY3JvbGw6ICdib29sZWFuJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBPZmZjYW52YXMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XFxuICAgICAgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKTtcXG4gICAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XFxuXFxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcXG4gICAgfSAvLyBHZXR0ZXJzXFxuXFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdCQ1O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDU7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xcbiAgICAgIHJldHVybiBOQU1FJDY7XFxuICAgIH0gLy8gUHVibGljXFxuXFxuXFxuICAgIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcXG4gICAgfVxcblxcbiAgICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcXG4gICAgICBpZiAodGhpcy5faXNTaG93bikge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDMsIHtcXG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fYmFja2Ryb3Auc2hvdygpO1xcblxcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xcbiAgICAgICAgbmV3IFNjcm9sbEJhckhlbHBlcigpLmhpZGUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgncm9sZScsICdkaWFsb2cnKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XSU5HJDEpO1xcblxcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XFxuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgdGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XFxuICAgICAgICAgIHRoaXMuX2ZvY3VzdHJhcC5hY3RpdmF0ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQzKTtcXG5cXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkckMSk7XFxuXFxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQzLCB7XFxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcXG4gICAgICAgIH0pO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcXG4gICAgfVxcblxcbiAgICBoaWRlKCkge1xcbiAgICAgIGlmICghdGhpcy5faXNTaG93bikge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFJDMpO1xcblxcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpO1xcblxcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURJTkcpO1xcblxcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZUNhbGxiYWNrID0gKCkgPT4ge1xcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQzLCBDTEFTU19OQU1FX0hJRElORyk7XFxuXFxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcXG5cXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xcbiAgICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkucmVzZXQoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQzKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsYmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XFxuICAgIH1cXG5cXG4gICAgZGlzcG9zZSgpIHtcXG4gICAgICB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCk7XFxuXFxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcXG5cXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xcbiAgICAgIGNvbnN0IGNsaWNrQ2FsbGJhY2sgPSAoKSA9PiB7XFxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xcbiAgICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgIH07IC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZVxcblxcblxcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKTtcXG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcXG4gICAgICAgIGNsYXNzTmFtZTogQ0xBU1NfTkFNRV9CQUNLRFJPUCxcXG4gICAgICAgIGlzVmlzaWJsZSxcXG4gICAgICAgIGlzQW5pbWF0ZWQ6IHRydWUsXFxuICAgICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxcbiAgICAgICAgY2xpY2tDYWxsYmFjazogaXNWaXNpYmxlID8gY2xpY2tDYWxsYmFjayA6IG51bGxcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcXG4gICAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XFxuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XFxuICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSBFU0NBUEVfS0VZKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XFxuICAgICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgfSk7XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gIH1cXG4gIC8qKlxcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cXG4gICAqL1xcblxcblxcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxLCBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcXG5cXG4gICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQzLCAoKSA9PiB7XFxuICAgICAgLy8gZm9jdXMgb24gdHJpZ2dlciB3aGVuIGl0IGlzIGNsb3NlZFxcbiAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcXG4gICAgICAgIHRoaXMuZm9jdXMoKTtcXG4gICAgICB9XFxuICAgIH0pOyAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIGEgdG9nZ2xlciBvZiBhbiBvZmZjYW52YXMsIHdoaWxlIGFub3RoZXIgaXMgb3BlblxcblxcbiAgICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUik7XFxuXFxuICAgIGlmIChhbHJlYWR5T3BlbiAmJiBhbHJlYWR5T3BlbiAhPT0gdGFyZ2V0KSB7XFxuICAgICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XFxuICAgIH1cXG5cXG4gICAgY29uc3QgZGF0YSA9IE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XFxuICAgIGRhdGEudG9nZ2xlKHRoaXMpO1xcbiAgfSk7XFxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIsICgpID0+IHtcXG4gICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBTZWxlY3RvckVuZ2luZS5maW5kKE9QRU5fU0VMRUNUT1IpKSB7XFxuICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2Uoc2VsZWN0b3IpLnNob3coKTtcXG4gICAgfVxcbiAgfSk7XFxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUsICgpID0+IHtcXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoJ1thcmlhLW1vZGFsXVtjbGFzcyo9c2hvd11bY2xhc3MqPW9mZmNhbnZhcy1dJykpIHtcXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xcbiAgICAgICAgT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCkuaGlkZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfSk7XFxuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihPZmZjYW52YXMpO1xcbiAgLyoqXFxuICAgKiBqUXVlcnlcXG4gICAqL1xcblxcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKE9mZmNhbnZhcyk7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHV0aWwvc2FuaXRpemVyLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIGNvbnN0IHVyaUF0dHJpYnV0ZXMgPSBuZXcgU2V0KFsnYmFja2dyb3VuZCcsICdjaXRlJywgJ2hyZWYnLCAnaXRlbXR5cGUnLCAnbG9uZ2Rlc2MnLCAncG9zdGVyJywgJ3NyYycsICd4bGluazpocmVmJ10pO1xcbiAgY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFxcXHctXSokL2k7XFxuICAvKipcXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgYSBjb21tb25seSB1c2VmdWwgc3Vic2V0IG9mIFVSTHMgdGhhdCBhcmUgc2FmZS5cXG4gICAqXFxuICAgKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTIuMi54L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlfHNtcyk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9pO1xcbiAgLyoqXFxuICAgKiBBIHBhdHRlcm4gdGhhdCBtYXRjaGVzIHNhZmUgZGF0YSBVUkxzLiBPbmx5IG1hdGNoZXMgaW1hZ2UsIHZpZGVvIGFuZCBhdWRpbyB0eXBlcy5cXG4gICAqXFxuICAgKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTIuMi54L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXFxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXFxcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxcXGQrL2Etel0rPSokL2k7XFxuXFxuICBjb25zdCBhbGxvd2VkQXR0cmlidXRlID0gKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpID0+IHtcXG4gICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IGF0dHJpYnV0ZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xcblxcbiAgICBpZiAoYWxsb3dlZEF0dHJpYnV0ZUxpc3QuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSkpIHtcXG4gICAgICBpZiAodXJpQXR0cmlidXRlcy5oYXMoYXR0cmlidXRlTmFtZSkpIHtcXG4gICAgICAgIHJldHVybiBCb29sZWFuKFNBRkVfVVJMX1BBVFRFUk4udGVzdChhdHRyaWJ1dGUubm9kZVZhbHVlKSB8fCBEQVRBX1VSTF9QQVRURVJOLnRlc3QoYXR0cmlidXRlLm5vZGVWYWx1ZSkpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfSAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cXG5cXG5cXG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKTtcXG4gIH07XFxuXFxuICBjb25zdCBEZWZhdWx0QWxsb3dsaXN0ID0ge1xcbiAgICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxcbiAgICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxcbiAgICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxcbiAgICBhcmVhOiBbXSxcXG4gICAgYjogW10sXFxuICAgIGJyOiBbXSxcXG4gICAgY29sOiBbXSxcXG4gICAgY29kZTogW10sXFxuICAgIGRpdjogW10sXFxuICAgIGVtOiBbXSxcXG4gICAgaHI6IFtdLFxcbiAgICBoMTogW10sXFxuICAgIGgyOiBbXSxcXG4gICAgaDM6IFtdLFxcbiAgICBoNDogW10sXFxuICAgIGg1OiBbXSxcXG4gICAgaDY6IFtdLFxcbiAgICBpOiBbXSxcXG4gICAgaW1nOiBbJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxcbiAgICBsaTogW10sXFxuICAgIG9sOiBbXSxcXG4gICAgcDogW10sXFxuICAgIHByZTogW10sXFxuICAgIHM6IFtdLFxcbiAgICBzbWFsbDogW10sXFxuICAgIHNwYW46IFtdLFxcbiAgICBzdWI6IFtdLFxcbiAgICBzdXA6IFtdLFxcbiAgICBzdHJvbmc6IFtdLFxcbiAgICB1OiBbXSxcXG4gICAgdWw6IFtdXFxuICB9O1xcbiAgZnVuY3Rpb24gc2FuaXRpemVIdG1sKHVuc2FmZUh0bWwsIGFsbG93TGlzdCwgc2FuaXRpemVGdW5jdGlvbikge1xcbiAgICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XFxuICAgICAgcmV0dXJuIHVuc2FmZUh0bWw7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNhbml0aXplRnVuY3Rpb24gJiYgdHlwZW9mIHNhbml0aXplRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICByZXR1cm4gc2FuaXRpemVGdW5jdGlvbih1bnNhZmVIdG1sKTtcXG4gICAgfVxcblxcbiAgICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xcbiAgICBjb25zdCBjcmVhdGVkRG9jdW1lbnQgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHVuc2FmZUh0bWwsICd0ZXh0L2h0bWwnKTtcXG4gICAgY29uc3QgZWxlbWVudHMgPSBbXS5jb25jYXQoLi4uY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcXG5cXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XFxuICAgICAgY29uc3QgZWxlbWVudE5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxuXFxuICAgICAgaWYgKCFPYmplY3Qua2V5cyhhbGxvd0xpc3QpLmluY2x1ZGVzKGVsZW1lbnROYW1lKSkge1xcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsZW1lbnQuYXR0cmlidXRlcyk7XFxuICAgICAgY29uc3QgYWxsb3dlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQoYWxsb3dMaXN0WycqJ10gfHwgW10sIGFsbG93TGlzdFtlbGVtZW50TmFtZV0gfHwgW10pO1xcblxcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZUxpc3QpIHtcXG4gICAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUubm9kZU5hbWUpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gY3JlYXRlZERvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB1dGlsL3RlbXBsYXRlLWZhY3RvcnkuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSQ1ID0gJ1RlbXBsYXRlRmFjdG9yeSc7XFxuICBjb25zdCBEZWZhdWx0JDQgPSB7XFxuICAgIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcXG4gICAgY29udGVudDoge30sXFxuICAgIC8vIHsgc2VsZWN0b3IgOiB0ZXh0ICwgIHNlbGVjdG9yMiA6IHRleHQyICwgfVxcbiAgICBleHRyYUNsYXNzOiAnJyxcXG4gICAgaHRtbDogZmFsc2UsXFxuICAgIHNhbml0aXplOiB0cnVlLFxcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxcbiAgICB0ZW1wbGF0ZTogJzxkaXY+PC9kaXY+J1xcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XFxuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXFxuICAgIGNvbnRlbnQ6ICdvYmplY3QnLFxcbiAgICBleHRyYUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxcbiAgICBodG1sOiAnYm9vbGVhbicsXFxuICAgIHNhbml0aXplOiAnYm9vbGVhbicsXFxuICAgIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZydcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0Q29udGVudFR5cGUgPSB7XFxuICAgIGVudHJ5OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9ufG51bGwpJyxcXG4gICAgc2VsZWN0b3I6ICcoc3RyaW5nfGVsZW1lbnQpJ1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBUZW1wbGF0ZUZhY3RvcnkgZXh0ZW5kcyBDb25maWcge1xcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcXG4gICAgICBzdXBlcigpO1xcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0JDQ7XFxuICAgIH1cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNDtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgICAgcmV0dXJuIE5BTUUkNTtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgZ2V0Q29udGVudCgpIHtcXG4gICAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyh0aGlzLl9jb25maWcuY29udGVudCkubWFwKGNvbmZpZyA9PiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb25maWcpKS5maWx0ZXIoQm9vbGVhbik7XFxuICAgIH1cXG5cXG4gICAgaGFzQ29udGVudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5nZXRDb250ZW50KCkubGVuZ3RoID4gMDtcXG4gICAgfVxcblxcbiAgICBjaGFuZ2VDb250ZW50KGNvbnRlbnQpIHtcXG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29udGVudCk7XFxuXFxuICAgICAgdGhpcy5fY29uZmlnLmNvbnRlbnQgPSB7IC4uLnRoaXMuX2NvbmZpZy5jb250ZW50LFxcbiAgICAgICAgLi4uY29udGVudFxcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH1cXG5cXG4gICAgdG9IdG1sKCkge1xcbiAgICAgIGNvbnN0IHRlbXBsYXRlV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xcbiAgICAgIHRlbXBsYXRlV3JhcHBlci5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKHRoaXMuX2NvbmZpZy50ZW1wbGF0ZSk7XFxuXFxuICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xcbiAgICAgICAgdGhpcy5fc2V0Q29udGVudCh0ZW1wbGF0ZVdyYXBwZXIsIHRleHQsIHNlbGVjdG9yKTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVdyYXBwZXIuY2hpbGRyZW5bMF07XFxuXFxuICAgICAgY29uc3QgZXh0cmFDbGFzcyA9IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5leHRyYUNsYXNzKTtcXG5cXG4gICAgICBpZiAoZXh0cmFDbGFzcykge1xcbiAgICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCguLi5leHRyYUNsYXNzLnNwbGl0KCcgJykpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGVtcGxhdGU7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZykge1xcbiAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcXG5cXG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29uZmlnLmNvbnRlbnQpO1xcbiAgICB9XFxuXFxuICAgIF9jaGVja0NvbnRlbnQoYXJnKSB7XFxuICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIGNvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKGFyZykpIHtcXG4gICAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoe1xcbiAgICAgICAgICBzZWxlY3RvcixcXG4gICAgICAgICAgZW50cnk6IGNvbnRlbnRcXG4gICAgICAgIH0sIERlZmF1bHRDb250ZW50VHlwZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9zZXRDb250ZW50KHRlbXBsYXRlLCBjb250ZW50LCBzZWxlY3Rvcikge1xcbiAgICAgIGNvbnN0IHRlbXBsYXRlRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IsIHRlbXBsYXRlKTtcXG5cXG4gICAgICBpZiAoIXRlbXBsYXRlRWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb250ZW50ID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oY29udGVudCk7XFxuXFxuICAgICAgaWYgKCFjb250ZW50KSB7XFxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQucmVtb3ZlKCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc0VsZW1lbnQoY29udGVudCkpIHtcXG4gICAgICAgIHRoaXMuX3B1dEVsZW1lbnRJblRlbXBsYXRlKGdldEVsZW1lbnQoY29udGVudCksIHRlbXBsYXRlRWxlbWVudCk7XFxuXFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUoY29udGVudCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XFxuICAgIH1cXG5cXG4gICAgX21heWJlU2FuaXRpemUoYXJnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZSA/IHNhbml0aXplSHRtbChhcmcsIHRoaXMuX2NvbmZpZy5hbGxvd0xpc3QsIHRoaXMuX2NvbmZpZy5zYW5pdGl6ZUZuKSA6IGFyZztcXG4gICAgfVxcblxcbiAgICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oYXJnKSB7XFxuICAgICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBhcmcodGhpcykgOiBhcmc7XFxuICAgIH1cXG5cXG4gICAgX3B1dEVsZW1lbnRJblRlbXBsYXRlKGVsZW1lbnQsIHRlbXBsYXRlRWxlbWVudCkge1xcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaHRtbCkge1xcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9ICcnO1xcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcXG4gICAgfVxcblxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB0b29sdGlwLmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUkNCA9ICd0b29sdGlwJztcXG4gIGNvbnN0IERJU0FMTE9XRURfQVRUUklCVVRFUyA9IG5ldyBTZXQoWydzYW5pdGl6ZScsICdhbGxvd0xpc3QnLCAnc2FuaXRpemVGbiddKTtcXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQyID0gJ2ZhZGUnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9NT0RBTCA9ICdtb2RhbCc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMiA9ICdzaG93JztcXG4gIGNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInO1xcbiAgY29uc3QgU0VMRUNUT1JfTU9EQUwgPSBgLiR7Q0xBU1NfTkFNRV9NT0RBTH1gO1xcbiAgY29uc3QgRVZFTlRfTU9EQUxfSElERSA9ICdoaWRlLmJzLm1vZGFsJztcXG4gIGNvbnN0IFRSSUdHRVJfSE9WRVIgPSAnaG92ZXInO1xcbiAgY29uc3QgVFJJR0dFUl9GT0NVUyA9ICdmb2N1cyc7XFxuICBjb25zdCBUUklHR0VSX0NMSUNLID0gJ2NsaWNrJztcXG4gIGNvbnN0IFRSSUdHRVJfTUFOVUFMID0gJ21hbnVhbCc7XFxuICBjb25zdCBFVkVOVF9ISURFJDIgPSAnaGlkZSc7XFxuICBjb25zdCBFVkVOVF9ISURERU4kMiA9ICdoaWRkZW4nO1xcbiAgY29uc3QgRVZFTlRfU0hPVyQyID0gJ3Nob3cnO1xcbiAgY29uc3QgRVZFTlRfU0hPV04kMiA9ICdzaG93bic7XFxuICBjb25zdCBFVkVOVF9JTlNFUlRFRCA9ICdpbnNlcnRlZCc7XFxuICBjb25zdCBFVkVOVF9DTElDSyQxID0gJ2NsaWNrJztcXG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4kMSA9ICdmb2N1c2luJztcXG4gIGNvbnN0IEVWRU5UX0ZPQ1VTT1VUJDEgPSAnZm9jdXNvdXQnO1xcbiAgY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJztcXG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSAnbW91c2VsZWF2ZSc7XFxuICBjb25zdCBBdHRhY2htZW50TWFwID0ge1xcbiAgICBBVVRPOiAnYXV0bycsXFxuICAgIFRPUDogJ3RvcCcsXFxuICAgIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcXG4gICAgTEVGVDogaXNSVEwoKSA/ICdyaWdodCcgOiAnbGVmdCdcXG4gIH07XFxuICBjb25zdCBEZWZhdWx0JDMgPSB7XFxuICAgIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXFxuICAgIGNvbnRhaW5lcjogZmFsc2UsXFxuICAgIGN1c3RvbUNsYXNzOiAnJyxcXG4gICAgZGVsYXk6IDAsXFxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXSxcXG4gICAgaHRtbDogZmFsc2UsXFxuICAgIG9mZnNldDogWzAsIDBdLFxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxcbiAgICBwb3BwZXJDb25maWc6IG51bGwsXFxuICAgIHNhbml0aXplOiB0cnVlLFxcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxcbiAgICBzZWxlY3RvcjogZmFsc2UsXFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cXFwidG9vbHRpcFxcXCIgcm9sZT1cXFwidG9vbHRpcFxcXCI+JyArICc8ZGl2IGNsYXNzPVxcXCJ0b29sdGlwLWFycm93XFxcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiPjwvZGl2PicgKyAnPC9kaXY+JyxcXG4gICAgdGl0bGU6ICcnLFxcbiAgICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkMyA9IHtcXG4gICAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcXG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXFxuICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXFxuICAgIGNvbnRhaW5lcjogJyhzdHJpbmd8ZWxlbWVudHxib29sZWFuKScsXFxuICAgIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxcbiAgICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXFxuICAgIGZhbGxiYWNrUGxhY2VtZW50czogJ2FycmF5JyxcXG4gICAgaHRtbDogJ2Jvb2xlYW4nLFxcbiAgICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXFxuICAgIHBsYWNlbWVudDogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcXG4gICAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0fGZ1bmN0aW9uKScsXFxuICAgIHNhbml0aXplOiAnYm9vbGVhbicsXFxuICAgIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8Ym9vbGVhbiknLFxcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZycsXFxuICAgIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXFxuICAgIHRyaWdnZXI6ICdzdHJpbmcnXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgaWYgKHR5cGVvZiBQb3BwZXJfX25hbWVzcGFjZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpOyAvLyBQcml2YXRlXFxuXFxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcXG4gICAgICB0aGlzLl90aW1lb3V0ID0gMDtcXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge307XFxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcXG4gICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkgPSBudWxsO1xcbiAgICAgIHRoaXMuX25ld0NvbnRlbnQgPSBudWxsOyAvLyBQcm90ZWN0ZWRcXG5cXG4gICAgICB0aGlzLnRpcCA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5fc2V0TGlzdGVuZXJzKCk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkMztcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQzO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSQ0O1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICBlbmFibGUoKSB7XFxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBkaXNhYmxlKCkge1xcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIHRvZ2dsZUVuYWJsZWQoKSB7XFxuICAgICAgdGhpcy5faXNFbmFibGVkID0gIXRoaXMuX2lzRW5hYmxlZDtcXG4gICAgfVxcblxcbiAgICB0b2dnbGUoZXZlbnQpIHtcXG4gICAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoZXZlbnQpIHtcXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xcblxcbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xcblxcbiAgICAgICAgaWYgKGNvbnRleHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xcbiAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgY29udGV4dC5fbGVhdmUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xcbiAgICAgICAgdGhpcy5fbGVhdmUoKTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fZW50ZXIoKTtcXG4gICAgfVxcblxcbiAgICBkaXNwb3NlKCkge1xcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xcblxcbiAgICAgIGlmICh0aGlzLnRpcCkge1xcbiAgICAgICAgdGhpcy50aXAucmVtb3ZlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcXG5cXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XFxuICAgIH1cXG5cXG4gICAgc2hvdygpIHtcXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCEodGhpcy5faXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPVyQyKSk7XFxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGZpbmRTaGFkb3dSb290KHRoaXMuX2VsZW1lbnQpO1xcblxcbiAgICAgIGNvbnN0IGlzSW5UaGVEb20gPSAoc2hhZG93Um9vdCB8fCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWlzSW5UaGVEb20pIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9IC8vIHRvZG8gdjYgcmVtb3ZlIHRoaXMgT1IgbWFrZSBpdCBvcHRpb25hbFxcblxcblxcbiAgICAgIGlmICh0aGlzLnRpcCkge1xcbiAgICAgICAgdGhpcy50aXAucmVtb3ZlKCk7XFxuICAgICAgICB0aGlzLnRpcCA9IG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xcblxcbiAgICAgIGNvbnN0IHtcXG4gICAgICAgIGNvbnRhaW5lclxcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XFxuXFxuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMudGlwKSkge1xcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZCh0aXApO1xcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSU5TRVJURUQpKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9wb3BwZXIgPSB0aGlzLl9jcmVhdGVQb3BwZXIodGlwKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDIpOyAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXFxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB0byB0aGUgYm9keSdzIGltbWVkaWF0ZSBjaGlsZHJlbjtcXG4gICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxcblxcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgICBjb25zdCBwcmV2aW91c0hvdmVyU3RhdGUgPSB0aGlzLl9pc0hvdmVyZWQ7XFxuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1dOJDIpKTtcXG5cXG4gICAgICAgIGlmIChwcmV2aW91c0hvdmVyU3RhdGUpIHtcXG4gICAgICAgICAgdGhpcy5fbGVhdmUoKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xcbiAgICB9XFxuXFxuICAgIGhpZGUoKSB7XFxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElERSQyKSk7XFxuXFxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRpcEVsZW1lbnQoKTtcXG5cXG4gICAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMik7IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXFxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcXG5cXG4gICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XFxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XFxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2U7XFxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0ZPQ1VTXSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcXG4gICAgICAgICAgdGlwLnJlbW92ZSgpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0hJRERFTiQyKSk7XFxuXFxuICAgICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XFxuICAgICAgfTtcXG5cXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgdGhpcy5faXNBbmltYXRlZCgpKTtcXG4gICAgfVxcblxcbiAgICB1cGRhdGUoKSB7XFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xcbiAgICAgIH1cXG4gICAgfSAvLyBQcm90ZWN0ZWRcXG5cXG5cXG4gICAgX2lzV2l0aENvbnRlbnQoKSB7XFxuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fZ2V0VGl0bGUoKSk7XFxuICAgIH1cXG5cXG4gICAgX2dldFRpcEVsZW1lbnQoKSB7XFxuICAgICAgaWYgKCF0aGlzLnRpcCkge1xcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLl9jcmVhdGVUaXBFbGVtZW50KHRoaXMuX25ld0NvbnRlbnQgfHwgdGhpcy5fZ2V0Q29udGVudEZvclRlbXBsYXRlKCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGhpcy50aXA7XFxuICAgIH1cXG5cXG4gICAgX2NyZWF0ZVRpcEVsZW1lbnQoY29udGVudCkge1xcbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KS50b0h0bWwoKTsgLy8gdG9kbzogcmVtb3ZlIHRoaXMgY2hlY2sgb24gdjZcXG5cXG5cXG4gICAgICBpZiAoIXRpcCkge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgICAgfVxcblxcbiAgICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfRkFERSQyLCBDTEFTU19OQU1FX1NIT1ckMik7IC8vIHRvZG86IG9uIHY2IHRoZSBmb2xsb3dpbmcgY2FuIGJlIGFjaGlldmVkIHdpdGggQ1NTIG9ubHlcXG5cXG4gICAgICB0aXAuY2xhc3NMaXN0LmFkZChgYnMtJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWF1dG9gKTtcXG4gICAgICBjb25zdCB0aXBJZCA9IGdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpLnRvU3RyaW5nKCk7XFxuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZCk7XFxuXFxuICAgICAgaWYgKHRoaXMuX2lzQW5pbWF0ZWQoKSkge1xcbiAgICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gdGlwO1xcbiAgICB9XFxuXFxuICAgIHNldENvbnRlbnQoY29udGVudCkge1xcbiAgICAgIHRoaXMuX25ld0NvbnRlbnQgPSBjb250ZW50O1xcblxcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcXG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcXG5cXG4gICAgICAgIHRoaXMuc2hvdygpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpIHtcXG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGVGYWN0b3J5KSB7XFxuICAgICAgICB0aGlzLl90ZW1wbGF0ZUZhY3RvcnkuY2hhbmdlQ29udGVudChjb250ZW50KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5ID0gbmV3IFRlbXBsYXRlRmFjdG9yeSh7IC4uLnRoaXMuX2NvbmZpZyxcXG4gICAgICAgICAgLy8gdGhlIGBjb250ZW50YCB2YXIgaGFzIHRvIGJlIGFmdGVyIGB0aGlzLl9jb25maWdgXFxuICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIGNvbmZpZy5jb250ZW50IGluIGNhc2Ugb2YgcG9wb3ZlclxcbiAgICAgICAgICBjb250ZW50LFxcbiAgICAgICAgICBleHRyYUNsYXNzOiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY3VzdG9tQ2xhc3MpXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuX3RlbXBsYXRlRmFjdG9yeTtcXG4gICAgfVxcblxcbiAgICBfZ2V0Q29udGVudEZvclRlbXBsYXRlKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBbU0VMRUNUT1JfVE9PTFRJUF9JTk5FUl06IHRoaXMuX2dldFRpdGxlKClcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIF9nZXRUaXRsZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLnRpdGxlKSB8fCB0aGlzLl9jb25maWcub3JpZ2luYWxUaXRsZTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpIHtcXG4gICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRPckNyZWF0ZUluc3RhbmNlKGV2ZW50LmRlbGVnYXRlVGFyZ2V0LCB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpKTtcXG4gICAgfVxcblxcbiAgICBfaXNBbmltYXRlZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmFuaW1hdGlvbiB8fCB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDIpO1xcbiAgICB9XFxuXFxuICAgIF9pc1Nob3duKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnRpcCAmJiB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDIpO1xcbiAgICB9XFxuXFxuICAgIF9jcmVhdGVQb3BwZXIodGlwKSB7XFxuICAgICAgY29uc3QgcGxhY2VtZW50ID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLl9lbGVtZW50KSA6IHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQ7XFxuICAgICAgY29uc3QgYXR0YWNobWVudCA9IEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xcbiAgICAgIHJldHVybiBQb3BwZXJfX25hbWVzcGFjZS5jcmVhdGVQb3BwZXIodGhpcy5fZWxlbWVudCwgdGlwLCB0aGlzLl9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRPZmZzZXQoKSB7XFxuICAgICAgY29uc3Qge1xcbiAgICAgICAgb2Zmc2V0XFxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcXG5cXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gb2Zmc2V0O1xcbiAgICB9XFxuXFxuICAgIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcXG4gICAgICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJyA/IGFyZy5jYWxsKHRoaXMuX2VsZW1lbnQpIDogYXJnO1xcbiAgICB9XFxuXFxuICAgIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xcbiAgICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcXG4gICAgICAgIHBsYWNlbWVudDogYXR0YWNobWVudCxcXG4gICAgICAgIG1vZGlmaWVyczogW3tcXG4gICAgICAgICAgbmFtZTogJ2ZsaXAnLFxcbiAgICAgICAgICBvcHRpb25zOiB7XFxuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXFxuICAgICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXFxuICAgICAgICAgIG9wdGlvbnM6IHtcXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0sIHtcXG4gICAgICAgICAgbmFtZTogJ2Fycm93JyxcXG4gICAgICAgICAgb3B0aW9uczoge1xcbiAgICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxcbiAgICAgICAgICB9XFxuICAgICAgICB9LCB7XFxuICAgICAgICAgIG5hbWU6ICdwcmVTZXRQbGFjZW1lbnQnLFxcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxcbiAgICAgICAgICBwaGFzZTogJ2JlZm9yZU1haW4nLFxcbiAgICAgICAgICBmbjogZGF0YSA9PiB7XFxuICAgICAgICAgICAgLy8gUHJlLXNldCBQb3BwZXIncyBwbGFjZW1lbnQgYXR0cmlidXRlIGluIG9yZGVyIHRvIHJlYWQgdGhlIGFycm93IHNpemVzIHByb3Blcmx5LlxcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgUG9wcGVyIG1peGVzIHVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGRpbWVuc2lvbnMgc2luY2UgdGhlIGluaXRpYWwgYXJyb3cgc3R5bGUgaXMgZm9yIHRvcCBwbGFjZW1lbnRcXG4gICAgICAgICAgICB0aGlzLl9nZXRUaXBFbGVtZW50KCkuc2V0QXR0cmlidXRlKCdkYXRhLXBvcHBlci1wbGFjZW1lbnQnLCBkYXRhLnN0YXRlLnBsYWNlbWVudCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1dXFxuICAgICAgfTtcXG4gICAgICByZXR1cm4geyAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXFxuICAgICAgICAuLi4odHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT09ICdmdW5jdGlvbicgPyB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKGRlZmF1bHRCc1BvcHBlckNvbmZpZykgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnKVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgX3NldExpc3RlbmVycygpIHtcXG4gICAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XFxuXFxuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRyaWdnZXJzKSB7XFxuICAgICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4gdGhpcy50b2dnbGUoZXZlbnQpKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVFJJR0dFUl9NQU5VQUwpIHtcXG4gICAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgPyB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9NT1VTRUVOVEVSKSA6IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTSU4kMSk7XFxuICAgICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX01PVVNFTEVBVkUpIDogdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfRk9DVVNPVVQkMSk7XFxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudEluLCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcXG5cXG4gICAgICAgICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW2V2ZW50LnR5cGUgPT09ICdmb2N1c2luJyA/IFRSSUdHRVJfRk9DVVMgOiBUUklHR0VSX0hPVkVSXSA9IHRydWU7XFxuXFxuICAgICAgICAgICAgY29udGV4dC5fZW50ZXIoKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBldmVudE91dCwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XFxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XFxuXFxuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcXG5cXG4gICAgICAgICAgICBjb250ZXh0Ll9sZWF2ZSgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9ICgpID0+IHtcXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XFxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xcblxcbiAgICAgIGlmICh0aGlzLl9jb25maWcuc2VsZWN0b3IpIHtcXG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IHsgLi4udGhpcy5fY29uZmlnLFxcbiAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcXG4gICAgICAgICAgc2VsZWN0b3I6ICcnXFxuICAgICAgICB9O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfZml4VGl0bGUoKSB7XFxuICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLl9jb25maWcub3JpZ2luYWxUaXRsZTtcXG5cXG4gICAgICBpZiAoIXRpdGxlKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudC50cmltKCkpIHtcXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgdGl0bGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcXG4gICAgfVxcblxcbiAgICBfZW50ZXIoKSB7XFxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSB8fCB0aGlzLl9pc0hvdmVyZWQpIHtcXG4gICAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWU7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWU7XFxuXFxuICAgICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICBpZiAodGhpcy5faXNIb3ZlcmVkKSB7XFxuICAgICAgICAgIHRoaXMuc2hvdygpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5zaG93KTtcXG4gICAgfVxcblxcbiAgICBfbGVhdmUoKSB7XFxuICAgICAgaWYgKHRoaXMuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBmYWxzZTtcXG5cXG4gICAgICB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XFxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgICAgfVxcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5oaWRlKTtcXG4gICAgfVxcblxcbiAgICBfc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XFxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGhhbmRsZXIsIHRpbWVvdXQpO1xcbiAgICB9XFxuXFxuICAgIF9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkge1xcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2FjdGl2ZVRyaWdnZXIpLmluY2x1ZGVzKHRydWUpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XFxuICAgICAgY29uc3QgZGF0YUF0dHJpYnV0ZXMgPSBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IGRhdGFBdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXMoZGF0YUF0dHJpYnV0ZXMpKSB7XFxuICAgICAgICBpZiAoRElTQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhkYXRhQXR0cmlidXRlKSkge1xcbiAgICAgICAgICBkZWxldGUgZGF0YUF0dHJpYnV0ZXNbZGF0YUF0dHJpYnV0ZV07XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGNvbmZpZyA9IHsgLi4uZGF0YUF0dHJpYnV0ZXMsXFxuICAgICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXFxuICAgICAgfTtcXG4gICAgICBjb25maWcgPSB0aGlzLl9tZXJnZUNvbmZpZ09iaihjb25maWcpO1xcbiAgICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcXG5cXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcXG5cXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9XFxuXFxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xcbiAgICAgIGNvbmZpZy5jb250YWluZXIgPSBjb25maWcuY29udGFpbmVyID09PSBmYWxzZSA/IGRvY3VtZW50LmJvZHkgOiBnZXRFbGVtZW50KGNvbmZpZy5jb250YWluZXIpO1xcblxcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmRlbGF5ID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgY29uZmlnLmRlbGF5ID0ge1xcbiAgICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXFxuICAgICAgICAgIGhpZGU6IGNvbmZpZy5kZWxheVxcbiAgICAgICAgfTtcXG4gICAgICB9XFxuXFxuICAgICAgY29uZmlnLm9yaWdpbmFsVGl0bGUgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJztcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcXG4gICAgICAgIGNvbmZpZy50aXRsZSA9IGNvbmZpZy50aXRsZS50b1N0cmluZygpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xcbiAgICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gY29uZmlnO1xcbiAgICB9XFxuXFxuICAgIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcXG4gICAgICBjb25zdCBjb25maWcgPSB7fTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9jb25maWcpIHtcXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdGhpcy5fY29uZmlnW2tleV0pIHtcXG4gICAgICAgICAgY29uZmlnW2tleV0gPSB0aGlzLl9jb25maWdba2V5XTtcXG4gICAgICAgIH1cXG4gICAgICB9IC8vIEluIHRoZSBmdXR1cmUgY2FuIGJlIHJlcGxhY2VkIHdpdGg6XFxuICAgICAgLy8gY29uc3Qga2V5c1dpdGhEaWZmZXJlbnRWYWx1ZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9jb25maWcpLmZpbHRlcihlbnRyeSA9PiB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRbZW50cnlbMF1dICE9PSB0aGlzLl9jb25maWdbZW50cnlbMF1dKVxcbiAgICAgIC8vIGBPYmplY3QuZnJvbUVudHJpZXMoa2V5c1dpdGhEaWZmZXJlbnRWYWx1ZXMpYFxcblxcblxcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX2Rpc3Bvc2VQb3BwZXIoKSB7XFxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcXG5cXG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9IC8vIFN0YXRpY1xcblxcblxcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgY29uc3QgZGF0YSA9IFRvb2x0aXAuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xcblxcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXFxcIiR7Y29uZmlnfVxcXCJgKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIGpRdWVyeVxcbiAgICovXFxuXFxuXFxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVG9vbHRpcCk7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IHBvcG92ZXIuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSQzID0gJ3BvcG92ZXInO1xcbiAgY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJztcXG4gIGNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XFxuICBjb25zdCBEZWZhdWx0JDIgPSB7IC4uLlRvb2x0aXAuRGVmYXVsdCxcXG4gICAgY29udGVudDogJycsXFxuICAgIG9mZnNldDogWzAsIDhdLFxcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXFxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cXFwicG9wb3ZlclxcXCIgcm9sZT1cXFwidG9vbHRpcFxcXCI+JyArICc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWFycm93XFxcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cXFwicG9wb3Zlci1oZWFkZXJcXFwiPjwvaDM+JyArICc8ZGl2IGNsYXNzPVxcXCJwb3BvdmVyLWJvZHlcXFwiPjwvZGl2PicgKyAnPC9kaXY+JyxcXG4gICAgdHJpZ2dlcjogJ2NsaWNrJ1xcbiAgfTtcXG4gIGNvbnN0IERlZmF1bHRUeXBlJDIgPSB7IC4uLlRvb2x0aXAuRGVmYXVsdFR5cGUsXFxuICAgIGNvbnRlbnQ6ICcobnVsbHxzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXFxuICB9O1xcbiAgLyoqXFxuICAgKiBDbGFzcyBkZWZpbml0aW9uXFxuICAgKi9cXG5cXG4gIGNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcXG4gICAgLy8gR2V0dGVyc1xcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkMjtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQyO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSQzO1xcbiAgICB9IC8vIE92ZXJyaWRlc1xcblxcblxcbiAgICBfaXNXaXRoQ29udGVudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XFxuICAgIH0gLy8gUHJpdmF0ZVxcblxcblxcbiAgICBfZ2V0Q29udGVudEZvclRlbXBsYXRlKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBbU0VMRUNUT1JfVElUTEVdOiB0aGlzLl9nZXRUaXRsZSgpLFxcbiAgICAgICAgW1NFTEVDVE9SX0NPTlRFTlRdOiB0aGlzLl9nZXRDb250ZW50KClcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIF9nZXRDb250ZW50KCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuY29udGVudCk7XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gUG9wb3Zlci5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcXFwiJHtjb25maWd9XFxcImApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZGF0YVtjb25maWddKCk7XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gIH1cXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihQb3BvdmVyKTtcXG5cXG4gIC8qKlxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqIEJvb3RzdHJhcCAodjUuMi4wKTogc2Nyb2xsc3B5LmpzXFxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKi9cXG4gIC8qKlxcbiAgICogQ29uc3RhbnRzXFxuICAgKi9cXG5cXG4gIGNvbnN0IE5BTUUkMiA9ICdzY3JvbGxzcHknO1xcbiAgY29uc3QgREFUQV9LRVkkMiA9ICdicy5zY3JvbGxzcHknO1xcbiAgY29uc3QgRVZFTlRfS0VZJDIgPSBgLiR7REFUQV9LRVkkMn1gO1xcbiAgY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XFxuICBjb25zdCBFVkVOVF9BQ1RJVkFURSA9IGBhY3RpdmF0ZSR7RVZFTlRfS0VZJDJ9YDtcXG4gIGNvbnN0IEVWRU5UX0NMSUNLID0gYGNsaWNrJHtFVkVOVF9LRVkkMn1gO1xcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQxID0gYGxvYWQke0VWRU5UX0tFWSQyfSR7REFUQV9BUElfS0VZfWA7XFxuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0lURU0gPSAnZHJvcGRvd24taXRlbSc7XFxuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSQxID0gJ2FjdGl2ZSc7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1NQWSA9ICdbZGF0YS1icy1zcHk9XFxcInNjcm9sbFxcXCJdJztcXG4gIGNvbnN0IFNFTEVDVE9SX1RBUkdFVF9MSU5LUyA9ICdbaHJlZl0nO1xcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0xJTktTID0gJy5uYXYtbGluayc7XFxuICBjb25zdCBTRUxFQ1RPUl9OQVZfSVRFTVMgPSAnLm5hdi1pdGVtJztcXG4gIGNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSc7XFxuICBjb25zdCBTRUxFQ1RPUl9MSU5LX0lURU1TID0gYCR7U0VMRUNUT1JfTkFWX0xJTktTfSwgJHtTRUxFQ1RPUl9OQVZfSVRFTVN9ID4gJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX0xJU1RfSVRFTVN9YDtcXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOID0gJy5kcm9wZG93bic7XFxuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcXG4gIGNvbnN0IERlZmF1bHQkMSA9IHtcXG4gICAgb2Zmc2V0OiBudWxsLFxcbiAgICAvLyBUT0RPOiB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xcbiAgICByb290TWFyZ2luOiAnMHB4IDBweCAtMjUlJyxcXG4gICAgc21vb3RoU2Nyb2xsOiBmYWxzZSxcXG4gICAgdGFyZ2V0OiBudWxsXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdFR5cGUkMSA9IHtcXG4gICAgb2Zmc2V0OiAnKG51bWJlcnxudWxsKScsXFxuICAgIC8vIFRPRE8gdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcXG4gICAgcm9vdE1hcmdpbjogJ3N0cmluZycsXFxuICAgIHNtb290aFNjcm9sbDogJ2Jvb2xlYW4nLFxcbiAgICB0YXJnZXQ6ICdlbGVtZW50J1xcbiAgfTtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTsgLy8gdGhpcy5fZWxlbWVudCBpcyB0aGUgb2JzZXJ2YWJsZXNDb250YWluZXIgYW5kIGNvbmZpZy50YXJnZXQgdGhlIG1lbnUgbGlua3Mgd3JhcHBlclxcblxcbiAgICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpO1xcbiAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcXG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkub3ZlcmZsb3dZID09PSAndmlzaWJsZScgPyBudWxsIDogdGhpcy5fZWxlbWVudDtcXG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xcbiAgICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcXG4gICAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEgPSB7XFxuICAgICAgICB2aXNpYmxlRW50cnlUb3A6IDAsXFxuICAgICAgICBwYXJlbnRTY3JvbGxUb3A6IDBcXG4gICAgICB9O1xcbiAgICAgIHRoaXMucmVmcmVzaCgpOyAvLyBpbml0aWFsaXplXFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHQkMTtcXG4gICAgfVxcblxcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQxO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRSQyO1xcbiAgICB9IC8vIFB1YmxpY1xcblxcblxcbiAgICByZWZyZXNoKCkge1xcbiAgICAgIHRoaXMuX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKTtcXG5cXG4gICAgICB0aGlzLl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpO1xcblxcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IHRoaXMuX2dldE5ld09ic2VydmVyKCk7XFxuICAgICAgfVxcblxcbiAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMudmFsdWVzKCkpIHtcXG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUoc2VjdGlvbik7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGRpc3Bvc2UoKSB7XFxuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xcblxcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xcbiAgICAgIC8vIFRPRE86IG9uIHY2IHRhcmdldCBzaG91bGQgYmUgZ2l2ZW4gZXhwbGljaXRseSAmIHJlbW92ZSB0aGUge3RhcmdldDogJ3NzLXRhcmdldCd9IGNhc2VcXG4gICAgICBjb25maWcudGFyZ2V0ID0gZ2V0RWxlbWVudChjb25maWcudGFyZ2V0KSB8fCBkb2N1bWVudC5ib2R5O1xcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH1cXG5cXG4gICAgX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCkge1xcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNtb290aFNjcm9sbCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH0gLy8gdW5yZWdpc3RlciBhbnkgcHJldmlvdXMgbGlzdGVuZXJzXFxuXFxuXFxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSyk7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLLCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIGV2ZW50ID0+IHtcXG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLmdldChldmVudC50YXJnZXQuaGFzaCk7XFxuXFxuICAgICAgICBpZiAob2JzZXJ2YWJsZVNlY3Rpb24pIHtcXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuX3Jvb3RFbGVtZW50IHx8IHdpbmRvdztcXG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gb2JzZXJ2YWJsZVNlY3Rpb24ub2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3A7XFxuXFxuICAgICAgICAgIGlmIChyb290LnNjcm9sbFRvKSB7XFxuICAgICAgICAgICAgcm9vdC5zY3JvbGxUbyh7XFxuICAgICAgICAgICAgICB0b3A6IGhlaWdodCxcXG4gICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfSAvLyBDaHJvbWUgNjAgZG9lc24ndCBzdXBwb3J0IGBzY3JvbGxUb2BcXG5cXG5cXG4gICAgICAgICAgcm9vdC5zY3JvbGxUb3AgPSBoZWlnaHQ7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgX2dldE5ld09ic2VydmVyKCkge1xcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XFxuICAgICAgICByb290OiB0aGlzLl9yb290RWxlbWVudCxcXG4gICAgICAgIHRocmVzaG9sZDogWzAuMSwgMC41LCAxXSxcXG4gICAgICAgIHJvb3RNYXJnaW46IHRoaXMuX2dldFJvb3RNYXJnaW4oKVxcbiAgICAgIH07XFxuICAgICAgcmV0dXJuIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHRoaXMuX29ic2VydmVyQ2FsbGJhY2soZW50cmllcyksIG9wdGlvbnMpO1xcbiAgICB9IC8vIFRoZSBsb2dpYyBvZiBzZWxlY3Rpb25cXG5cXG5cXG4gICAgX29ic2VydmVyQ2FsbGJhY2soZW50cmllcykge1xcbiAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBlbnRyeSA9PiB0aGlzLl90YXJnZXRMaW5rcy5nZXQoYCMke2VudHJ5LnRhcmdldC5pZH1gKTtcXG5cXG4gICAgICBjb25zdCBhY3RpdmF0ZSA9IGVudHJ5ID0+IHtcXG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3AgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wO1xcblxcbiAgICAgICAgdGhpcy5fcHJvY2Vzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XFxuICAgICAgfTtcXG5cXG4gICAgICBjb25zdCBwYXJlbnRTY3JvbGxUb3AgPSAodGhpcy5fcm9vdEVsZW1lbnQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5zY3JvbGxUb3A7XFxuICAgICAgY29uc3QgdXNlclNjcm9sbHNEb3duID0gcGFyZW50U2Nyb2xsVG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS5wYXJlbnRTY3JvbGxUb3A7XFxuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcCA9IHBhcmVudFNjcm9sbFRvcDtcXG5cXG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcXG4gICAgICAgIGlmICghZW50cnkuaXNJbnRlcnNlY3RpbmcpIHtcXG4gICAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcXG5cXG4gICAgICAgICAgdGhpcy5fY2xlYXJBY3RpdmVDbGFzcyh0YXJnZXRFbGVtZW50KGVudHJ5KSk7XFxuXFxuICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgY29uc3QgZW50cnlJc0xvd2VyVGhhblByZXZpb3VzID0gZW50cnkudGFyZ2V0Lm9mZnNldFRvcCA+PSB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEudmlzaWJsZUVudHJ5VG9wOyAvLyBpZiB3ZSBhcmUgc2Nyb2xsaW5nIGRvd24sIHBpY2sgdGhlIGJpZ2dlciBvZmZzZXRUb3BcXG5cXG4gICAgICAgIGlmICh1c2VyU2Nyb2xsc0Rvd24gJiYgZW50cnlJc0xvd2VyVGhhblByZXZpb3VzKSB7XFxuICAgICAgICAgIGFjdGl2YXRlKGVudHJ5KTsgLy8gaWYgcGFyZW50IGlzbid0IHNjcm9sbGVkLCBsZXQncyBrZWVwIHRoZSBmaXJzdCB2aXNpYmxlIGl0ZW0sIGJyZWFraW5nIHRoZSBpdGVyYXRpb25cXG5cXG4gICAgICAgICAgaWYgKCFwYXJlbnRTY3JvbGxUb3ApIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9IC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgdXAsIHBpY2sgdGhlIHNtYWxsZXN0IG9mZnNldFRvcFxcblxcblxcbiAgICAgICAgaWYgKCF1c2VyU2Nyb2xsc0Rvd24gJiYgIWVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xcbiAgICAgICAgICBhY3RpdmF0ZShlbnRyeSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9IC8vIFRPRE86IHY2IE9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnMuIFVzZSByb290TWFyZ2luIG9ubHlcXG5cXG5cXG4gICAgX2dldFJvb3RNYXJnaW4oKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vZmZzZXQgPyBgJHt0aGlzLl9jb25maWcub2Zmc2V0fXB4IDBweCAtMzAlYCA6IHRoaXMuX2NvbmZpZy5yb290TWFyZ2luO1xcbiAgICB9XFxuXFxuICAgIF9pbml0aWFsaXplVGFyZ2V0c0FuZE9ic2VydmFibGVzKCkge1xcbiAgICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpO1xcbiAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcXG4gICAgICBjb25zdCB0YXJnZXRMaW5rcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfVEFSR0VUX0xJTktTLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IGFuY2hvciBvZiB0YXJnZXRMaW5rcykge1xcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGFuY2hvciBoYXMgYW4gaWQgYW5kIGlzIG5vdCBkaXNhYmxlZFxcbiAgICAgICAgaWYgKCFhbmNob3IuaGFzaCB8fCBpc0Rpc2FibGVkKGFuY2hvcikpIHtcXG4gICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoYW5jaG9yLmhhc2gsIHRoaXMuX2VsZW1lbnQpOyAvLyBlbnN1cmUgdGhhdCB0aGUgb2JzZXJ2YWJsZVNlY3Rpb24gZXhpc3RzICYgaXMgdmlzaWJsZVxcblxcbiAgICAgICAgaWYgKGlzVmlzaWJsZShvYnNlcnZhYmxlU2VjdGlvbikpIHtcXG4gICAgICAgICAgdGhpcy5fdGFyZ2V0TGlua3Muc2V0KGFuY2hvci5oYXNoLCBhbmNob3IpO1xcblxcbiAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuc2V0KGFuY2hvci5oYXNoLCBvYnNlcnZhYmxlU2VjdGlvbik7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9wcm9jZXNzKHRhcmdldCkge1xcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgPT09IHRhcmdldCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRoaXMuX2NvbmZpZy50YXJnZXQpO1xcblxcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcXG4gICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcXG5cXG4gICAgICB0aGlzLl9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KTtcXG5cXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgX2FjdGl2YXRlUGFyZW50cyh0YXJnZXQpIHtcXG4gICAgICAvLyBBY3RpdmF0ZSBkcm9wZG93biBwYXJlbnRzXFxuICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xcbiAgICAgICAgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSwgdGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfRFJPUERPV04pKS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBmb3IgKGNvbnN0IGxpc3RHcm91cCBvZiBTZWxlY3RvckVuZ2luZS5wYXJlbnRzKHRhcmdldCwgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApKSB7XFxuICAgICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXFxuICAgICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBTZWxlY3RvckVuZ2luZS5wcmV2KGxpc3RHcm91cCwgU0VMRUNUT1JfTElOS19JVEVNUykpIHtcXG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfY2xlYXJBY3RpdmVDbGFzcyhwYXJlbnQpIHtcXG4gICAgICBwYXJlbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKTtcXG4gICAgICBjb25zdCBhY3RpdmVOb2RlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoYCR7U0VMRUNUT1JfVEFSR0VUX0xJTktTfS4ke0NMQVNTX05BTUVfQUNUSVZFJDF9YCwgcGFyZW50KTtcXG5cXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWN0aXZlTm9kZXMpIHtcXG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQxKTtcXG4gICAgICB9XFxuICAgIH0gLy8gU3RhdGljXFxuXFxuXFxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjb25zdCBkYXRhID0gU2Nyb2xsU3B5LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxcbiAgICovXFxuXFxuXFxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDEsICgpID0+IHtcXG4gICAgZm9yIChjb25zdCBzcHkgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1NQWSkpIHtcXG4gICAgICBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZShzcHkpO1xcbiAgICB9XFxuICB9KTtcXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihTY3JvbGxTcHkpO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB0YWIuanNcXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4gICAqL1xcbiAgLyoqXFxuICAgKiBDb25zdGFudHNcXG4gICAqL1xcblxcbiAgY29uc3QgTkFNRSQxID0gJ3RhYic7XFxuICBjb25zdCBEQVRBX0tFWSQxID0gJ2JzLnRhYic7XFxuICBjb25zdCBFVkVOVF9LRVkkMSA9IGAuJHtEQVRBX0tFWSQxfWA7XFxuICBjb25zdCBFVkVOVF9ISURFJDEgPSBgaGlkZSR7RVZFTlRfS0VZJDF9YDtcXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQxID0gYGhpZGRlbiR7RVZFTlRfS0VZJDF9YDtcXG4gIGNvbnN0IEVWRU5UX1NIT1ckMSA9IGBzaG93JHtFVkVOVF9LRVkkMX1gO1xcbiAgY29uc3QgRVZFTlRfU0hPV04kMSA9IGBzaG93biR7RVZFTlRfS0VZJDF9YDtcXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVkkMX1gO1xcbiAgY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkMX1gO1xcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVkkMX1gO1xcbiAgY29uc3QgQVJST1dfTEVGVF9LRVkgPSAnQXJyb3dMZWZ0JztcXG4gIGNvbnN0IEFSUk9XX1JJR0hUX0tFWSA9ICdBcnJvd1JpZ2h0JztcXG4gIGNvbnN0IEFSUk9XX1VQX0tFWSA9ICdBcnJvd1VwJztcXG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZID0gJ0Fycm93RG93bic7XFxuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnO1xcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDEgPSAnZmFkZSc7XFxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcXG4gIGNvbnN0IENMQVNTX0RST1BET1dOID0gJ2Ryb3Bkb3duJztcXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fSVRFTSA9ICcuZHJvcGRvd24taXRlbSc7XFxuICBjb25zdCBOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJzpub3QoLmRyb3Bkb3duLXRvZ2dsZSknO1xcbiAgY29uc3QgU0VMRUNUT1JfVEFCX1BBTkVMID0gJy5saXN0LWdyb3VwLCAubmF2LCBbcm9sZT1cXFwidGFibGlzdFxcXCJdJztcXG4gIGNvbnN0IFNFTEVDVE9SX09VVEVSID0gJy5uYXYtaXRlbSwgLmxpc3QtZ3JvdXAtaXRlbSc7XFxuICBjb25zdCBTRUxFQ1RPUl9JTk5FUiA9IGAubmF2LWxpbmske05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCAubGlzdC1ncm91cC1pdGVtJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgW3JvbGU9XFxcInRhYlxcXCJdJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfWA7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XFxcInRhYlxcXCJdLCBbZGF0YS1icy10b2dnbGU9XFxcInBpbGxcXFwiXSwgW2RhdGEtYnMtdG9nZ2xlPVxcXCJsaXN0XFxcIl0nOyAvLyB0b2RvOnY2OiBjb3VsZCBiZSBvbmx5IGB0YWJgXFxuXFxuICBjb25zdCBTRUxFQ1RPUl9JTk5FUl9FTEVNID0gYCR7U0VMRUNUT1JfSU5ORVJ9LCAke1NFTEVDVE9SX0RBVEFfVE9HR0xFfWA7XFxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUgPSBgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVxcXCJ0YWJcXFwiXSwgLiR7Q0xBU1NfTkFNRV9BQ1RJVkV9W2RhdGEtYnMtdG9nZ2xlPVxcXCJwaWxsXFxcIl0sIC4ke0NMQVNTX05BTUVfQUNUSVZFfVtkYXRhLWJzLXRvZ2dsZT1cXFwibGlzdFxcXCJdYDtcXG4gIC8qKlxcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxcbiAgICovXFxuXFxuICBjbGFzcyBUYWIgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xcbiAgICAgIHN1cGVyKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9UQUJfUEFORUwpO1xcblxcbiAgICAgIGlmICghdGhpcy5fcGFyZW50KSB7XFxuICAgICAgICByZXR1cm47IC8vIHRvZG86IHNob3VsZCBUaHJvdyBleGNlcHRpb24gb24gdjZcXG4gICAgICAgIC8vIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZWxlbWVudC5vdXRlckhUTUx9IGhhcyBub3QgYSB2YWxpZCBwYXJlbnQgJHtTRUxFQ1RPUl9JTk5FUl9FTEVNfWApXFxuICAgICAgfSAvLyBTZXQgdXAgaW5pdGlhbCBhcmlhIGF0dHJpYnV0ZXNcXG5cXG5cXG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlcyh0aGlzLl9wYXJlbnQsIHRoaXMuX2dldENoaWxkcmVuKCkpO1xcblxcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XFxuICAgIH0gLy8gR2V0dGVyc1xcblxcblxcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XFxuICAgICAgcmV0dXJuIE5BTUUkMTtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgc2hvdygpIHtcXG4gICAgICAvLyBTaG93cyB0aGlzIGVsZW0gYW5kIGRlYWN0aXZhdGUgdGhlIGFjdGl2ZSBzaWJsaW5nIGlmIGV4aXN0c1xcbiAgICAgIGNvbnN0IGlubmVyRWxlbSA9IHRoaXMuX2VsZW1lbnQ7XFxuXFxuICAgICAgaWYgKHRoaXMuX2VsZW1Jc0FjdGl2ZShpbm5lckVsZW0pKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfSAvLyBTZWFyY2ggZm9yIGFjdGl2ZSB0YWIgb24gc2FtZSBwYXJlbnQgdG8gZGVhY3RpdmF0ZSBpdFxcblxcblxcbiAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcXG5cXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBhY3RpdmUgPyBFdmVudEhhbmRsZXIudHJpZ2dlcihhY3RpdmUsIEVWRU5UX0hJREUkMSwge1xcbiAgICAgICAgcmVsYXRlZFRhcmdldDogaW5uZXJFbGVtXFxuICAgICAgfSkgOiBudWxsO1xcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKGlubmVyRWxlbSwgRVZFTlRfU0hPVyQxLCB7XFxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBhY3RpdmVcXG4gICAgICB9KTtcXG5cXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgaGlkZUV2ZW50ICYmIGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX2RlYWN0aXZhdGUoYWN0aXZlLCBpbm5lckVsZW0pO1xcblxcbiAgICAgIHRoaXMuX2FjdGl2YXRlKGlubmVyRWxlbSwgYWN0aXZlKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9hY3RpdmF0ZShlbGVtZW50LCByZWxhdGVkRWxlbSkge1xcbiAgICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xcblxcbiAgICAgIHRoaXMuX2FjdGl2YXRlKGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGFjdGl2YXRlL3Nob3cgdGhlIHByb3BlciBzZWN0aW9uXFxuXFxuXFxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcXG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xcblxcbiAgICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgdHJ1ZSk7XFxuXFxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9TSE9XTiQxLCB7XFxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRFbGVtXFxuICAgICAgICB9KTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XFxuICAgIH1cXG5cXG4gICAgX2RlYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcXG4gICAgICBlbGVtZW50LmJsdXIoKTtcXG5cXG4gICAgICB0aGlzLl9kZWFjdGl2YXRlKGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGRlYWN0aXZhdGUgdGhlIHNob3duIHNlY3Rpb24gdG9vXFxuXFxuXFxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcXG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQxKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSk7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcXG5cXG4gICAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIGZhbHNlKTtcXG5cXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX0hJRERFTiQxLCB7XFxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRFbGVtXFxuICAgICAgICB9KTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XFxuICAgIH1cXG5cXG4gICAgX2tleWRvd24oZXZlbnQpIHtcXG4gICAgICBpZiAoIVtBUlJPV19MRUZUX0tFWSwgQVJST1dfUklHSFRfS0VZLCBBUlJPV19VUF9LRVksIEFSUk9XX0RPV05fS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wUHJvcGFnYXRpb24vcHJldmVudERlZmF1bHQgYm90aCBhZGRlZCB0byBzdXBwb3J0IHVwL2Rvd24ga2V5cyB3aXRob3V0IHNjcm9sbGluZyB0aGUgcGFnZVxcblxcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgY29uc3QgaXNOZXh0ID0gW0FSUk9XX1JJR0hUX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSk7XFxuICAgICAgY29uc3QgbmV4dEFjdGl2ZUVsZW1lbnQgPSBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRDaGlsZHJlbigpLmZpbHRlcihlbGVtZW50ID0+ICFpc0Rpc2FibGVkKGVsZW1lbnQpKSwgZXZlbnQudGFyZ2V0LCBpc05leHQsIHRydWUpO1xcblxcbiAgICAgIGlmIChuZXh0QWN0aXZlRWxlbWVudCkge1xcbiAgICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UobmV4dEFjdGl2ZUVsZW1lbnQpLnNob3coKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgX2dldENoaWxkcmVuKCkge1xcbiAgICAgIC8vIGNvbGxlY3Rpb24gb2YgaW5uZXIgZWxlbWVudHNcXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JTk5FUl9FTEVNLCB0aGlzLl9wYXJlbnQpO1xcbiAgICB9XFxuXFxuICAgIF9nZXRBY3RpdmVFbGVtKCkge1xcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbmQoY2hpbGQgPT4gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKSkgfHwgbnVsbDtcXG4gICAgfVxcblxcbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXMocGFyZW50LCBjaGlsZHJlbikge1xcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHBhcmVudCwgJ3JvbGUnLCAndGFibGlzdCcpO1xcblxcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcXG4gICAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpIHtcXG4gICAgICBjaGlsZCA9IHRoaXMuX2dldElubmVyRWxlbWVudChjaGlsZCk7XFxuXFxuICAgICAgY29uc3QgaXNBY3RpdmUgPSB0aGlzLl9lbGVtSXNBY3RpdmUoY2hpbGQpO1xcblxcbiAgICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChjaGlsZCk7XFxuXFxuICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgaXNBY3RpdmUpO1xcblxcbiAgICAgIGlmIChvdXRlckVsZW0gIT09IGNoaWxkKSB7XFxuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhvdXRlckVsZW0sICdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoIWlzQWN0aXZlKSB7XFxuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKGNoaWxkLCAncm9sZScsICd0YWInKTsgLy8gc2V0IGF0dHJpYnV0ZXMgdG8gdGhlIHJlbGF0ZWQgcGFuZWwgdG9vXFxuXFxuXFxuICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKTtcXG4gICAgfVxcblxcbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKSB7XFxuICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RWxlbWVudEZyb21TZWxlY3RvcihjaGlsZCk7XFxuXFxuICAgICAgaWYgKCF0YXJnZXQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHModGFyZ2V0LCAncm9sZScsICd0YWJwYW5lbCcpO1xcblxcbiAgICAgIGlmIChjaGlsZC5pZCkge1xcbiAgICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHModGFyZ2V0LCAnYXJpYS1sYWJlbGxlZGJ5JywgYCMke2NoaWxkLmlkfWApO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgb3Blbikge1xcbiAgICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChlbGVtZW50KTtcXG5cXG4gICAgICBpZiAoIW91dGVyRWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfRFJPUERPV04pKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIGNvbnN0IHRvZ2dsZSA9IChzZWxlY3RvciwgY2xhc3NOYW1lKSA9PiB7XFxuICAgICAgICBjb25zdCBlbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3Rvciwgb3V0ZXJFbGVtKTtcXG5cXG4gICAgICAgIGlmIChlbGVtZW50KSB7XFxuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShjbGFzc05hbWUsIG9wZW4pO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuXFxuICAgICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSwgQ0xBU1NfTkFNRV9BQ1RJVkUpO1xcbiAgICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VLCBDTEFTU19OQU1FX1NIT1ckMSk7XFxuICAgICAgdG9nZ2xlKFNFTEVDVE9SX0RST1BET1dOX0lURU0sIENMQVNTX05BTUVfQUNUSVZFKTtcXG4gICAgICBvdXRlckVsZW0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgb3Blbik7XFxuICAgIH1cXG5cXG4gICAgX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKGVsZW1lbnQsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcXG4gICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBfZWxlbUlzQWN0aXZlKGVsZW0pIHtcXG4gICAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xcbiAgICB9IC8vIFRyeSB0byBnZXQgdGhlIGlubmVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtbGluaylcXG5cXG5cXG4gICAgX2dldElubmVyRWxlbWVudChlbGVtKSB7XFxuICAgICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhTRUxFQ1RPUl9JTk5FUl9FTEVNKSA/IGVsZW0gOiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lOTkVSX0VMRU0sIGVsZW0pO1xcbiAgICB9IC8vIFRyeSB0byBnZXQgdGhlIG91dGVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtaXRlbSlcXG5cXG5cXG4gICAgX2dldE91dGVyRWxlbWVudChlbGVtKSB7XFxuICAgICAgcmV0dXJuIGVsZW0uY2xvc2VzdChTRUxFQ1RPUl9PVVRFUikgfHwgZWxlbTtcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcXG5cXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgfVxcbiAgLyoqXFxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxcbiAgICovXFxuXFxuXFxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB9XFxuXFxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcXG4gIH0pO1xcbiAgLyoqXFxuICAgKiBJbml0aWFsaXplIG9uIGZvY3VzXFxuICAgKi9cXG5cXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFKSkge1xcbiAgICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQpO1xcbiAgICB9XFxuICB9KTtcXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUYWIpO1xcblxcbiAgLyoqXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICogQm9vdHN0cmFwICh2NS4yLjApOiB0b2FzdC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICAvKipcXG4gICAqIENvbnN0YW50c1xcbiAgICovXFxuXFxuICBjb25zdCBOQU1FID0gJ3RvYXN0JztcXG4gIGNvbnN0IERBVEFfS0VZID0gJ2JzLnRvYXN0JztcXG4gIGNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gO1xcbiAgY29uc3QgRVZFTlRfTU9VU0VPVkVSID0gYG1vdXNlb3ZlciR7RVZFTlRfS0VZfWA7XFxuICBjb25zdCBFVkVOVF9NT1VTRU9VVCA9IGBtb3VzZW91dCR7RVZFTlRfS0VZfWA7XFxuICBjb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gO1xcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQgPSBgZm9jdXNvdXQke0VWRU5UX0tFWX1gO1xcbiAgY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YDtcXG4gIGNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gO1xcbiAgY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YDtcXG4gIGNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YDtcXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJztcXG4gIGNvbnN0IENMQVNTX05BTUVfSElERSA9ICdoaWRlJzsgLy8gQGRlcHJlY2F0ZWQgLSBrZXB0IGhlcmUgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcXG5cXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93JztcXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcXG4gIGNvbnN0IERlZmF1bHRUeXBlID0ge1xcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcXG4gICAgYXV0b2hpZGU6ICdib29sZWFuJyxcXG4gICAgZGVsYXk6ICdudW1iZXInXFxuICB9O1xcbiAgY29uc3QgRGVmYXVsdCA9IHtcXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxcbiAgICBhdXRvaGlkZTogdHJ1ZSxcXG4gICAgZGVsYXk6IDUwMDBcXG4gIH07XFxuICAvKipcXG4gICAqIENsYXNzIGRlZmluaXRpb25cXG4gICAqL1xcblxcbiAgY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XFxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcXG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcXG4gICAgICB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gZmFsc2U7XFxuICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGZhbHNlO1xcblxcbiAgICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xcbiAgICB9IC8vIEdldHRlcnNcXG5cXG5cXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xcbiAgICAgIHJldHVybiBEZWZhdWx0O1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XFxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xcbiAgICB9XFxuXFxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcXG4gICAgICByZXR1cm4gTkFNRTtcXG4gICAgfSAvLyBQdWJsaWNcXG5cXG5cXG4gICAgc2hvdygpIHtcXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XKTtcXG5cXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XFxuXFxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpO1xcblxcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04pO1xcblxcbiAgICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcXG4gICAgICB9O1xcblxcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxcblxcblxcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcXG5cXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XLCBDTEFTU19OQU1FX1NIT1dJTkcpO1xcblxcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xcbiAgICB9XFxuXFxuICAgIGhpZGUoKSB7XFxuICAgICAgaWYgKCF0aGlzLmlzU2hvd24oKSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKTtcXG5cXG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcXG5cXG5cXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcsIENMQVNTX05BTUVfU0hPVyk7XFxuXFxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4pO1xcbiAgICAgIH07XFxuXFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyk7XFxuXFxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XFxuICAgIH1cXG5cXG4gICAgZGlzcG9zZSgpIHtcXG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcXG5cXG4gICAgICBpZiAodGhpcy5pc1Nob3duKCkpIHtcXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xcbiAgICAgIH1cXG5cXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XFxuICAgIH1cXG5cXG4gICAgaXNTaG93bigpIHtcXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKTtcXG4gICAgfSAvLyBQcml2YXRlXFxuXFxuXFxuICAgIF9tYXliZVNjaGVkdWxlSGlkZSgpIHtcXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5hdXRvaGlkZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiB8fCB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICAgIHRoaXMuaGlkZSgpO1xcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XFxuICAgIH1cXG5cXG4gICAgX29uSW50ZXJhY3Rpb24oZXZlbnQsIGlzSW50ZXJhY3RpbmcpIHtcXG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcXG4gICAgICAgIGNhc2UgJ21vdXNlb3Zlcic6XFxuICAgICAgICBjYXNlICdtb3VzZW91dCc6XFxuICAgICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xcbiAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxcbiAgICAgICAgY2FzZSAnZm9jdXNvdXQnOlxcbiAgICAgICAgICB0aGlzLl9oYXNLZXlib2FyZEludGVyYWN0aW9uID0gaXNJbnRlcmFjdGluZztcXG4gICAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XFxuICAgICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgY29uc3QgbmV4dEVsZW1lbnQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xcblxcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSBuZXh0RWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKG5leHRFbGVtZW50KSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xcbiAgICB9XFxuXFxuICAgIF9zZXRMaXN0ZW5lcnMoKSB7XFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfRk9DVVNJTiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcXG4gICAgfVxcblxcbiAgICBfY2xlYXJUaW1lb3V0KCkge1xcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcXG4gICAgfSAvLyBTdGF0aWNcXG5cXG5cXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb2FzdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFxcXCIke2NvbmZpZ31cXFwiYCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICB9XFxuICAvKipcXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXFxuICAgKi9cXG5cXG5cXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKFRvYXN0KTtcXG4gIC8qKlxcbiAgICogalF1ZXJ5XFxuICAgKi9cXG5cXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUb2FzdCk7XFxuXFxuICAvKipcXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuICAgKiBCb290c3RyYXAgKHY1LjIuMCk6IGluZGV4LnVtZC5qc1xcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXFxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbiAgICovXFxuICBjb25zdCBpbmRleF91bWQgPSB7XFxuICAgIEFsZXJ0LFxcbiAgICBCdXR0b24sXFxuICAgIENhcm91c2VsLFxcbiAgICBDb2xsYXBzZSxcXG4gICAgRHJvcGRvd24sXFxuICAgIE1vZGFsLFxcbiAgICBPZmZjYW52YXMsXFxuICAgIFBvcG92ZXIsXFxuICAgIFNjcm9sbFNweSxcXG4gICAgVGFiLFxcbiAgICBUb2FzdCxcXG4gICAgVG9vbHRpcFxcbiAgfTtcXG5cXG4gIHJldHVybiBpbmRleF91bWQ7XFxuXFxufSkpO1xcblwiIiwibW9kdWxlLmV4cG9ydHMgPSBcIi8qIVxcbiAqIFNlbGVjdDIgNC4wLjEzXFxuICogaHR0cHM6Ly9zZWxlY3QyLmdpdGh1Yi5pb1xcbiAqXFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXFxuICogaHR0cHM6Ly9naXRodWIuY29tL3NlbGVjdDIvc2VsZWN0Mi9ibG9iL21hc3Rlci9MSUNFTlNFLm1kXFxuICovXFxuOyhmdW5jdGlvbiAoZmFjdG9yeSkge1xcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXFxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcXG4gICAgLy8gTm9kZS9Db21tb25KU1xcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCBqUXVlcnkpIHtcXG4gICAgICBpZiAoalF1ZXJ5ID09PSB1bmRlZmluZWQpIHtcXG4gICAgICAgIC8vIHJlcXVpcmUoJ2pRdWVyeScpIHJldHVybnMgYSBmYWN0b3J5IHRoYXQgcmVxdWlyZXMgd2luZG93IHRvXFxuICAgICAgICAvLyBidWlsZCBhIGpRdWVyeSBpbnN0YW5jZSwgd2Ugbm9ybWFsaXplIGhvdyB3ZSB1c2UgbW9kdWxlc1xcbiAgICAgICAgLy8gdGhhdCByZXF1aXJlIHRoaXMgcGF0dGVybiBidXQgdGhlIHdpbmRvdyBwcm92aWRlZCBpcyBhIG5vb3BcXG4gICAgICAgIC8vIGlmIGl0J3MgZGVmaW5lZCAoaG93IGpxdWVyeSB3b3JrcylcXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICBqUXVlcnkgPSByZXF1aXJlKCdqcXVlcnknKShyb290KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgZmFjdG9yeShqUXVlcnkpO1xcbiAgICAgIHJldHVybiBqUXVlcnk7XFxuICAgIH07XFxuICB9IGVsc2Uge1xcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcXG4gICAgZmFjdG9yeShqUXVlcnkpO1xcbiAgfVxcbn0gKGZ1bmN0aW9uIChqUXVlcnkpIHtcXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHNvIHdlIGNhbiBjYXRjaCB0aGUgQU1EIGxvYWRlciBjb25maWd1cmF0aW9uIGFuZCB1c2UgaXRcXG4gIC8vIFRoZSBpbm5lciBmaWxlIHNob3VsZCBiZSB3cmFwcGVkIChieSBgYmFubmVyLnN0YXJ0LmpzYCkgaW4gYSBmdW5jdGlvbiB0aGF0XFxuICAvLyByZXR1cm5zIHRoZSBBTUQgbG9hZGVyIHJlZmVyZW5jZXMuXFxuICB2YXIgUzIgPShmdW5jdGlvbiAoKSB7XFxuICAvLyBSZXN0b3JlIHRoZSBTZWxlY3QyIEFNRCBsb2FkZXIgc28gaXQgY2FuIGJlIHVzZWRcXG4gIC8vIE5lZWRlZCBtb3N0bHkgaW4gdGhlIGxhbmd1YWdlIGZpbGVzLCB3aGVyZSB0aGUgbG9hZGVyIGlzIG5vdCBpbnNlcnRlZFxcbiAgaWYgKGpRdWVyeSAmJiBqUXVlcnkuZm4gJiYgalF1ZXJ5LmZuLnNlbGVjdDIgJiYgalF1ZXJ5LmZuLnNlbGVjdDIuYW1kKSB7XFxuICAgIHZhciBTMiA9IGpRdWVyeS5mbi5zZWxlY3QyLmFtZDtcXG4gIH1cXG52YXIgUzI7KGZ1bmN0aW9uICgpIHsgaWYgKCFTMiB8fCAhUzIucmVxdWlyZWpzKSB7XFxuaWYgKCFTMikgeyBTMiA9IHt9OyB9IGVsc2UgeyByZXF1aXJlID0gUzI7IH1cXG4vKipcXG4gKiBAbGljZW5zZSBhbG1vbmQgMC4zLjMgQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMuXFxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UsIGh0dHA6Ly9naXRodWIuY29tL3JlcXVpcmVqcy9hbG1vbmQvTElDRU5TRVxcbiAqL1xcbi8vR29pbmcgc2xvcHB5IHRvIGF2b2lkICd1c2Ugc3RyaWN0JyBzdHJpbmcgY29zdCwgYnV0IHN0cmljdCBwcmFjdGljZXMgc2hvdWxkXFxuLy9iZSBmb2xsb3dlZC5cXG4vKmdsb2JhbCBzZXRUaW1lb3V0OiBmYWxzZSAqL1xcblxcbnZhciByZXF1aXJlanMsIHJlcXVpcmUsIGRlZmluZTtcXG4oZnVuY3Rpb24gKHVuZGVmKSB7XFxuICAgIHZhciBtYWluLCByZXEsIG1ha2VNYXAsIGhhbmRsZXJzLFxcbiAgICAgICAgZGVmaW5lZCA9IHt9LFxcbiAgICAgICAgd2FpdGluZyA9IHt9LFxcbiAgICAgICAgY29uZmlnID0ge30sXFxuICAgICAgICBkZWZpbmluZyA9IHt9LFxcbiAgICAgICAgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcXG4gICAgICAgIGFwcyA9IFtdLnNsaWNlLFxcbiAgICAgICAganNTdWZmaXhSZWdFeHAgPSAvXFxcXC5qcyQvO1xcblxcbiAgICBmdW5jdGlvbiBoYXNQcm9wKG9iaiwgcHJvcCkge1xcbiAgICAgICAgcmV0dXJuIGhhc093bi5jYWxsKG9iaiwgcHJvcCk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEdpdmVuIGEgcmVsYXRpdmUgbW9kdWxlIG5hbWUsIGxpa2UgLi9zb21ldGhpbmcsIG5vcm1hbGl6ZSBpdCB0b1xcbiAgICAgKiBhIHJlYWwgbmFtZSB0aGF0IGNhbiBiZSBtYXBwZWQgdG8gYSBwYXRoLlxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgcmVsYXRpdmUgbmFtZVxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYmFzZU5hbWUgYSByZWFsIG5hbWUgdGhhdCB0aGUgbmFtZSBhcmcgaXMgcmVsYXRpdmVcXG4gICAgICogdG8uXFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbmFtZVxcbiAgICAgKi9cXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKG5hbWUsIGJhc2VOYW1lKSB7XFxuICAgICAgICB2YXIgbmFtZVBhcnRzLCBuYW1lU2VnbWVudCwgbWFwVmFsdWUsIGZvdW5kTWFwLCBsYXN0SW5kZXgsXFxuICAgICAgICAgICAgZm91bmRJLCBmb3VuZFN0YXJNYXAsIHN0YXJJLCBpLCBqLCBwYXJ0LCBub3JtYWxpemVkQmFzZVBhcnRzLFxcbiAgICAgICAgICAgIGJhc2VQYXJ0cyA9IGJhc2VOYW1lICYmIGJhc2VOYW1lLnNwbGl0KFxcXCIvXFxcIiksXFxuICAgICAgICAgICAgbWFwID0gY29uZmlnLm1hcCxcXG4gICAgICAgICAgICBzdGFyTWFwID0gKG1hcCAmJiBtYXBbJyonXSkgfHwge307XFxuXFxuICAgICAgICAvL0FkanVzdCBhbnkgcmVsYXRpdmUgcGF0aHMuXFxuICAgICAgICBpZiAobmFtZSkge1xcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCcvJyk7XFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gbmFtZS5sZW5ndGggLSAxO1xcblxcbiAgICAgICAgICAgIC8vIElmIHdhbnRpbmcgbm9kZSBJRCBjb21wYXRpYmlsaXR5LCBzdHJpcCAuanMgZnJvbSBlbmRcXG4gICAgICAgICAgICAvLyBvZiBJRHMuIEhhdmUgdG8gZG8gdGhpcyBoZXJlLCBhbmQgbm90IGluIG5hbWVUb1VybFxcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugbm9kZSBhbGxvd3MgZWl0aGVyIC5qcyBvciBub24gLmpzIHRvIG1hcFxcbiAgICAgICAgICAgIC8vIHRvIHNhbWUgZmlsZS5cXG4gICAgICAgICAgICBpZiAoY29uZmlnLm5vZGVJZENvbXBhdCAmJiBqc1N1ZmZpeFJlZ0V4cC50ZXN0KG5hbWVbbGFzdEluZGV4XSkpIHtcXG4gICAgICAgICAgICAgICAgbmFtZVtsYXN0SW5kZXhdID0gbmFtZVtsYXN0SW5kZXhdLnJlcGxhY2UoanNTdWZmaXhSZWdFeHAsICcnKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy8gU3RhcnRzIHdpdGggYSAnLicgc28gbmVlZCB0aGUgYmFzZU5hbWVcXG4gICAgICAgICAgICBpZiAobmFtZVswXS5jaGFyQXQoMCkgPT09ICcuJyAmJiBiYXNlUGFydHMpIHtcXG4gICAgICAgICAgICAgICAgLy9Db252ZXJ0IGJhc2VOYW1lIHRvIGFycmF5LCBhbmQgbG9wIG9mZiB0aGUgbGFzdCBwYXJ0LFxcbiAgICAgICAgICAgICAgICAvL3NvIHRoYXQgLiBtYXRjaGVzIHRoYXQgJ2RpcmVjdG9yeScgYW5kIG5vdCBuYW1lIG9mIHRoZSBiYXNlTmFtZSdzXFxuICAgICAgICAgICAgICAgIC8vbW9kdWxlLiBGb3IgaW5zdGFuY2UsIGJhc2VOYW1lIG9mICdvbmUvdHdvL3RocmVlJywgbWFwcyB0b1xcbiAgICAgICAgICAgICAgICAvLydvbmUvdHdvL3RocmVlLmpzJywgYnV0IHdlIHdhbnQgdGhlIGRpcmVjdG9yeSwgJ29uZS90d28nIGZvclxcbiAgICAgICAgICAgICAgICAvL3RoaXMgbm9ybWFsaXphdGlvbi5cXG4gICAgICAgICAgICAgICAgbm9ybWFsaXplZEJhc2VQYXJ0cyA9IGJhc2VQYXJ0cy5zbGljZSgwLCBiYXNlUGFydHMubGVuZ3RoIC0gMSk7XFxuICAgICAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemVkQmFzZVBhcnRzLmNvbmNhdChuYW1lKTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgLy9zdGFydCB0cmltRG90c1xcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgICAgIHBhcnQgPSBuYW1lW2ldO1xcbiAgICAgICAgICAgICAgICBpZiAocGFydCA9PT0gJy4nKSB7XFxuICAgICAgICAgICAgICAgICAgICBuYW1lLnNwbGljZShpLCAxKTtcXG4gICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJ0ID09PSAnLi4nKSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhdCB0aGUgc3RhcnQsIG9yIHByZXZpb3VzIHZhbHVlIGlzIHN0aWxsIC4uLFxcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VlcCB0aGVtIHNvIHRoYXQgd2hlbiBjb252ZXJ0ZWQgdG8gYSBwYXRoIGl0IG1heVxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RpbGwgd29yayB3aGVuIGNvbnZlcnRlZCB0byBhIHBhdGgsIGV2ZW4gdGhvdWdoXFxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBhbiBJRCBpdCBpcyBsZXNzIHRoYW4gaWRlYWwuIEluIGxhcmdlciBwb2ludFxcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVsZWFzZXMsIG1heSBiZSBiZXR0ZXIgdG8ganVzdCBraWNrIG91dCBhbiBlcnJvci5cXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwIHx8IChpID09PSAxICYmIG5hbWVbMl0gPT09ICcuLicpIHx8IG5hbWVbaSAtIDFdID09PSAnLi4nKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPiAwKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZS5zcGxpY2UoaSAtIDEsIDIpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMjtcXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvL2VuZCB0cmltRG90c1xcblxcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lLmpvaW4oJy8nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vQXBwbHkgbWFwIGNvbmZpZyBpZiBhdmFpbGFibGUuXFxuICAgICAgICBpZiAoKGJhc2VQYXJ0cyB8fCBzdGFyTWFwKSAmJiBtYXApIHtcXG4gICAgICAgICAgICBuYW1lUGFydHMgPSBuYW1lLnNwbGl0KCcvJyk7XFxuXFxuICAgICAgICAgICAgZm9yIChpID0gbmFtZVBhcnRzLmxlbmd0aDsgaSA+IDA7IGkgLT0gMSkge1xcbiAgICAgICAgICAgICAgICBuYW1lU2VnbWVudCA9IG5hbWVQYXJ0cy5zbGljZSgwLCBpKS5qb2luKFxcXCIvXFxcIik7XFxuXFxuICAgICAgICAgICAgICAgIGlmIChiYXNlUGFydHMpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vRmluZCB0aGUgbG9uZ2VzdCBiYXNlTmFtZSBzZWdtZW50IG1hdGNoIGluIHRoZSBjb25maWcuXFxuICAgICAgICAgICAgICAgICAgICAvL1NvLCBkbyBqb2lucyBvbiB0aGUgYmlnZ2VzdCB0byBzbWFsbGVzdCBsZW5ndGhzIG9mIGJhc2VQYXJ0cy5cXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGJhc2VQYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXBWYWx1ZSA9IG1hcFtiYXNlUGFydHMuc2xpY2UoMCwgaikuam9pbignLycpXTtcXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICAvL2Jhc2VOYW1lIHNlZ21lbnQgaGFzICBjb25maWcsIGZpbmQgaWYgaXQgaGFzIG9uZSBmb3JcXG4gICAgICAgICAgICAgICAgICAgICAgICAvL3RoaXMgbmFtZS5cXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFwVmFsdWUpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwVmFsdWUgPSBtYXBWYWx1ZVtuYW1lU2VnbWVudF07XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXBWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9NYXRjaCwgdXBkYXRlIG5hbWUgdG8gdGhlIG5ldyB2YWx1ZS5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kTWFwID0gbWFwVmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZEkgPSBpO1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kTWFwKSB7XFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgICAvL0NoZWNrIGZvciBhIHN0YXIgbWFwIG1hdGNoLCBidXQganVzdCBob2xkIG9uIHRvIGl0LFxcbiAgICAgICAgICAgICAgICAvL2lmIHRoZXJlIGlzIGEgc2hvcnRlciBzZWdtZW50IG1hdGNoIGxhdGVyIGluIGEgbWF0Y2hpbmdcXG4gICAgICAgICAgICAgICAgLy9jb25maWcsIHRoZW4gZmF2b3Igb3ZlciB0aGlzIHN0YXIgbWFwLlxcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kU3Rhck1hcCAmJiBzdGFyTWFwICYmIHN0YXJNYXBbbmFtZVNlZ21lbnRdKSB7XFxuICAgICAgICAgICAgICAgICAgICBmb3VuZFN0YXJNYXAgPSBzdGFyTWFwW25hbWVTZWdtZW50XTtcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJJID0gaTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoIWZvdW5kTWFwICYmIGZvdW5kU3Rhck1hcCkge1xcbiAgICAgICAgICAgICAgICBmb3VuZE1hcCA9IGZvdW5kU3Rhck1hcDtcXG4gICAgICAgICAgICAgICAgZm91bmRJID0gc3Rhckk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChmb3VuZE1hcCkge1xcbiAgICAgICAgICAgICAgICBuYW1lUGFydHMuc3BsaWNlKDAsIGZvdW5kSSwgZm91bmRNYXApO1xcbiAgICAgICAgICAgICAgICBuYW1lID0gbmFtZVBhcnRzLmpvaW4oJy8nKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gbmFtZTtcXG4gICAgfVxcblxcbiAgICBmdW5jdGlvbiBtYWtlUmVxdWlyZShyZWxOYW1lLCBmb3JjZVN5bmMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgLy9BIHZlcnNpb24gb2YgYSByZXF1aXJlIGZ1bmN0aW9uIHRoYXQgcGFzc2VzIGEgbW9kdWxlTmFtZVxcbiAgICAgICAgICAgIC8vdmFsdWUgZm9yIGl0ZW1zIHRoYXQgbWF5IG5lZWQgdG9cXG4gICAgICAgICAgICAvL2xvb2sgdXAgcGF0aHMgcmVsYXRpdmUgdG8gdGhlIG1vZHVsZU5hbWVcXG4gICAgICAgICAgICB2YXIgYXJncyA9IGFwcy5jYWxsKGFyZ3VtZW50cywgMCk7XFxuXFxuICAgICAgICAgICAgLy9JZiBmaXJzdCBhcmcgaXMgbm90IHJlcXVpcmUoJ3N0cmluZycpLCBhbmQgdGhlcmUgaXMgb25seVxcbiAgICAgICAgICAgIC8vb25lIGFyZywgaXQgaXMgdGhlIGFycmF5IGZvcm0gd2l0aG91dCBhIGNhbGxiYWNrLiBJbnNlcnRcXG4gICAgICAgICAgICAvL2EgbnVsbCBzbyB0aGF0IHRoZSBmb2xsb3dpbmcgY29uY2F0IGlzIGNvcnJlY3QuXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJyAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gobnVsbCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiByZXEuYXBwbHkodW5kZWYsIGFyZ3MuY29uY2F0KFtyZWxOYW1lLCBmb3JjZVN5bmNdKSk7XFxuICAgICAgICB9O1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIG1ha2VOb3JtYWxpemUocmVsTmFtZSkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZShuYW1lLCByZWxOYW1lKTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbWFrZUxvYWQoZGVwTmFtZSkge1xcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIGRlZmluZWRbZGVwTmFtZV0gPSB2YWx1ZTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gY2FsbERlcChuYW1lKSB7XFxuICAgICAgICBpZiAoaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xcbiAgICAgICAgICAgIHZhciBhcmdzID0gd2FpdGluZ1tuYW1lXTtcXG4gICAgICAgICAgICBkZWxldGUgd2FpdGluZ1tuYW1lXTtcXG4gICAgICAgICAgICBkZWZpbmluZ1tuYW1lXSA9IHRydWU7XFxuICAgICAgICAgICAgbWFpbi5hcHBseSh1bmRlZiwgYXJncyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIWhhc1Byb3AoZGVmaW5lZCwgbmFtZSkgJiYgIWhhc1Byb3AoZGVmaW5pbmcsIG5hbWUpKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyAnICsgbmFtZSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZGVmaW5lZFtuYW1lXTtcXG4gICAgfVxcblxcbiAgICAvL1R1cm5zIGEgcGx1Z2luIXJlc291cmNlIHRvIFtwbHVnaW4sIHJlc291cmNlXVxcbiAgICAvL3dpdGggdGhlIHBsdWdpbiBiZWluZyB1bmRlZmluZWQgaWYgdGhlIG5hbWVcXG4gICAgLy9kaWQgbm90IGhhdmUgYSBwbHVnaW4gcHJlZml4LlxcbiAgICBmdW5jdGlvbiBzcGxpdFByZWZpeChuYW1lKSB7XFxuICAgICAgICB2YXIgcHJlZml4LFxcbiAgICAgICAgICAgIGluZGV4ID0gbmFtZSA/IG5hbWUuaW5kZXhPZignIScpIDogLTE7XFxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xcbiAgICAgICAgICAgIHByZWZpeCA9IG5hbWUuc3Vic3RyaW5nKDAsIGluZGV4KTtcXG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoaW5kZXggKyAxLCBuYW1lLmxlbmd0aCk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gW3ByZWZpeCwgbmFtZV07XFxuICAgIH1cXG5cXG4gICAgLy9DcmVhdGVzIGEgcGFydHMgYXJyYXkgZm9yIGEgcmVsTmFtZSB3aGVyZSBmaXJzdCBwYXJ0IGlzIHBsdWdpbiBJRCxcXG4gICAgLy9zZWNvbmQgcGFydCBpcyByZXNvdXJjZSBJRC4gQXNzdW1lcyByZWxOYW1lIGhhcyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZC5cXG4gICAgZnVuY3Rpb24gbWFrZVJlbFBhcnRzKHJlbE5hbWUpIHtcXG4gICAgICAgIHJldHVybiByZWxOYW1lID8gc3BsaXRQcmVmaXgocmVsTmFtZSkgOiBbXTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogTWFrZXMgYSBuYW1lIG1hcCwgbm9ybWFsaXppbmcgdGhlIG5hbWUsIGFuZCB1c2luZyBhIHBsdWdpblxcbiAgICAgKiBmb3Igbm9ybWFsaXphdGlvbiBpZiBuZWNlc3NhcnkuIEdyYWJzIGEgcmVmIHRvIHBsdWdpblxcbiAgICAgKiB0b28sIGFzIGFuIG9wdGltaXphdGlvbi5cXG4gICAgICovXFxuICAgIG1ha2VNYXAgPSBmdW5jdGlvbiAobmFtZSwgcmVsUGFydHMpIHtcXG4gICAgICAgIHZhciBwbHVnaW4sXFxuICAgICAgICAgICAgcGFydHMgPSBzcGxpdFByZWZpeChuYW1lKSxcXG4gICAgICAgICAgICBwcmVmaXggPSBwYXJ0c1swXSxcXG4gICAgICAgICAgICByZWxSZXNvdXJjZU5hbWUgPSByZWxQYXJ0c1sxXTtcXG5cXG4gICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcXG5cXG4gICAgICAgIGlmIChwcmVmaXgpIHtcXG4gICAgICAgICAgICBwcmVmaXggPSBub3JtYWxpemUocHJlZml4LCByZWxSZXNvdXJjZU5hbWUpO1xcbiAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vTm9ybWFsaXplIGFjY29yZGluZ1xcbiAgICAgICAgaWYgKHByZWZpeCkge1xcbiAgICAgICAgICAgIGlmIChwbHVnaW4gJiYgcGx1Z2luLm5vcm1hbGl6ZSkge1xcbiAgICAgICAgICAgICAgICBuYW1lID0gcGx1Z2luLm5vcm1hbGl6ZShuYW1lLCBtYWtlTm9ybWFsaXplKHJlbFJlc291cmNlTmFtZSkpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemUobmFtZSwgcmVsUmVzb3VyY2VOYW1lKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG5hbWUgPSBub3JtYWxpemUobmFtZSwgcmVsUmVzb3VyY2VOYW1lKTtcXG4gICAgICAgICAgICBwYXJ0cyA9IHNwbGl0UHJlZml4KG5hbWUpO1xcbiAgICAgICAgICAgIHByZWZpeCA9IHBhcnRzWzBdO1xcbiAgICAgICAgICAgIG5hbWUgPSBwYXJ0c1sxXTtcXG4gICAgICAgICAgICBpZiAocHJlZml4KSB7XFxuICAgICAgICAgICAgICAgIHBsdWdpbiA9IGNhbGxEZXAocHJlZml4KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL1VzaW5nIHJpZGljdWxvdXMgcHJvcGVydHkgbmFtZXMgZm9yIHNwYWNlIHJlYXNvbnNcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgZjogcHJlZml4ID8gcHJlZml4ICsgJyEnICsgbmFtZSA6IG5hbWUsIC8vZnVsbE5hbWVcXG4gICAgICAgICAgICBuOiBuYW1lLFxcbiAgICAgICAgICAgIHByOiBwcmVmaXgsXFxuICAgICAgICAgICAgcDogcGx1Z2luXFxuICAgICAgICB9O1xcbiAgICB9O1xcblxcbiAgICBmdW5jdGlvbiBtYWtlQ29uZmlnKG5hbWUpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIChjb25maWcgJiYgY29uZmlnLmNvbmZpZyAmJiBjb25maWcuY29uZmlnW25hbWVdKSB8fCB7fTtcXG4gICAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgaGFuZGxlcnMgPSB7XFxuICAgICAgICByZXF1aXJlOiBmdW5jdGlvbiAobmFtZSkge1xcbiAgICAgICAgICAgIHJldHVybiBtYWtlUmVxdWlyZShuYW1lKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBleHBvcnRzOiBmdW5jdGlvbiAobmFtZSkge1xcbiAgICAgICAgICAgIHZhciBlID0gZGVmaW5lZFtuYW1lXTtcXG4gICAgICAgICAgICBpZiAodHlwZW9mIGUgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiAoZGVmaW5lZFtuYW1lXSA9IHt9KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgbW9kdWxlOiBmdW5jdGlvbiAobmFtZSkge1xcbiAgICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgICAgIGlkOiBuYW1lLFxcbiAgICAgICAgICAgICAgICB1cmk6ICcnLFxcbiAgICAgICAgICAgICAgICBleHBvcnRzOiBkZWZpbmVkW25hbWVdLFxcbiAgICAgICAgICAgICAgICBjb25maWc6IG1ha2VDb25maWcobmFtZSlcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBtYWluID0gZnVuY3Rpb24gKG5hbWUsIGRlcHMsIGNhbGxiYWNrLCByZWxOYW1lKSB7XFxuICAgICAgICB2YXIgY2pzTW9kdWxlLCBkZXBOYW1lLCByZXQsIG1hcCwgaSwgcmVsUGFydHMsXFxuICAgICAgICAgICAgYXJncyA9IFtdLFxcbiAgICAgICAgICAgIGNhbGxiYWNrVHlwZSA9IHR5cGVvZiBjYWxsYmFjayxcXG4gICAgICAgICAgICB1c2luZ0V4cG9ydHM7XFxuXFxuICAgICAgICAvL1VzZSBuYW1lIGlmIG5vIHJlbE5hbWVcXG4gICAgICAgIHJlbE5hbWUgPSByZWxOYW1lIHx8IG5hbWU7XFxuICAgICAgICByZWxQYXJ0cyA9IG1ha2VSZWxQYXJ0cyhyZWxOYW1lKTtcXG5cXG4gICAgICAgIC8vQ2FsbCB0aGUgY2FsbGJhY2sgdG8gZGVmaW5lIHRoZSBtb2R1bGUsIGlmIG5lY2Vzc2FyeS5cXG4gICAgICAgIGlmIChjYWxsYmFja1R5cGUgPT09ICd1bmRlZmluZWQnIHx8IGNhbGxiYWNrVHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIC8vUHVsbCBvdXQgdGhlIGRlZmluZWQgZGVwZW5kZW5jaWVzIGFuZCBwYXNzIHRoZSBvcmRlcmVkXFxuICAgICAgICAgICAgLy92YWx1ZXMgdG8gdGhlIGNhbGxiYWNrLlxcbiAgICAgICAgICAgIC8vRGVmYXVsdCB0byBbcmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlXSBpZiBubyBkZXBzXFxuICAgICAgICAgICAgZGVwcyA9ICFkZXBzLmxlbmd0aCAmJiBjYWxsYmFjay5sZW5ndGggPyBbJ3JlcXVpcmUnLCAnZXhwb3J0cycsICdtb2R1bGUnXSA6IGRlcHM7XFxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlcHMubGVuZ3RoOyBpICs9IDEpIHtcXG4gICAgICAgICAgICAgICAgbWFwID0gbWFrZU1hcChkZXBzW2ldLCByZWxQYXJ0cyk7XFxuICAgICAgICAgICAgICAgIGRlcE5hbWUgPSBtYXAuZjtcXG5cXG4gICAgICAgICAgICAgICAgLy9GYXN0IHBhdGggQ29tbW9uSlMgc3RhbmRhcmQgZGVwZW5kZW5jaWVzLlxcbiAgICAgICAgICAgICAgICBpZiAoZGVwTmFtZSA9PT0gXFxcInJlcXVpcmVcXFwiKSB7XFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMucmVxdWlyZShuYW1lKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkZXBOYW1lID09PSBcXFwiZXhwb3J0c1xcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXFxuICAgICAgICAgICAgICAgICAgICBhcmdzW2ldID0gaGFuZGxlcnMuZXhwb3J0cyhuYW1lKTtcXG4gICAgICAgICAgICAgICAgICAgIHVzaW5nRXhwb3J0cyA9IHRydWU7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVwTmFtZSA9PT0gXFxcIm1vZHVsZVxcXCIpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vQ29tbW9uSlMgbW9kdWxlIHNwZWMgMS4xXFxuICAgICAgICAgICAgICAgICAgICBjanNNb2R1bGUgPSBhcmdzW2ldID0gaGFuZGxlcnMubW9kdWxlKG5hbWUpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhhc1Byb3AoZGVmaW5lZCwgZGVwTmFtZSkgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcm9wKHdhaXRpbmcsIGRlcE5hbWUpIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzUHJvcChkZWZpbmluZywgZGVwTmFtZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBjYWxsRGVwKGRlcE5hbWUpO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hcC5wKSB7XFxuICAgICAgICAgICAgICAgICAgICBtYXAucC5sb2FkKG1hcC5uLCBtYWtlUmVxdWlyZShyZWxOYW1lLCB0cnVlKSwgbWFrZUxvYWQoZGVwTmFtZSksIHt9KTtcXG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbaV0gPSBkZWZpbmVkW2RlcE5hbWVdO1xcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5hbWUgKyAnIG1pc3NpbmcgJyArIGRlcE5hbWUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldCA9IGNhbGxiYWNrID8gY2FsbGJhY2suYXBwbHkoZGVmaW5lZFtuYW1lXSwgYXJncykgOiB1bmRlZmluZWQ7XFxuXFxuICAgICAgICAgICAgaWYgKG5hbWUpIHtcXG4gICAgICAgICAgICAgICAgLy9JZiBzZXR0aW5nIGV4cG9ydHMgdmlhIFxcXCJtb2R1bGVcXFwiIGlzIGluIHBsYXksXFxuICAgICAgICAgICAgICAgIC8vZmF2b3IgdGhhdCBvdmVyIHJldHVybiB2YWx1ZSBhbmQgZXhwb3J0cy4gQWZ0ZXIgdGhhdCxcXG4gICAgICAgICAgICAgICAgLy9mYXZvciBhIG5vbi11bmRlZmluZWQgcmV0dXJuIHZhbHVlIG92ZXIgZXhwb3J0cyB1c2UuXFxuICAgICAgICAgICAgICAgIGlmIChjanNNb2R1bGUgJiYgY2pzTW9kdWxlLmV4cG9ydHMgIT09IHVuZGVmICYmXFxuICAgICAgICAgICAgICAgICAgICAgICAgY2pzTW9kdWxlLmV4cG9ydHMgIT09IGRlZmluZWRbbmFtZV0pIHtcXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSBjanNNb2R1bGUuZXhwb3J0cztcXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXQgIT09IHVuZGVmIHx8ICF1c2luZ0V4cG9ydHMpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vVXNlIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgZnVuY3Rpb24uXFxuICAgICAgICAgICAgICAgICAgICBkZWZpbmVkW25hbWVdID0gcmV0O1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIGlmIChuYW1lKSB7XFxuICAgICAgICAgICAgLy9NYXkganVzdCBiZSBhbiBvYmplY3QgZGVmaW5pdGlvbiBmb3IgdGhlIG1vZHVsZS4gT25seVxcbiAgICAgICAgICAgIC8vd29ycnkgYWJvdXQgZGVmaW5pbmcgaWYgaGF2ZSBhIG1vZHVsZSBuYW1lLlxcbiAgICAgICAgICAgIGRlZmluZWRbbmFtZV0gPSBjYWxsYmFjaztcXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgcmVxdWlyZWpzID0gcmVxdWlyZSA9IHJlcSA9IGZ1bmN0aW9uIChkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSwgZm9yY2VTeW5jLCBhbHQpIHtcXG4gICAgICAgIGlmICh0eXBlb2YgZGVwcyA9PT0gXFxcInN0cmluZ1xcXCIpIHtcXG4gICAgICAgICAgICBpZiAoaGFuZGxlcnNbZGVwc10pIHtcXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpbiB0aGlzIGNhc2UgaXMgcmVhbGx5IHJlbE5hbWVcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXJzW2RlcHNdKGNhbGxiYWNrKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy9KdXN0IHJldHVybiB0aGUgbW9kdWxlIHdhbnRlZC4gSW4gdGhpcyBzY2VuYXJpbywgdGhlXFxuICAgICAgICAgICAgLy9kZXBzIGFyZyBpcyB0aGUgbW9kdWxlIG5hbWUsIGFuZCBzZWNvbmQgYXJnIChpZiBwYXNzZWQpXFxuICAgICAgICAgICAgLy9pcyBqdXN0IHRoZSByZWxOYW1lLlxcbiAgICAgICAgICAgIC8vTm9ybWFsaXplIG1vZHVsZSBuYW1lLCBpZiBpdCBjb250YWlucyAuIG9yIC4uXFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxEZXAobWFrZU1hcChkZXBzLCBtYWtlUmVsUGFydHMoY2FsbGJhY2spKS5mKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoIWRlcHMuc3BsaWNlKSB7XFxuICAgICAgICAgICAgLy9kZXBzIGlzIGEgY29uZmlnIG9iamVjdCwgbm90IGFuIGFycmF5LlxcbiAgICAgICAgICAgIGNvbmZpZyA9IGRlcHM7XFxuICAgICAgICAgICAgaWYgKGNvbmZpZy5kZXBzKSB7XFxuICAgICAgICAgICAgICAgIHJlcShjb25maWcuZGVwcywgY29uZmlnLmNhbGxiYWNrKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChjYWxsYmFjay5zcGxpY2UpIHtcXG4gICAgICAgICAgICAgICAgLy9jYWxsYmFjayBpcyBhbiBhcnJheSwgd2hpY2ggbWVhbnMgaXQgaXMgYSBkZXBlbmRlbmN5IGxpc3QuXFxuICAgICAgICAgICAgICAgIC8vQWRqdXN0IGFyZ3MgaWYgdGhlcmUgYXJlIGRlcGVuZGVuY2llc1xcbiAgICAgICAgICAgICAgICBkZXBzID0gY2FsbGJhY2s7XFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcmVsTmFtZTtcXG4gICAgICAgICAgICAgICAgcmVsTmFtZSA9IG51bGw7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZGVwcyA9IHVuZGVmO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vU3VwcG9ydCByZXF1aXJlKFsnYSddKVxcbiAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiAoKSB7fTtcXG5cXG4gICAgICAgIC8vSWYgcmVsTmFtZSBpcyBhIGZ1bmN0aW9uLCBpdCBpcyBhbiBlcnJiYWNrIGhhbmRsZXIsXFxuICAgICAgICAvL3NvIHJlbW92ZSBpdC5cXG4gICAgICAgIGlmICh0eXBlb2YgcmVsTmFtZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIHJlbE5hbWUgPSBmb3JjZVN5bmM7XFxuICAgICAgICAgICAgZm9yY2VTeW5jID0gYWx0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9TaW11bGF0ZSBhc3luYyBjYWxsYmFjaztcXG4gICAgICAgIGlmIChmb3JjZVN5bmMpIHtcXG4gICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vVXNpbmcgYSBub24temVybyB2YWx1ZSBiZWNhdXNlIG9mIGNvbmNlcm4gZm9yIHdoYXQgb2xkIGJyb3dzZXJzXFxuICAgICAgICAgICAgLy9kbywgYW5kIGxhdGVzdCBicm93c2VycyBcXFwidXBncmFkZVxcXCIgdG8gNCBpZiBsb3dlciB2YWx1ZSBpcyB1c2VkOlxcbiAgICAgICAgICAgIC8vaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGltZXJzLmh0bWwjZG9tLXdpbmRvd3RpbWVycy1zZXR0aW1lb3V0OlxcbiAgICAgICAgICAgIC8vSWYgd2FudCBhIHZhbHVlIGltbWVkaWF0ZWx5LCB1c2UgcmVxdWlyZSgnaWQnKSBpbnN0ZWFkIC0tIHNvbWV0aGluZ1xcbiAgICAgICAgICAgIC8vdGhhdCB3b3JrcyBpbiBhbG1vbmQgb24gdGhlIGdsb2JhbCBsZXZlbCwgYnV0IG5vdCBndWFyYW50ZWVkIGFuZFxcbiAgICAgICAgICAgIC8vdW5saWtlbHkgdG8gd29yayBpbiBvdGhlciBBTUQgaW1wbGVtZW50YXRpb25zLlxcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBtYWluKHVuZGVmLCBkZXBzLCBjYWxsYmFjaywgcmVsTmFtZSk7XFxuICAgICAgICAgICAgfSwgNCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmVxO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogSnVzdCBkcm9wcyB0aGUgY29uZmlnIG9uIHRoZSBmbG9vciwgYnV0IHJldHVybnMgcmVxIGluIGNhc2VcXG4gICAgICogdGhlIGNvbmZpZyByZXR1cm4gdmFsdWUgaXMgdXNlZC5cXG4gICAgICovXFxuICAgIHJlcS5jb25maWcgPSBmdW5jdGlvbiAoY2ZnKSB7XFxuICAgICAgICByZXR1cm4gcmVxKGNmZyk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeHBvc2UgbW9kdWxlIHJlZ2lzdHJ5IGZvciBkZWJ1Z2dpbmcgYW5kIHRvb2xpbmdcXG4gICAgICovXFxuICAgIHJlcXVpcmVqcy5fZGVmaW5lZCA9IGRlZmluZWQ7XFxuXFxuICAgIGRlZmluZSA9IGZ1bmN0aW9uIChuYW1lLCBkZXBzLCBjYWxsYmFjaykge1xcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VlIGFsbW9uZCBSRUFETUU6IGluY29ycmVjdCBtb2R1bGUgYnVpbGQsIG5vIG1vZHVsZSBuYW1lJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL1RoaXMgbW9kdWxlIG1heSBub3QgaGF2ZSBkZXBlbmRlbmNpZXNcXG4gICAgICAgIGlmICghZGVwcy5zcGxpY2UpIHtcXG4gICAgICAgICAgICAvL2RlcHMgaXMgbm90IGFuIGFycmF5LCBzbyBwcm9iYWJseSBtZWFuc1xcbiAgICAgICAgICAgIC8vYW4gb2JqZWN0IGxpdGVyYWwgb3IgZmFjdG9yeSBmdW5jdGlvbiBmb3JcXG4gICAgICAgICAgICAvL3RoZSB2YWx1ZS4gQWRqdXN0IGFyZ3MuXFxuICAgICAgICAgICAgY2FsbGJhY2sgPSBkZXBzO1xcbiAgICAgICAgICAgIGRlcHMgPSBbXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghaGFzUHJvcChkZWZpbmVkLCBuYW1lKSAmJiAhaGFzUHJvcCh3YWl0aW5nLCBuYW1lKSkge1xcbiAgICAgICAgICAgIHdhaXRpbmdbbmFtZV0gPSBbbmFtZSwgZGVwcywgY2FsbGJhY2tdO1xcbiAgICAgICAgfVxcbiAgICB9O1xcblxcbiAgICBkZWZpbmUuYW1kID0ge1xcbiAgICAgICAgalF1ZXJ5OiB0cnVlXFxuICAgIH07XFxufSgpKTtcXG5cXG5TMi5yZXF1aXJlanMgPSByZXF1aXJlanM7UzIucmVxdWlyZSA9IHJlcXVpcmU7UzIuZGVmaW5lID0gZGVmaW5lO1xcbn1cXG59KCkpO1xcblMyLmRlZmluZShcXFwiYWxtb25kXFxcIiwgZnVuY3Rpb24oKXt9KTtcXG5cXG4vKiBnbG9iYWwgalF1ZXJ5OmZhbHNlLCAkOmZhbHNlICovXFxuUzIuZGVmaW5lKCdqcXVlcnknLFtdLGZ1bmN0aW9uICgpIHtcXG4gIHZhciBfJCA9IGpRdWVyeSB8fCAkO1xcblxcbiAgaWYgKF8kID09IG51bGwgJiYgY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XFxuICAgIGNvbnNvbGUuZXJyb3IoXFxuICAgICAgJ1NlbGVjdDI6IEFuIGluc3RhbmNlIG9mIGpRdWVyeSBvciBhIGpRdWVyeS1jb21wYXRpYmxlIGxpYnJhcnkgd2FzIG5vdCAnICtcXG4gICAgICAnZm91bmQuIE1ha2Ugc3VyZSB0aGF0IHlvdSBhcmUgaW5jbHVkaW5nIGpRdWVyeSBiZWZvcmUgU2VsZWN0MiBvbiB5b3VyICcgK1xcbiAgICAgICd3ZWIgcGFnZS4nXFxuICAgICk7XFxuICB9XFxuXFxuICByZXR1cm4gXyQ7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL3V0aWxzJyxbXFxuICAnanF1ZXJ5J1xcbl0sIGZ1bmN0aW9uICgkKSB7XFxuICB2YXIgVXRpbHMgPSB7fTtcXG5cXG4gIFV0aWxzLkV4dGVuZCA9IGZ1bmN0aW9uIChDaGlsZENsYXNzLCBTdXBlckNsYXNzKSB7XFxuICAgIHZhciBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcXG5cXG4gICAgZnVuY3Rpb24gQmFzZUNvbnN0cnVjdG9yICgpIHtcXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yID0gQ2hpbGRDbGFzcztcXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBrZXkgaW4gU3VwZXJDbGFzcykge1xcbiAgICAgIGlmIChfX2hhc1Byb3AuY2FsbChTdXBlckNsYXNzLCBrZXkpKSB7XFxuICAgICAgICBDaGlsZENsYXNzW2tleV0gPSBTdXBlckNsYXNzW2tleV07XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIEJhc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBTdXBlckNsYXNzLnByb3RvdHlwZTtcXG4gICAgQ2hpbGRDbGFzcy5wcm90b3R5cGUgPSBuZXcgQmFzZUNvbnN0cnVjdG9yKCk7XFxuICAgIENoaWxkQ2xhc3MuX19zdXBlcl9fID0gU3VwZXJDbGFzcy5wcm90b3R5cGU7XFxuXFxuICAgIHJldHVybiBDaGlsZENsYXNzO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIGdldE1ldGhvZHMgKHRoZUNsYXNzKSB7XFxuICAgIHZhciBwcm90byA9IHRoZUNsYXNzLnByb3RvdHlwZTtcXG5cXG4gICAgdmFyIG1ldGhvZHMgPSBbXTtcXG5cXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBwcm90bykge1xcbiAgICAgIHZhciBtID0gcHJvdG9bbWV0aG9kTmFtZV07XFxuXFxuICAgICAgaWYgKHR5cGVvZiBtICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdjb25zdHJ1Y3RvcicpIHtcXG4gICAgICAgIGNvbnRpbnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICBtZXRob2RzLnB1c2gobWV0aG9kTmFtZSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1ldGhvZHM7XFxuICB9XFxuXFxuICBVdGlscy5EZWNvcmF0ZSA9IGZ1bmN0aW9uIChTdXBlckNsYXNzLCBEZWNvcmF0b3JDbGFzcykge1xcbiAgICB2YXIgZGVjb3JhdGVkTWV0aG9kcyA9IGdldE1ldGhvZHMoRGVjb3JhdG9yQ2xhc3MpO1xcbiAgICB2YXIgc3VwZXJNZXRob2RzID0gZ2V0TWV0aG9kcyhTdXBlckNsYXNzKTtcXG5cXG4gICAgZnVuY3Rpb24gRGVjb3JhdGVkQ2xhc3MgKCkge1xcbiAgICAgIHZhciB1bnNoaWZ0ID0gQXJyYXkucHJvdG90eXBlLnVuc2hpZnQ7XFxuXFxuICAgICAgdmFyIGFyZ0NvdW50ID0gRGVjb3JhdG9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yLmxlbmd0aDtcXG5cXG4gICAgICB2YXIgY2FsbGVkQ29uc3RydWN0b3IgPSBTdXBlckNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcXG5cXG4gICAgICBpZiAoYXJnQ291bnQgPiAwKSB7XFxuICAgICAgICB1bnNoaWZ0LmNhbGwoYXJndW1lbnRzLCBTdXBlckNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcik7XFxuXFxuICAgICAgICBjYWxsZWRDb25zdHJ1Y3RvciA9IERlY29yYXRvckNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcXG4gICAgICB9XFxuXFxuICAgICAgY2FsbGVkQ29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfVxcblxcbiAgICBEZWNvcmF0b3JDbGFzcy5kaXNwbGF5TmFtZSA9IFN1cGVyQ2xhc3MuZGlzcGxheU5hbWU7XFxuXFxuICAgIGZ1bmN0aW9uIGN0ciAoKSB7XFxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9IERlY29yYXRlZENsYXNzO1xcbiAgICB9XFxuXFxuICAgIERlY29yYXRlZENsYXNzLnByb3RvdHlwZSA9IG5ldyBjdHIoKTtcXG5cXG4gICAgZm9yICh2YXIgbSA9IDA7IG0gPCBzdXBlck1ldGhvZHMubGVuZ3RoOyBtKyspIHtcXG4gICAgICB2YXIgc3VwZXJNZXRob2QgPSBzdXBlck1ldGhvZHNbbV07XFxuXFxuICAgICAgRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlW3N1cGVyTWV0aG9kXSA9XFxuICAgICAgICBTdXBlckNsYXNzLnByb3RvdHlwZVtzdXBlck1ldGhvZF07XFxuICAgIH1cXG5cXG4gICAgdmFyIGNhbGxlZE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7XFxuICAgICAgLy8gU3R1YiBvdXQgdGhlIG9yaWdpbmFsIG1ldGhvZCBpZiBpdCdzIG5vdCBkZWNvcmF0aW5nIGFuIGFjdHVhbCBtZXRob2RcXG4gICAgICB2YXIgb3JpZ2luYWxNZXRob2QgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG4gICAgICBpZiAobWV0aG9kTmFtZSBpbiBEZWNvcmF0ZWRDbGFzcy5wcm90b3R5cGUpIHtcXG4gICAgICAgIG9yaWdpbmFsTWV0aG9kID0gRGVjb3JhdGVkQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgZGVjb3JhdGVkTWV0aG9kID0gRGVjb3JhdG9yQ2xhc3MucHJvdG90eXBlW21ldGhvZE5hbWVdO1xcblxcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgdW5zaGlmdCA9IEFycmF5LnByb3RvdHlwZS51bnNoaWZ0O1xcblxcbiAgICAgICAgdW5zaGlmdC5jYWxsKGFyZ3VtZW50cywgb3JpZ2luYWxNZXRob2QpO1xcblxcbiAgICAgICAgcmV0dXJuIGRlY29yYXRlZE1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH07XFxuICAgIH07XFxuXFxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGVjb3JhdGVkTWV0aG9kcy5sZW5ndGg7IGQrKykge1xcbiAgICAgIHZhciBkZWNvcmF0ZWRNZXRob2QgPSBkZWNvcmF0ZWRNZXRob2RzW2RdO1xcblxcbiAgICAgIERlY29yYXRlZENsYXNzLnByb3RvdHlwZVtkZWNvcmF0ZWRNZXRob2RdID0gY2FsbGVkTWV0aG9kKGRlY29yYXRlZE1ldGhvZCk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIERlY29yYXRlZENsYXNzO1xcbiAgfTtcXG5cXG4gIHZhciBPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmxpc3RlbmVycyA9IHt9O1xcbiAgfTtcXG5cXG4gIE9ic2VydmFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2ZW50LCBjYWxsYmFjaykge1xcbiAgICB0aGlzLmxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzIHx8IHt9O1xcblxcbiAgICBpZiAoZXZlbnQgaW4gdGhpcy5saXN0ZW5lcnMpIHtcXG4gICAgICB0aGlzLmxpc3RlbmVyc1tldmVudF0ucHVzaChjYWxsYmFjayk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRdID0gW2NhbGxiYWNrXTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIE9ic2VydmFibGUucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xcbiAgICB2YXIgcGFyYW1zID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcblxcbiAgICB0aGlzLmxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzIHx8IHt9O1xcblxcbiAgICAvLyBQYXJhbXMgc2hvdWxkIGFsd2F5cyBjb21lIGluIGFzIGFuIGFycmF5XFxuICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xcbiAgICAgIHBhcmFtcyA9IFtdO1xcbiAgICB9XFxuXFxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBhcmd1bWVudHMgdG8gdGhlIGV2ZW50LCB1c2UgYSB0ZW1wb3Jhcnkgb2JqZWN0XFxuICAgIGlmIChwYXJhbXMubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcGFyYW1zLnB1c2goe30pO1xcbiAgICB9XFxuXFxuICAgIC8vIFNldCB0aGUgYF90eXBlYCBvZiB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBldmVudFxcbiAgICBwYXJhbXNbMF0uX3R5cGUgPSBldmVudDtcXG5cXG4gICAgaWYgKGV2ZW50IGluIHRoaXMubGlzdGVuZXJzKSB7XFxuICAgICAgdGhpcy5pbnZva2UodGhpcy5saXN0ZW5lcnNbZXZlbnRdLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xcbiAgICB9XFxuXFxuICAgIGlmICgnKicgaW4gdGhpcy5saXN0ZW5lcnMpIHtcXG4gICAgICB0aGlzLmludm9rZSh0aGlzLmxpc3RlbmVyc1snKiddLCBhcmd1bWVudHMpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuaW52b2tlID0gZnVuY3Rpb24gKGxpc3RlbmVycywgcGFyYW1zKSB7XFxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgcGFyYW1zKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFV0aWxzLk9ic2VydmFibGUgPSBPYnNlcnZhYmxlO1xcblxcbiAgVXRpbHMuZ2VuZXJhdGVDaGFycyA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcXG4gICAgdmFyIGNoYXJzID0gJyc7XFxuXFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgcmFuZG9tQ2hhciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDM2KTtcXG4gICAgICBjaGFycyArPSByYW5kb21DaGFyLnRvU3RyaW5nKDM2KTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gY2hhcnM7XFxuICB9O1xcblxcbiAgVXRpbHMuYmluZCA9IGZ1bmN0aW9uIChmdW5jLCBjb250ZXh0KSB7XFxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xcbiAgICB9O1xcbiAgfTtcXG5cXG4gIFV0aWxzLl9jb252ZXJ0RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgIGZvciAodmFyIG9yaWdpbmFsS2V5IGluIGRhdGEpIHtcXG4gICAgICB2YXIga2V5cyA9IG9yaWdpbmFsS2V5LnNwbGl0KCctJyk7XFxuXFxuICAgICAgdmFyIGRhdGFMZXZlbCA9IGRhdGE7XFxuXFxuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuXFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBrZXlzLmxlbmd0aDsgaysrKSB7XFxuICAgICAgICB2YXIga2V5ID0ga2V5c1trXTtcXG5cXG4gICAgICAgIC8vIExvd2VyY2FzZSB0aGUgZmlyc3QgbGV0dGVyXFxuICAgICAgICAvLyBCeSBkZWZhdWx0LCBkYXNoLXNlcGFyYXRlZCBiZWNvbWVzIGNhbWVsQ2FzZVxcbiAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygwLCAxKS50b0xvd2VyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcXG5cXG4gICAgICAgIGlmICghKGtleSBpbiBkYXRhTGV2ZWwpKSB7XFxuICAgICAgICAgIGRhdGFMZXZlbFtrZXldID0ge307XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoayA9PSBrZXlzLmxlbmd0aCAtIDEpIHtcXG4gICAgICAgICAgZGF0YUxldmVsW2tleV0gPSBkYXRhW29yaWdpbmFsS2V5XTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGRhdGFMZXZlbCA9IGRhdGFMZXZlbFtrZXldO1xcbiAgICAgIH1cXG5cXG4gICAgICBkZWxldGUgZGF0YVtvcmlnaW5hbEtleV07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRhdGE7XFxuICB9O1xcblxcbiAgVXRpbHMuaGFzU2Nyb2xsID0gZnVuY3Rpb24gKGluZGV4LCBlbCkge1xcbiAgICAvLyBBZGFwdGVkIGZyb20gdGhlIGZ1bmN0aW9uIGNyZWF0ZWQgYnkgQFNoYWRvd1NjcmlwdGVyXFxuICAgIC8vIGFuZCBhZGFwdGVkIGJ5IEBCaWxsQmFycnkgb24gdGhlIFN0YWNrIEV4Y2hhbmdlIENvZGUgUmV2aWV3IHdlYnNpdGUuXFxuICAgIC8vIFRoZSBvcmlnaW5hbCBjb2RlIGNhbiBiZSBmb3VuZCBhdFxcbiAgICAvLyBodHRwOi8vY29kZXJldmlldy5zdGFja2V4Y2hhbmdlLmNvbS9xLzEzMzM4XFxuICAgIC8vIGFuZCB3YXMgZGVzaWduZWQgdG8gYmUgdXNlZCB3aXRoIHRoZSBTaXp6bGUgc2VsZWN0b3IgZW5naW5lLlxcblxcbiAgICB2YXIgJGVsID0gJChlbCk7XFxuICAgIHZhciBvdmVyZmxvd1ggPSBlbC5zdHlsZS5vdmVyZmxvd1g7XFxuICAgIHZhciBvdmVyZmxvd1kgPSBlbC5zdHlsZS5vdmVyZmxvd1k7XFxuXFxuICAgIC8vQ2hlY2sgYm90aCB4IGFuZCB5IGRlY2xhcmF0aW9uc1xcbiAgICBpZiAob3ZlcmZsb3dYID09PSBvdmVyZmxvd1kgJiZcXG4gICAgICAgIChvdmVyZmxvd1kgPT09ICdoaWRkZW4nIHx8IG92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICBpZiAob3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBvdmVyZmxvd1kgPT09ICdzY3JvbGwnKSB7XFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuICgkZWwuaW5uZXJIZWlnaHQoKSA8IGVsLnNjcm9sbEhlaWdodCB8fFxcbiAgICAgICRlbC5pbm5lcldpZHRoKCkgPCBlbC5zY3JvbGxXaWR0aCk7XFxuICB9O1xcblxcbiAgVXRpbHMuZXNjYXBlTWFya3VwID0gZnVuY3Rpb24gKG1hcmt1cCkge1xcbiAgICB2YXIgcmVwbGFjZU1hcCA9IHtcXG4gICAgICAnXFxcXFxcXFwnOiAnJiM5MjsnLFxcbiAgICAgICcmJzogJyZhbXA7JyxcXG4gICAgICAnPCc6ICcmbHQ7JyxcXG4gICAgICAnPic6ICcmZ3Q7JyxcXG4gICAgICAnXFxcIic6ICcmcXVvdDsnLFxcbiAgICAgICdcXFxcJyc6ICcmIzM5OycsXFxuICAgICAgJy8nOiAnJiM0NzsnXFxuICAgIH07XFxuXFxuICAgIC8vIERvIG5vdCB0cnkgdG8gZXNjYXBlIHRoZSBtYXJrdXAgaWYgaXQncyBub3QgYSBzdHJpbmdcXG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgcmV0dXJuIG1hcmt1cDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gU3RyaW5nKG1hcmt1cCkucmVwbGFjZSgvWyY8PlxcXCInXFxcXC9cXFxcXFxcXF0vZywgZnVuY3Rpb24gKG1hdGNoKSB7XFxuICAgICAgcmV0dXJuIHJlcGxhY2VNYXBbbWF0Y2hdO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICAvLyBBcHBlbmQgYW4gYXJyYXkgb2YgalF1ZXJ5IG5vZGVzIHRvIGEgZ2l2ZW4gZWxlbWVudC5cXG4gIFV0aWxzLmFwcGVuZE1hbnkgPSBmdW5jdGlvbiAoJGVsZW1lbnQsICRub2Rlcykge1xcbiAgICAvLyBqUXVlcnkgMS43LnggZG9lcyBub3Qgc3VwcG9ydCAkLmZuLmFwcGVuZCgpIHdpdGggYW4gYXJyYXlcXG4gICAgLy8gRmFsbCBiYWNrIHRvIGEgalF1ZXJ5IG9iamVjdCBjb2xsZWN0aW9uIHVzaW5nICQuZm4uYWRkKClcXG4gICAgaWYgKCQuZm4uanF1ZXJ5LnN1YnN0cigwLCAzKSA9PT0gJzEuNycpIHtcXG4gICAgICB2YXIgJGpxTm9kZXMgPSAkKCk7XFxuXFxuICAgICAgJC5tYXAoJG5vZGVzLCBmdW5jdGlvbiAobm9kZSkge1xcbiAgICAgICAgJGpxTm9kZXMgPSAkanFOb2Rlcy5hZGQobm9kZSk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgJG5vZGVzID0gJGpxTm9kZXM7XFxuICAgIH1cXG5cXG4gICAgJGVsZW1lbnQuYXBwZW5kKCRub2Rlcyk7XFxuICB9O1xcblxcbiAgLy8gQ2FjaGUgb2JqZWN0cyBpbiBVdGlscy5fX2NhY2hlIGluc3RlYWQgb2YgJC5kYXRhIChzZWUgIzQzNDYpXFxuICBVdGlscy5fX2NhY2hlID0ge307XFxuXFxuICB2YXIgaWQgPSAwO1xcbiAgVXRpbHMuR2V0VW5pcXVlRWxlbWVudElkID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcXG4gICAgLy8gR2V0IGEgdW5pcXVlIGVsZW1lbnQgSWQuIElmIGVsZW1lbnQgaGFzIG5vIGlkLFxcbiAgICAvLyBjcmVhdGVzIGEgbmV3IHVuaXF1ZSBudW1iZXIsIHN0b3JlcyBpdCBpbiB0aGUgaWRcXG4gICAgLy8gYXR0cmlidXRlIGFuZCByZXR1cm5zIHRoZSBuZXcgaWQuXFxuICAgIC8vIElmIGFuIGlkIGFscmVhZHkgZXhpc3RzLCBpdCBzaW1wbHkgcmV0dXJucyBpdC5cXG5cXG4gICAgdmFyIHNlbGVjdDJJZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXNlbGVjdDItaWQnKTtcXG4gICAgaWYgKHNlbGVjdDJJZCA9PSBudWxsKSB7XFxuICAgICAgLy8gSWYgZWxlbWVudCBoYXMgaWQsIHVzZSBpdC5cXG4gICAgICBpZiAoZWxlbWVudC5pZCkge1xcbiAgICAgICAgc2VsZWN0MklkID0gZWxlbWVudC5pZDtcXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLXNlbGVjdDItaWQnLCBzZWxlY3QySWQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zZWxlY3QyLWlkJywgKytpZCk7XFxuICAgICAgICBzZWxlY3QySWQgPSBpZC50b1N0cmluZygpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gc2VsZWN0MklkO1xcbiAgfTtcXG5cXG4gIFV0aWxzLlN0b3JlRGF0YSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xcbiAgICAvLyBTdG9yZXMgYW4gaXRlbSBpbiB0aGUgY2FjaGUgZm9yIGEgc3BlY2lmaWVkIGVsZW1lbnQuXFxuICAgIC8vIG5hbWUgaXMgdGhlIGNhY2hlIGtleS5cXG4gICAgdmFyIGlkID0gVXRpbHMuR2V0VW5pcXVlRWxlbWVudElkKGVsZW1lbnQpO1xcbiAgICBpZiAoIVV0aWxzLl9fY2FjaGVbaWRdKSB7XFxuICAgICAgVXRpbHMuX19jYWNoZVtpZF0gPSB7fTtcXG4gICAgfVxcblxcbiAgICBVdGlscy5fX2NhY2hlW2lkXVtuYW1lXSA9IHZhbHVlO1xcbiAgfTtcXG5cXG4gIFV0aWxzLkdldERhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xcbiAgICAvLyBSZXRyaWV2ZXMgYSB2YWx1ZSBmcm9tIHRoZSBjYWNoZSBieSBpdHMga2V5IChuYW1lKVxcbiAgICAvLyBuYW1lIGlzIG9wdGlvbmFsLiBJZiBubyBuYW1lIHNwZWNpZmllZCwgcmV0dXJuXFxuICAgIC8vIGFsbCBjYWNoZSBpdGVtcyBmb3IgdGhlIHNwZWNpZmllZCBlbGVtZW50LlxcbiAgICAvLyBhbmQgZm9yIGEgc3BlY2lmaWVkIGVsZW1lbnQuXFxuICAgIHZhciBpZCA9IFV0aWxzLkdldFVuaXF1ZUVsZW1lbnRJZChlbGVtZW50KTtcXG4gICAgaWYgKG5hbWUpIHtcXG4gICAgICBpZiAoVXRpbHMuX19jYWNoZVtpZF0pIHtcXG4gICAgICAgIGlmIChVdGlscy5fX2NhY2hlW2lkXVtuYW1lXSAhPSBudWxsKSB7XFxuICAgICAgICAgIHJldHVybiBVdGlscy5fX2NhY2hlW2lkXVtuYW1lXTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAkKGVsZW1lbnQpLmRhdGEobmFtZSk7IC8vIEZhbGxiYWNrIHRvIEhUTUw1IGRhdGEgYXR0cmlicy5cXG4gICAgICB9XFxuICAgICAgcmV0dXJuICQoZWxlbWVudCkuZGF0YShuYW1lKTsgLy8gRmFsbGJhY2sgdG8gSFRNTDUgZGF0YSBhdHRyaWJzLlxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBVdGlscy5fX2NhY2hlW2lkXTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFV0aWxzLlJlbW92ZURhdGEgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xcbiAgICAvLyBSZW1vdmVzIGFsbCBjYWNoZWQgaXRlbXMgZm9yIGEgc3BlY2lmaWVkIGVsZW1lbnQuXFxuICAgIHZhciBpZCA9IFV0aWxzLkdldFVuaXF1ZUVsZW1lbnRJZChlbGVtZW50KTtcXG4gICAgaWYgKFV0aWxzLl9fY2FjaGVbaWRdICE9IG51bGwpIHtcXG4gICAgICBkZWxldGUgVXRpbHMuX19jYWNoZVtpZF07XFxuICAgIH1cXG5cXG4gICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0Mi1pZCcpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBVdGlscztcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvcmVzdWx0cycsW1xcbiAgJ2pxdWVyeScsXFxuICAnLi91dGlscydcXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMpIHtcXG4gIGZ1bmN0aW9uIFJlc3VsdHMgKCRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcikge1xcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XFxuICAgIHRoaXMuZGF0YSA9IGRhdGFBZGFwdGVyO1xcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcbiAgICBSZXN1bHRzLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xcbiAgfVxcblxcbiAgVXRpbHMuRXh0ZW5kKFJlc3VsdHMsIFV0aWxzLk9ic2VydmFibGUpO1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJHJlc3VsdHMgPSAkKFxcbiAgICAgICc8dWwgY2xhc3M9XFxcInNlbGVjdDItcmVzdWx0c19fb3B0aW9uc1xcXCIgcm9sZT1cXFwibGlzdGJveFxcXCI+PC91bD4nXFxuICAgICk7XFxuXFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdtdWx0aXBsZScpKSB7XFxuICAgICAgJHJlc3VsdHMuYXR0cignYXJpYS1tdWx0aXNlbGVjdGFibGUnLCAndHJ1ZScpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuJHJlc3VsdHMgPSAkcmVzdWx0cztcXG5cXG4gICAgcmV0dXJuICRyZXN1bHRzO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLiRyZXN1bHRzLmVtcHR5KCk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuZGlzcGxheU1lc3NhZ2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgIHZhciBlc2NhcGVNYXJrdXAgPSB0aGlzLm9wdGlvbnMuZ2V0KCdlc2NhcGVNYXJrdXAnKTtcXG5cXG4gICAgdGhpcy5jbGVhcigpO1xcbiAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XFxuXFxuICAgIHZhciAkbWVzc2FnZSA9ICQoXFxuICAgICAgJzxsaSByb2xlPVxcXCJhbGVydFxcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiJyArXFxuICAgICAgJyBjbGFzcz1cXFwic2VsZWN0Mi1yZXN1bHRzX19vcHRpb25cXFwiPjwvbGk+J1xcbiAgICApO1xcblxcbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldChwYXJhbXMubWVzc2FnZSk7XFxuXFxuICAgICRtZXNzYWdlLmFwcGVuZChcXG4gICAgICBlc2NhcGVNYXJrdXAoXFxuICAgICAgICBtZXNzYWdlKHBhcmFtcy5hcmdzKVxcbiAgICAgIClcXG4gICAgKTtcXG5cXG4gICAgJG1lc3NhZ2VbMF0uY2xhc3NOYW1lICs9ICcgc2VsZWN0Mi1yZXN1bHRzX19tZXNzYWdlJztcXG5cXG4gICAgdGhpcy4kcmVzdWx0cy5hcHBlbmQoJG1lc3NhZ2UpO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLmhpZGVNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy4kcmVzdWx0cy5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzX19tZXNzYWdlJykucmVtb3ZlKCk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgdGhpcy5oaWRlTG9hZGluZygpO1xcblxcbiAgICB2YXIgJG9wdGlvbnMgPSBbXTtcXG5cXG4gICAgaWYgKGRhdGEucmVzdWx0cyA9PSBudWxsIHx8IGRhdGEucmVzdWx0cy5sZW5ndGggPT09IDApIHtcXG4gICAgICBpZiAodGhpcy4kcmVzdWx0cy5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZXN1bHRzOm1lc3NhZ2UnLCB7XFxuICAgICAgICAgIG1lc3NhZ2U6ICdub1Jlc3VsdHMnXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGRhdGEucmVzdWx0cyA9IHRoaXMuc29ydChkYXRhLnJlc3VsdHMpO1xcblxcbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEucmVzdWx0cy5sZW5ndGg7IGQrKykge1xcbiAgICAgIHZhciBpdGVtID0gZGF0YS5yZXN1bHRzW2RdO1xcblxcbiAgICAgIHZhciAkb3B0aW9uID0gdGhpcy5vcHRpb24oaXRlbSk7XFxuXFxuICAgICAgJG9wdGlvbnMucHVzaCgkb3B0aW9uKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLiRyZXN1bHRzLmFwcGVuZCgkb3B0aW9ucyk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUucG9zaXRpb24gPSBmdW5jdGlvbiAoJHJlc3VsdHMsICRkcm9wZG93bikge1xcbiAgICB2YXIgJHJlc3VsdHNDb250YWluZXIgPSAkZHJvcGRvd24uZmluZCgnLnNlbGVjdDItcmVzdWx0cycpO1xcbiAgICAkcmVzdWx0c0NvbnRhaW5lci5hcHBlbmQoJHJlc3VsdHMpO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLnNvcnQgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB2YXIgc29ydGVyID0gdGhpcy5vcHRpb25zLmdldCgnc29ydGVyJyk7XFxuXFxuICAgIHJldHVybiBzb3J0ZXIoZGF0YSk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuaGlnaGxpZ2h0Rmlyc3RJdGVtID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRyZXN1bHRzXFxuICAgICAgLmZpbmQoJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvblthcmlhLXNlbGVjdGVkXScpO1xcblxcbiAgICB2YXIgJHNlbGVjdGVkID0gJG9wdGlvbnMuZmlsdGVyKCdbYXJpYS1zZWxlY3RlZD10cnVlXScpO1xcblxcbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IHNlbGVjdGVkIG9wdGlvbnNcXG4gICAgaWYgKCRzZWxlY3RlZC5sZW5ndGggPiAwKSB7XFxuICAgICAgLy8gSWYgdGhlcmUgYXJlIHNlbGVjdGVkIG9wdGlvbnMsIGhpZ2hsaWdodCB0aGUgZmlyc3RcXG4gICAgICAkc2VsZWN0ZWQuZmlyc3QoKS50cmlnZ2VyKCdtb3VzZWVudGVyJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIHNlbGVjdGVkIG9wdGlvbnMsIGhpZ2hsaWdodCB0aGUgZmlyc3Qgb3B0aW9uXFxuICAgICAgLy8gaW4gdGhlIGRyb3Bkb3duXFxuICAgICAgJG9wdGlvbnMuZmlyc3QoKS50cmlnZ2VyKCdtb3VzZWVudGVyJyk7XFxuICAgIH1cXG5cXG4gICAgdGhpcy5lbnN1cmVIaWdobGlnaHRWaXNpYmxlKCk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuc2V0Q2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB0aGlzLmRhdGEuY3VycmVudChmdW5jdGlvbiAoc2VsZWN0ZWQpIHtcXG4gICAgICB2YXIgc2VsZWN0ZWRJZHMgPSAkLm1hcChzZWxlY3RlZCwgZnVuY3Rpb24gKHMpIHtcXG4gICAgICAgIHJldHVybiBzLmlkLnRvU3RyaW5nKCk7XFxuICAgICAgfSk7XFxuXFxuICAgICAgdmFyICRvcHRpb25zID0gc2VsZi4kcmVzdWx0c1xcbiAgICAgICAgLmZpbmQoJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvblthcmlhLXNlbGVjdGVkXScpO1xcblxcbiAgICAgICRvcHRpb25zLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRvcHRpb24gPSAkKHRoaXMpO1xcblxcbiAgICAgICAgdmFyIGl0ZW0gPSBVdGlscy5HZXREYXRhKHRoaXMsICdkYXRhJyk7XFxuXFxuICAgICAgICAvLyBpZCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgd2hlbiBjb21wYXJpbmdcXG4gICAgICAgIHZhciBpZCA9ICcnICsgaXRlbS5pZDtcXG5cXG4gICAgICAgIGlmICgoaXRlbS5lbGVtZW50ICE9IG51bGwgJiYgaXRlbS5lbGVtZW50LnNlbGVjdGVkKSB8fFxcbiAgICAgICAgICAgIChpdGVtLmVsZW1lbnQgPT0gbnVsbCAmJiAkLmluQXJyYXkoaWQsIHNlbGVjdGVkSWRzKSA+IC0xKSkge1xcbiAgICAgICAgICAkb3B0aW9uLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCAndHJ1ZScpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgJG9wdGlvbi5hdHRyKCdhcmlhLXNlbGVjdGVkJywgJ2ZhbHNlJyk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFJlc3VsdHMucHJvdG90eXBlLnNob3dMb2FkaW5nID0gZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICB0aGlzLmhpZGVMb2FkaW5nKCk7XFxuXFxuICAgIHZhciBsb2FkaW5nTW9yZSA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldCgnc2VhcmNoaW5nJyk7XFxuXFxuICAgIHZhciBsb2FkaW5nID0ge1xcbiAgICAgIGRpc2FibGVkOiB0cnVlLFxcbiAgICAgIGxvYWRpbmc6IHRydWUsXFxuICAgICAgdGV4dDogbG9hZGluZ01vcmUocGFyYW1zKVxcbiAgICB9O1xcbiAgICB2YXIgJGxvYWRpbmcgPSB0aGlzLm9wdGlvbihsb2FkaW5nKTtcXG4gICAgJGxvYWRpbmcuY2xhc3NOYW1lICs9ICcgbG9hZGluZy1yZXN1bHRzJztcXG5cXG4gICAgdGhpcy4kcmVzdWx0cy5wcmVwZW5kKCRsb2FkaW5nKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5oaWRlTG9hZGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy4kcmVzdWx0cy5maW5kKCcubG9hZGluZy1yZXN1bHRzJykucmVtb3ZlKCk7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUub3B0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgdmFyIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XFxuICAgIG9wdGlvbi5jbGFzc05hbWUgPSAnc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24nO1xcblxcbiAgICB2YXIgYXR0cnMgPSB7XFxuICAgICAgJ3JvbGUnOiAnb3B0aW9uJyxcXG4gICAgICAnYXJpYS1zZWxlY3RlZCc6ICdmYWxzZSdcXG4gICAgfTtcXG5cXG4gICAgdmFyIG1hdGNoZXMgPSB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxcbiAgICAgIHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxcbiAgICAgIHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XFxuXFxuICAgIGlmICgoZGF0YS5lbGVtZW50ICE9IG51bGwgJiYgbWF0Y2hlcy5jYWxsKGRhdGEuZWxlbWVudCwgJzpkaXNhYmxlZCcpKSB8fFxcbiAgICAgICAgKGRhdGEuZWxlbWVudCA9PSBudWxsICYmIGRhdGEuZGlzYWJsZWQpKSB7XFxuICAgICAgZGVsZXRlIGF0dHJzWydhcmlhLXNlbGVjdGVkJ107XFxuICAgICAgYXR0cnNbJ2FyaWEtZGlzYWJsZWQnXSA9ICd0cnVlJztcXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YS5pZCA9PSBudWxsKSB7XFxuICAgICAgZGVsZXRlIGF0dHJzWydhcmlhLXNlbGVjdGVkJ107XFxuICAgIH1cXG5cXG4gICAgaWYgKGRhdGEuX3Jlc3VsdElkICE9IG51bGwpIHtcXG4gICAgICBvcHRpb24uaWQgPSBkYXRhLl9yZXN1bHRJZDtcXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YS50aXRsZSkge1xcbiAgICAgIG9wdGlvbi50aXRsZSA9IGRhdGEudGl0bGU7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRhdGEuY2hpbGRyZW4pIHtcXG4gICAgICBhdHRycy5yb2xlID0gJ2dyb3VwJztcXG4gICAgICBhdHRyc1snYXJpYS1sYWJlbCddID0gZGF0YS50ZXh0O1xcbiAgICAgIGRlbGV0ZSBhdHRyc1snYXJpYS1zZWxlY3RlZCddO1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGF0dHIgaW4gYXR0cnMpIHtcXG4gICAgICB2YXIgdmFsID0gYXR0cnNbYXR0cl07XFxuXFxuICAgICAgb3B0aW9uLnNldEF0dHJpYnV0ZShhdHRyLCB2YWwpO1xcbiAgICB9XFxuXFxuICAgIGlmIChkYXRhLmNoaWxkcmVuKSB7XFxuICAgICAgdmFyICRvcHRpb24gPSAkKG9wdGlvbik7XFxuXFxuICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3Ryb25nJyk7XFxuICAgICAgbGFiZWwuY2xhc3NOYW1lID0gJ3NlbGVjdDItcmVzdWx0c19fZ3JvdXAnO1xcblxcbiAgICAgIHZhciAkbGFiZWwgPSAkKGxhYmVsKTtcXG4gICAgICB0aGlzLnRlbXBsYXRlKGRhdGEsIGxhYmVsKTtcXG5cXG4gICAgICB2YXIgJGNoaWxkcmVuID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBkYXRhLmNoaWxkcmVuLmxlbmd0aDsgYysrKSB7XFxuICAgICAgICB2YXIgY2hpbGQgPSBkYXRhLmNoaWxkcmVuW2NdO1xcblxcbiAgICAgICAgdmFyICRjaGlsZCA9IHRoaXMub3B0aW9uKGNoaWxkKTtcXG5cXG4gICAgICAgICRjaGlsZHJlbi5wdXNoKCRjaGlsZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciAkY2hpbGRyZW5Db250YWluZXIgPSAkKCc8dWw+PC91bD4nLCB7XFxuICAgICAgICAnY2xhc3MnOiAnc2VsZWN0Mi1yZXN1bHRzX19vcHRpb25zIHNlbGVjdDItcmVzdWx0c19fb3B0aW9ucy0tbmVzdGVkJ1xcbiAgICAgIH0pO1xcblxcbiAgICAgICRjaGlsZHJlbkNvbnRhaW5lci5hcHBlbmQoJGNoaWxkcmVuKTtcXG5cXG4gICAgICAkb3B0aW9uLmFwcGVuZChsYWJlbCk7XFxuICAgICAgJG9wdGlvbi5hcHBlbmQoJGNoaWxkcmVuQ29udGFpbmVyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnRlbXBsYXRlKGRhdGEsIG9wdGlvbik7XFxuICAgIH1cXG5cXG4gICAgVXRpbHMuU3RvcmVEYXRhKG9wdGlvbiwgJ2RhdGEnLCBkYXRhKTtcXG5cXG4gICAgcmV0dXJuIG9wdGlvbjtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHZhciBpZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0cyc7XFxuXFxuICAgIHRoaXMuJHJlc3VsdHMuYXR0cignaWQnLCBpZCk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czphbGwnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgc2VsZi5jbGVhcigpO1xcbiAgICAgIHNlbGYuYXBwZW5kKHBhcmFtcy5kYXRhKTtcXG5cXG4gICAgICBpZiAoY29udGFpbmVyLmlzT3BlbigpKSB7XFxuICAgICAgICBzZWxmLnNldENsYXNzZXMoKTtcXG4gICAgICAgIHNlbGYuaGlnaGxpZ2h0Rmlyc3RJdGVtKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmFwcGVuZCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLmFwcGVuZChwYXJhbXMuZGF0YSk7XFxuXFxuICAgICAgaWYgKGNvbnRhaW5lci5pc09wZW4oKSkge1xcbiAgICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdxdWVyeScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLmhpZGVNZXNzYWdlcygpO1xcbiAgICAgIHNlbGYuc2hvd0xvYWRpbmcocGFyYW1zKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmICghY29udGFpbmVyLmlzT3BlbigpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHNlbGYuc2V0Q2xhc3NlcygpO1xcblxcbiAgICAgIGlmIChzZWxmLm9wdGlvbnMuZ2V0KCdzY3JvbGxBZnRlclNlbGVjdCcpKSB7XFxuICAgICAgICBzZWxmLmhpZ2hsaWdodEZpcnN0SXRlbSgpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigndW5zZWxlY3QnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKCFjb250YWluZXIuaXNPcGVuKCkpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XFxuXFxuICAgICAgaWYgKHNlbGYub3B0aW9ucy5nZXQoJ3Njcm9sbEFmdGVyU2VsZWN0JykpIHtcXG4gICAgICAgIHNlbGYuaGlnaGxpZ2h0Rmlyc3RJdGVtKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIC8vIFdoZW4gdGhlIGRyb3Bkb3duIGlzIG9wZW4sIGFyaWEtZXhwZW5kZWQ9XFxcInRydWVcXFwiXFxuICAgICAgc2VsZi4kcmVzdWx0cy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcXG4gICAgICBzZWxmLiRyZXN1bHRzLmF0dHIoJ2FyaWEtaGlkZGVuJywgJ2ZhbHNlJyk7XFxuXFxuICAgICAgc2VsZi5zZXRDbGFzc2VzKCk7XFxuICAgICAgc2VsZi5lbnN1cmVIaWdobGlnaHRWaXNpYmxlKCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIC8vIFdoZW4gdGhlIGRyb3Bkb3duIGlzIGNsb3NlZCwgYXJpYS1leHBlbmRlZD1cXFwiZmFsc2VcXFwiXFxuICAgICAgc2VsZi4kcmVzdWx0cy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XFxuICAgICAgc2VsZi4kcmVzdWx0cy5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XFxuICAgICAgc2VsZi4kcmVzdWx0cy5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czp0b2dnbGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICRoaWdobGlnaHRlZCA9IHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XFxuXFxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgJGhpZ2hsaWdodGVkLnRyaWdnZXIoJ21vdXNldXAnKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICRoaWdobGlnaHRlZCA9IHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XFxuXFxuICAgICAgaWYgKCRoaWdobGlnaHRlZC5sZW5ndGggPT09IDApIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKCRoaWdobGlnaHRlZFswXSwgJ2RhdGEnKTtcXG5cXG4gICAgICBpZiAoJGhpZ2hsaWdodGVkLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnKSA9PSAndHJ1ZScpIHtcXG4gICAgICAgIHNlbGYudHJpZ2dlcignY2xvc2UnLCB7fSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0Jywge1xcbiAgICAgICAgICBkYXRhOiBkYXRhXFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6cHJldmlvdXMnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICRoaWdobGlnaHRlZCA9IHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKCk7XFxuXFxuICAgICAgdmFyICRvcHRpb25zID0gc2VsZi4kcmVzdWx0cy5maW5kKCdbYXJpYS1zZWxlY3RlZF0nKTtcXG5cXG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gJG9wdGlvbnMuaW5kZXgoJGhpZ2hsaWdodGVkKTtcXG5cXG4gICAgICAvLyBJZiB3ZSBhcmUgYWxyZWFkeSBhdCB0aGUgdG9wLCBkb24ndCBtb3ZlIGZ1cnRoZXJcXG4gICAgICAvLyBJZiBubyBvcHRpb25zLCBjdXJyZW50SW5kZXggd2lsbCBiZSAtMVxcbiAgICAgIGlmIChjdXJyZW50SW5kZXggPD0gMCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgbmV4dEluZGV4ID0gY3VycmVudEluZGV4IC0gMTtcXG5cXG4gICAgICAvLyBJZiBub25lIGFyZSBoaWdobGlnaHRlZCwgaGlnaGxpZ2h0IHRoZSBmaXJzdFxcbiAgICAgIGlmICgkaGlnaGxpZ2h0ZWQubGVuZ3RoID09PSAwKSB7XFxuICAgICAgICBuZXh0SW5kZXggPSAwO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgJG5leHQgPSAkb3B0aW9ucy5lcShuZXh0SW5kZXgpO1xcblxcbiAgICAgICRuZXh0LnRyaWdnZXIoJ21vdXNlZW50ZXInKTtcXG5cXG4gICAgICB2YXIgY3VycmVudE9mZnNldCA9IHNlbGYuJHJlc3VsdHMub2Zmc2V0KCkudG9wO1xcbiAgICAgIHZhciBuZXh0VG9wID0gJG5leHQub2Zmc2V0KCkudG9wO1xcbiAgICAgIHZhciBuZXh0T2Zmc2V0ID0gc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AoKSArIChuZXh0VG9wIC0gY3VycmVudE9mZnNldCk7XFxuXFxuICAgICAgaWYgKG5leHRJbmRleCA9PT0gMCkge1xcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AoMCk7XFxuICAgICAgfSBlbHNlIGlmIChuZXh0VG9wIC0gY3VycmVudE9mZnNldCA8IDApIHtcXG4gICAgICAgIHNlbGYuJHJlc3VsdHMuc2Nyb2xsVG9wKG5leHRPZmZzZXQpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czpuZXh0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciAkaGlnaGxpZ2h0ZWQgPSBzZWxmLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xcblxcbiAgICAgIHZhciAkb3B0aW9ucyA9IHNlbGYuJHJlc3VsdHMuZmluZCgnW2FyaWEtc2VsZWN0ZWRdJyk7XFxuXFxuICAgICAgdmFyIGN1cnJlbnRJbmRleCA9ICRvcHRpb25zLmluZGV4KCRoaWdobGlnaHRlZCk7XFxuXFxuICAgICAgdmFyIG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XFxuXFxuICAgICAgLy8gSWYgd2UgYXJlIGF0IHRoZSBsYXN0IG9wdGlvbiwgc3RheSB0aGVyZVxcbiAgICAgIGlmIChuZXh0SW5kZXggPj0gJG9wdGlvbnMubGVuZ3RoKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciAkbmV4dCA9ICRvcHRpb25zLmVxKG5leHRJbmRleCk7XFxuXFxuICAgICAgJG5leHQudHJpZ2dlcignbW91c2VlbnRlcicpO1xcblxcbiAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gc2VsZi4kcmVzdWx0cy5vZmZzZXQoKS50b3AgK1xcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5vdXRlckhlaWdodChmYWxzZSk7XFxuICAgICAgdmFyIG5leHRCb3R0b20gPSAkbmV4dC5vZmZzZXQoKS50b3AgKyAkbmV4dC5vdXRlckhlaWdodChmYWxzZSk7XFxuICAgICAgdmFyIG5leHRPZmZzZXQgPSBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgpICsgbmV4dEJvdHRvbSAtIGN1cnJlbnRPZmZzZXQ7XFxuXFxuICAgICAgaWYgKG5leHRJbmRleCA9PT0gMCkge1xcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AoMCk7XFxuICAgICAgfSBlbHNlIGlmIChuZXh0Qm90dG9tID4gY3VycmVudE9mZnNldCkge1xcbiAgICAgICAgc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AobmV4dE9mZnNldCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmZvY3VzJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHBhcmFtcy5lbGVtZW50LmFkZENsYXNzKCdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0taGlnaGxpZ2h0ZWQnKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czptZXNzYWdlJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHNlbGYuZGlzcGxheU1lc3NhZ2UocGFyYW1zKTtcXG4gICAgfSk7XFxuXFxuICAgIGlmICgkLmZuLm1vdXNld2hlZWwpIHtcXG4gICAgICB0aGlzLiRyZXN1bHRzLm9uKCdtb3VzZXdoZWVsJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgIHZhciB0b3AgPSBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcCgpO1xcblxcbiAgICAgICAgdmFyIGJvdHRvbSA9IHNlbGYuJHJlc3VsdHMuZ2V0KDApLnNjcm9sbEhlaWdodCAtIHRvcCArIGUuZGVsdGFZO1xcblxcbiAgICAgICAgdmFyIGlzQXRUb3AgPSBlLmRlbHRhWSA+IDAgJiYgdG9wIC0gZS5kZWx0YVkgPD0gMDtcXG4gICAgICAgIHZhciBpc0F0Qm90dG9tID0gZS5kZWx0YVkgPCAwICYmIGJvdHRvbSA8PSBzZWxmLiRyZXN1bHRzLmhlaWdodCgpO1xcblxcbiAgICAgICAgaWYgKGlzQXRUb3ApIHtcXG4gICAgICAgICAgc2VsZi4kcmVzdWx0cy5zY3JvbGxUb3AoMCk7XFxuXFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBdEJvdHRvbSkge1xcbiAgICAgICAgICBzZWxmLiRyZXN1bHRzLnNjcm9sbFRvcChcXG4gICAgICAgICAgICBzZWxmLiRyZXN1bHRzLmdldCgwKS5zY3JvbGxIZWlnaHQgLSBzZWxmLiRyZXN1bHRzLmhlaWdodCgpXFxuICAgICAgICAgICk7XFxuXFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICB0aGlzLiRyZXN1bHRzLm9uKCdtb3VzZXVwJywgJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvblthcmlhLXNlbGVjdGVkXScsXFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XFxuXFxuICAgICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKHRoaXMsICdkYXRhJyk7XFxuXFxuICAgICAgaWYgKCR0aGlzLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnKSA9PT0gJ3RydWUnKSB7XFxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmdldCgnbXVsdGlwbGUnKSkge1xcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dCxcXG4gICAgICAgICAgICBkYXRhOiBkYXRhXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdjbG9zZScsIHt9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi50cmlnZ2VyKCdzZWxlY3QnLCB7XFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnQsXFxuICAgICAgICBkYXRhOiBkYXRhXFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRyZXN1bHRzLm9uKCdtb3VzZWVudGVyJywgJy5zZWxlY3QyLXJlc3VsdHNfX29wdGlvblthcmlhLXNlbGVjdGVkXScsXFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHZhciBkYXRhID0gVXRpbHMuR2V0RGF0YSh0aGlzLCAnZGF0YScpO1xcblxcbiAgICAgIHNlbGYuZ2V0SGlnaGxpZ2h0ZWRSZXN1bHRzKClcXG4gICAgICAgICAgLnJlbW92ZUNsYXNzKCdzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0taGlnaGxpZ2h0ZWQnKTtcXG5cXG4gICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6Zm9jdXMnLCB7XFxuICAgICAgICBkYXRhOiBkYXRhLFxcbiAgICAgICAgZWxlbWVudDogJCh0aGlzKVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5nZXRIaWdobGlnaHRlZFJlc3VsdHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciAkaGlnaGxpZ2h0ZWQgPSB0aGlzLiRyZXN1bHRzXFxuICAgIC5maW5kKCcuc2VsZWN0Mi1yZXN1bHRzX19vcHRpb24tLWhpZ2hsaWdodGVkJyk7XFxuXFxuICAgIHJldHVybiAkaGlnaGxpZ2h0ZWQ7XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy4kcmVzdWx0cy5yZW1vdmUoKTtcXG4gIH07XFxuXFxuICBSZXN1bHRzLnByb3RvdHlwZS5lbnN1cmVIaWdobGlnaHRWaXNpYmxlID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJGhpZ2hsaWdodGVkID0gdGhpcy5nZXRIaWdobGlnaHRlZFJlc3VsdHMoKTtcXG5cXG4gICAgaWYgKCRoaWdobGlnaHRlZC5sZW5ndGggPT09IDApIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyICRvcHRpb25zID0gdGhpcy4kcmVzdWx0cy5maW5kKCdbYXJpYS1zZWxlY3RlZF0nKTtcXG5cXG4gICAgdmFyIGN1cnJlbnRJbmRleCA9ICRvcHRpb25zLmluZGV4KCRoaWdobGlnaHRlZCk7XFxuXFxuICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gdGhpcy4kcmVzdWx0cy5vZmZzZXQoKS50b3A7XFxuICAgIHZhciBuZXh0VG9wID0gJGhpZ2hsaWdodGVkLm9mZnNldCgpLnRvcDtcXG4gICAgdmFyIG5leHRPZmZzZXQgPSB0aGlzLiRyZXN1bHRzLnNjcm9sbFRvcCgpICsgKG5leHRUb3AgLSBjdXJyZW50T2Zmc2V0KTtcXG5cXG4gICAgdmFyIG9mZnNldERlbHRhID0gbmV4dFRvcCAtIGN1cnJlbnRPZmZzZXQ7XFxuICAgIG5leHRPZmZzZXQgLT0gJGhpZ2hsaWdodGVkLm91dGVySGVpZ2h0KGZhbHNlKSAqIDI7XFxuXFxuICAgIGlmIChjdXJyZW50SW5kZXggPD0gMikge1xcbiAgICAgIHRoaXMuJHJlc3VsdHMuc2Nyb2xsVG9wKDApO1xcbiAgICB9IGVsc2UgaWYgKG9mZnNldERlbHRhID4gdGhpcy4kcmVzdWx0cy5vdXRlckhlaWdodCgpIHx8IG9mZnNldERlbHRhIDwgMCkge1xcbiAgICAgIHRoaXMuJHJlc3VsdHMuc2Nyb2xsVG9wKG5leHRPZmZzZXQpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgUmVzdWx0cy5wcm90b3R5cGUudGVtcGxhdGUgPSBmdW5jdGlvbiAocmVzdWx0LCBjb250YWluZXIpIHtcXG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLmdldCgndGVtcGxhdGVSZXN1bHQnKTtcXG4gICAgdmFyIGVzY2FwZU1hcmt1cCA9IHRoaXMub3B0aW9ucy5nZXQoJ2VzY2FwZU1hcmt1cCcpO1xcblxcbiAgICB2YXIgY29udGVudCA9IHRlbXBsYXRlKHJlc3VsdCwgY29udGFpbmVyKTtcXG5cXG4gICAgaWYgKGNvbnRlbnQgPT0gbnVsbCkge1xcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xcbiAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBlc2NhcGVNYXJrdXAoY29udGVudCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgJChjb250YWluZXIpLmFwcGVuZChjb250ZW50KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIHJldHVybiBSZXN1bHRzO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9rZXlzJyxbXFxuXFxuXSwgZnVuY3Rpb24gKCkge1xcbiAgdmFyIEtFWVMgPSB7XFxuICAgIEJBQ0tTUEFDRTogOCxcXG4gICAgVEFCOiA5LFxcbiAgICBFTlRFUjogMTMsXFxuICAgIFNISUZUOiAxNixcXG4gICAgQ1RSTDogMTcsXFxuICAgIEFMVDogMTgsXFxuICAgIEVTQzogMjcsXFxuICAgIFNQQUNFOiAzMixcXG4gICAgUEFHRV9VUDogMzMsXFxuICAgIFBBR0VfRE9XTjogMzQsXFxuICAgIEVORDogMzUsXFxuICAgIEhPTUU6IDM2LFxcbiAgICBMRUZUOiAzNyxcXG4gICAgVVA6IDM4LFxcbiAgICBSSUdIVDogMzksXFxuICAgIERPV046IDQwLFxcbiAgICBERUxFVEU6IDQ2XFxuICB9O1xcblxcbiAgcmV0dXJuIEtFWVM7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL3NlbGVjdGlvbi9iYXNlJyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuLi91dGlscycsXFxuICAnLi4va2V5cydcXG5dLCBmdW5jdGlvbiAoJCwgVXRpbHMsIEtFWVMpIHtcXG4gIGZ1bmN0aW9uIEJhc2VTZWxlY3Rpb24gKCRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXG4gICAgQmFzZVNlbGVjdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG4gIH1cXG5cXG4gIFV0aWxzLkV4dGVuZChCYXNlU2VsZWN0aW9uLCBVdGlscy5PYnNlcnZhYmxlKTtcXG5cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRzZWxlY3Rpb24gPSAkKFxcbiAgICAgICc8c3BhbiBjbGFzcz1cXFwic2VsZWN0Mi1zZWxlY3Rpb25cXFwiIHJvbGU9XFxcImNvbWJvYm94XFxcIiAnICtcXG4gICAgICAnIGFyaWEtaGFzcG9wdXA9XFxcInRydWVcXFwiIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIj4nICtcXG4gICAgICAnPC9zcGFuPidcXG4gICAgKTtcXG5cXG4gICAgdGhpcy5fdGFiaW5kZXggPSAwO1xcblxcbiAgICBpZiAoVXRpbHMuR2V0RGF0YSh0aGlzLiRlbGVtZW50WzBdLCAnb2xkLXRhYmluZGV4JykgIT0gbnVsbCkge1xcbiAgICAgIHRoaXMuX3RhYmluZGV4ID0gVXRpbHMuR2V0RGF0YSh0aGlzLiRlbGVtZW50WzBdLCAnb2xkLXRhYmluZGV4Jyk7XFxuICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpICE9IG51bGwpIHtcXG4gICAgICB0aGlzLl90YWJpbmRleCA9IHRoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnKTtcXG4gICAgfVxcblxcbiAgICAkc2VsZWN0aW9uLmF0dHIoJ3RpdGxlJywgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpKTtcXG4gICAgJHNlbGVjdGlvbi5hdHRyKCd0YWJpbmRleCcsIHRoaXMuX3RhYmluZGV4KTtcXG4gICAgJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ2ZhbHNlJyk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbiA9ICRzZWxlY3Rpb247XFxuXFxuICAgIHJldHVybiAkc2VsZWN0aW9uO1xcbiAgfTtcXG5cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdmFyIHJlc3VsdHNJZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0cyc7XFxuXFxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYudHJpZ2dlcignZm9jdXMnLCBldnQpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdibHVyJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYuX2hhbmRsZUJsdXIoZXZ0KTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBzZWxmLnRyaWdnZXIoJ2tleXByZXNzJywgZXZ0KTtcXG5cXG4gICAgICBpZiAoZXZ0LndoaWNoID09PSBLRVlTLlNQQUNFKSB7XFxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6Zm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHBhcmFtcy5kYXRhLl9yZXN1bHRJZCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3NlbGVjdGlvbjp1cGRhdGUnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgc2VsZi51cGRhdGUocGFyYW1zLmRhdGEpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIC8vIFdoZW4gdGhlIGRyb3Bkb3duIGlzIG9wZW4sIGFyaWEtZXhwYW5kZWQ9XFxcInRydWVcXFwiXFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLW93bnMnLCByZXN1bHRzSWQpO1xcblxcbiAgICAgIHNlbGYuX2F0dGFjaENsb3NlSGFuZGxlcihjb250YWluZXIpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAvLyBXaGVuIHRoZSBkcm9wZG93biBpcyBjbG9zZWQsIGFyaWEtZXhwYW5kZWQ9XFxcImZhbHNlXFxcIlxcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XFxuICAgICAgc2VsZi4kc2VsZWN0aW9uLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5yZW1vdmVBdHRyKCdhcmlhLW93bnMnKTtcXG5cXG4gICAgICBzZWxmLiRzZWxlY3Rpb24udHJpZ2dlcignZm9jdXMnKTtcXG5cXG4gICAgICBzZWxmLl9kZXRhY2hDbG9zZUhhbmRsZXIoY29udGFpbmVyKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignZW5hYmxlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCd0YWJpbmRleCcsIHNlbGYuX3RhYmluZGV4KTtcXG4gICAgICBzZWxmLiRzZWxlY3Rpb24uYXR0cignYXJpYS1kaXNhYmxlZCcsICdmYWxzZScpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdkaXNhYmxlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCd0YWJpbmRleCcsICctMScpO1xcbiAgICAgIHNlbGYuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWRpc2FibGVkJywgJ3RydWUnKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUuX2hhbmRsZUJsdXIgPSBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGFzIHRoZSBhY3RpdmUgZWxlbWVudCBpcyB0aGUgYm9keSB3aGVuIHRoZSB0YWJcXG4gICAgLy8ga2V5IGlzIHByZXNzZWQsIHBvc3NpYmx5IGFsb25nIHdpdGggb3RoZXJzLlxcbiAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgLy8gRG9uJ3QgdHJpZ2dlciBgYmx1cmAgaWYgdGhlIGZvY3VzIGlzIHN0aWxsIGluIHRoZSBzZWxlY3Rpb25cXG4gICAgICBpZiAoXFxuICAgICAgICAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBzZWxmLiRzZWxlY3Rpb25bMF0pIHx8XFxuICAgICAgICAoJC5jb250YWlucyhzZWxmLiRzZWxlY3Rpb25bMF0sIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxcbiAgICAgICkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBzZWxmLnRyaWdnZXIoJ2JsdXInLCBldnQpO1xcbiAgICB9LCAxKTtcXG4gIH07XFxuXFxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5fYXR0YWNoQ2xvc2VIYW5kbGVyID0gZnVuY3Rpb24gKGNvbnRhaW5lcikge1xcblxcbiAgICAkKGRvY3VtZW50LmJvZHkpLm9uKCdtb3VzZWRvd24uc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgIHZhciAkdGFyZ2V0ID0gJChlLnRhcmdldCk7XFxuXFxuICAgICAgdmFyICRzZWxlY3QgPSAkdGFyZ2V0LmNsb3Nlc3QoJy5zZWxlY3QyJyk7XFxuXFxuICAgICAgdmFyICRhbGwgPSAkKCcuc2VsZWN0Mi5zZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xcblxcbiAgICAgICRhbGwuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAodGhpcyA9PSAkc2VsZWN0WzBdKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciAkZWxlbWVudCA9IFV0aWxzLkdldERhdGEodGhpcywgJ2VsZW1lbnQnKTtcXG5cXG4gICAgICAgICRlbGVtZW50LnNlbGVjdDIoJ2Nsb3NlJyk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLl9kZXRhY2hDbG9zZUhhbmRsZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XFxuICAgICQoZG9jdW1lbnQuYm9keSkub2ZmKCdtb3VzZWRvd24uc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkKTtcXG4gIH07XFxuXFxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgkc2VsZWN0aW9uLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciAkc2VsZWN0aW9uQ29udGFpbmVyID0gJGNvbnRhaW5lci5maW5kKCcuc2VsZWN0aW9uJyk7XFxuICAgICRzZWxlY3Rpb25Db250YWluZXIuYXBwZW5kKCRzZWxlY3Rpb24pO1xcbiAgfTtcXG5cXG4gIEJhc2VTZWxlY3Rpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuX2RldGFjaENsb3NlSGFuZGxlcih0aGlzLmNvbnRhaW5lcik7XFxuICB9O1xcblxcbiAgQmFzZVNlbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHVwZGF0ZWAgbWV0aG9kIG11c3QgYmUgZGVmaW5lZCBpbiBjaGlsZCBjbGFzc2VzLicpO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogSGVscGVyIG1ldGhvZCB0byBhYnN0cmFjdCB0aGUgXFxcImVuYWJsZWRcXFwiIChub3QgXFxcImRpc2FibGVkXFxcIikgc3RhdGUgb2YgdGhpc1xcbiAgICogb2JqZWN0LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge3RydWV9IGlmIHRoZSBpbnN0YW5jZSBpcyBub3QgZGlzYWJsZWQuXFxuICAgKiBAcmV0dXJuIHtmYWxzZX0gaWYgdGhlIGluc3RhbmNlIGlzIGRpc2FibGVkLlxcbiAgICovXFxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5pc0VuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHJldHVybiAhdGhpcy5pc0Rpc2FibGVkKCk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFic3RyYWN0IHRoZSBcXFwiZGlzYWJsZWRcXFwiIHN0YXRlIG9mIHRoaXMgb2JqZWN0LlxcbiAgICpcXG4gICAqIEByZXR1cm4ge3RydWV9IGlmIHRoZSBkaXNhYmxlZCBvcHRpb24gaXMgdHJ1ZS5cXG4gICAqIEByZXR1cm4ge2ZhbHNlfSBpZiB0aGUgZGlzYWJsZWQgb3B0aW9uIGlzIGZhbHNlLlxcbiAgICovXFxuICBCYXNlU2VsZWN0aW9uLnByb3RvdHlwZS5pc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zLmdldCgnZGlzYWJsZWQnKTtcXG4gIH07XFxuXFxuICByZXR1cm4gQmFzZVNlbGVjdGlvbjtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL3NpbmdsZScsW1xcbiAgJ2pxdWVyeScsXFxuICAnLi9iYXNlJyxcXG4gICcuLi91dGlscycsXFxuICAnLi4va2V5cydcXG5dLCBmdW5jdGlvbiAoJCwgQmFzZVNlbGVjdGlvbiwgVXRpbHMsIEtFWVMpIHtcXG4gIGZ1bmN0aW9uIFNpbmdsZVNlbGVjdGlvbiAoKSB7XFxuICAgIFNpbmdsZVNlbGVjdGlvbi5fX3N1cGVyX18uY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIFV0aWxzLkV4dGVuZChTaW5nbGVTZWxlY3Rpb24sIEJhc2VTZWxlY3Rpb24pO1xcblxcbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciAkc2VsZWN0aW9uID0gU2luZ2xlU2VsZWN0aW9uLl9fc3VwZXJfXy5yZW5kZXIuY2FsbCh0aGlzKTtcXG5cXG4gICAgJHNlbGVjdGlvbi5hZGRDbGFzcygnc2VsZWN0Mi1zZWxlY3Rpb24tLXNpbmdsZScpO1xcblxcbiAgICAkc2VsZWN0aW9uLmh0bWwoXFxuICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWRcXFwiPjwvc3Bhbj4nICtcXG4gICAgICAnPHNwYW4gY2xhc3M9XFxcInNlbGVjdDItc2VsZWN0aW9uX19hcnJvd1xcXCIgcm9sZT1cXFwicHJlc2VudGF0aW9uXFxcIj4nICtcXG4gICAgICAgICc8YiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPjwvYj4nICtcXG4gICAgICAnPC9zcGFuPidcXG4gICAgKTtcXG5cXG4gICAgcmV0dXJuICRzZWxlY3Rpb247XFxuICB9O1xcblxcbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIFNpbmdsZVNlbGVjdGlvbi5fX3N1cGVyX18uYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcbiAgICB2YXIgaWQgPSBjb250YWluZXIuaWQgKyAnLWNvbnRhaW5lcic7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJylcXG4gICAgICAuYXR0cignaWQnLCBpZClcXG4gICAgICAuYXR0cigncm9sZScsICd0ZXh0Ym94JylcXG4gICAgICAuYXR0cignYXJpYS1yZWFkb25seScsICd0cnVlJyk7XFxuICAgIHRoaXMuJHNlbGVjdGlvbi5hdHRyKCdhcmlhLWxhYmVsbGVkYnknLCBpZCk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIC8vIE9ubHkgcmVzcG9uZCB0byBsZWZ0IGNsaWNrc1xcbiAgICAgIGlmIChldnQud2hpY2ggIT09IDEpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgc2VsZi50cmlnZ2VyKCd0b2dnbGUnLCB7XFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgLy8gVXNlciBmb2N1c2VzIG9uIHRoZSBjb250YWluZXJcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbignYmx1cicsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAvLyBVc2VyIGV4aXRzIHRoZSBjb250YWluZXJcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignZm9jdXMnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgaWYgKCFjb250YWluZXIuaXNPcGVuKCkpIHtcXG4gICAgICAgIHNlbGYuJHNlbGVjdGlvbi50cmlnZ2VyKCdmb2N1cycpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcblxcbiAgU2luZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRyZW5kZXJlZCA9IHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJyk7XFxuICAgICRyZW5kZXJlZC5lbXB0eSgpO1xcbiAgICAkcmVuZGVyZWQucmVtb3ZlQXR0cigndGl0bGUnKTsgLy8gY2xlYXIgdG9vbHRpcCBvbiBlbXB0eVxcbiAgfTtcXG5cXG4gIFNpbmdsZVNlbGVjdGlvbi5wcm90b3R5cGUuZGlzcGxheSA9IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIpIHtcXG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLmdldCgndGVtcGxhdGVTZWxlY3Rpb24nKTtcXG4gICAgdmFyIGVzY2FwZU1hcmt1cCA9IHRoaXMub3B0aW9ucy5nZXQoJ2VzY2FwZU1hcmt1cCcpO1xcblxcbiAgICByZXR1cm4gZXNjYXBlTWFya3VwKHRlbXBsYXRlKGRhdGEsIGNvbnRhaW5lcikpO1xcbiAgfTtcXG5cXG4gIFNpbmdsZVNlbGVjdGlvbi5wcm90b3R5cGUuc2VsZWN0aW9uQ29udGFpbmVyID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gJCgnPHNwYW4+PC9zcGFuPicpO1xcbiAgfTtcXG5cXG4gIFNpbmdsZVNlbGVjdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XFxuICAgICAgdGhpcy5jbGVhcigpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgc2VsZWN0aW9uID0gZGF0YVswXTtcXG5cXG4gICAgdmFyICRyZW5kZXJlZCA9IHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJyk7XFxuICAgIHZhciBmb3JtYXR0ZWQgPSB0aGlzLmRpc3BsYXkoc2VsZWN0aW9uLCAkcmVuZGVyZWQpO1xcblxcbiAgICAkcmVuZGVyZWQuZW1wdHkoKS5hcHBlbmQoZm9ybWF0dGVkKTtcXG5cXG4gICAgdmFyIHRpdGxlID0gc2VsZWN0aW9uLnRpdGxlIHx8IHNlbGVjdGlvbi50ZXh0O1xcblxcbiAgICBpZiAodGl0bGUpIHtcXG4gICAgICAkcmVuZGVyZWQuYXR0cigndGl0bGUnLCB0aXRsZSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgJHJlbmRlcmVkLnJlbW92ZUF0dHIoJ3RpdGxlJyk7XFxuICAgIH1cXG4gIH07XFxuXFxuICByZXR1cm4gU2luZ2xlU2VsZWN0aW9uO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vbXVsdGlwbGUnLFtcXG4gICdqcXVlcnknLFxcbiAgJy4vYmFzZScsXFxuICAnLi4vdXRpbHMnXFxuXSwgZnVuY3Rpb24gKCQsIEJhc2VTZWxlY3Rpb24sIFV0aWxzKSB7XFxuICBmdW5jdGlvbiBNdWx0aXBsZVNlbGVjdGlvbiAoJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgTXVsdGlwbGVTZWxlY3Rpb24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxuXFxuICBVdGlscy5FeHRlbmQoTXVsdGlwbGVTZWxlY3Rpb24sIEJhc2VTZWxlY3Rpb24pO1xcblxcbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRzZWxlY3Rpb24gPSBNdWx0aXBsZVNlbGVjdGlvbi5fX3N1cGVyX18ucmVuZGVyLmNhbGwodGhpcyk7XFxuXFxuICAgICRzZWxlY3Rpb24uYWRkQ2xhc3MoJ3NlbGVjdDItc2VsZWN0aW9uLS1tdWx0aXBsZScpO1xcblxcbiAgICAkc2VsZWN0aW9uLmh0bWwoXFxuICAgICAgJzx1bCBjbGFzcz1cXFwic2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkXFxcIj48L3VsPidcXG4gICAgKTtcXG5cXG4gICAgcmV0dXJuICRzZWxlY3Rpb247XFxuICB9O1xcblxcbiAgTXVsdGlwbGVTZWxlY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgTXVsdGlwbGVTZWxlY3Rpb24uX19zdXBlcl9fLmJpbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBzZWxmLnRyaWdnZXIoJ3RvZ2dsZScsIHtcXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKFxcbiAgICAgICdjbGljaycsXFxuICAgICAgJy5zZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlX19yZW1vdmUnLFxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgaXQgaXMgZGlzYWJsZWRcXG4gICAgICAgIGlmIChzZWxmLmlzRGlzYWJsZWQoKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgJHJlbW92ZSA9ICQodGhpcyk7XFxuICAgICAgICB2YXIgJHNlbGVjdGlvbiA9ICRyZW1vdmUucGFyZW50KCk7XFxuXFxuICAgICAgICB2YXIgZGF0YSA9IFV0aWxzLkdldERhdGEoJHNlbGVjdGlvblswXSwgJ2RhdGEnKTtcXG5cXG4gICAgICAgIHNlbGYudHJpZ2dlcigndW5zZWxlY3QnLCB7XFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dCxcXG4gICAgICAgICAgZGF0YTogZGF0YVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICApO1xcbiAgfTtcXG5cXG4gIE11bHRpcGxlU2VsZWN0aW9uLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRyZW5kZXJlZCA9IHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJyk7XFxuICAgICRyZW5kZXJlZC5lbXB0eSgpO1xcbiAgICAkcmVuZGVyZWQucmVtb3ZlQXR0cigndGl0bGUnKTtcXG4gIH07XFxuXFxuICBNdWx0aXBsZVNlbGVjdGlvbi5wcm90b3R5cGUuZGlzcGxheSA9IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIpIHtcXG4gICAgdmFyIHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLmdldCgndGVtcGxhdGVTZWxlY3Rpb24nKTtcXG4gICAgdmFyIGVzY2FwZU1hcmt1cCA9IHRoaXMub3B0aW9ucy5nZXQoJ2VzY2FwZU1hcmt1cCcpO1xcblxcbiAgICByZXR1cm4gZXNjYXBlTWFya3VwKHRlbXBsYXRlKGRhdGEsIGNvbnRhaW5lcikpO1xcbiAgfTtcXG5cXG4gIE11bHRpcGxlU2VsZWN0aW9uLnByb3RvdHlwZS5zZWxlY3Rpb25Db250YWluZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciAkY29udGFpbmVyID0gJChcXG4gICAgICAnPGxpIGNsYXNzPVxcXCJzZWxlY3QyLXNlbGVjdGlvbl9fY2hvaWNlXFxcIj4nICtcXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwic2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZV9fcmVtb3ZlXFxcIiByb2xlPVxcXCJwcmVzZW50YXRpb25cXFwiPicgK1xcbiAgICAgICAgICAnJnRpbWVzOycgK1xcbiAgICAgICAgJzwvc3Bhbj4nICtcXG4gICAgICAnPC9saT4nXFxuICAgICk7XFxuXFxuICAgIHJldHVybiAkY29udGFpbmVyO1xcbiAgfTtcXG5cXG4gIE11bHRpcGxlU2VsZWN0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB0aGlzLmNsZWFyKCk7XFxuXFxuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgJHNlbGVjdGlvbnMgPSBbXTtcXG5cXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XFxuICAgICAgdmFyIHNlbGVjdGlvbiA9IGRhdGFbZF07XFxuXFxuICAgICAgdmFyICRzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbkNvbnRhaW5lcigpO1xcbiAgICAgIHZhciBmb3JtYXR0ZWQgPSB0aGlzLmRpc3BsYXkoc2VsZWN0aW9uLCAkc2VsZWN0aW9uKTtcXG5cXG4gICAgICAkc2VsZWN0aW9uLmFwcGVuZChmb3JtYXR0ZWQpO1xcblxcbiAgICAgIHZhciB0aXRsZSA9IHNlbGVjdGlvbi50aXRsZSB8fCBzZWxlY3Rpb24udGV4dDtcXG5cXG4gICAgICBpZiAodGl0bGUpIHtcXG4gICAgICAgICRzZWxlY3Rpb24uYXR0cigndGl0bGUnLCB0aXRsZSk7XFxuICAgICAgfVxcblxcbiAgICAgIFV0aWxzLlN0b3JlRGF0YSgkc2VsZWN0aW9uWzBdLCAnZGF0YScsIHNlbGVjdGlvbik7XFxuXFxuICAgICAgJHNlbGVjdGlvbnMucHVzaCgkc2VsZWN0aW9uKTtcXG4gICAgfVxcblxcbiAgICB2YXIgJHJlbmRlcmVkID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKTtcXG5cXG4gICAgVXRpbHMuYXBwZW5kTWFueSgkcmVuZGVyZWQsICRzZWxlY3Rpb25zKTtcXG4gIH07XFxuXFxuICByZXR1cm4gTXVsdGlwbGVTZWxlY3Rpb247XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL3NlbGVjdGlvbi9wbGFjZWhvbGRlcicsW1xcbiAgJy4uL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uIChVdGlscykge1xcbiAgZnVuY3Rpb24gUGxhY2Vob2xkZXIgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IHRoaXMubm9ybWFsaXplUGxhY2Vob2xkZXIob3B0aW9ucy5nZXQoJ3BsYWNlaG9sZGVyJykpO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBQbGFjZWhvbGRlci5wcm90b3R5cGUubm9ybWFsaXplUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoXywgcGxhY2Vob2xkZXIpIHtcXG4gICAgaWYgKHR5cGVvZiBwbGFjZWhvbGRlciA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBwbGFjZWhvbGRlciA9IHtcXG4gICAgICAgIGlkOiAnJyxcXG4gICAgICAgIHRleHQ6IHBsYWNlaG9sZGVyXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XFxuICB9O1xcblxcbiAgUGxhY2Vob2xkZXIucHJvdG90eXBlLmNyZWF0ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGxhY2Vob2xkZXIpIHtcXG4gICAgdmFyICRwbGFjZWhvbGRlciA9IHRoaXMuc2VsZWN0aW9uQ29udGFpbmVyKCk7XFxuXFxuICAgICRwbGFjZWhvbGRlci5odG1sKHRoaXMuZGlzcGxheShwbGFjZWhvbGRlcikpO1xcbiAgICAkcGxhY2Vob2xkZXIuYWRkQ2xhc3MoJ3NlbGVjdDItc2VsZWN0aW9uX19wbGFjZWhvbGRlcicpXFxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnc2VsZWN0Mi1zZWxlY3Rpb25fX2Nob2ljZScpO1xcblxcbiAgICByZXR1cm4gJHBsYWNlaG9sZGVyO1xcbiAgfTtcXG5cXG4gIFBsYWNlaG9sZGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XFxuICAgIHZhciBzaW5nbGVQbGFjZWhvbGRlciA9IChcXG4gICAgICBkYXRhLmxlbmd0aCA9PSAxICYmIGRhdGFbMF0uaWQgIT0gdGhpcy5wbGFjZWhvbGRlci5pZFxcbiAgICApO1xcbiAgICB2YXIgbXVsdGlwbGVTZWxlY3Rpb25zID0gZGF0YS5sZW5ndGggPiAxO1xcblxcbiAgICBpZiAobXVsdGlwbGVTZWxlY3Rpb25zIHx8IHNpbmdsZVBsYWNlaG9sZGVyKSB7XFxuICAgICAgcmV0dXJuIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuY2xlYXIoKTtcXG5cXG4gICAgdmFyICRwbGFjZWhvbGRlciA9IHRoaXMuY3JlYXRlUGxhY2Vob2xkZXIodGhpcy5wbGFjZWhvbGRlcik7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykuYXBwZW5kKCRwbGFjZWhvbGRlcik7XFxuICB9O1xcblxcbiAgcmV0dXJuIFBsYWNlaG9sZGVyO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9zZWxlY3Rpb24vYWxsb3dDbGVhcicsW1xcbiAgJ2pxdWVyeScsXFxuICAnLi4va2V5cycsXFxuICAnLi4vdXRpbHMnXFxuXSwgZnVuY3Rpb24gKCQsIEtFWVMsIFV0aWxzKSB7XFxuICBmdW5jdGlvbiBBbGxvd0NsZWFyICgpIHsgfVxcblxcbiAgQWxsb3dDbGVhci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyID09IG51bGwpIHtcXG4gICAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnZGVidWcnKSAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XFxuICAgICAgICBjb25zb2xlLmVycm9yKFxcbiAgICAgICAgICAnU2VsZWN0MjogVGhlIGBhbGxvd0NsZWFyYCBvcHRpb24gc2hvdWxkIGJlIHVzZWQgaW4gY29tYmluYXRpb24gJyArXFxuICAgICAgICAgICd3aXRoIHRoZSBgcGxhY2Vob2xkZXJgIG9wdGlvbi4nXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ21vdXNlZG93bicsICcuc2VsZWN0Mi1zZWxlY3Rpb25fX2NsZWFyJyxcXG4gICAgICBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgICBzZWxmLl9oYW5kbGVDbGVhcihldnQpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdrZXlwcmVzcycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBzZWxmLl9oYW5kbGVLZXlib2FyZENsZWFyKGV2dCwgY29udGFpbmVyKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgQWxsb3dDbGVhci5wcm90b3R5cGUuX2hhbmRsZUNsZWFyID0gZnVuY3Rpb24gKF8sIGV2dCkge1xcbiAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIGl0IGlzIGRpc2FibGVkXFxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgJGNsZWFyID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fY2xlYXInKTtcXG5cXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiBub3RoaW5nIGhhcyBiZWVuIHNlbGVjdGVkXFxuICAgIGlmICgkY2xlYXIubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcXG5cXG4gICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKCRjbGVhclswXSwgJ2RhdGEnKTtcXG5cXG4gICAgdmFyIHByZXZpb3VzVmFsID0gdGhpcy4kZWxlbWVudC52YWwoKTtcXG4gICAgdGhpcy4kZWxlbWVudC52YWwodGhpcy5wbGFjZWhvbGRlci5pZCk7XFxuXFxuICAgIHZhciB1bnNlbGVjdERhdGEgPSB7XFxuICAgICAgZGF0YTogZGF0YVxcbiAgICB9O1xcbiAgICB0aGlzLnRyaWdnZXIoJ2NsZWFyJywgdW5zZWxlY3REYXRhKTtcXG4gICAgaWYgKHVuc2VsZWN0RGF0YS5wcmV2ZW50ZWQpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50LnZhbChwcmV2aW91c1ZhbCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGF0YS5sZW5ndGg7IGQrKykge1xcbiAgICAgIHVuc2VsZWN0RGF0YSA9IHtcXG4gICAgICAgIGRhdGE6IGRhdGFbZF1cXG4gICAgICB9O1xcblxcbiAgICAgIC8vIFRyaWdnZXIgdGhlIGB1bnNlbGVjdGAgZXZlbnQsIHNvIHBlb3BsZSBjYW4gcHJldmVudCBpdCBmcm9tIGJlaW5nXFxuICAgICAgLy8gY2xlYXJlZC5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3Vuc2VsZWN0JywgdW5zZWxlY3REYXRhKTtcXG5cXG4gICAgICAvLyBJZiB0aGUgZXZlbnQgd2FzIHByZXZlbnRlZCwgZG9uJ3QgY2xlYXIgaXQgb3V0LlxcbiAgICAgIGlmICh1bnNlbGVjdERhdGEucHJldmVudGVkKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnZhbChwcmV2aW91c1ZhbCk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaW5wdXQnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcXG5cXG4gICAgdGhpcy50cmlnZ2VyKCd0b2dnbGUnLCB7fSk7XFxuICB9O1xcblxcbiAgQWxsb3dDbGVhci5wcm90b3R5cGUuX2hhbmRsZUtleWJvYXJkQ2xlYXIgPSBmdW5jdGlvbiAoXywgZXZ0LCBjb250YWluZXIpIHtcXG4gICAgaWYgKGNvbnRhaW5lci5pc09wZW4oKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoZXZ0LndoaWNoID09IEtFWVMuREVMRVRFIHx8IGV2dC53aGljaCA9PSBLRVlTLkJBQ0tTUEFDRSkge1xcbiAgICAgIHRoaXMuX2hhbmRsZUNsZWFyKGV2dCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBBbGxvd0NsZWFyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xcblxcbiAgICBpZiAodGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcGxhY2Vob2xkZXInKS5sZW5ndGggPiAwIHx8XFxuICAgICAgICBkYXRhLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB2YXIgcmVtb3ZlQWxsID0gdGhpcy5vcHRpb25zLmdldCgndHJhbnNsYXRpb25zJykuZ2V0KCdyZW1vdmVBbGxJdGVtcycpO1xcblxcbiAgICB2YXIgJHJlbW92ZSA9ICQoXFxuICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLXNlbGVjdGlvbl9fY2xlYXJcXFwiIHRpdGxlPVxcXCInICsgcmVtb3ZlQWxsKCkgKydcXFwiPicgK1xcbiAgICAgICAgJyZ0aW1lczsnICtcXG4gICAgICAnPC9zcGFuPidcXG4gICAgKTtcXG4gICAgVXRpbHMuU3RvcmVEYXRhKCRyZW1vdmVbMF0sICdkYXRhJywgZGF0YSk7XFxuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5maW5kKCcuc2VsZWN0Mi1zZWxlY3Rpb25fX3JlbmRlcmVkJykucHJlcGVuZCgkcmVtb3ZlKTtcXG4gIH07XFxuXFxuICByZXR1cm4gQWxsb3dDbGVhcjtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL3NlYXJjaCcsW1xcbiAgJ2pxdWVyeScsXFxuICAnLi4vdXRpbHMnLFxcbiAgJy4uL2tleXMnXFxuXSwgZnVuY3Rpb24gKCQsIFV0aWxzLCBLRVlTKSB7XFxuICBmdW5jdGlvbiBTZWFyY2ggKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgU2VhcmNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XFxuICAgIHZhciAkc2VhcmNoID0gJChcXG4gICAgICAnPGxpIGNsYXNzPVxcXCJzZWxlY3QyLXNlYXJjaCBzZWxlY3QyLXNlYXJjaC0taW5saW5lXFxcIj4nICtcXG4gICAgICAgICc8aW5wdXQgY2xhc3M9XFxcInNlbGVjdDItc2VhcmNoX19maWVsZFxcXCIgdHlwZT1cXFwic2VhcmNoXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiJyArXFxuICAgICAgICAnIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwibm9uZVxcXCInICtcXG4gICAgICAgICcgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiIHJvbGU9XFxcInNlYXJjaGJveFxcXCIgYXJpYS1hdXRvY29tcGxldGU9XFxcImxpc3RcXFwiIC8+JyArXFxuICAgICAgJzwvbGk+J1xcbiAgICApO1xcblxcbiAgICB0aGlzLiRzZWFyY2hDb250YWluZXIgPSAkc2VhcmNoO1xcbiAgICB0aGlzLiRzZWFyY2ggPSAkc2VhcmNoLmZpbmQoJ2lucHV0Jyk7XFxuXFxuICAgIHZhciAkcmVuZGVyZWQgPSBkZWNvcmF0ZWQuY2FsbCh0aGlzKTtcXG5cXG4gICAgdGhpcy5fdHJhbnNmZXJUYWJJbmRleCgpO1xcblxcbiAgICByZXR1cm4gJHJlbmRlcmVkO1xcbiAgfTtcXG5cXG4gIFNlYXJjaC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHZhciByZXN1bHRzSWQgPSBjb250YWluZXIuaWQgKyAnLXJlc3VsdHMnO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xcblxcbiAgICBjb250YWluZXIub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kc2VhcmNoLmF0dHIoJ2FyaWEtY29udHJvbHMnLCByZXN1bHRzSWQpO1xcbiAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLiRzZWFyY2gudmFsKCcnKTtcXG4gICAgICBzZWxmLiRzZWFyY2gucmVtb3ZlQXR0cignYXJpYS1jb250cm9scycpO1xcbiAgICAgIHNlbGYuJHNlYXJjaC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcXG4gICAgICBzZWxmLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignZW5hYmxlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJHNlYXJjaC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKTtcXG5cXG4gICAgICBzZWxmLl90cmFuc2ZlclRhYkluZGV4KCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2Rpc2FibGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kc2VhcmNoLnByb3AoJ2Rpc2FibGVkJywgdHJ1ZSk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdmb2N1cycpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmZvY3VzJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIGlmIChwYXJhbXMuZGF0YS5fcmVzdWx0SWQpIHtcXG4gICAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnLCBwYXJhbXMuZGF0YS5fcmVzdWx0SWQpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzZWxmLiRzZWFyY2gucmVtb3ZlQXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdmb2N1c2luJywgJy5zZWxlY3QyLXNlYXJjaC0taW5saW5lJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYudHJpZ2dlcignZm9jdXMnLCBldnQpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdmb2N1c291dCcsICcuc2VsZWN0Mi1zZWFyY2gtLWlubGluZScsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBzZWxmLl9oYW5kbGVCbHVyKGV2dCk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24ub24oJ2tleWRvd24nLCAnLnNlbGVjdDItc2VhcmNoLS1pbmxpbmUnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcbiAgICAgIHNlbGYudHJpZ2dlcigna2V5cHJlc3MnLCBldnQpO1xcblxcbiAgICAgIHNlbGYuX2tleVVwUHJldmVudGVkID0gZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xcblxcbiAgICAgIHZhciBrZXkgPSBldnQud2hpY2g7XFxuXFxuICAgICAgaWYgKGtleSA9PT0gS0VZUy5CQUNLU1BBQ0UgJiYgc2VsZi4kc2VhcmNoLnZhbCgpID09PSAnJykge1xcbiAgICAgICAgdmFyICRwcmV2aW91c0Nob2ljZSA9IHNlbGYuJHNlYXJjaENvbnRhaW5lclxcbiAgICAgICAgICAucHJldignLnNlbGVjdDItc2VsZWN0aW9uX19jaG9pY2UnKTtcXG5cXG4gICAgICAgIGlmICgkcHJldmlvdXNDaG9pY2UubGVuZ3RoID4gMCkge1xcbiAgICAgICAgICB2YXIgaXRlbSA9IFV0aWxzLkdldERhdGEoJHByZXZpb3VzQ2hvaWNlWzBdLCAnZGF0YScpO1xcblxcbiAgICAgICAgICBzZWxmLnNlYXJjaFJlbW92ZUNob2ljZShpdGVtKTtcXG5cXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKCdjbGljaycsICcuc2VsZWN0Mi1zZWFyY2gtLWlubGluZScsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBpZiAoc2VsZi4kc2VhcmNoLnZhbCgpKSB7XFxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgLy8gVHJ5IHRvIGRldGVjdCB0aGUgSUUgdmVyc2lvbiBzaG91bGQgdGhlIGBkb2N1bWVudE1vZGVgIHByb3BlcnR5IHRoYXRcXG4gICAgLy8gaXMgc3RvcmVkIG9uIHRoZSBkb2N1bWVudC4gVGhpcyBpcyBvbmx5IGltcGxlbWVudGVkIGluIElFIGFuZCBpc1xcbiAgICAvLyBzbGlnaHRseSBjbGVhbmVyIHRoYW4gZG9pbmcgYSB1c2VyIGFnZW50IGNoZWNrLlxcbiAgICAvLyBUaGlzIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUgaW4gRWRnZSwgYnV0IEVkZ2UgYWxzbyBkb2Vzbid0IGhhdmVcXG4gICAgLy8gdGhpcyBidWcuXFxuICAgIHZhciBtc2llID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xcbiAgICB2YXIgZGlzYWJsZUlucHV0RXZlbnRzID0gbXNpZSAmJiBtc2llIDw9IDExO1xcblxcbiAgICAvLyBXb3JrYXJvdW5kIGZvciBicm93c2VycyB3aGljaCBkbyBub3Qgc3VwcG9ydCB0aGUgYGlucHV0YCBldmVudFxcbiAgICAvLyBUaGlzIHdpbGwgcHJldmVudCBkb3VibGUtdHJpZ2dlcmluZyBvZiBldmVudHMgZm9yIGJyb3dzZXJzIHdoaWNoIHN1cHBvcnRcXG4gICAgLy8gYm90aCB0aGUgYGtleXVwYCBhbmQgYGlucHV0YCBldmVudHMuXFxuICAgIHRoaXMuJHNlbGVjdGlvbi5vbihcXG4gICAgICAnaW5wdXQuc2VhcmNoY2hlY2snLFxcbiAgICAgICcuc2VsZWN0Mi1zZWFyY2gtLWlubGluZScsXFxuICAgICAgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgICAgLy8gSUUgd2lsbCB0cmlnZ2VyIHRoZSBgaW5wdXRgIGV2ZW50IHdoZW4gYSBwbGFjZWhvbGRlciBpcyB1c2VkIG9uIGFcXG4gICAgICAgIC8vIHNlYXJjaCBib3guIFRvIGdldCBhcm91bmQgdGhpcyBpc3N1ZSwgd2UgYXJlIGZvcmNlZCB0byBpZ25vcmUgYWxsXFxuICAgICAgICAvLyBgaW5wdXRgIGV2ZW50cyBpbiBJRSBhbmQga2VlcCB1c2luZyBga2V5dXBgLlxcbiAgICAgICAgaWYgKGRpc2FibGVJbnB1dEV2ZW50cykge1xcbiAgICAgICAgICBzZWxmLiRzZWxlY3Rpb24ub2ZmKCdpbnB1dC5zZWFyY2ggaW5wdXQuc2VhcmNoY2hlY2snKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gVW5iaW5kIHRoZSBkdXBsaWNhdGVkIGBrZXl1cGAgZXZlbnRcXG4gICAgICAgIHNlbGYuJHNlbGVjdGlvbi5vZmYoJ2tleXVwLnNlYXJjaCcpO1xcbiAgICAgIH1cXG4gICAgKTtcXG5cXG4gICAgdGhpcy4kc2VsZWN0aW9uLm9uKFxcbiAgICAgICdrZXl1cC5zZWFyY2ggaW5wdXQuc2VhcmNoJyxcXG4gICAgICAnLnNlbGVjdDItc2VhcmNoLS1pbmxpbmUnLFxcbiAgICAgIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAgIC8vIElFIHdpbGwgdHJpZ2dlciB0aGUgYGlucHV0YCBldmVudCB3aGVuIGEgcGxhY2Vob2xkZXIgaXMgdXNlZCBvbiBhXFxuICAgICAgICAvLyBzZWFyY2ggYm94LiBUbyBnZXQgYXJvdW5kIHRoaXMgaXNzdWUsIHdlIGFyZSBmb3JjZWQgdG8gaWdub3JlIGFsbFxcbiAgICAgICAgLy8gYGlucHV0YCBldmVudHMgaW4gSUUgYW5kIGtlZXAgdXNpbmcgYGtleXVwYC5cXG4gICAgICAgIGlmIChkaXNhYmxlSW5wdXRFdmVudHMgJiYgZXZ0LnR5cGUgPT09ICdpbnB1dCcpIHtcXG4gICAgICAgICAgc2VsZi4kc2VsZWN0aW9uLm9mZignaW5wdXQuc2VhcmNoIGlucHV0LnNlYXJjaGNoZWNrJyk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBrZXkgPSBldnQud2hpY2g7XFxuXFxuICAgICAgICAvLyBXZSBjYW4gZnJlZWx5IGlnbm9yZSBldmVudHMgZnJvbSBtb2RpZmllciBrZXlzXFxuICAgICAgICBpZiAoa2V5ID09IEtFWVMuU0hJRlQgfHwga2V5ID09IEtFWVMuQ1RSTCB8fCBrZXkgPT0gS0VZUy5BTFQpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gVGFiYmluZyB3aWxsIGJlIGhhbmRsZWQgZHVyaW5nIHRoZSBga2V5ZG93bmAgcGhhc2VcXG4gICAgICAgIGlmIChrZXkgPT0gS0VZUy5UQUIpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2VsZi5oYW5kbGVTZWFyY2goZXZ0KTtcXG4gICAgICB9XFxuICAgICk7XFxuICB9O1xcblxcbiAgLyoqXFxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRyYW5zZmVyIHRoZSB0YWJpbmRleCBhdHRyaWJ1dGUgZnJvbSB0aGUgcmVuZGVyZWRcXG4gICAqIHNlbGVjdGlvbiB0byB0aGUgc2VhcmNoIGJveC4gVGhpcyBhbGxvd3MgZm9yIHRoZSBzZWFyY2ggYm94IHRvIGJlIHVzZWQgYXNcXG4gICAqIHRoZSBwcmltYXJ5IGZvY3VzIGluc3RlYWQgb2YgdGhlIHNlbGVjdGlvbiBjb250YWluZXIuXFxuICAgKlxcbiAgICogQHByaXZhdGVcXG4gICAqL1xcbiAgU2VhcmNoLnByb3RvdHlwZS5fdHJhbnNmZXJUYWJJbmRleCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcXG4gICAgdGhpcy4kc2VhcmNoLmF0dHIoJ3RhYmluZGV4JywgdGhpcy4kc2VsZWN0aW9uLmF0dHIoJ3RhYmluZGV4JykpO1xcbiAgICB0aGlzLiRzZWxlY3Rpb24uYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcXG4gIH07XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLmNyZWF0ZVBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGxhY2Vob2xkZXIpIHtcXG4gICAgdGhpcy4kc2VhcmNoLmF0dHIoJ3BsYWNlaG9sZGVyJywgcGxhY2Vob2xkZXIudGV4dCk7XFxuICB9O1xcblxcbiAgU2VhcmNoLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBkYXRhKSB7XFxuICAgIHZhciBzZWFyY2hIYWRGb2N1cyA9IHRoaXMuJHNlYXJjaFswXSA9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xcblxcbiAgICB0aGlzLiRzZWFyY2guYXR0cigncGxhY2Vob2xkZXInLCAnJyk7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xcblxcbiAgICB0aGlzLiRzZWxlY3Rpb24uZmluZCgnLnNlbGVjdDItc2VsZWN0aW9uX19yZW5kZXJlZCcpXFxuICAgICAgICAgICAgICAgICAgIC5hcHBlbmQodGhpcy4kc2VhcmNoQ29udGFpbmVyKTtcXG5cXG4gICAgdGhpcy5yZXNpemVTZWFyY2goKTtcXG4gICAgaWYgKHNlYXJjaEhhZEZvY3VzKSB7XFxuICAgICAgdGhpcy4kc2VhcmNoLnRyaWdnZXIoJ2ZvY3VzJyk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLmhhbmRsZVNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy5yZXNpemVTZWFyY2goKTtcXG5cXG4gICAgaWYgKCF0aGlzLl9rZXlVcFByZXZlbnRlZCkge1xcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuJHNlYXJjaC52YWwoKTtcXG5cXG4gICAgICB0aGlzLnRyaWdnZXIoJ3F1ZXJ5Jywge1xcbiAgICAgICAgdGVybTogaW5wdXRcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9rZXlVcFByZXZlbnRlZCA9IGZhbHNlO1xcbiAgfTtcXG5cXG4gIFNlYXJjaC5wcm90b3R5cGUuc2VhcmNoUmVtb3ZlQ2hvaWNlID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgaXRlbSkge1xcbiAgICB0aGlzLnRyaWdnZXIoJ3Vuc2VsZWN0Jywge1xcbiAgICAgIGRhdGE6IGl0ZW1cXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJHNlYXJjaC52YWwoaXRlbS50ZXh0KTtcXG4gICAgdGhpcy5oYW5kbGVTZWFyY2goKTtcXG4gIH07XFxuXFxuICBTZWFyY2gucHJvdG90eXBlLnJlc2l6ZVNlYXJjaCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdGhpcy4kc2VhcmNoLmNzcygnd2lkdGgnLCAnMjVweCcpO1xcblxcbiAgICB2YXIgd2lkdGggPSAnJztcXG5cXG4gICAgaWYgKHRoaXMuJHNlYXJjaC5hdHRyKCdwbGFjZWhvbGRlcicpICE9PSAnJykge1xcbiAgICAgIHdpZHRoID0gdGhpcy4kc2VsZWN0aW9uLmZpbmQoJy5zZWxlY3QyLXNlbGVjdGlvbl9fcmVuZGVyZWQnKS53aWR0aCgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciBtaW5pbXVtV2lkdGggPSB0aGlzLiRzZWFyY2gudmFsKCkubGVuZ3RoICsgMTtcXG5cXG4gICAgICB3aWR0aCA9IChtaW5pbXVtV2lkdGggKiAwLjc1KSArICdlbSc7XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kc2VhcmNoLmNzcygnd2lkdGgnLCB3aWR0aCk7XFxuICB9O1xcblxcbiAgcmV0dXJuIFNlYXJjaDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvc2VsZWN0aW9uL2V2ZW50UmVsYXknLFtcXG4gICdqcXVlcnknXFxuXSwgZnVuY3Rpb24gKCQpIHtcXG4gIGZ1bmN0aW9uIEV2ZW50UmVsYXkgKCkgeyB9XFxuXFxuICBFdmVudFJlbGF5LnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIHJlbGF5RXZlbnRzID0gW1xcbiAgICAgICdvcGVuJywgJ29wZW5pbmcnLFxcbiAgICAgICdjbG9zZScsICdjbG9zaW5nJyxcXG4gICAgICAnc2VsZWN0JywgJ3NlbGVjdGluZycsXFxuICAgICAgJ3Vuc2VsZWN0JywgJ3Vuc2VsZWN0aW5nJyxcXG4gICAgICAnY2xlYXInLCAnY2xlYXJpbmcnXFxuICAgIF07XFxuXFxuICAgIHZhciBwcmV2ZW50YWJsZUV2ZW50cyA9IFtcXG4gICAgICAnb3BlbmluZycsICdjbG9zaW5nJywgJ3NlbGVjdGluZycsICd1bnNlbGVjdGluZycsICdjbGVhcmluZydcXG4gICAgXTtcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCcqJywgZnVuY3Rpb24gKG5hbWUsIHBhcmFtcykge1xcbiAgICAgIC8vIElnbm9yZSBldmVudHMgdGhhdCBzaG91bGQgbm90IGJlIHJlbGF5ZWRcXG4gICAgICBpZiAoJC5pbkFycmF5KG5hbWUsIHJlbGF5RXZlbnRzKSA9PT0gLTEpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuXFxuICAgICAgLy8gVGhlIHBhcmFtZXRlcnMgc2hvdWxkIGFsd2F5cyBiZSBhbiBvYmplY3RcXG4gICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XFxuXFxuICAgICAgLy8gR2VuZXJhdGUgdGhlIGpRdWVyeSBldmVudCBmb3IgdGhlIFNlbGVjdDIgZXZlbnRcXG4gICAgICB2YXIgZXZ0ID0gJC5FdmVudCgnc2VsZWN0MjonICsgbmFtZSwge1xcbiAgICAgICAgcGFyYW1zOiBwYXJhbXNcXG4gICAgICB9KTtcXG5cXG4gICAgICBzZWxmLiRlbGVtZW50LnRyaWdnZXIoZXZ0KTtcXG5cXG4gICAgICAvLyBPbmx5IGhhbmRsZSBwcmV2ZW50YWJsZSBldmVudHMgaWYgaXQgd2FzIG9uZVxcbiAgICAgIGlmICgkLmluQXJyYXkobmFtZSwgcHJldmVudGFibGVFdmVudHMpID09PSAtMSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBwYXJhbXMucHJldmVudGVkID0gZXZ0LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICByZXR1cm4gRXZlbnRSZWxheTtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvdHJhbnNsYXRpb24nLFtcXG4gICdqcXVlcnknLFxcbiAgJ3JlcXVpcmUnXFxuXSwgZnVuY3Rpb24gKCQsIHJlcXVpcmUpIHtcXG4gIGZ1bmN0aW9uIFRyYW5zbGF0aW9uIChkaWN0KSB7XFxuICAgIHRoaXMuZGljdCA9IGRpY3QgfHwge307XFxuICB9XFxuXFxuICBUcmFuc2xhdGlvbi5wcm90b3R5cGUuYWxsID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy5kaWN0O1xcbiAgfTtcXG5cXG4gIFRyYW5zbGF0aW9uLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XFxuICAgIHJldHVybiB0aGlzLmRpY3Rba2V5XTtcXG4gIH07XFxuXFxuICBUcmFuc2xhdGlvbi5wcm90b3R5cGUuZXh0ZW5kID0gZnVuY3Rpb24gKHRyYW5zbGF0aW9uKSB7XFxuICAgIHRoaXMuZGljdCA9ICQuZXh0ZW5kKHt9LCB0cmFuc2xhdGlvbi5hbGwoKSwgdGhpcy5kaWN0KTtcXG4gIH07XFxuXFxuICAvLyBTdGF0aWMgZnVuY3Rpb25zXFxuXFxuICBUcmFuc2xhdGlvbi5fY2FjaGUgPSB7fTtcXG5cXG4gIFRyYW5zbGF0aW9uLmxvYWRQYXRoID0gZnVuY3Rpb24gKHBhdGgpIHtcXG4gICAgaWYgKCEocGF0aCBpbiBUcmFuc2xhdGlvbi5fY2FjaGUpKSB7XFxuICAgICAgdmFyIHRyYW5zbGF0aW9ucyA9IHJlcXVpcmUocGF0aCk7XFxuXFxuICAgICAgVHJhbnNsYXRpb24uX2NhY2hlW3BhdGhdID0gdHJhbnNsYXRpb25zO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBuZXcgVHJhbnNsYXRpb24oVHJhbnNsYXRpb24uX2NhY2hlW3BhdGhdKTtcXG4gIH07XFxuXFxuICByZXR1cm4gVHJhbnNsYXRpb247XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RpYWNyaXRpY3MnLFtcXG5cXG5dLCBmdW5jdGlvbiAoKSB7XFxuICB2YXIgZGlhY3JpdGljcyA9IHtcXG4gICAgJ1xcXFx1MjRCNic6ICdBJyxcXG4gICAgJ1xcXFx1RkYyMSc6ICdBJyxcXG4gICAgJ1xcXFx1MDBDMCc6ICdBJyxcXG4gICAgJ1xcXFx1MDBDMSc6ICdBJyxcXG4gICAgJ1xcXFx1MDBDMic6ICdBJyxcXG4gICAgJ1xcXFx1MUVBNic6ICdBJyxcXG4gICAgJ1xcXFx1MUVBNCc6ICdBJyxcXG4gICAgJ1xcXFx1MUVBQSc6ICdBJyxcXG4gICAgJ1xcXFx1MUVBOCc6ICdBJyxcXG4gICAgJ1xcXFx1MDBDMyc6ICdBJyxcXG4gICAgJ1xcXFx1MDEwMCc6ICdBJyxcXG4gICAgJ1xcXFx1MDEwMic6ICdBJyxcXG4gICAgJ1xcXFx1MUVCMCc6ICdBJyxcXG4gICAgJ1xcXFx1MUVBRSc6ICdBJyxcXG4gICAgJ1xcXFx1MUVCNCc6ICdBJyxcXG4gICAgJ1xcXFx1MUVCMic6ICdBJyxcXG4gICAgJ1xcXFx1MDIyNic6ICdBJyxcXG4gICAgJ1xcXFx1MDFFMCc6ICdBJyxcXG4gICAgJ1xcXFx1MDBDNCc6ICdBJyxcXG4gICAgJ1xcXFx1MDFERSc6ICdBJyxcXG4gICAgJ1xcXFx1MUVBMic6ICdBJyxcXG4gICAgJ1xcXFx1MDBDNSc6ICdBJyxcXG4gICAgJ1xcXFx1MDFGQSc6ICdBJyxcXG4gICAgJ1xcXFx1MDFDRCc6ICdBJyxcXG4gICAgJ1xcXFx1MDIwMCc6ICdBJyxcXG4gICAgJ1xcXFx1MDIwMic6ICdBJyxcXG4gICAgJ1xcXFx1MUVBMCc6ICdBJyxcXG4gICAgJ1xcXFx1MUVBQyc6ICdBJyxcXG4gICAgJ1xcXFx1MUVCNic6ICdBJyxcXG4gICAgJ1xcXFx1MUUwMCc6ICdBJyxcXG4gICAgJ1xcXFx1MDEwNCc6ICdBJyxcXG4gICAgJ1xcXFx1MDIzQSc6ICdBJyxcXG4gICAgJ1xcXFx1MkM2Ric6ICdBJyxcXG4gICAgJ1xcXFx1QTczMic6ICdBQScsXFxuICAgICdcXFxcdTAwQzYnOiAnQUUnLFxcbiAgICAnXFxcXHUwMUZDJzogJ0FFJyxcXG4gICAgJ1xcXFx1MDFFMic6ICdBRScsXFxuICAgICdcXFxcdUE3MzQnOiAnQU8nLFxcbiAgICAnXFxcXHVBNzM2JzogJ0FVJyxcXG4gICAgJ1xcXFx1QTczOCc6ICdBVicsXFxuICAgICdcXFxcdUE3M0EnOiAnQVYnLFxcbiAgICAnXFxcXHVBNzNDJzogJ0FZJyxcXG4gICAgJ1xcXFx1MjRCNyc6ICdCJyxcXG4gICAgJ1xcXFx1RkYyMic6ICdCJyxcXG4gICAgJ1xcXFx1MUUwMic6ICdCJyxcXG4gICAgJ1xcXFx1MUUwNCc6ICdCJyxcXG4gICAgJ1xcXFx1MUUwNic6ICdCJyxcXG4gICAgJ1xcXFx1MDI0Myc6ICdCJyxcXG4gICAgJ1xcXFx1MDE4Mic6ICdCJyxcXG4gICAgJ1xcXFx1MDE4MSc6ICdCJyxcXG4gICAgJ1xcXFx1MjRCOCc6ICdDJyxcXG4gICAgJ1xcXFx1RkYyMyc6ICdDJyxcXG4gICAgJ1xcXFx1MDEwNic6ICdDJyxcXG4gICAgJ1xcXFx1MDEwOCc6ICdDJyxcXG4gICAgJ1xcXFx1MDEwQSc6ICdDJyxcXG4gICAgJ1xcXFx1MDEwQyc6ICdDJyxcXG4gICAgJ1xcXFx1MDBDNyc6ICdDJyxcXG4gICAgJ1xcXFx1MUUwOCc6ICdDJyxcXG4gICAgJ1xcXFx1MDE4Nyc6ICdDJyxcXG4gICAgJ1xcXFx1MDIzQic6ICdDJyxcXG4gICAgJ1xcXFx1QTczRSc6ICdDJyxcXG4gICAgJ1xcXFx1MjRCOSc6ICdEJyxcXG4gICAgJ1xcXFx1RkYyNCc6ICdEJyxcXG4gICAgJ1xcXFx1MUUwQSc6ICdEJyxcXG4gICAgJ1xcXFx1MDEwRSc6ICdEJyxcXG4gICAgJ1xcXFx1MUUwQyc6ICdEJyxcXG4gICAgJ1xcXFx1MUUxMCc6ICdEJyxcXG4gICAgJ1xcXFx1MUUxMic6ICdEJyxcXG4gICAgJ1xcXFx1MUUwRSc6ICdEJyxcXG4gICAgJ1xcXFx1MDExMCc6ICdEJyxcXG4gICAgJ1xcXFx1MDE4Qic6ICdEJyxcXG4gICAgJ1xcXFx1MDE4QSc6ICdEJyxcXG4gICAgJ1xcXFx1MDE4OSc6ICdEJyxcXG4gICAgJ1xcXFx1QTc3OSc6ICdEJyxcXG4gICAgJ1xcXFx1MDFGMSc6ICdEWicsXFxuICAgICdcXFxcdTAxQzQnOiAnRFonLFxcbiAgICAnXFxcXHUwMUYyJzogJ0R6JyxcXG4gICAgJ1xcXFx1MDFDNSc6ICdEeicsXFxuICAgICdcXFxcdTI0QkEnOiAnRScsXFxuICAgICdcXFxcdUZGMjUnOiAnRScsXFxuICAgICdcXFxcdTAwQzgnOiAnRScsXFxuICAgICdcXFxcdTAwQzknOiAnRScsXFxuICAgICdcXFxcdTAwQ0EnOiAnRScsXFxuICAgICdcXFxcdTFFQzAnOiAnRScsXFxuICAgICdcXFxcdTFFQkUnOiAnRScsXFxuICAgICdcXFxcdTFFQzQnOiAnRScsXFxuICAgICdcXFxcdTFFQzInOiAnRScsXFxuICAgICdcXFxcdTFFQkMnOiAnRScsXFxuICAgICdcXFxcdTAxMTInOiAnRScsXFxuICAgICdcXFxcdTFFMTQnOiAnRScsXFxuICAgICdcXFxcdTFFMTYnOiAnRScsXFxuICAgICdcXFxcdTAxMTQnOiAnRScsXFxuICAgICdcXFxcdTAxMTYnOiAnRScsXFxuICAgICdcXFxcdTAwQ0InOiAnRScsXFxuICAgICdcXFxcdTFFQkEnOiAnRScsXFxuICAgICdcXFxcdTAxMUEnOiAnRScsXFxuICAgICdcXFxcdTAyMDQnOiAnRScsXFxuICAgICdcXFxcdTAyMDYnOiAnRScsXFxuICAgICdcXFxcdTFFQjgnOiAnRScsXFxuICAgICdcXFxcdTFFQzYnOiAnRScsXFxuICAgICdcXFxcdTAyMjgnOiAnRScsXFxuICAgICdcXFxcdTFFMUMnOiAnRScsXFxuICAgICdcXFxcdTAxMTgnOiAnRScsXFxuICAgICdcXFxcdTFFMTgnOiAnRScsXFxuICAgICdcXFxcdTFFMUEnOiAnRScsXFxuICAgICdcXFxcdTAxOTAnOiAnRScsXFxuICAgICdcXFxcdTAxOEUnOiAnRScsXFxuICAgICdcXFxcdTI0QkInOiAnRicsXFxuICAgICdcXFxcdUZGMjYnOiAnRicsXFxuICAgICdcXFxcdTFFMUUnOiAnRicsXFxuICAgICdcXFxcdTAxOTEnOiAnRicsXFxuICAgICdcXFxcdUE3N0InOiAnRicsXFxuICAgICdcXFxcdTI0QkMnOiAnRycsXFxuICAgICdcXFxcdUZGMjcnOiAnRycsXFxuICAgICdcXFxcdTAxRjQnOiAnRycsXFxuICAgICdcXFxcdTAxMUMnOiAnRycsXFxuICAgICdcXFxcdTFFMjAnOiAnRycsXFxuICAgICdcXFxcdTAxMUUnOiAnRycsXFxuICAgICdcXFxcdTAxMjAnOiAnRycsXFxuICAgICdcXFxcdTAxRTYnOiAnRycsXFxuICAgICdcXFxcdTAxMjInOiAnRycsXFxuICAgICdcXFxcdTAxRTQnOiAnRycsXFxuICAgICdcXFxcdTAxOTMnOiAnRycsXFxuICAgICdcXFxcdUE3QTAnOiAnRycsXFxuICAgICdcXFxcdUE3N0QnOiAnRycsXFxuICAgICdcXFxcdUE3N0UnOiAnRycsXFxuICAgICdcXFxcdTI0QkQnOiAnSCcsXFxuICAgICdcXFxcdUZGMjgnOiAnSCcsXFxuICAgICdcXFxcdTAxMjQnOiAnSCcsXFxuICAgICdcXFxcdTFFMjInOiAnSCcsXFxuICAgICdcXFxcdTFFMjYnOiAnSCcsXFxuICAgICdcXFxcdTAyMUUnOiAnSCcsXFxuICAgICdcXFxcdTFFMjQnOiAnSCcsXFxuICAgICdcXFxcdTFFMjgnOiAnSCcsXFxuICAgICdcXFxcdTFFMkEnOiAnSCcsXFxuICAgICdcXFxcdTAxMjYnOiAnSCcsXFxuICAgICdcXFxcdTJDNjcnOiAnSCcsXFxuICAgICdcXFxcdTJDNzUnOiAnSCcsXFxuICAgICdcXFxcdUE3OEQnOiAnSCcsXFxuICAgICdcXFxcdTI0QkUnOiAnSScsXFxuICAgICdcXFxcdUZGMjknOiAnSScsXFxuICAgICdcXFxcdTAwQ0MnOiAnSScsXFxuICAgICdcXFxcdTAwQ0QnOiAnSScsXFxuICAgICdcXFxcdTAwQ0UnOiAnSScsXFxuICAgICdcXFxcdTAxMjgnOiAnSScsXFxuICAgICdcXFxcdTAxMkEnOiAnSScsXFxuICAgICdcXFxcdTAxMkMnOiAnSScsXFxuICAgICdcXFxcdTAxMzAnOiAnSScsXFxuICAgICdcXFxcdTAwQ0YnOiAnSScsXFxuICAgICdcXFxcdTFFMkUnOiAnSScsXFxuICAgICdcXFxcdTFFQzgnOiAnSScsXFxuICAgICdcXFxcdTAxQ0YnOiAnSScsXFxuICAgICdcXFxcdTAyMDgnOiAnSScsXFxuICAgICdcXFxcdTAyMEEnOiAnSScsXFxuICAgICdcXFxcdTFFQ0EnOiAnSScsXFxuICAgICdcXFxcdTAxMkUnOiAnSScsXFxuICAgICdcXFxcdTFFMkMnOiAnSScsXFxuICAgICdcXFxcdTAxOTcnOiAnSScsXFxuICAgICdcXFxcdTI0QkYnOiAnSicsXFxuICAgICdcXFxcdUZGMkEnOiAnSicsXFxuICAgICdcXFxcdTAxMzQnOiAnSicsXFxuICAgICdcXFxcdTAyNDgnOiAnSicsXFxuICAgICdcXFxcdTI0QzAnOiAnSycsXFxuICAgICdcXFxcdUZGMkInOiAnSycsXFxuICAgICdcXFxcdTFFMzAnOiAnSycsXFxuICAgICdcXFxcdTAxRTgnOiAnSycsXFxuICAgICdcXFxcdTFFMzInOiAnSycsXFxuICAgICdcXFxcdTAxMzYnOiAnSycsXFxuICAgICdcXFxcdTFFMzQnOiAnSycsXFxuICAgICdcXFxcdTAxOTgnOiAnSycsXFxuICAgICdcXFxcdTJDNjknOiAnSycsXFxuICAgICdcXFxcdUE3NDAnOiAnSycsXFxuICAgICdcXFxcdUE3NDInOiAnSycsXFxuICAgICdcXFxcdUE3NDQnOiAnSycsXFxuICAgICdcXFxcdUE3QTInOiAnSycsXFxuICAgICdcXFxcdTI0QzEnOiAnTCcsXFxuICAgICdcXFxcdUZGMkMnOiAnTCcsXFxuICAgICdcXFxcdTAxM0YnOiAnTCcsXFxuICAgICdcXFxcdTAxMzknOiAnTCcsXFxuICAgICdcXFxcdTAxM0QnOiAnTCcsXFxuICAgICdcXFxcdTFFMzYnOiAnTCcsXFxuICAgICdcXFxcdTFFMzgnOiAnTCcsXFxuICAgICdcXFxcdTAxM0InOiAnTCcsXFxuICAgICdcXFxcdTFFM0MnOiAnTCcsXFxuICAgICdcXFxcdTFFM0EnOiAnTCcsXFxuICAgICdcXFxcdTAxNDEnOiAnTCcsXFxuICAgICdcXFxcdTAyM0QnOiAnTCcsXFxuICAgICdcXFxcdTJDNjInOiAnTCcsXFxuICAgICdcXFxcdTJDNjAnOiAnTCcsXFxuICAgICdcXFxcdUE3NDgnOiAnTCcsXFxuICAgICdcXFxcdUE3NDYnOiAnTCcsXFxuICAgICdcXFxcdUE3ODAnOiAnTCcsXFxuICAgICdcXFxcdTAxQzcnOiAnTEonLFxcbiAgICAnXFxcXHUwMUM4JzogJ0xqJyxcXG4gICAgJ1xcXFx1MjRDMic6ICdNJyxcXG4gICAgJ1xcXFx1RkYyRCc6ICdNJyxcXG4gICAgJ1xcXFx1MUUzRSc6ICdNJyxcXG4gICAgJ1xcXFx1MUU0MCc6ICdNJyxcXG4gICAgJ1xcXFx1MUU0Mic6ICdNJyxcXG4gICAgJ1xcXFx1MkM2RSc6ICdNJyxcXG4gICAgJ1xcXFx1MDE5Qyc6ICdNJyxcXG4gICAgJ1xcXFx1MjRDMyc6ICdOJyxcXG4gICAgJ1xcXFx1RkYyRSc6ICdOJyxcXG4gICAgJ1xcXFx1MDFGOCc6ICdOJyxcXG4gICAgJ1xcXFx1MDE0Myc6ICdOJyxcXG4gICAgJ1xcXFx1MDBEMSc6ICdOJyxcXG4gICAgJ1xcXFx1MUU0NCc6ICdOJyxcXG4gICAgJ1xcXFx1MDE0Nyc6ICdOJyxcXG4gICAgJ1xcXFx1MUU0Nic6ICdOJyxcXG4gICAgJ1xcXFx1MDE0NSc6ICdOJyxcXG4gICAgJ1xcXFx1MUU0QSc6ICdOJyxcXG4gICAgJ1xcXFx1MUU0OCc6ICdOJyxcXG4gICAgJ1xcXFx1MDIyMCc6ICdOJyxcXG4gICAgJ1xcXFx1MDE5RCc6ICdOJyxcXG4gICAgJ1xcXFx1QTc5MCc6ICdOJyxcXG4gICAgJ1xcXFx1QTdBNCc6ICdOJyxcXG4gICAgJ1xcXFx1MDFDQSc6ICdOSicsXFxuICAgICdcXFxcdTAxQ0InOiAnTmonLFxcbiAgICAnXFxcXHUyNEM0JzogJ08nLFxcbiAgICAnXFxcXHVGRjJGJzogJ08nLFxcbiAgICAnXFxcXHUwMEQyJzogJ08nLFxcbiAgICAnXFxcXHUwMEQzJzogJ08nLFxcbiAgICAnXFxcXHUwMEQ0JzogJ08nLFxcbiAgICAnXFxcXHUxRUQyJzogJ08nLFxcbiAgICAnXFxcXHUxRUQwJzogJ08nLFxcbiAgICAnXFxcXHUxRUQ2JzogJ08nLFxcbiAgICAnXFxcXHUxRUQ0JzogJ08nLFxcbiAgICAnXFxcXHUwMEQ1JzogJ08nLFxcbiAgICAnXFxcXHUxRTRDJzogJ08nLFxcbiAgICAnXFxcXHUwMjJDJzogJ08nLFxcbiAgICAnXFxcXHUxRTRFJzogJ08nLFxcbiAgICAnXFxcXHUwMTRDJzogJ08nLFxcbiAgICAnXFxcXHUxRTUwJzogJ08nLFxcbiAgICAnXFxcXHUxRTUyJzogJ08nLFxcbiAgICAnXFxcXHUwMTRFJzogJ08nLFxcbiAgICAnXFxcXHUwMjJFJzogJ08nLFxcbiAgICAnXFxcXHUwMjMwJzogJ08nLFxcbiAgICAnXFxcXHUwMEQ2JzogJ08nLFxcbiAgICAnXFxcXHUwMjJBJzogJ08nLFxcbiAgICAnXFxcXHUxRUNFJzogJ08nLFxcbiAgICAnXFxcXHUwMTUwJzogJ08nLFxcbiAgICAnXFxcXHUwMUQxJzogJ08nLFxcbiAgICAnXFxcXHUwMjBDJzogJ08nLFxcbiAgICAnXFxcXHUwMjBFJzogJ08nLFxcbiAgICAnXFxcXHUwMUEwJzogJ08nLFxcbiAgICAnXFxcXHUxRURDJzogJ08nLFxcbiAgICAnXFxcXHUxRURBJzogJ08nLFxcbiAgICAnXFxcXHUxRUUwJzogJ08nLFxcbiAgICAnXFxcXHUxRURFJzogJ08nLFxcbiAgICAnXFxcXHUxRUUyJzogJ08nLFxcbiAgICAnXFxcXHUxRUNDJzogJ08nLFxcbiAgICAnXFxcXHUxRUQ4JzogJ08nLFxcbiAgICAnXFxcXHUwMUVBJzogJ08nLFxcbiAgICAnXFxcXHUwMUVDJzogJ08nLFxcbiAgICAnXFxcXHUwMEQ4JzogJ08nLFxcbiAgICAnXFxcXHUwMUZFJzogJ08nLFxcbiAgICAnXFxcXHUwMTg2JzogJ08nLFxcbiAgICAnXFxcXHUwMTlGJzogJ08nLFxcbiAgICAnXFxcXHVBNzRBJzogJ08nLFxcbiAgICAnXFxcXHVBNzRDJzogJ08nLFxcbiAgICAnXFxcXHUwMTUyJzogJ09FJyxcXG4gICAgJ1xcXFx1MDFBMic6ICdPSScsXFxuICAgICdcXFxcdUE3NEUnOiAnT08nLFxcbiAgICAnXFxcXHUwMjIyJzogJ09VJyxcXG4gICAgJ1xcXFx1MjRDNSc6ICdQJyxcXG4gICAgJ1xcXFx1RkYzMCc6ICdQJyxcXG4gICAgJ1xcXFx1MUU1NCc6ICdQJyxcXG4gICAgJ1xcXFx1MUU1Nic6ICdQJyxcXG4gICAgJ1xcXFx1MDFBNCc6ICdQJyxcXG4gICAgJ1xcXFx1MkM2Myc6ICdQJyxcXG4gICAgJ1xcXFx1QTc1MCc6ICdQJyxcXG4gICAgJ1xcXFx1QTc1Mic6ICdQJyxcXG4gICAgJ1xcXFx1QTc1NCc6ICdQJyxcXG4gICAgJ1xcXFx1MjRDNic6ICdRJyxcXG4gICAgJ1xcXFx1RkYzMSc6ICdRJyxcXG4gICAgJ1xcXFx1QTc1Nic6ICdRJyxcXG4gICAgJ1xcXFx1QTc1OCc6ICdRJyxcXG4gICAgJ1xcXFx1MDI0QSc6ICdRJyxcXG4gICAgJ1xcXFx1MjRDNyc6ICdSJyxcXG4gICAgJ1xcXFx1RkYzMic6ICdSJyxcXG4gICAgJ1xcXFx1MDE1NCc6ICdSJyxcXG4gICAgJ1xcXFx1MUU1OCc6ICdSJyxcXG4gICAgJ1xcXFx1MDE1OCc6ICdSJyxcXG4gICAgJ1xcXFx1MDIxMCc6ICdSJyxcXG4gICAgJ1xcXFx1MDIxMic6ICdSJyxcXG4gICAgJ1xcXFx1MUU1QSc6ICdSJyxcXG4gICAgJ1xcXFx1MUU1Qyc6ICdSJyxcXG4gICAgJ1xcXFx1MDE1Nic6ICdSJyxcXG4gICAgJ1xcXFx1MUU1RSc6ICdSJyxcXG4gICAgJ1xcXFx1MDI0Qyc6ICdSJyxcXG4gICAgJ1xcXFx1MkM2NCc6ICdSJyxcXG4gICAgJ1xcXFx1QTc1QSc6ICdSJyxcXG4gICAgJ1xcXFx1QTdBNic6ICdSJyxcXG4gICAgJ1xcXFx1QTc4Mic6ICdSJyxcXG4gICAgJ1xcXFx1MjRDOCc6ICdTJyxcXG4gICAgJ1xcXFx1RkYzMyc6ICdTJyxcXG4gICAgJ1xcXFx1MUU5RSc6ICdTJyxcXG4gICAgJ1xcXFx1MDE1QSc6ICdTJyxcXG4gICAgJ1xcXFx1MUU2NCc6ICdTJyxcXG4gICAgJ1xcXFx1MDE1Qyc6ICdTJyxcXG4gICAgJ1xcXFx1MUU2MCc6ICdTJyxcXG4gICAgJ1xcXFx1MDE2MCc6ICdTJyxcXG4gICAgJ1xcXFx1MUU2Nic6ICdTJyxcXG4gICAgJ1xcXFx1MUU2Mic6ICdTJyxcXG4gICAgJ1xcXFx1MUU2OCc6ICdTJyxcXG4gICAgJ1xcXFx1MDIxOCc6ICdTJyxcXG4gICAgJ1xcXFx1MDE1RSc6ICdTJyxcXG4gICAgJ1xcXFx1MkM3RSc6ICdTJyxcXG4gICAgJ1xcXFx1QTdBOCc6ICdTJyxcXG4gICAgJ1xcXFx1QTc4NCc6ICdTJyxcXG4gICAgJ1xcXFx1MjRDOSc6ICdUJyxcXG4gICAgJ1xcXFx1RkYzNCc6ICdUJyxcXG4gICAgJ1xcXFx1MUU2QSc6ICdUJyxcXG4gICAgJ1xcXFx1MDE2NCc6ICdUJyxcXG4gICAgJ1xcXFx1MUU2Qyc6ICdUJyxcXG4gICAgJ1xcXFx1MDIxQSc6ICdUJyxcXG4gICAgJ1xcXFx1MDE2Mic6ICdUJyxcXG4gICAgJ1xcXFx1MUU3MCc6ICdUJyxcXG4gICAgJ1xcXFx1MUU2RSc6ICdUJyxcXG4gICAgJ1xcXFx1MDE2Nic6ICdUJyxcXG4gICAgJ1xcXFx1MDFBQyc6ICdUJyxcXG4gICAgJ1xcXFx1MDFBRSc6ICdUJyxcXG4gICAgJ1xcXFx1MDIzRSc6ICdUJyxcXG4gICAgJ1xcXFx1QTc4Nic6ICdUJyxcXG4gICAgJ1xcXFx1QTcyOCc6ICdUWicsXFxuICAgICdcXFxcdTI0Q0EnOiAnVScsXFxuICAgICdcXFxcdUZGMzUnOiAnVScsXFxuICAgICdcXFxcdTAwRDknOiAnVScsXFxuICAgICdcXFxcdTAwREEnOiAnVScsXFxuICAgICdcXFxcdTAwREInOiAnVScsXFxuICAgICdcXFxcdTAxNjgnOiAnVScsXFxuICAgICdcXFxcdTFFNzgnOiAnVScsXFxuICAgICdcXFxcdTAxNkEnOiAnVScsXFxuICAgICdcXFxcdTFFN0EnOiAnVScsXFxuICAgICdcXFxcdTAxNkMnOiAnVScsXFxuICAgICdcXFxcdTAwREMnOiAnVScsXFxuICAgICdcXFxcdTAxREInOiAnVScsXFxuICAgICdcXFxcdTAxRDcnOiAnVScsXFxuICAgICdcXFxcdTAxRDUnOiAnVScsXFxuICAgICdcXFxcdTAxRDknOiAnVScsXFxuICAgICdcXFxcdTFFRTYnOiAnVScsXFxuICAgICdcXFxcdTAxNkUnOiAnVScsXFxuICAgICdcXFxcdTAxNzAnOiAnVScsXFxuICAgICdcXFxcdTAxRDMnOiAnVScsXFxuICAgICdcXFxcdTAyMTQnOiAnVScsXFxuICAgICdcXFxcdTAyMTYnOiAnVScsXFxuICAgICdcXFxcdTAxQUYnOiAnVScsXFxuICAgICdcXFxcdTFFRUEnOiAnVScsXFxuICAgICdcXFxcdTFFRTgnOiAnVScsXFxuICAgICdcXFxcdTFFRUUnOiAnVScsXFxuICAgICdcXFxcdTFFRUMnOiAnVScsXFxuICAgICdcXFxcdTFFRjAnOiAnVScsXFxuICAgICdcXFxcdTFFRTQnOiAnVScsXFxuICAgICdcXFxcdTFFNzInOiAnVScsXFxuICAgICdcXFxcdTAxNzInOiAnVScsXFxuICAgICdcXFxcdTFFNzYnOiAnVScsXFxuICAgICdcXFxcdTFFNzQnOiAnVScsXFxuICAgICdcXFxcdTAyNDQnOiAnVScsXFxuICAgICdcXFxcdTI0Q0InOiAnVicsXFxuICAgICdcXFxcdUZGMzYnOiAnVicsXFxuICAgICdcXFxcdTFFN0MnOiAnVicsXFxuICAgICdcXFxcdTFFN0UnOiAnVicsXFxuICAgICdcXFxcdTAxQjInOiAnVicsXFxuICAgICdcXFxcdUE3NUUnOiAnVicsXFxuICAgICdcXFxcdTAyNDUnOiAnVicsXFxuICAgICdcXFxcdUE3NjAnOiAnVlknLFxcbiAgICAnXFxcXHUyNENDJzogJ1cnLFxcbiAgICAnXFxcXHVGRjM3JzogJ1cnLFxcbiAgICAnXFxcXHUxRTgwJzogJ1cnLFxcbiAgICAnXFxcXHUxRTgyJzogJ1cnLFxcbiAgICAnXFxcXHUwMTc0JzogJ1cnLFxcbiAgICAnXFxcXHUxRTg2JzogJ1cnLFxcbiAgICAnXFxcXHUxRTg0JzogJ1cnLFxcbiAgICAnXFxcXHUxRTg4JzogJ1cnLFxcbiAgICAnXFxcXHUyQzcyJzogJ1cnLFxcbiAgICAnXFxcXHUyNENEJzogJ1gnLFxcbiAgICAnXFxcXHVGRjM4JzogJ1gnLFxcbiAgICAnXFxcXHUxRThBJzogJ1gnLFxcbiAgICAnXFxcXHUxRThDJzogJ1gnLFxcbiAgICAnXFxcXHUyNENFJzogJ1knLFxcbiAgICAnXFxcXHVGRjM5JzogJ1knLFxcbiAgICAnXFxcXHUxRUYyJzogJ1knLFxcbiAgICAnXFxcXHUwMEREJzogJ1knLFxcbiAgICAnXFxcXHUwMTc2JzogJ1knLFxcbiAgICAnXFxcXHUxRUY4JzogJ1knLFxcbiAgICAnXFxcXHUwMjMyJzogJ1knLFxcbiAgICAnXFxcXHUxRThFJzogJ1knLFxcbiAgICAnXFxcXHUwMTc4JzogJ1knLFxcbiAgICAnXFxcXHUxRUY2JzogJ1knLFxcbiAgICAnXFxcXHUxRUY0JzogJ1knLFxcbiAgICAnXFxcXHUwMUIzJzogJ1knLFxcbiAgICAnXFxcXHUwMjRFJzogJ1knLFxcbiAgICAnXFxcXHUxRUZFJzogJ1knLFxcbiAgICAnXFxcXHUyNENGJzogJ1onLFxcbiAgICAnXFxcXHVGRjNBJzogJ1onLFxcbiAgICAnXFxcXHUwMTc5JzogJ1onLFxcbiAgICAnXFxcXHUxRTkwJzogJ1onLFxcbiAgICAnXFxcXHUwMTdCJzogJ1onLFxcbiAgICAnXFxcXHUwMTdEJzogJ1onLFxcbiAgICAnXFxcXHUxRTkyJzogJ1onLFxcbiAgICAnXFxcXHUxRTk0JzogJ1onLFxcbiAgICAnXFxcXHUwMUI1JzogJ1onLFxcbiAgICAnXFxcXHUwMjI0JzogJ1onLFxcbiAgICAnXFxcXHUyQzdGJzogJ1onLFxcbiAgICAnXFxcXHUyQzZCJzogJ1onLFxcbiAgICAnXFxcXHVBNzYyJzogJ1onLFxcbiAgICAnXFxcXHUyNEQwJzogJ2EnLFxcbiAgICAnXFxcXHVGRjQxJzogJ2EnLFxcbiAgICAnXFxcXHUxRTlBJzogJ2EnLFxcbiAgICAnXFxcXHUwMEUwJzogJ2EnLFxcbiAgICAnXFxcXHUwMEUxJzogJ2EnLFxcbiAgICAnXFxcXHUwMEUyJzogJ2EnLFxcbiAgICAnXFxcXHUxRUE3JzogJ2EnLFxcbiAgICAnXFxcXHUxRUE1JzogJ2EnLFxcbiAgICAnXFxcXHUxRUFCJzogJ2EnLFxcbiAgICAnXFxcXHUxRUE5JzogJ2EnLFxcbiAgICAnXFxcXHUwMEUzJzogJ2EnLFxcbiAgICAnXFxcXHUwMTAxJzogJ2EnLFxcbiAgICAnXFxcXHUwMTAzJzogJ2EnLFxcbiAgICAnXFxcXHUxRUIxJzogJ2EnLFxcbiAgICAnXFxcXHUxRUFGJzogJ2EnLFxcbiAgICAnXFxcXHUxRUI1JzogJ2EnLFxcbiAgICAnXFxcXHUxRUIzJzogJ2EnLFxcbiAgICAnXFxcXHUwMjI3JzogJ2EnLFxcbiAgICAnXFxcXHUwMUUxJzogJ2EnLFxcbiAgICAnXFxcXHUwMEU0JzogJ2EnLFxcbiAgICAnXFxcXHUwMURGJzogJ2EnLFxcbiAgICAnXFxcXHUxRUEzJzogJ2EnLFxcbiAgICAnXFxcXHUwMEU1JzogJ2EnLFxcbiAgICAnXFxcXHUwMUZCJzogJ2EnLFxcbiAgICAnXFxcXHUwMUNFJzogJ2EnLFxcbiAgICAnXFxcXHUwMjAxJzogJ2EnLFxcbiAgICAnXFxcXHUwMjAzJzogJ2EnLFxcbiAgICAnXFxcXHUxRUExJzogJ2EnLFxcbiAgICAnXFxcXHUxRUFEJzogJ2EnLFxcbiAgICAnXFxcXHUxRUI3JzogJ2EnLFxcbiAgICAnXFxcXHUxRTAxJzogJ2EnLFxcbiAgICAnXFxcXHUwMTA1JzogJ2EnLFxcbiAgICAnXFxcXHUyQzY1JzogJ2EnLFxcbiAgICAnXFxcXHUwMjUwJzogJ2EnLFxcbiAgICAnXFxcXHVBNzMzJzogJ2FhJyxcXG4gICAgJ1xcXFx1MDBFNic6ICdhZScsXFxuICAgICdcXFxcdTAxRkQnOiAnYWUnLFxcbiAgICAnXFxcXHUwMUUzJzogJ2FlJyxcXG4gICAgJ1xcXFx1QTczNSc6ICdhbycsXFxuICAgICdcXFxcdUE3MzcnOiAnYXUnLFxcbiAgICAnXFxcXHVBNzM5JzogJ2F2JyxcXG4gICAgJ1xcXFx1QTczQic6ICdhdicsXFxuICAgICdcXFxcdUE3M0QnOiAnYXknLFxcbiAgICAnXFxcXHUyNEQxJzogJ2InLFxcbiAgICAnXFxcXHVGRjQyJzogJ2InLFxcbiAgICAnXFxcXHUxRTAzJzogJ2InLFxcbiAgICAnXFxcXHUxRTA1JzogJ2InLFxcbiAgICAnXFxcXHUxRTA3JzogJ2InLFxcbiAgICAnXFxcXHUwMTgwJzogJ2InLFxcbiAgICAnXFxcXHUwMTgzJzogJ2InLFxcbiAgICAnXFxcXHUwMjUzJzogJ2InLFxcbiAgICAnXFxcXHUyNEQyJzogJ2MnLFxcbiAgICAnXFxcXHVGRjQzJzogJ2MnLFxcbiAgICAnXFxcXHUwMTA3JzogJ2MnLFxcbiAgICAnXFxcXHUwMTA5JzogJ2MnLFxcbiAgICAnXFxcXHUwMTBCJzogJ2MnLFxcbiAgICAnXFxcXHUwMTBEJzogJ2MnLFxcbiAgICAnXFxcXHUwMEU3JzogJ2MnLFxcbiAgICAnXFxcXHUxRTA5JzogJ2MnLFxcbiAgICAnXFxcXHUwMTg4JzogJ2MnLFxcbiAgICAnXFxcXHUwMjNDJzogJ2MnLFxcbiAgICAnXFxcXHVBNzNGJzogJ2MnLFxcbiAgICAnXFxcXHUyMTg0JzogJ2MnLFxcbiAgICAnXFxcXHUyNEQzJzogJ2QnLFxcbiAgICAnXFxcXHVGRjQ0JzogJ2QnLFxcbiAgICAnXFxcXHUxRTBCJzogJ2QnLFxcbiAgICAnXFxcXHUwMTBGJzogJ2QnLFxcbiAgICAnXFxcXHUxRTBEJzogJ2QnLFxcbiAgICAnXFxcXHUxRTExJzogJ2QnLFxcbiAgICAnXFxcXHUxRTEzJzogJ2QnLFxcbiAgICAnXFxcXHUxRTBGJzogJ2QnLFxcbiAgICAnXFxcXHUwMTExJzogJ2QnLFxcbiAgICAnXFxcXHUwMThDJzogJ2QnLFxcbiAgICAnXFxcXHUwMjU2JzogJ2QnLFxcbiAgICAnXFxcXHUwMjU3JzogJ2QnLFxcbiAgICAnXFxcXHVBNzdBJzogJ2QnLFxcbiAgICAnXFxcXHUwMUYzJzogJ2R6JyxcXG4gICAgJ1xcXFx1MDFDNic6ICdkeicsXFxuICAgICdcXFxcdTI0RDQnOiAnZScsXFxuICAgICdcXFxcdUZGNDUnOiAnZScsXFxuICAgICdcXFxcdTAwRTgnOiAnZScsXFxuICAgICdcXFxcdTAwRTknOiAnZScsXFxuICAgICdcXFxcdTAwRUEnOiAnZScsXFxuICAgICdcXFxcdTFFQzEnOiAnZScsXFxuICAgICdcXFxcdTFFQkYnOiAnZScsXFxuICAgICdcXFxcdTFFQzUnOiAnZScsXFxuICAgICdcXFxcdTFFQzMnOiAnZScsXFxuICAgICdcXFxcdTFFQkQnOiAnZScsXFxuICAgICdcXFxcdTAxMTMnOiAnZScsXFxuICAgICdcXFxcdTFFMTUnOiAnZScsXFxuICAgICdcXFxcdTFFMTcnOiAnZScsXFxuICAgICdcXFxcdTAxMTUnOiAnZScsXFxuICAgICdcXFxcdTAxMTcnOiAnZScsXFxuICAgICdcXFxcdTAwRUInOiAnZScsXFxuICAgICdcXFxcdTFFQkInOiAnZScsXFxuICAgICdcXFxcdTAxMUInOiAnZScsXFxuICAgICdcXFxcdTAyMDUnOiAnZScsXFxuICAgICdcXFxcdTAyMDcnOiAnZScsXFxuICAgICdcXFxcdTFFQjknOiAnZScsXFxuICAgICdcXFxcdTFFQzcnOiAnZScsXFxuICAgICdcXFxcdTAyMjknOiAnZScsXFxuICAgICdcXFxcdTFFMUQnOiAnZScsXFxuICAgICdcXFxcdTAxMTknOiAnZScsXFxuICAgICdcXFxcdTFFMTknOiAnZScsXFxuICAgICdcXFxcdTFFMUInOiAnZScsXFxuICAgICdcXFxcdTAyNDcnOiAnZScsXFxuICAgICdcXFxcdTAyNUInOiAnZScsXFxuICAgICdcXFxcdTAxREQnOiAnZScsXFxuICAgICdcXFxcdTI0RDUnOiAnZicsXFxuICAgICdcXFxcdUZGNDYnOiAnZicsXFxuICAgICdcXFxcdTFFMUYnOiAnZicsXFxuICAgICdcXFxcdTAxOTInOiAnZicsXFxuICAgICdcXFxcdUE3N0MnOiAnZicsXFxuICAgICdcXFxcdTI0RDYnOiAnZycsXFxuICAgICdcXFxcdUZGNDcnOiAnZycsXFxuICAgICdcXFxcdTAxRjUnOiAnZycsXFxuICAgICdcXFxcdTAxMUQnOiAnZycsXFxuICAgICdcXFxcdTFFMjEnOiAnZycsXFxuICAgICdcXFxcdTAxMUYnOiAnZycsXFxuICAgICdcXFxcdTAxMjEnOiAnZycsXFxuICAgICdcXFxcdTAxRTcnOiAnZycsXFxuICAgICdcXFxcdTAxMjMnOiAnZycsXFxuICAgICdcXFxcdTAxRTUnOiAnZycsXFxuICAgICdcXFxcdTAyNjAnOiAnZycsXFxuICAgICdcXFxcdUE3QTEnOiAnZycsXFxuICAgICdcXFxcdTFENzknOiAnZycsXFxuICAgICdcXFxcdUE3N0YnOiAnZycsXFxuICAgICdcXFxcdTI0RDcnOiAnaCcsXFxuICAgICdcXFxcdUZGNDgnOiAnaCcsXFxuICAgICdcXFxcdTAxMjUnOiAnaCcsXFxuICAgICdcXFxcdTFFMjMnOiAnaCcsXFxuICAgICdcXFxcdTFFMjcnOiAnaCcsXFxuICAgICdcXFxcdTAyMUYnOiAnaCcsXFxuICAgICdcXFxcdTFFMjUnOiAnaCcsXFxuICAgICdcXFxcdTFFMjknOiAnaCcsXFxuICAgICdcXFxcdTFFMkInOiAnaCcsXFxuICAgICdcXFxcdTFFOTYnOiAnaCcsXFxuICAgICdcXFxcdTAxMjcnOiAnaCcsXFxuICAgICdcXFxcdTJDNjgnOiAnaCcsXFxuICAgICdcXFxcdTJDNzYnOiAnaCcsXFxuICAgICdcXFxcdTAyNjUnOiAnaCcsXFxuICAgICdcXFxcdTAxOTUnOiAnaHYnLFxcbiAgICAnXFxcXHUyNEQ4JzogJ2knLFxcbiAgICAnXFxcXHVGRjQ5JzogJ2knLFxcbiAgICAnXFxcXHUwMEVDJzogJ2knLFxcbiAgICAnXFxcXHUwMEVEJzogJ2knLFxcbiAgICAnXFxcXHUwMEVFJzogJ2knLFxcbiAgICAnXFxcXHUwMTI5JzogJ2knLFxcbiAgICAnXFxcXHUwMTJCJzogJ2knLFxcbiAgICAnXFxcXHUwMTJEJzogJ2knLFxcbiAgICAnXFxcXHUwMEVGJzogJ2knLFxcbiAgICAnXFxcXHUxRTJGJzogJ2knLFxcbiAgICAnXFxcXHUxRUM5JzogJ2knLFxcbiAgICAnXFxcXHUwMUQwJzogJ2knLFxcbiAgICAnXFxcXHUwMjA5JzogJ2knLFxcbiAgICAnXFxcXHUwMjBCJzogJ2knLFxcbiAgICAnXFxcXHUxRUNCJzogJ2knLFxcbiAgICAnXFxcXHUwMTJGJzogJ2knLFxcbiAgICAnXFxcXHUxRTJEJzogJ2knLFxcbiAgICAnXFxcXHUwMjY4JzogJ2knLFxcbiAgICAnXFxcXHUwMTMxJzogJ2knLFxcbiAgICAnXFxcXHUyNEQ5JzogJ2onLFxcbiAgICAnXFxcXHVGRjRBJzogJ2onLFxcbiAgICAnXFxcXHUwMTM1JzogJ2onLFxcbiAgICAnXFxcXHUwMUYwJzogJ2onLFxcbiAgICAnXFxcXHUwMjQ5JzogJ2onLFxcbiAgICAnXFxcXHUyNERBJzogJ2snLFxcbiAgICAnXFxcXHVGRjRCJzogJ2snLFxcbiAgICAnXFxcXHUxRTMxJzogJ2snLFxcbiAgICAnXFxcXHUwMUU5JzogJ2snLFxcbiAgICAnXFxcXHUxRTMzJzogJ2snLFxcbiAgICAnXFxcXHUwMTM3JzogJ2snLFxcbiAgICAnXFxcXHUxRTM1JzogJ2snLFxcbiAgICAnXFxcXHUwMTk5JzogJ2snLFxcbiAgICAnXFxcXHUyQzZBJzogJ2snLFxcbiAgICAnXFxcXHVBNzQxJzogJ2snLFxcbiAgICAnXFxcXHVBNzQzJzogJ2snLFxcbiAgICAnXFxcXHVBNzQ1JzogJ2snLFxcbiAgICAnXFxcXHVBN0EzJzogJ2snLFxcbiAgICAnXFxcXHUyNERCJzogJ2wnLFxcbiAgICAnXFxcXHVGRjRDJzogJ2wnLFxcbiAgICAnXFxcXHUwMTQwJzogJ2wnLFxcbiAgICAnXFxcXHUwMTNBJzogJ2wnLFxcbiAgICAnXFxcXHUwMTNFJzogJ2wnLFxcbiAgICAnXFxcXHUxRTM3JzogJ2wnLFxcbiAgICAnXFxcXHUxRTM5JzogJ2wnLFxcbiAgICAnXFxcXHUwMTNDJzogJ2wnLFxcbiAgICAnXFxcXHUxRTNEJzogJ2wnLFxcbiAgICAnXFxcXHUxRTNCJzogJ2wnLFxcbiAgICAnXFxcXHUwMTdGJzogJ2wnLFxcbiAgICAnXFxcXHUwMTQyJzogJ2wnLFxcbiAgICAnXFxcXHUwMTlBJzogJ2wnLFxcbiAgICAnXFxcXHUwMjZCJzogJ2wnLFxcbiAgICAnXFxcXHUyQzYxJzogJ2wnLFxcbiAgICAnXFxcXHVBNzQ5JzogJ2wnLFxcbiAgICAnXFxcXHVBNzgxJzogJ2wnLFxcbiAgICAnXFxcXHVBNzQ3JzogJ2wnLFxcbiAgICAnXFxcXHUwMUM5JzogJ2xqJyxcXG4gICAgJ1xcXFx1MjREQyc6ICdtJyxcXG4gICAgJ1xcXFx1RkY0RCc6ICdtJyxcXG4gICAgJ1xcXFx1MUUzRic6ICdtJyxcXG4gICAgJ1xcXFx1MUU0MSc6ICdtJyxcXG4gICAgJ1xcXFx1MUU0Myc6ICdtJyxcXG4gICAgJ1xcXFx1MDI3MSc6ICdtJyxcXG4gICAgJ1xcXFx1MDI2Ric6ICdtJyxcXG4gICAgJ1xcXFx1MjRERCc6ICduJyxcXG4gICAgJ1xcXFx1RkY0RSc6ICduJyxcXG4gICAgJ1xcXFx1MDFGOSc6ICduJyxcXG4gICAgJ1xcXFx1MDE0NCc6ICduJyxcXG4gICAgJ1xcXFx1MDBGMSc6ICduJyxcXG4gICAgJ1xcXFx1MUU0NSc6ICduJyxcXG4gICAgJ1xcXFx1MDE0OCc6ICduJyxcXG4gICAgJ1xcXFx1MUU0Nyc6ICduJyxcXG4gICAgJ1xcXFx1MDE0Nic6ICduJyxcXG4gICAgJ1xcXFx1MUU0Qic6ICduJyxcXG4gICAgJ1xcXFx1MUU0OSc6ICduJyxcXG4gICAgJ1xcXFx1MDE5RSc6ICduJyxcXG4gICAgJ1xcXFx1MDI3Mic6ICduJyxcXG4gICAgJ1xcXFx1MDE0OSc6ICduJyxcXG4gICAgJ1xcXFx1QTc5MSc6ICduJyxcXG4gICAgJ1xcXFx1QTdBNSc6ICduJyxcXG4gICAgJ1xcXFx1MDFDQyc6ICduaicsXFxuICAgICdcXFxcdTI0REUnOiAnbycsXFxuICAgICdcXFxcdUZGNEYnOiAnbycsXFxuICAgICdcXFxcdTAwRjInOiAnbycsXFxuICAgICdcXFxcdTAwRjMnOiAnbycsXFxuICAgICdcXFxcdTAwRjQnOiAnbycsXFxuICAgICdcXFxcdTFFRDMnOiAnbycsXFxuICAgICdcXFxcdTFFRDEnOiAnbycsXFxuICAgICdcXFxcdTFFRDcnOiAnbycsXFxuICAgICdcXFxcdTFFRDUnOiAnbycsXFxuICAgICdcXFxcdTAwRjUnOiAnbycsXFxuICAgICdcXFxcdTFFNEQnOiAnbycsXFxuICAgICdcXFxcdTAyMkQnOiAnbycsXFxuICAgICdcXFxcdTFFNEYnOiAnbycsXFxuICAgICdcXFxcdTAxNEQnOiAnbycsXFxuICAgICdcXFxcdTFFNTEnOiAnbycsXFxuICAgICdcXFxcdTFFNTMnOiAnbycsXFxuICAgICdcXFxcdTAxNEYnOiAnbycsXFxuICAgICdcXFxcdTAyMkYnOiAnbycsXFxuICAgICdcXFxcdTAyMzEnOiAnbycsXFxuICAgICdcXFxcdTAwRjYnOiAnbycsXFxuICAgICdcXFxcdTAyMkInOiAnbycsXFxuICAgICdcXFxcdTFFQ0YnOiAnbycsXFxuICAgICdcXFxcdTAxNTEnOiAnbycsXFxuICAgICdcXFxcdTAxRDInOiAnbycsXFxuICAgICdcXFxcdTAyMEQnOiAnbycsXFxuICAgICdcXFxcdTAyMEYnOiAnbycsXFxuICAgICdcXFxcdTAxQTEnOiAnbycsXFxuICAgICdcXFxcdTFFREQnOiAnbycsXFxuICAgICdcXFxcdTFFREInOiAnbycsXFxuICAgICdcXFxcdTFFRTEnOiAnbycsXFxuICAgICdcXFxcdTFFREYnOiAnbycsXFxuICAgICdcXFxcdTFFRTMnOiAnbycsXFxuICAgICdcXFxcdTFFQ0QnOiAnbycsXFxuICAgICdcXFxcdTFFRDknOiAnbycsXFxuICAgICdcXFxcdTAxRUInOiAnbycsXFxuICAgICdcXFxcdTAxRUQnOiAnbycsXFxuICAgICdcXFxcdTAwRjgnOiAnbycsXFxuICAgICdcXFxcdTAxRkYnOiAnbycsXFxuICAgICdcXFxcdTAyNTQnOiAnbycsXFxuICAgICdcXFxcdUE3NEInOiAnbycsXFxuICAgICdcXFxcdUE3NEQnOiAnbycsXFxuICAgICdcXFxcdTAyNzUnOiAnbycsXFxuICAgICdcXFxcdTAxNTMnOiAnb2UnLFxcbiAgICAnXFxcXHUwMUEzJzogJ29pJyxcXG4gICAgJ1xcXFx1MDIyMyc6ICdvdScsXFxuICAgICdcXFxcdUE3NEYnOiAnb28nLFxcbiAgICAnXFxcXHUyNERGJzogJ3AnLFxcbiAgICAnXFxcXHVGRjUwJzogJ3AnLFxcbiAgICAnXFxcXHUxRTU1JzogJ3AnLFxcbiAgICAnXFxcXHUxRTU3JzogJ3AnLFxcbiAgICAnXFxcXHUwMUE1JzogJ3AnLFxcbiAgICAnXFxcXHUxRDdEJzogJ3AnLFxcbiAgICAnXFxcXHVBNzUxJzogJ3AnLFxcbiAgICAnXFxcXHVBNzUzJzogJ3AnLFxcbiAgICAnXFxcXHVBNzU1JzogJ3AnLFxcbiAgICAnXFxcXHUyNEUwJzogJ3EnLFxcbiAgICAnXFxcXHVGRjUxJzogJ3EnLFxcbiAgICAnXFxcXHUwMjRCJzogJ3EnLFxcbiAgICAnXFxcXHVBNzU3JzogJ3EnLFxcbiAgICAnXFxcXHVBNzU5JzogJ3EnLFxcbiAgICAnXFxcXHUyNEUxJzogJ3InLFxcbiAgICAnXFxcXHVGRjUyJzogJ3InLFxcbiAgICAnXFxcXHUwMTU1JzogJ3InLFxcbiAgICAnXFxcXHUxRTU5JzogJ3InLFxcbiAgICAnXFxcXHUwMTU5JzogJ3InLFxcbiAgICAnXFxcXHUwMjExJzogJ3InLFxcbiAgICAnXFxcXHUwMjEzJzogJ3InLFxcbiAgICAnXFxcXHUxRTVCJzogJ3InLFxcbiAgICAnXFxcXHUxRTVEJzogJ3InLFxcbiAgICAnXFxcXHUwMTU3JzogJ3InLFxcbiAgICAnXFxcXHUxRTVGJzogJ3InLFxcbiAgICAnXFxcXHUwMjREJzogJ3InLFxcbiAgICAnXFxcXHUwMjdEJzogJ3InLFxcbiAgICAnXFxcXHVBNzVCJzogJ3InLFxcbiAgICAnXFxcXHVBN0E3JzogJ3InLFxcbiAgICAnXFxcXHVBNzgzJzogJ3InLFxcbiAgICAnXFxcXHUyNEUyJzogJ3MnLFxcbiAgICAnXFxcXHVGRjUzJzogJ3MnLFxcbiAgICAnXFxcXHUwMERGJzogJ3MnLFxcbiAgICAnXFxcXHUwMTVCJzogJ3MnLFxcbiAgICAnXFxcXHUxRTY1JzogJ3MnLFxcbiAgICAnXFxcXHUwMTVEJzogJ3MnLFxcbiAgICAnXFxcXHUxRTYxJzogJ3MnLFxcbiAgICAnXFxcXHUwMTYxJzogJ3MnLFxcbiAgICAnXFxcXHUxRTY3JzogJ3MnLFxcbiAgICAnXFxcXHUxRTYzJzogJ3MnLFxcbiAgICAnXFxcXHUxRTY5JzogJ3MnLFxcbiAgICAnXFxcXHUwMjE5JzogJ3MnLFxcbiAgICAnXFxcXHUwMTVGJzogJ3MnLFxcbiAgICAnXFxcXHUwMjNGJzogJ3MnLFxcbiAgICAnXFxcXHVBN0E5JzogJ3MnLFxcbiAgICAnXFxcXHVBNzg1JzogJ3MnLFxcbiAgICAnXFxcXHUxRTlCJzogJ3MnLFxcbiAgICAnXFxcXHUyNEUzJzogJ3QnLFxcbiAgICAnXFxcXHVGRjU0JzogJ3QnLFxcbiAgICAnXFxcXHUxRTZCJzogJ3QnLFxcbiAgICAnXFxcXHUxRTk3JzogJ3QnLFxcbiAgICAnXFxcXHUwMTY1JzogJ3QnLFxcbiAgICAnXFxcXHUxRTZEJzogJ3QnLFxcbiAgICAnXFxcXHUwMjFCJzogJ3QnLFxcbiAgICAnXFxcXHUwMTYzJzogJ3QnLFxcbiAgICAnXFxcXHUxRTcxJzogJ3QnLFxcbiAgICAnXFxcXHUxRTZGJzogJ3QnLFxcbiAgICAnXFxcXHUwMTY3JzogJ3QnLFxcbiAgICAnXFxcXHUwMUFEJzogJ3QnLFxcbiAgICAnXFxcXHUwMjg4JzogJ3QnLFxcbiAgICAnXFxcXHUyQzY2JzogJ3QnLFxcbiAgICAnXFxcXHVBNzg3JzogJ3QnLFxcbiAgICAnXFxcXHVBNzI5JzogJ3R6JyxcXG4gICAgJ1xcXFx1MjRFNCc6ICd1JyxcXG4gICAgJ1xcXFx1RkY1NSc6ICd1JyxcXG4gICAgJ1xcXFx1MDBGOSc6ICd1JyxcXG4gICAgJ1xcXFx1MDBGQSc6ICd1JyxcXG4gICAgJ1xcXFx1MDBGQic6ICd1JyxcXG4gICAgJ1xcXFx1MDE2OSc6ICd1JyxcXG4gICAgJ1xcXFx1MUU3OSc6ICd1JyxcXG4gICAgJ1xcXFx1MDE2Qic6ICd1JyxcXG4gICAgJ1xcXFx1MUU3Qic6ICd1JyxcXG4gICAgJ1xcXFx1MDE2RCc6ICd1JyxcXG4gICAgJ1xcXFx1MDBGQyc6ICd1JyxcXG4gICAgJ1xcXFx1MDFEQyc6ICd1JyxcXG4gICAgJ1xcXFx1MDFEOCc6ICd1JyxcXG4gICAgJ1xcXFx1MDFENic6ICd1JyxcXG4gICAgJ1xcXFx1MDFEQSc6ICd1JyxcXG4gICAgJ1xcXFx1MUVFNyc6ICd1JyxcXG4gICAgJ1xcXFx1MDE2Ric6ICd1JyxcXG4gICAgJ1xcXFx1MDE3MSc6ICd1JyxcXG4gICAgJ1xcXFx1MDFENCc6ICd1JyxcXG4gICAgJ1xcXFx1MDIxNSc6ICd1JyxcXG4gICAgJ1xcXFx1MDIxNyc6ICd1JyxcXG4gICAgJ1xcXFx1MDFCMCc6ICd1JyxcXG4gICAgJ1xcXFx1MUVFQic6ICd1JyxcXG4gICAgJ1xcXFx1MUVFOSc6ICd1JyxcXG4gICAgJ1xcXFx1MUVFRic6ICd1JyxcXG4gICAgJ1xcXFx1MUVFRCc6ICd1JyxcXG4gICAgJ1xcXFx1MUVGMSc6ICd1JyxcXG4gICAgJ1xcXFx1MUVFNSc6ICd1JyxcXG4gICAgJ1xcXFx1MUU3Myc6ICd1JyxcXG4gICAgJ1xcXFx1MDE3Myc6ICd1JyxcXG4gICAgJ1xcXFx1MUU3Nyc6ICd1JyxcXG4gICAgJ1xcXFx1MUU3NSc6ICd1JyxcXG4gICAgJ1xcXFx1MDI4OSc6ICd1JyxcXG4gICAgJ1xcXFx1MjRFNSc6ICd2JyxcXG4gICAgJ1xcXFx1RkY1Nic6ICd2JyxcXG4gICAgJ1xcXFx1MUU3RCc6ICd2JyxcXG4gICAgJ1xcXFx1MUU3Ric6ICd2JyxcXG4gICAgJ1xcXFx1MDI4Qic6ICd2JyxcXG4gICAgJ1xcXFx1QTc1Ric6ICd2JyxcXG4gICAgJ1xcXFx1MDI4Qyc6ICd2JyxcXG4gICAgJ1xcXFx1QTc2MSc6ICd2eScsXFxuICAgICdcXFxcdTI0RTYnOiAndycsXFxuICAgICdcXFxcdUZGNTcnOiAndycsXFxuICAgICdcXFxcdTFFODEnOiAndycsXFxuICAgICdcXFxcdTFFODMnOiAndycsXFxuICAgICdcXFxcdTAxNzUnOiAndycsXFxuICAgICdcXFxcdTFFODcnOiAndycsXFxuICAgICdcXFxcdTFFODUnOiAndycsXFxuICAgICdcXFxcdTFFOTgnOiAndycsXFxuICAgICdcXFxcdTFFODknOiAndycsXFxuICAgICdcXFxcdTJDNzMnOiAndycsXFxuICAgICdcXFxcdTI0RTcnOiAneCcsXFxuICAgICdcXFxcdUZGNTgnOiAneCcsXFxuICAgICdcXFxcdTFFOEInOiAneCcsXFxuICAgICdcXFxcdTFFOEQnOiAneCcsXFxuICAgICdcXFxcdTI0RTgnOiAneScsXFxuICAgICdcXFxcdUZGNTknOiAneScsXFxuICAgICdcXFxcdTFFRjMnOiAneScsXFxuICAgICdcXFxcdTAwRkQnOiAneScsXFxuICAgICdcXFxcdTAxNzcnOiAneScsXFxuICAgICdcXFxcdTFFRjknOiAneScsXFxuICAgICdcXFxcdTAyMzMnOiAneScsXFxuICAgICdcXFxcdTFFOEYnOiAneScsXFxuICAgICdcXFxcdTAwRkYnOiAneScsXFxuICAgICdcXFxcdTFFRjcnOiAneScsXFxuICAgICdcXFxcdTFFOTknOiAneScsXFxuICAgICdcXFxcdTFFRjUnOiAneScsXFxuICAgICdcXFxcdTAxQjQnOiAneScsXFxuICAgICdcXFxcdTAyNEYnOiAneScsXFxuICAgICdcXFxcdTFFRkYnOiAneScsXFxuICAgICdcXFxcdTI0RTknOiAneicsXFxuICAgICdcXFxcdUZGNUEnOiAneicsXFxuICAgICdcXFxcdTAxN0EnOiAneicsXFxuICAgICdcXFxcdTFFOTEnOiAneicsXFxuICAgICdcXFxcdTAxN0MnOiAneicsXFxuICAgICdcXFxcdTAxN0UnOiAneicsXFxuICAgICdcXFxcdTFFOTMnOiAneicsXFxuICAgICdcXFxcdTFFOTUnOiAneicsXFxuICAgICdcXFxcdTAxQjYnOiAneicsXFxuICAgICdcXFxcdTAyMjUnOiAneicsXFxuICAgICdcXFxcdTAyNDAnOiAneicsXFxuICAgICdcXFxcdTJDNkMnOiAneicsXFxuICAgICdcXFxcdUE3NjMnOiAneicsXFxuICAgICdcXFxcdTAzODYnOiAnXFxcXHUwMzkxJyxcXG4gICAgJ1xcXFx1MDM4OCc6ICdcXFxcdTAzOTUnLFxcbiAgICAnXFxcXHUwMzg5JzogJ1xcXFx1MDM5NycsXFxuICAgICdcXFxcdTAzOEEnOiAnXFxcXHUwMzk5JyxcXG4gICAgJ1xcXFx1MDNBQSc6ICdcXFxcdTAzOTknLFxcbiAgICAnXFxcXHUwMzhDJzogJ1xcXFx1MDM5RicsXFxuICAgICdcXFxcdTAzOEUnOiAnXFxcXHUwM0E1JyxcXG4gICAgJ1xcXFx1MDNBQic6ICdcXFxcdTAzQTUnLFxcbiAgICAnXFxcXHUwMzhGJzogJ1xcXFx1MDNBOScsXFxuICAgICdcXFxcdTAzQUMnOiAnXFxcXHUwM0IxJyxcXG4gICAgJ1xcXFx1MDNBRCc6ICdcXFxcdTAzQjUnLFxcbiAgICAnXFxcXHUwM0FFJzogJ1xcXFx1MDNCNycsXFxuICAgICdcXFxcdTAzQUYnOiAnXFxcXHUwM0I5JyxcXG4gICAgJ1xcXFx1MDNDQSc6ICdcXFxcdTAzQjknLFxcbiAgICAnXFxcXHUwMzkwJzogJ1xcXFx1MDNCOScsXFxuICAgICdcXFxcdTAzQ0MnOiAnXFxcXHUwM0JGJyxcXG4gICAgJ1xcXFx1MDNDRCc6ICdcXFxcdTAzQzUnLFxcbiAgICAnXFxcXHUwM0NCJzogJ1xcXFx1MDNDNScsXFxuICAgICdcXFxcdTAzQjAnOiAnXFxcXHUwM0M1JyxcXG4gICAgJ1xcXFx1MDNDRSc6ICdcXFxcdTAzQzknLFxcbiAgICAnXFxcXHUwM0MyJzogJ1xcXFx1MDNDMycsXFxuICAgICdcXFxcdTIwMTknOiAnXFxcXCcnXFxuICB9O1xcblxcbiAgcmV0dXJuIGRpYWNyaXRpY3M7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvYmFzZScsW1xcbiAgJy4uL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uIChVdGlscykge1xcbiAgZnVuY3Rpb24gQmFzZUFkYXB0ZXIgKCRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIEJhc2VBZGFwdGVyLl9fc3VwZXJfXy5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMpO1xcbiAgfVxcblxcbiAgVXRpbHMuRXh0ZW5kKEJhc2VBZGFwdGVyLCBVdGlscy5PYnNlcnZhYmxlKTtcXG5cXG4gIEJhc2VBZGFwdGVyLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGBjdXJyZW50YCBtZXRob2QgbXVzdCBiZSBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXMuJyk7XFxuICB9O1xcblxcbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHF1ZXJ5YCBtZXRob2QgbXVzdCBiZSBkZWZpbmVkIGluIGNoaWxkIGNsYXNzZXMuJyk7XFxuICB9O1xcblxcbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIC8vIENhbiBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXFxuICB9O1xcblxcbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8vIENhbiBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzXFxuICB9O1xcblxcbiAgQmFzZUFkYXB0ZXIucHJvdG90eXBlLmdlbmVyYXRlUmVzdWx0SWQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCBkYXRhKSB7XFxuICAgIHZhciBpZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0LSc7XFxuXFxuICAgIGlkICs9IFV0aWxzLmdlbmVyYXRlQ2hhcnMoNCk7XFxuXFxuICAgIGlmIChkYXRhLmlkICE9IG51bGwpIHtcXG4gICAgICBpZCArPSAnLScgKyBkYXRhLmlkLnRvU3RyaW5nKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWQgKz0gJy0nICsgVXRpbHMuZ2VuZXJhdGVDaGFycyg0KTtcXG4gICAgfVxcbiAgICByZXR1cm4gaWQ7XFxuICB9O1xcblxcbiAgcmV0dXJuIEJhc2VBZGFwdGVyO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL3NlbGVjdCcsW1xcbiAgJy4vYmFzZScsXFxuICAnLi4vdXRpbHMnLFxcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoQmFzZUFkYXB0ZXIsIFV0aWxzLCAkKSB7XFxuICBmdW5jdGlvbiBTZWxlY3RBZGFwdGVyICgkZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XFxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFxuICAgIFNlbGVjdEFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XFxuICB9XFxuXFxuICBVdGlscy5FeHRlbmQoU2VsZWN0QWRhcHRlciwgQmFzZUFkYXB0ZXIpO1xcblxcbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xcbiAgICB2YXIgZGF0YSA9IFtdO1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnOnNlbGVjdGVkJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyICRvcHRpb24gPSAkKHRoaXMpO1xcblxcbiAgICAgIHZhciBvcHRpb24gPSBzZWxmLml0ZW0oJG9wdGlvbik7XFxuXFxuICAgICAgZGF0YS5wdXNoKG9wdGlvbik7XFxuICAgIH0pO1xcblxcbiAgICBjYWxsYmFjayhkYXRhKTtcXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGRhdGEuc2VsZWN0ZWQgPSB0cnVlO1xcblxcbiAgICAvLyBJZiBkYXRhLmVsZW1lbnQgaXMgYSBET00gbm9kZSwgdXNlIGl0IGluc3RlYWRcXG4gICAgaWYgKCQoZGF0YS5lbGVtZW50KS5pcygnb3B0aW9uJykpIHtcXG4gICAgICBkYXRhLmVsZW1lbnQuc2VsZWN0ZWQgPSB0cnVlO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaW5wdXQnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMuJGVsZW1lbnQucHJvcCgnbXVsdGlwbGUnKSkge1xcbiAgICAgIHRoaXMuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcXG4gICAgICAgIHZhciB2YWwgPSBbXTtcXG5cXG4gICAgICAgIGRhdGEgPSBbZGF0YV07XFxuICAgICAgICBkYXRhLnB1c2guYXBwbHkoZGF0YSwgY3VycmVudERhdGEpO1xcblxcbiAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XFxuICAgICAgICAgIHZhciBpZCA9IGRhdGFbZF0uaWQ7XFxuXFxuICAgICAgICAgIGlmICgkLmluQXJyYXkoaWQsIHZhbCkgPT09IC0xKSB7XFxuICAgICAgICAgICAgdmFsLnB1c2goaWQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZWxmLiRlbGVtZW50LnZhbCh2YWwpO1xcbiAgICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHZhciB2YWwgPSBkYXRhLmlkO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQudmFsKHZhbCk7XFxuICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGlmICghdGhpcy4kZWxlbWVudC5wcm9wKCdtdWx0aXBsZScpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGRhdGEuc2VsZWN0ZWQgPSBmYWxzZTtcXG5cXG4gICAgaWYgKCQoZGF0YS5lbGVtZW50KS5pcygnb3B0aW9uJykpIHtcXG4gICAgICBkYXRhLmVsZW1lbnQuc2VsZWN0ZWQgPSBmYWxzZTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2lucHV0JykudHJpZ2dlcignY2hhbmdlJyk7XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcXG4gICAgICB2YXIgdmFsID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBjdXJyZW50RGF0YS5sZW5ndGg7IGQrKykge1xcbiAgICAgICAgdmFyIGlkID0gY3VycmVudERhdGFbZF0uaWQ7XFxuXFxuICAgICAgICBpZiAoaWQgIT09IGRhdGEuaWQgJiYgJC5pbkFycmF5KGlkLCB2YWwpID09PSAtMSkge1xcbiAgICAgICAgICB2YWwucHVzaChpZCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHNlbGYuJGVsZW1lbnQudmFsKHZhbCk7XFxuXFxuICAgICAgc2VsZi4kZWxlbWVudC50cmlnZ2VyKCdpbnB1dCcpLnRyaWdnZXIoJ2NoYW5nZScpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xcblxcbiAgICBjb250YWluZXIub24oJ3NlbGVjdCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLnNlbGVjdChwYXJhbXMuZGF0YSk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Vuc2VsZWN0JywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIHNlbGYudW5zZWxlY3QocGFyYW1zLmRhdGEpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcbiAgICAvLyBSZW1vdmUgYW55dGhpbmcgYWRkZWQgdG8gY2hpbGQgZWxlbWVudHNcXG4gICAgdGhpcy4kZWxlbWVudC5maW5kKCcqJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgLy8gUmVtb3ZlIGFueSBjdXN0b20gZGF0YSBzZXQgYnkgU2VsZWN0MlxcbiAgICAgIFV0aWxzLlJlbW92ZURhdGEodGhpcyk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcXG4gICAgdmFyIGRhdGEgPSBbXTtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB2YXIgJG9wdGlvbnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCk7XFxuXFxuICAgICRvcHRpb25zLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciAkb3B0aW9uID0gJCh0aGlzKTtcXG5cXG4gICAgICBpZiAoISRvcHRpb24uaXMoJ29wdGlvbicpICYmICEkb3B0aW9uLmlzKCdvcHRncm91cCcpKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHZhciBvcHRpb24gPSBzZWxmLml0ZW0oJG9wdGlvbik7XFxuXFxuICAgICAgdmFyIG1hdGNoZXMgPSBzZWxmLm1hdGNoZXMocGFyYW1zLCBvcHRpb24pO1xcblxcbiAgICAgIGlmIChtYXRjaGVzICE9PSBudWxsKSB7XFxuICAgICAgICBkYXRhLnB1c2gobWF0Y2hlcyk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gICAgY2FsbGJhY2soe1xcbiAgICAgIHJlc3VsdHM6IGRhdGFcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuYWRkT3B0aW9ucyA9IGZ1bmN0aW9uICgkb3B0aW9ucykge1xcbiAgICBVdGlscy5hcHBlbmRNYW55KHRoaXMuJGVsZW1lbnQsICRvcHRpb25zKTtcXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAoZGF0YSkge1xcbiAgICB2YXIgb3B0aW9uO1xcblxcbiAgICBpZiAoZGF0YS5jaGlsZHJlbikge1xcbiAgICAgIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGdyb3VwJyk7XFxuICAgICAgb3B0aW9uLmxhYmVsID0gZGF0YS50ZXh0O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29wdGlvbicpO1xcblxcbiAgICAgIGlmIChvcHRpb24udGV4dENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgb3B0aW9uLnRleHRDb250ZW50ID0gZGF0YS50ZXh0O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvcHRpb24uaW5uZXJUZXh0ID0gZGF0YS50ZXh0O1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YS5pZCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgb3B0aW9uLnZhbHVlID0gZGF0YS5pZDtcXG4gICAgfVxcblxcbiAgICBpZiAoZGF0YS5kaXNhYmxlZCkge1xcbiAgICAgIG9wdGlvbi5kaXNhYmxlZCA9IHRydWU7XFxuICAgIH1cXG5cXG4gICAgaWYgKGRhdGEuc2VsZWN0ZWQpIHtcXG4gICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIGlmIChkYXRhLnRpdGxlKSB7XFxuICAgICAgb3B0aW9uLnRpdGxlID0gZGF0YS50aXRsZTtcXG4gICAgfVxcblxcbiAgICB2YXIgJG9wdGlvbiA9ICQob3B0aW9uKTtcXG5cXG4gICAgdmFyIG5vcm1hbGl6ZWREYXRhID0gdGhpcy5fbm9ybWFsaXplSXRlbShkYXRhKTtcXG4gICAgbm9ybWFsaXplZERhdGEuZWxlbWVudCA9IG9wdGlvbjtcXG5cXG4gICAgLy8gT3ZlcnJpZGUgdGhlIG9wdGlvbidzIGRhdGEgd2l0aCB0aGUgY29tYmluZWQgZGF0YVxcbiAgICBVdGlscy5TdG9yZURhdGEob3B0aW9uLCAnZGF0YScsIG5vcm1hbGl6ZWREYXRhKTtcXG5cXG4gICAgcmV0dXJuICRvcHRpb247XFxuICB9O1xcblxcbiAgU2VsZWN0QWRhcHRlci5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uICgkb3B0aW9uKSB7XFxuICAgIHZhciBkYXRhID0ge307XFxuXFxuICAgIGRhdGEgPSBVdGlscy5HZXREYXRhKCRvcHRpb25bMF0sICdkYXRhJyk7XFxuXFxuICAgIGlmIChkYXRhICE9IG51bGwpIHtcXG4gICAgICByZXR1cm4gZGF0YTtcXG4gICAgfVxcblxcbiAgICBpZiAoJG9wdGlvbi5pcygnb3B0aW9uJykpIHtcXG4gICAgICBkYXRhID0ge1xcbiAgICAgICAgaWQ6ICRvcHRpb24udmFsKCksXFxuICAgICAgICB0ZXh0OiAkb3B0aW9uLnRleHQoKSxcXG4gICAgICAgIGRpc2FibGVkOiAkb3B0aW9uLnByb3AoJ2Rpc2FibGVkJyksXFxuICAgICAgICBzZWxlY3RlZDogJG9wdGlvbi5wcm9wKCdzZWxlY3RlZCcpLFxcbiAgICAgICAgdGl0bGU6ICRvcHRpb24ucHJvcCgndGl0bGUnKVxcbiAgICAgIH07XFxuICAgIH0gZWxzZSBpZiAoJG9wdGlvbi5pcygnb3B0Z3JvdXAnKSkge1xcbiAgICAgIGRhdGEgPSB7XFxuICAgICAgICB0ZXh0OiAkb3B0aW9uLnByb3AoJ2xhYmVsJyksXFxuICAgICAgICBjaGlsZHJlbjogW10sXFxuICAgICAgICB0aXRsZTogJG9wdGlvbi5wcm9wKCd0aXRsZScpXFxuICAgICAgfTtcXG5cXG4gICAgICB2YXIgJGNoaWxkcmVuID0gJG9wdGlvbi5jaGlsZHJlbignb3B0aW9uJyk7XFxuICAgICAgdmFyIGNoaWxkcmVuID0gW107XFxuXFxuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCAkY2hpbGRyZW4ubGVuZ3RoOyBjKyspIHtcXG4gICAgICAgIHZhciAkY2hpbGQgPSAkKCRjaGlsZHJlbltjXSk7XFxuXFxuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLml0ZW0oJGNoaWxkKTtcXG5cXG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICBkYXRhLmNoaWxkcmVuID0gY2hpbGRyZW47XFxuICAgIH1cXG5cXG4gICAgZGF0YSA9IHRoaXMuX25vcm1hbGl6ZUl0ZW0oZGF0YSk7XFxuICAgIGRhdGEuZWxlbWVudCA9ICRvcHRpb25bMF07XFxuXFxuICAgIFV0aWxzLlN0b3JlRGF0YSgkb3B0aW9uWzBdLCAnZGF0YScsIGRhdGEpO1xcblxcbiAgICByZXR1cm4gZGF0YTtcXG4gIH07XFxuXFxuICBTZWxlY3RBZGFwdGVyLnByb3RvdHlwZS5fbm9ybWFsaXplSXRlbSA9IGZ1bmN0aW9uIChpdGVtKSB7XFxuICAgIGlmIChpdGVtICE9PSBPYmplY3QoaXRlbSkpIHtcXG4gICAgICBpdGVtID0ge1xcbiAgICAgICAgaWQ6IGl0ZW0sXFxuICAgICAgICB0ZXh0OiBpdGVtXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICBpdGVtID0gJC5leHRlbmQoe30sIHtcXG4gICAgICB0ZXh0OiAnJ1xcbiAgICB9LCBpdGVtKTtcXG5cXG4gICAgdmFyIGRlZmF1bHRzID0ge1xcbiAgICAgIHNlbGVjdGVkOiBmYWxzZSxcXG4gICAgICBkaXNhYmxlZDogZmFsc2VcXG4gICAgfTtcXG5cXG4gICAgaWYgKGl0ZW0uaWQgIT0gbnVsbCkge1xcbiAgICAgIGl0ZW0uaWQgPSBpdGVtLmlkLnRvU3RyaW5nKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGl0ZW0udGV4dCAhPSBudWxsKSB7XFxuICAgICAgaXRlbS50ZXh0ID0gaXRlbS50ZXh0LnRvU3RyaW5nKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGl0ZW0uX3Jlc3VsdElkID09IG51bGwgJiYgaXRlbS5pZCAmJiB0aGlzLmNvbnRhaW5lciAhPSBudWxsKSB7XFxuICAgICAgaXRlbS5fcmVzdWx0SWQgPSB0aGlzLmdlbmVyYXRlUmVzdWx0SWQodGhpcy5jb250YWluZXIsIGl0ZW0pO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGl0ZW0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdEFkYXB0ZXIucHJvdG90eXBlLm1hdGNoZXMgPSBmdW5jdGlvbiAocGFyYW1zLCBkYXRhKSB7XFxuICAgIHZhciBtYXRjaGVyID0gdGhpcy5vcHRpb25zLmdldCgnbWF0Y2hlcicpO1xcblxcbiAgICByZXR1cm4gbWF0Y2hlcihwYXJhbXMsIGRhdGEpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBTZWxlY3RBZGFwdGVyO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL2FycmF5JyxbXFxuICAnLi9zZWxlY3QnLFxcbiAgJy4uL3V0aWxzJyxcXG4gICdqcXVlcnknXFxuXSwgZnVuY3Rpb24gKFNlbGVjdEFkYXB0ZXIsIFV0aWxzLCAkKSB7XFxuICBmdW5jdGlvbiBBcnJheUFkYXB0ZXIgKCRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHRoaXMuX2RhdGFUb0NvbnZlcnQgPSBvcHRpb25zLmdldCgnZGF0YScpIHx8IFtdO1xcblxcbiAgICBBcnJheUFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgVXRpbHMuRXh0ZW5kKEFycmF5QWRhcHRlciwgU2VsZWN0QWRhcHRlcik7XFxuXFxuICBBcnJheUFkYXB0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIEFycmF5QWRhcHRlci5fX3N1cGVyX18uYmluZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIHRoaXMuYWRkT3B0aW9ucyh0aGlzLmNvbnZlcnRUb09wdGlvbnModGhpcy5fZGF0YVRvQ29udmVydCkpO1xcbiAgfTtcXG5cXG4gIEFycmF5QWRhcHRlci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgdmFyICRvcHRpb24gPSB0aGlzLiRlbGVtZW50LmZpbmQoJ29wdGlvbicpLmZpbHRlcihmdW5jdGlvbiAoaSwgZWxtKSB7XFxuICAgICAgcmV0dXJuIGVsbS52YWx1ZSA9PSBkYXRhLmlkLnRvU3RyaW5nKCk7XFxuICAgIH0pO1xcblxcbiAgICBpZiAoJG9wdGlvbi5sZW5ndGggPT09IDApIHtcXG4gICAgICAkb3B0aW9uID0gdGhpcy5vcHRpb24oZGF0YSk7XFxuXFxuICAgICAgdGhpcy5hZGRPcHRpb25zKCRvcHRpb24pO1xcbiAgICB9XFxuXFxuICAgIEFycmF5QWRhcHRlci5fX3N1cGVyX18uc2VsZWN0LmNhbGwodGhpcywgZGF0YSk7XFxuICB9O1xcblxcbiAgQXJyYXlBZGFwdGVyLnByb3RvdHlwZS5jb252ZXJ0VG9PcHRpb25zID0gZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB2YXIgJGV4aXN0aW5nID0gdGhpcy4kZWxlbWVudC5maW5kKCdvcHRpb24nKTtcXG4gICAgdmFyIGV4aXN0aW5nSWRzID0gJGV4aXN0aW5nLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIHNlbGYuaXRlbSgkKHRoaXMpKS5pZDtcXG4gICAgfSkuZ2V0KCk7XFxuXFxuICAgIHZhciAkb3B0aW9ucyA9IFtdO1xcblxcbiAgICAvLyBGaWx0ZXIgb3V0IGFsbCBpdGVtcyBleGNlcHQgZm9yIHRoZSBvbmUgcGFzc2VkIGluIHRoZSBhcmd1bWVudFxcbiAgICBmdW5jdGlvbiBvbmx5SXRlbSAoaXRlbSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gJCh0aGlzKS52YWwoKSA9PSBpdGVtLmlkO1xcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkYXRhLmxlbmd0aDsgZCsrKSB7XFxuICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9ub3JtYWxpemVJdGVtKGRhdGFbZF0pO1xcblxcbiAgICAgIC8vIFNraXAgaXRlbXMgd2hpY2ggd2VyZSBwcmUtbG9hZGVkLCBvbmx5IG1lcmdlIHRoZSBkYXRhXFxuICAgICAgaWYgKCQuaW5BcnJheShpdGVtLmlkLCBleGlzdGluZ0lkcykgPj0gMCkge1xcbiAgICAgICAgdmFyICRleGlzdGluZ09wdGlvbiA9ICRleGlzdGluZy5maWx0ZXIob25seUl0ZW0oaXRlbSkpO1xcblxcbiAgICAgICAgdmFyIGV4aXN0aW5nRGF0YSA9IHRoaXMuaXRlbSgkZXhpc3RpbmdPcHRpb24pO1xcbiAgICAgICAgdmFyIG5ld0RhdGEgPSAkLmV4dGVuZCh0cnVlLCB7fSwgaXRlbSwgZXhpc3RpbmdEYXRhKTtcXG5cXG4gICAgICAgIHZhciAkbmV3T3B0aW9uID0gdGhpcy5vcHRpb24obmV3RGF0YSk7XFxuXFxuICAgICAgICAkZXhpc3RpbmdPcHRpb24ucmVwbGFjZVdpdGgoJG5ld09wdGlvbik7XFxuXFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyICRvcHRpb24gPSB0aGlzLm9wdGlvbihpdGVtKTtcXG5cXG4gICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xcbiAgICAgICAgdmFyICRjaGlsZHJlbiA9IHRoaXMuY29udmVydFRvT3B0aW9ucyhpdGVtLmNoaWxkcmVuKTtcXG5cXG4gICAgICAgIFV0aWxzLmFwcGVuZE1hbnkoJG9wdGlvbiwgJGNoaWxkcmVuKTtcXG4gICAgICB9XFxuXFxuICAgICAgJG9wdGlvbnMucHVzaCgkb3B0aW9uKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gJG9wdGlvbnM7XFxuICB9O1xcblxcbiAgcmV0dXJuIEFycmF5QWRhcHRlcjtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZGF0YS9hamF4JyxbXFxuICAnLi9hcnJheScsXFxuICAnLi4vdXRpbHMnLFxcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoQXJyYXlBZGFwdGVyLCBVdGlscywgJCkge1xcbiAgZnVuY3Rpb24gQWpheEFkYXB0ZXIgKCRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHRoaXMuYWpheE9wdGlvbnMgPSB0aGlzLl9hcHBseURlZmF1bHRzKG9wdGlvbnMuZ2V0KCdhamF4JykpO1xcblxcbiAgICBpZiAodGhpcy5hamF4T3B0aW9ucy5wcm9jZXNzUmVzdWx0cyAhPSBudWxsKSB7XFxuICAgICAgdGhpcy5wcm9jZXNzUmVzdWx0cyA9IHRoaXMuYWpheE9wdGlvbnMucHJvY2Vzc1Jlc3VsdHM7XFxuICAgIH1cXG5cXG4gICAgQWpheEFkYXB0ZXIuX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgVXRpbHMuRXh0ZW5kKEFqYXhBZGFwdGVyLCBBcnJheUFkYXB0ZXIpO1xcblxcbiAgQWpheEFkYXB0ZXIucHJvdG90eXBlLl9hcHBseURlZmF1bHRzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgdmFyIGRlZmF1bHRzID0ge1xcbiAgICAgIGRhdGE6IGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICAgIHJldHVybiAkLmV4dGVuZCh7fSwgcGFyYW1zLCB7XFxuICAgICAgICAgIHE6IHBhcmFtcy50ZXJtXFxuICAgICAgICB9KTtcXG4gICAgICB9LFxcbiAgICAgIHRyYW5zcG9ydDogZnVuY3Rpb24gKHBhcmFtcywgc3VjY2VzcywgZmFpbHVyZSkge1xcbiAgICAgICAgdmFyICRyZXF1ZXN0ID0gJC5hamF4KHBhcmFtcyk7XFxuXFxuICAgICAgICAkcmVxdWVzdC50aGVuKHN1Y2Nlc3MpO1xcbiAgICAgICAgJHJlcXVlc3QuZmFpbChmYWlsdXJlKTtcXG5cXG4gICAgICAgIHJldHVybiAkcmVxdWVzdDtcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIHJldHVybiAkLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xcbiAgfTtcXG5cXG4gIEFqYXhBZGFwdGVyLnByb3RvdHlwZS5wcm9jZXNzUmVzdWx0cyA9IGZ1bmN0aW9uIChyZXN1bHRzKSB7XFxuICAgIHJldHVybiByZXN1bHRzO1xcbiAgfTtcXG5cXG4gIEFqYXhBZGFwdGVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XFxuICAgIHZhciBtYXRjaGVzID0gW107XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgaWYgKHRoaXMuX3JlcXVlc3QgIT0gbnVsbCkge1xcbiAgICAgIC8vIEpTT05QIHJlcXVlc3RzIGNhbm5vdCBhbHdheXMgYmUgYWJvcnRlZFxcbiAgICAgIGlmICgkLmlzRnVuY3Rpb24odGhpcy5fcmVxdWVzdC5hYm9ydCkpIHtcXG4gICAgICAgIHRoaXMuX3JlcXVlc3QuYWJvcnQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XFxuICAgIH1cXG5cXG4gICAgdmFyIG9wdGlvbnMgPSAkLmV4dGVuZCh7XFxuICAgICAgdHlwZTogJ0dFVCdcXG4gICAgfSwgdGhpcy5hamF4T3B0aW9ucyk7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy51cmwgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBvcHRpb25zLnVybCA9IG9wdGlvbnMudXJsLmNhbGwodGhpcy4kZWxlbWVudCwgcGFyYW1zKTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIG9wdGlvbnMuZGF0YSA9IG9wdGlvbnMuZGF0YS5jYWxsKHRoaXMuJGVsZW1lbnQsIHBhcmFtcyk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gcmVxdWVzdCAoKSB7XFxuICAgICAgdmFyICRyZXF1ZXN0ID0gb3B0aW9ucy50cmFuc3BvcnQob3B0aW9ucywgZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHZhciByZXN1bHRzID0gc2VsZi5wcm9jZXNzUmVzdWx0cyhkYXRhLCBwYXJhbXMpO1xcblxcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5nZXQoJ2RlYnVnJykgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xcbiAgICAgICAgICAvLyBDaGVjayB0byBtYWtlIHN1cmUgdGhhdCB0aGUgcmVzcG9uc2UgaW5jbHVkZWQgYSBgcmVzdWx0c2Aga2V5LlxcbiAgICAgICAgICBpZiAoIXJlc3VsdHMgfHwgIXJlc3VsdHMucmVzdWx0cyB8fCAhJC5pc0FycmF5KHJlc3VsdHMucmVzdWx0cykpIHtcXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxcbiAgICAgICAgICAgICAgJ1NlbGVjdDI6IFRoZSBBSkFYIHJlc3VsdHMgZGlkIG5vdCByZXR1cm4gYW4gYXJyYXkgaW4gdGhlICcgK1xcbiAgICAgICAgICAgICAgJ2ByZXN1bHRzYCBrZXkgb2YgdGhlIHJlc3BvbnNlLidcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjYWxsYmFjayhyZXN1bHRzKTtcXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCBpZiBhIHJlcXVlc3Qgd2FzIGFib3J0ZWRcXG4gICAgICAgIC8vIE9ubHkgd29ya3MgaWYgdGhlIHRyYW5zcG9ydCBleHBvc2VzIGEgc3RhdHVzIHByb3BlcnR5XFxuICAgICAgICBpZiAoJ3N0YXR1cycgaW4gJHJlcXVlc3QgJiZcXG4gICAgICAgICAgICAoJHJlcXVlc3Quc3RhdHVzID09PSAwIHx8ICRyZXF1ZXN0LnN0YXR1cyA9PT0gJzAnKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6bWVzc2FnZScsIHtcXG4gICAgICAgICAgbWVzc2FnZTogJ2Vycm9yTG9hZGluZydcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcblxcbiAgICAgIHNlbGYuX3JlcXVlc3QgPSAkcmVxdWVzdDtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5hamF4T3B0aW9ucy5kZWxheSAmJiBwYXJhbXMudGVybSAhPSBudWxsKSB7XFxuICAgICAgaWYgKHRoaXMuX3F1ZXJ5VGltZW91dCkge1xcbiAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLl9xdWVyeVRpbWVvdXQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB0aGlzLl9xdWVyeVRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChyZXF1ZXN0LCB0aGlzLmFqYXhPcHRpb25zLmRlbGF5KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXF1ZXN0KCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICByZXR1cm4gQWpheEFkYXB0ZXI7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvdGFncycsW1xcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoJCkge1xcbiAgZnVuY3Rpb24gVGFncyAoZGVjb3JhdGVkLCAkZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICB2YXIgdGFncyA9IG9wdGlvbnMuZ2V0KCd0YWdzJyk7XFxuXFxuICAgIHZhciBjcmVhdGVUYWcgPSBvcHRpb25zLmdldCgnY3JlYXRlVGFnJyk7XFxuXFxuICAgIGlmIChjcmVhdGVUYWcgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHRoaXMuY3JlYXRlVGFnID0gY3JlYXRlVGFnO1xcbiAgICB9XFxuXFxuICAgIHZhciBpbnNlcnRUYWcgPSBvcHRpb25zLmdldCgnaW5zZXJ0VGFnJyk7XFxuXFxuICAgIGlmIChpbnNlcnRUYWcgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgdGhpcy5pbnNlcnRUYWcgPSBpbnNlcnRUYWc7XFxuICAgIH1cXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xcblxcbiAgICBpZiAoJC5pc0FycmF5KHRhZ3MpKSB7XFxuICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0YWdzLmxlbmd0aDsgdCsrKSB7XFxuICAgICAgICB2YXIgdGFnID0gdGFnc1t0XTtcXG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5fbm9ybWFsaXplSXRlbSh0YWcpO1xcblxcbiAgICAgICAgdmFyICRvcHRpb24gPSB0aGlzLm9wdGlvbihpdGVtKTtcXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXBwZW5kKCRvcHRpb24pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgVGFncy5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdGhpcy5fcmVtb3ZlT2xkVGFncygpO1xcblxcbiAgICBpZiAocGFyYW1zLnRlcm0gPT0gbnVsbCB8fCBwYXJhbXMucGFnZSAhPSBudWxsKSB7XFxuICAgICAgZGVjb3JhdGVkLmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHdyYXBwZXIgKG9iaiwgY2hpbGQpIHtcXG4gICAgICB2YXIgZGF0YSA9IG9iai5yZXN1bHRzO1xcblxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIG9wdGlvbiA9IGRhdGFbaV07XFxuXFxuICAgICAgICB2YXIgY2hlY2tDaGlsZHJlbiA9IChcXG4gICAgICAgICAgb3B0aW9uLmNoaWxkcmVuICE9IG51bGwgJiZcXG4gICAgICAgICAgIXdyYXBwZXIoe1xcbiAgICAgICAgICAgIHJlc3VsdHM6IG9wdGlvbi5jaGlsZHJlblxcbiAgICAgICAgICB9LCB0cnVlKVxcbiAgICAgICAgKTtcXG5cXG4gICAgICAgIHZhciBvcHRpb25UZXh0ID0gKG9wdGlvbi50ZXh0IHx8ICcnKS50b1VwcGVyQ2FzZSgpO1xcbiAgICAgICAgdmFyIHBhcmFtc1Rlcm0gPSAocGFyYW1zLnRlcm0gfHwgJycpLnRvVXBwZXJDYXNlKCk7XFxuXFxuICAgICAgICB2YXIgY2hlY2tUZXh0ID0gb3B0aW9uVGV4dCA9PT0gcGFyYW1zVGVybTtcXG5cXG4gICAgICAgIGlmIChjaGVja1RleHQgfHwgY2hlY2tDaGlsZHJlbikge1xcbiAgICAgICAgICBpZiAoY2hpbGQpIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgb2JqLmRhdGEgPSBkYXRhO1xcbiAgICAgICAgICBjYWxsYmFjayhvYmopO1xcblxcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjaGlsZCkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfVxcblxcbiAgICAgIHZhciB0YWcgPSBzZWxmLmNyZWF0ZVRhZyhwYXJhbXMpO1xcblxcbiAgICAgIGlmICh0YWcgIT0gbnVsbCkge1xcbiAgICAgICAgdmFyICRvcHRpb24gPSBzZWxmLm9wdGlvbih0YWcpO1xcbiAgICAgICAgJG9wdGlvbi5hdHRyKCdkYXRhLXNlbGVjdDItdGFnJywgdHJ1ZSk7XFxuXFxuICAgICAgICBzZWxmLmFkZE9wdGlvbnMoWyRvcHRpb25dKTtcXG5cXG4gICAgICAgIHNlbGYuaW5zZXJ0VGFnKGRhdGEsIHRhZyk7XFxuICAgICAgfVxcblxcbiAgICAgIG9iai5yZXN1bHRzID0gZGF0YTtcXG5cXG4gICAgICBjYWxsYmFjayhvYmopO1xcbiAgICB9XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcywgd3JhcHBlcik7XFxuICB9O1xcblxcbiAgVGFncy5wcm90b3R5cGUuY3JlYXRlVGFnID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zKSB7XFxuICAgIHZhciB0ZXJtID0gJC50cmltKHBhcmFtcy50ZXJtKTtcXG5cXG4gICAgaWYgKHRlcm0gPT09ICcnKSB7XFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHtcXG4gICAgICBpZDogdGVybSxcXG4gICAgICB0ZXh0OiB0ZXJtXFxuICAgIH07XFxuICB9O1xcblxcbiAgVGFncy5wcm90b3R5cGUuaW5zZXJ0VGFnID0gZnVuY3Rpb24gKF8sIGRhdGEsIHRhZykge1xcbiAgICBkYXRhLnVuc2hpZnQodGFnKTtcXG4gIH07XFxuXFxuICBUYWdzLnByb3RvdHlwZS5fcmVtb3ZlT2xkVGFncyA9IGZ1bmN0aW9uIChfKSB7XFxuICAgIHZhciAkb3B0aW9ucyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnb3B0aW9uW2RhdGEtc2VsZWN0Mi10YWddJyk7XFxuXFxuICAgICRvcHRpb25zLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgICQodGhpcykucmVtb3ZlKCk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIHJldHVybiBUYWdzO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL3Rva2VuaXplcicsW1xcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoJCkge1xcbiAgZnVuY3Rpb24gVG9rZW5pemVyIChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHZhciB0b2tlbml6ZXIgPSBvcHRpb25zLmdldCgndG9rZW5pemVyJyk7XFxuXFxuICAgIGlmICh0b2tlbml6ZXIgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHRoaXMudG9rZW5pemVyID0gdG9rZW5pemVyO1xcbiAgICB9XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zKTtcXG4gIH1cXG5cXG4gIFRva2VuaXplci5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBjb250YWluZXIsICRjb250YWluZXIpO1xcblxcbiAgICB0aGlzLiRzZWFyY2ggPSAgY29udGFpbmVyLmRyb3Bkb3duLiRzZWFyY2ggfHwgY29udGFpbmVyLnNlbGVjdGlvbi4kc2VhcmNoIHx8XFxuICAgICAgJGNvbnRhaW5lci5maW5kKCcuc2VsZWN0Mi1zZWFyY2hfX2ZpZWxkJyk7XFxuICB9O1xcblxcbiAgVG9rZW5pemVyLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICBmdW5jdGlvbiBjcmVhdGVBbmRTZWxlY3QgKGRhdGEpIHtcXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGRhdGEgb2JqZWN0IHNvIHdlIGNhbiB1c2UgaXQgZm9yIGNoZWNrc1xcbiAgICAgIHZhciBpdGVtID0gc2VsZi5fbm9ybWFsaXplSXRlbShkYXRhKTtcXG5cXG4gICAgICAvLyBDaGVjayBpZiB0aGUgZGF0YSBvYmplY3QgYWxyZWFkeSBleGlzdHMgYXMgYSB0YWdcXG4gICAgICAvLyBTZWxlY3QgaXQgaWYgaXQgZG9lc24ndFxcbiAgICAgIHZhciAkZXhpc3RpbmdPcHRpb25zID0gc2VsZi4kZWxlbWVudC5maW5kKCdvcHRpb24nKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuICQodGhpcykudmFsKCkgPT09IGl0ZW0uaWQ7XFxuICAgICAgfSk7XFxuXFxuICAgICAgLy8gSWYgYW4gZXhpc3Rpbmcgb3B0aW9uIHdhc24ndCBmb3VuZCBmb3IgaXQsIGNyZWF0ZSB0aGUgb3B0aW9uXFxuICAgICAgaWYgKCEkZXhpc3RpbmdPcHRpb25zLmxlbmd0aCkge1xcbiAgICAgICAgdmFyICRvcHRpb24gPSBzZWxmLm9wdGlvbihpdGVtKTtcXG4gICAgICAgICRvcHRpb24uYXR0cignZGF0YS1zZWxlY3QyLXRhZycsIHRydWUpO1xcblxcbiAgICAgICAgc2VsZi5fcmVtb3ZlT2xkVGFncygpO1xcbiAgICAgICAgc2VsZi5hZGRPcHRpb25zKFskb3B0aW9uXSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIFNlbGVjdCB0aGUgaXRlbSwgbm93IHRoYXQgd2Uga25vdyB0aGVyZSBpcyBhbiBvcHRpb24gZm9yIGl0XFxuICAgICAgc2VsZWN0KGl0ZW0pO1xcbiAgICB9XFxuXFxuICAgIGZ1bmN0aW9uIHNlbGVjdCAoZGF0YSkge1xcbiAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0Jywge1xcbiAgICAgICAgZGF0YTogZGF0YVxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHBhcmFtcy50ZXJtID0gcGFyYW1zLnRlcm0gfHwgJyc7XFxuXFxuICAgIHZhciB0b2tlbkRhdGEgPSB0aGlzLnRva2VuaXplcihwYXJhbXMsIHRoaXMub3B0aW9ucywgY3JlYXRlQW5kU2VsZWN0KTtcXG5cXG4gICAgaWYgKHRva2VuRGF0YS50ZXJtICE9PSBwYXJhbXMudGVybSkge1xcbiAgICAgIC8vIFJlcGxhY2UgdGhlIHNlYXJjaCB0ZXJtIGlmIHdlIGhhdmUgdGhlIHNlYXJjaCBib3hcXG4gICAgICBpZiAodGhpcy4kc2VhcmNoLmxlbmd0aCkge1xcbiAgICAgICAgdGhpcy4kc2VhcmNoLnZhbCh0b2tlbkRhdGEudGVybSk7XFxuICAgICAgICB0aGlzLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcXG4gICAgICB9XFxuXFxuICAgICAgcGFyYW1zLnRlcm0gPSB0b2tlbkRhdGEudGVybTtcXG4gICAgfVxcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcXG4gIH07XFxuXFxuICBUb2tlbml6ZXIucHJvdG90eXBlLnRva2VuaXplciA9IGZ1bmN0aW9uIChfLCBwYXJhbXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XFxuICAgIHZhciBzZXBhcmF0b3JzID0gb3B0aW9ucy5nZXQoJ3Rva2VuU2VwYXJhdG9ycycpIHx8IFtdO1xcbiAgICB2YXIgdGVybSA9IHBhcmFtcy50ZXJtO1xcbiAgICB2YXIgaSA9IDA7XFxuXFxuICAgIHZhciBjcmVhdGVUYWcgPSB0aGlzLmNyZWF0ZVRhZyB8fCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIGlkOiBwYXJhbXMudGVybSxcXG4gICAgICAgIHRleHQ6IHBhcmFtcy50ZXJtXFxuICAgICAgfTtcXG4gICAgfTtcXG5cXG4gICAgd2hpbGUgKGkgPCB0ZXJtLmxlbmd0aCkge1xcbiAgICAgIHZhciB0ZXJtQ2hhciA9IHRlcm1baV07XFxuXFxuICAgICAgaWYgKCQuaW5BcnJheSh0ZXJtQ2hhciwgc2VwYXJhdG9ycykgPT09IC0xKSB7XFxuICAgICAgICBpKys7XFxuXFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIHBhcnQgPSB0ZXJtLnN1YnN0cigwLCBpKTtcXG4gICAgICB2YXIgcGFydFBhcmFtcyA9ICQuZXh0ZW5kKHt9LCBwYXJhbXMsIHtcXG4gICAgICAgIHRlcm06IHBhcnRcXG4gICAgICB9KTtcXG5cXG4gICAgICB2YXIgZGF0YSA9IGNyZWF0ZVRhZyhwYXJ0UGFyYW1zKTtcXG5cXG4gICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XFxuICAgICAgICBpKys7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuXFxuICAgICAgY2FsbGJhY2soZGF0YSk7XFxuXFxuICAgICAgLy8gUmVzZXQgdGhlIHRlcm0gdG8gbm90IGluY2x1ZGUgdGhlIHRva2VuaXplZCBwb3J0aW9uXFxuICAgICAgdGVybSA9IHRlcm0uc3Vic3RyKGkgKyAxKSB8fCAnJztcXG4gICAgICBpID0gMDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4ge1xcbiAgICAgIHRlcm06IHRlcm1cXG4gICAgfTtcXG4gIH07XFxuXFxuICByZXR1cm4gVG9rZW5pemVyO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kYXRhL21pbmltdW1JbnB1dExlbmd0aCcsW1xcblxcbl0sIGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIE1pbmltdW1JbnB1dExlbmd0aCAoZGVjb3JhdGVkLCAkZSwgb3B0aW9ucykge1xcbiAgICB0aGlzLm1pbmltdW1JbnB1dExlbmd0aCA9IG9wdGlvbnMuZ2V0KCdtaW5pbXVtSW5wdXRMZW5ndGgnKTtcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGUsIG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgTWluaW11bUlucHV0TGVuZ3RoLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcywgY2FsbGJhY2spIHtcXG4gICAgcGFyYW1zLnRlcm0gPSBwYXJhbXMudGVybSB8fCAnJztcXG5cXG4gICAgaWYgKHBhcmFtcy50ZXJtLmxlbmd0aCA8IHRoaXMubWluaW11bUlucHV0TGVuZ3RoKSB7XFxuICAgICAgdGhpcy50cmlnZ2VyKCdyZXN1bHRzOm1lc3NhZ2UnLCB7XFxuICAgICAgICBtZXNzYWdlOiAnaW5wdXRUb29TaG9ydCcsXFxuICAgICAgICBhcmdzOiB7XFxuICAgICAgICAgIG1pbmltdW06IHRoaXMubWluaW11bUlucHV0TGVuZ3RoLFxcbiAgICAgICAgICBpbnB1dDogcGFyYW1zLnRlcm0sXFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zXFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xcbiAgfTtcXG5cXG4gIHJldHVybiBNaW5pbXVtSW5wdXRMZW5ndGg7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvbWF4aW11bUlucHV0TGVuZ3RoJyxbXFxuXFxuXSwgZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gTWF4aW11bUlucHV0TGVuZ3RoIChkZWNvcmF0ZWQsICRlLCBvcHRpb25zKSB7XFxuICAgIHRoaXMubWF4aW11bUlucHV0TGVuZ3RoID0gb3B0aW9ucy5nZXQoJ21heGltdW1JbnB1dExlbmd0aCcpO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZSwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBNYXhpbXVtSW5wdXRMZW5ndGgucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgcGFyYW1zLCBjYWxsYmFjaykge1xcbiAgICBwYXJhbXMudGVybSA9IHBhcmFtcy50ZXJtIHx8ICcnO1xcblxcbiAgICBpZiAodGhpcy5tYXhpbXVtSW5wdXRMZW5ndGggPiAwICYmXFxuICAgICAgICBwYXJhbXMudGVybS5sZW5ndGggPiB0aGlzLm1heGltdW1JbnB1dExlbmd0aCkge1xcbiAgICAgIHRoaXMudHJpZ2dlcigncmVzdWx0czptZXNzYWdlJywge1xcbiAgICAgICAgbWVzc2FnZTogJ2lucHV0VG9vTG9uZycsXFxuICAgICAgICBhcmdzOiB7XFxuICAgICAgICAgIG1heGltdW06IHRoaXMubWF4aW11bUlucHV0TGVuZ3RoLFxcbiAgICAgICAgICBpbnB1dDogcGFyYW1zLnRlcm0sXFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zXFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xcbiAgfTtcXG5cXG4gIHJldHVybiBNYXhpbXVtSW5wdXRMZW5ndGg7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2RhdGEvbWF4aW11bVNlbGVjdGlvbkxlbmd0aCcsW1xcblxcbl0sIGZ1bmN0aW9uICgpe1xcbiAgZnVuY3Rpb24gTWF4aW11bVNlbGVjdGlvbkxlbmd0aCAoZGVjb3JhdGVkLCAkZSwgb3B0aW9ucykge1xcbiAgICB0aGlzLm1heGltdW1TZWxlY3Rpb25MZW5ndGggPSBvcHRpb25zLmdldCgnbWF4aW11bVNlbGVjdGlvbkxlbmd0aCcpO1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZSwgb3B0aW9ucyk7XFxuICB9XFxuXFxuICBNYXhpbXVtU2VsZWN0aW9uTGVuZ3RoLnByb3RvdHlwZS5iaW5kID1cXG4gICAgZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgICAgY29udGFpbmVyLm9uKCdzZWxlY3QnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBzZWxmLl9jaGVja0lmTWF4aW11bVNlbGVjdGVkKCk7XFxuICAgICAgfSk7XFxuICB9O1xcblxcbiAgTWF4aW11bVNlbGVjdGlvbkxlbmd0aC5wcm90b3R5cGUucXVlcnkgPVxcbiAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBwYXJhbXMsIGNhbGxiYWNrKSB7XFxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuX2NoZWNrSWZNYXhpbXVtU2VsZWN0ZWQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZGVjb3JhdGVkLmNhbGwoc2VsZiwgcGFyYW1zLCBjYWxsYmFjayk7XFxuICAgICAgfSk7XFxuICB9O1xcblxcbiAgTWF4aW11bVNlbGVjdGlvbkxlbmd0aC5wcm90b3R5cGUuX2NoZWNrSWZNYXhpbXVtU2VsZWN0ZWQgPVxcbiAgICBmdW5jdGlvbiAoXywgc3VjY2Vzc0NhbGxiYWNrKSB7XFxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAgIHRoaXMuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcXG4gICAgICAgIHZhciBjb3VudCA9IGN1cnJlbnREYXRhICE9IG51bGwgPyBjdXJyZW50RGF0YS5sZW5ndGggOiAwO1xcbiAgICAgICAgaWYgKHNlbGYubWF4aW11bVNlbGVjdGlvbkxlbmd0aCA+IDAgJiZcXG4gICAgICAgICAgY291bnQgPj0gc2VsZi5tYXhpbXVtU2VsZWN0aW9uTGVuZ3RoKSB7XFxuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czptZXNzYWdlJywge1xcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdtYXhpbXVtU2VsZWN0ZWQnLFxcbiAgICAgICAgICAgIGFyZ3M6IHtcXG4gICAgICAgICAgICAgIG1heGltdW06IHNlbGYubWF4aW11bVNlbGVjdGlvbkxlbmd0aFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChzdWNjZXNzQ2FsbGJhY2spIHtcXG4gICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIE1heGltdW1TZWxlY3Rpb25MZW5ndGg7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duJyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uICgkLCBVdGlscykge1xcbiAgZnVuY3Rpb24gRHJvcGRvd24gKCRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcXG5cXG4gICAgRHJvcGRvd24uX19zdXBlcl9fLmNvbnN0cnVjdG9yLmNhbGwodGhpcyk7XFxuICB9XFxuXFxuICBVdGlscy5FeHRlbmQoRHJvcGRvd24sIFV0aWxzLk9ic2VydmFibGUpO1xcblxcbiAgRHJvcGRvd24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRkcm9wZG93biA9ICQoXFxuICAgICAgJzxzcGFuIGNsYXNzPVxcXCJzZWxlY3QyLWRyb3Bkb3duXFxcIj4nICtcXG4gICAgICAgICc8c3BhbiBjbGFzcz1cXFwic2VsZWN0Mi1yZXN1bHRzXFxcIj48L3NwYW4+JyArXFxuICAgICAgJzwvc3Bhbj4nXFxuICAgICk7XFxuXFxuICAgICRkcm9wZG93bi5hdHRyKCdkaXInLCB0aGlzLm9wdGlvbnMuZ2V0KCdkaXInKSk7XFxuXFxuICAgIHRoaXMuJGRyb3Bkb3duID0gJGRyb3Bkb3duO1xcblxcbiAgICByZXR1cm4gJGRyb3Bkb3duO1xcbiAgfTtcXG5cXG4gIERyb3Bkb3duLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKCkge1xcbiAgICAvLyBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3Nlc1xcbiAgfTtcXG5cXG4gIERyb3Bkb3duLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgkZHJvcGRvd24sICRjb250YWluZXIpIHtcXG4gICAgLy8gU2hvdWxkIGJlIGltcGxlbWVudGVkIGluIHN1YmNsYXNzZXNcXG4gIH07XFxuXFxuICBEcm9wZG93bi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gUmVtb3ZlIHRoZSBkcm9wZG93biBmcm9tIHRoZSBET01cXG4gICAgdGhpcy4kZHJvcGRvd24ucmVtb3ZlKCk7XFxuICB9O1xcblxcbiAgcmV0dXJuIERyb3Bkb3duO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9zZWFyY2gnLFtcXG4gICdqcXVlcnknLFxcbiAgJy4uL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uICgkLCBVdGlscykge1xcbiAgZnVuY3Rpb24gU2VhcmNoICgpIHsgfVxcblxcbiAgU2VhcmNoLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XFxuICAgIHZhciAkcmVuZGVyZWQgPSBkZWNvcmF0ZWQuY2FsbCh0aGlzKTtcXG5cXG4gICAgdmFyICRzZWFyY2ggPSAkKFxcbiAgICAgICc8c3BhbiBjbGFzcz1cXFwic2VsZWN0Mi1zZWFyY2ggc2VsZWN0Mi1zZWFyY2gtLWRyb3Bkb3duXFxcIj4nICtcXG4gICAgICAgICc8aW5wdXQgY2xhc3M9XFxcInNlbGVjdDItc2VhcmNoX19maWVsZFxcXCIgdHlwZT1cXFwic2VhcmNoXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiJyArXFxuICAgICAgICAnIGF1dG9jb21wbGV0ZT1cXFwib2ZmXFxcIiBhdXRvY29ycmVjdD1cXFwib2ZmXFxcIiBhdXRvY2FwaXRhbGl6ZT1cXFwibm9uZVxcXCInICtcXG4gICAgICAgICcgc3BlbGxjaGVjaz1cXFwiZmFsc2VcXFwiIHJvbGU9XFxcInNlYXJjaGJveFxcXCIgYXJpYS1hdXRvY29tcGxldGU9XFxcImxpc3RcXFwiIC8+JyArXFxuICAgICAgJzwvc3Bhbj4nXFxuICAgICk7XFxuXFxuICAgIHRoaXMuJHNlYXJjaENvbnRhaW5lciA9ICRzZWFyY2g7XFxuICAgIHRoaXMuJHNlYXJjaCA9ICRzZWFyY2guZmluZCgnaW5wdXQnKTtcXG5cXG4gICAgJHJlbmRlcmVkLnByZXBlbmQoJHNlYXJjaCk7XFxuXFxuICAgIHJldHVybiAkcmVuZGVyZWQ7XFxuICB9O1xcblxcbiAgU2VhcmNoLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgdmFyIHJlc3VsdHNJZCA9IGNvbnRhaW5lci5pZCArICctcmVzdWx0cyc7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIHRoaXMuJHNlYXJjaC5vbigna2V5ZG93bicsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBzZWxmLnRyaWdnZXIoJ2tleXByZXNzJywgZXZ0KTtcXG5cXG4gICAgICBzZWxmLl9rZXlVcFByZXZlbnRlZCA9IGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcXG4gICAgfSk7XFxuXFxuICAgIC8vIFdvcmthcm91bmQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvIG5vdCBzdXBwb3J0IHRoZSBgaW5wdXRgIGV2ZW50XFxuICAgIC8vIFRoaXMgd2lsbCBwcmV2ZW50IGRvdWJsZS10cmlnZ2VyaW5nIG9mIGV2ZW50cyBmb3IgYnJvd3NlcnMgd2hpY2ggc3VwcG9ydFxcbiAgICAvLyBib3RoIHRoZSBga2V5dXBgIGFuZCBgaW5wdXRgIGV2ZW50cy5cXG4gICAgdGhpcy4kc2VhcmNoLm9uKCdpbnB1dCcsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICAvLyBVbmJpbmQgdGhlIGR1cGxpY2F0ZWQgYGtleXVwYCBldmVudFxcbiAgICAgICQodGhpcykub2ZmKCdrZXl1cCcpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kc2VhcmNoLm9uKCdrZXl1cCBpbnB1dCcsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBzZWxmLmhhbmRsZVNlYXJjaChldnQpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdvcGVuJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCd0YWJpbmRleCcsIDApO1xcbiAgICAgIHNlbGYuJHNlYXJjaC5hdHRyKCdhcmlhLWNvbnRyb2xzJywgcmVzdWx0c0lkKTtcXG5cXG4gICAgICBzZWxmLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcXG5cXG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBzZWxmLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcXG4gICAgICB9LCAwKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kc2VhcmNoLmF0dHIoJ3RhYmluZGV4JywgLTEpO1xcbiAgICAgIHNlbGYuJHNlYXJjaC5yZW1vdmVBdHRyKCdhcmlhLWNvbnRyb2xzJyk7XFxuICAgICAgc2VsZi4kc2VhcmNoLnJlbW92ZUF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpO1xcblxcbiAgICAgIHNlbGYuJHNlYXJjaC52YWwoJycpO1xcbiAgICAgIHNlbGYuJHNlYXJjaC50cmlnZ2VyKCdibHVyJyk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2ZvY3VzJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIGlmICghY29udGFpbmVyLmlzT3BlbigpKSB7XFxuICAgICAgICBzZWxmLiRzZWFyY2gudHJpZ2dlcignZm9jdXMnKTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6YWxsJywgZnVuY3Rpb24gKHBhcmFtcykge1xcbiAgICAgIGlmIChwYXJhbXMucXVlcnkudGVybSA9PSBudWxsIHx8IHBhcmFtcy5xdWVyeS50ZXJtID09PSAnJykge1xcbiAgICAgICAgdmFyIHNob3dTZWFyY2ggPSBzZWxmLnNob3dTZWFyY2gocGFyYW1zKTtcXG5cXG4gICAgICAgIGlmIChzaG93U2VhcmNoKSB7XFxuICAgICAgICAgIHNlbGYuJHNlYXJjaENvbnRhaW5lci5yZW1vdmVDbGFzcygnc2VsZWN0Mi1zZWFyY2gtLWhpZGUnKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNlbGYuJHNlYXJjaENvbnRhaW5lci5hZGRDbGFzcygnc2VsZWN0Mi1zZWFyY2gtLWhpZGUnKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6Zm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgaWYgKHBhcmFtcy5kYXRhLl9yZXN1bHRJZCkge1xcbiAgICAgICAgc2VsZi4kc2VhcmNoLmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIHBhcmFtcy5kYXRhLl9yZXN1bHRJZCk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHNlbGYuJHNlYXJjaC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlYXJjaC5wcm90b3R5cGUuaGFuZGxlU2VhcmNoID0gZnVuY3Rpb24gKGV2dCkge1xcbiAgICBpZiAoIXRoaXMuX2tleVVwUHJldmVudGVkKSB7XFxuICAgICAgdmFyIGlucHV0ID0gdGhpcy4kc2VhcmNoLnZhbCgpO1xcblxcbiAgICAgIHRoaXMudHJpZ2dlcigncXVlcnknLCB7XFxuICAgICAgICB0ZXJtOiBpbnB1dFxcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuX2tleVVwUHJldmVudGVkID0gZmFsc2U7XFxuICB9O1xcblxcbiAgU2VhcmNoLnByb3RvdHlwZS5zaG93U2VhcmNoID0gZnVuY3Rpb24gKF8sIHBhcmFtcykge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH07XFxuXFxuICByZXR1cm4gU2VhcmNoO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9oaWRlUGxhY2Vob2xkZXInLFtcXG5cXG5dLCBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBIaWRlUGxhY2Vob2xkZXIgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKSB7XFxuICAgIHRoaXMucGxhY2Vob2xkZXIgPSB0aGlzLm5vcm1hbGl6ZVBsYWNlaG9sZGVyKG9wdGlvbnMuZ2V0KCdwbGFjZWhvbGRlcicpKTtcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKTtcXG4gIH1cXG5cXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgZGF0YSkge1xcbiAgICBkYXRhLnJlc3VsdHMgPSB0aGlzLnJlbW92ZVBsYWNlaG9sZGVyKGRhdGEucmVzdWx0cyk7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xcbiAgfTtcXG5cXG4gIEhpZGVQbGFjZWhvbGRlci5wcm90b3R5cGUubm9ybWFsaXplUGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAoXywgcGxhY2Vob2xkZXIpIHtcXG4gICAgaWYgKHR5cGVvZiBwbGFjZWhvbGRlciA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBwbGFjZWhvbGRlciA9IHtcXG4gICAgICAgIGlkOiAnJyxcXG4gICAgICAgIHRleHQ6IHBsYWNlaG9sZGVyXFxuICAgICAgfTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcGxhY2Vob2xkZXI7XFxuICB9O1xcblxcbiAgSGlkZVBsYWNlaG9sZGVyLnByb3RvdHlwZS5yZW1vdmVQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChfLCBkYXRhKSB7XFxuICAgIHZhciBtb2RpZmllZERhdGEgPSBkYXRhLnNsaWNlKDApO1xcblxcbiAgICBmb3IgKHZhciBkID0gZGF0YS5sZW5ndGggLSAxOyBkID49IDA7IGQtLSkge1xcbiAgICAgIHZhciBpdGVtID0gZGF0YVtkXTtcXG5cXG4gICAgICBpZiAodGhpcy5wbGFjZWhvbGRlci5pZCA9PT0gaXRlbS5pZCkge1xcbiAgICAgICAgbW9kaWZpZWREYXRhLnNwbGljZShkLCAxKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG1vZGlmaWVkRGF0YTtcXG4gIH07XFxuXFxuICByZXR1cm4gSGlkZVBsYWNlaG9sZGVyO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9pbmZpbml0ZVNjcm9sbCcsW1xcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoJCkge1xcbiAgZnVuY3Rpb24gSW5maW5pdGVTY3JvbGwgKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKSB7XFxuICAgIHRoaXMubGFzdFBhcmFtcyA9IHt9O1xcblxcbiAgICBkZWNvcmF0ZWQuY2FsbCh0aGlzLCAkZWxlbWVudCwgb3B0aW9ucywgZGF0YUFkYXB0ZXIpO1xcblxcbiAgICB0aGlzLiRsb2FkaW5nTW9yZSA9IHRoaXMuY3JlYXRlTG9hZGluZ01vcmUoKTtcXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XFxuICB9XFxuXFxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgZGF0YSkge1xcbiAgICB0aGlzLiRsb2FkaW5nTW9yZS5yZW1vdmUoKTtcXG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGRhdGEpO1xcblxcbiAgICBpZiAodGhpcy5zaG93TG9hZGluZ01vcmUoZGF0YSkpIHtcXG4gICAgICB0aGlzLiRyZXN1bHRzLmFwcGVuZCh0aGlzLiRsb2FkaW5nTW9yZSk7XFxuICAgICAgdGhpcy5sb2FkTW9yZUlmTmVlZGVkKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncXVlcnknLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgc2VsZi5sYXN0UGFyYW1zID0gcGFyYW1zO1xcbiAgICAgIHNlbGYubG9hZGluZyA9IHRydWU7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3F1ZXJ5OmFwcGVuZCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLmxhc3RQYXJhbXMgPSBwYXJhbXM7XFxuICAgICAgc2VsZi5sb2FkaW5nID0gdHJ1ZTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuJHJlc3VsdHMub24oJ3Njcm9sbCcsIHRoaXMubG9hZE1vcmVJZk5lZWRlZC5iaW5kKHRoaXMpKTtcXG4gIH07XFxuXFxuICBJbmZpbml0ZVNjcm9sbC5wcm90b3R5cGUubG9hZE1vcmVJZk5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGlzTG9hZE1vcmVWaXNpYmxlID0gJC5jb250YWlucyhcXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXFxuICAgICAgdGhpcy4kbG9hZGluZ01vcmVbMF1cXG4gICAgKTtcXG5cXG4gICAgaWYgKHRoaXMubG9hZGluZyB8fCAhaXNMb2FkTW9yZVZpc2libGUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB0aGlzLiRyZXN1bHRzLm9mZnNldCgpLnRvcCArXFxuICAgICAgdGhpcy4kcmVzdWx0cy5vdXRlckhlaWdodChmYWxzZSk7XFxuICAgIHZhciBsb2FkaW5nTW9yZU9mZnNldCA9IHRoaXMuJGxvYWRpbmdNb3JlLm9mZnNldCgpLnRvcCArXFxuICAgICAgdGhpcy4kbG9hZGluZ01vcmUub3V0ZXJIZWlnaHQoZmFsc2UpO1xcblxcbiAgICBpZiAoY3VycmVudE9mZnNldCArIDUwID49IGxvYWRpbmdNb3JlT2Zmc2V0KSB7XFxuICAgICAgdGhpcy5sb2FkTW9yZSgpO1xcbiAgICB9XFxuICB9O1xcblxcbiAgSW5maW5pdGVTY3JvbGwucHJvdG90eXBlLmxvYWRNb3JlID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xcblxcbiAgICB2YXIgcGFyYW1zID0gJC5leHRlbmQoe30sIHtwYWdlOiAxfSwgdGhpcy5sYXN0UGFyYW1zKTtcXG5cXG4gICAgcGFyYW1zLnBhZ2UrKztcXG5cXG4gICAgdGhpcy50cmlnZ2VyKCdxdWVyeTphcHBlbmQnLCBwYXJhbXMpO1xcbiAgfTtcXG5cXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5zaG93TG9hZGluZ01vcmUgPSBmdW5jdGlvbiAoXywgZGF0YSkge1xcbiAgICByZXR1cm4gZGF0YS5wYWdpbmF0aW9uICYmIGRhdGEucGFnaW5hdGlvbi5tb3JlO1xcbiAgfTtcXG5cXG4gIEluZmluaXRlU2Nyb2xsLnByb3RvdHlwZS5jcmVhdGVMb2FkaW5nTW9yZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRvcHRpb24gPSAkKFxcbiAgICAgICc8bGkgJyArXFxuICAgICAgJ2NsYXNzPVxcXCJzZWxlY3QyLXJlc3VsdHNfX29wdGlvbiBzZWxlY3QyLXJlc3VsdHNfX29wdGlvbi0tbG9hZC1tb3JlXFxcIicgK1xcbiAgICAgICdyb2xlPVxcXCJvcHRpb25cXFwiIGFyaWEtZGlzYWJsZWQ9XFxcInRydWVcXFwiPjwvbGk+J1xcbiAgICApO1xcblxcbiAgICB2YXIgbWVzc2FnZSA9IHRoaXMub3B0aW9ucy5nZXQoJ3RyYW5zbGF0aW9ucycpLmdldCgnbG9hZGluZ01vcmUnKTtcXG5cXG4gICAgJG9wdGlvbi5odG1sKG1lc3NhZ2UodGhpcy5sYXN0UGFyYW1zKSk7XFxuXFxuICAgIHJldHVybiAkb3B0aW9uO1xcbiAgfTtcXG5cXG4gIHJldHVybiBJbmZpbml0ZVNjcm9sbDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvZHJvcGRvd24vYXR0YWNoQm9keScsW1xcbiAgJ2pxdWVyeScsXFxuICAnLi4vdXRpbHMnXFxuXSwgZnVuY3Rpb24gKCQsIFV0aWxzKSB7XFxuICBmdW5jdGlvbiBBdHRhY2hCb2R5IChkZWNvcmF0ZWQsICRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIHRoaXMuJGRyb3Bkb3duUGFyZW50ID0gJChvcHRpb25zLmdldCgnZHJvcGRvd25QYXJlbnQnKSB8fCBkb2N1bWVudC5ib2R5KTtcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgJGVsZW1lbnQsIG9wdGlvbnMpO1xcbiAgfVxcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIGNvbnRhaW5lci5vbignb3BlbicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLl9zaG93RHJvcGRvd24oKTtcXG4gICAgICBzZWxmLl9hdHRhY2hQb3NpdGlvbmluZ0hhbmRsZXIoY29udGFpbmVyKTtcXG5cXG4gICAgICAvLyBNdXN0IGJpbmQgYWZ0ZXIgdGhlIHJlc3VsdHMgaGFuZGxlcnMgdG8gZW5zdXJlIGNvcnJlY3Qgc2l6aW5nXFxuICAgICAgc2VsZi5fYmluZENvbnRhaW5lclJlc3VsdEhhbmRsZXJzKGNvbnRhaW5lcik7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuX2hpZGVEcm9wZG93bigpO1xcbiAgICAgIHNlbGYuX2RldGFjaFBvc2l0aW9uaW5nSGFuZGxlcihjb250YWluZXIpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIub24oJ21vdXNlZG93bicsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMpO1xcblxcbiAgICB0aGlzLiRkcm9wZG93bkNvbnRhaW5lci5yZW1vdmUoKTtcXG4gIH07XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsICRkcm9wZG93biwgJGNvbnRhaW5lcikge1xcbiAgICAvLyBDbG9uZSBhbGwgb2YgdGhlIGNvbnRhaW5lciBjbGFzc2VzXFxuICAgICRkcm9wZG93bi5hdHRyKCdjbGFzcycsICRjb250YWluZXIuYXR0cignY2xhc3MnKSk7XFxuXFxuICAgICRkcm9wZG93bi5yZW1vdmVDbGFzcygnc2VsZWN0MicpO1xcbiAgICAkZHJvcGRvd24uYWRkQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1vcGVuJyk7XFxuXFxuICAgICRkcm9wZG93bi5jc3Moe1xcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxcbiAgICAgIHRvcDogLTk5OTk5OVxcbiAgICB9KTtcXG5cXG4gICAgdGhpcy4kY29udGFpbmVyID0gJGNvbnRhaW5lcjtcXG4gIH07XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XFxuICAgIHZhciAkY29udGFpbmVyID0gJCgnPHNwYW4+PC9zcGFuPicpO1xcblxcbiAgICB2YXIgJGRyb3Bkb3duID0gZGVjb3JhdGVkLmNhbGwodGhpcyk7XFxuICAgICRjb250YWluZXIuYXBwZW5kKCRkcm9wZG93bik7XFxuXFxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyID0gJGNvbnRhaW5lcjtcXG5cXG4gICAgcmV0dXJuICRjb250YWluZXI7XFxuICB9O1xcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX2hpZGVEcm9wZG93biA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQpIHtcXG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIuZGV0YWNoKCk7XFxuICB9O1xcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX2JpbmRDb250YWluZXJSZXN1bHRIYW5kbGVycyA9XFxuICAgICAgZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyKSB7XFxuXFxuICAgIC8vIFRoZXNlIHNob3VsZCBvbmx5IGJlIGJvdW5kIG9uY2VcXG4gICAgaWYgKHRoaXMuX2NvbnRhaW5lclJlc3VsdHNIYW5kbGVyc0JvdW5kKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgY29udGFpbmVyLm9uKCdyZXN1bHRzOmFsbCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XFxuICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbigncmVzdWx0czphcHBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi5fcG9zaXRpb25Ecm9wZG93bigpO1xcbiAgICAgIHNlbGYuX3Jlc2l6ZURyb3Bkb3duKCk7XFxuICAgIH0pO1xcblxcbiAgICBjb250YWluZXIub24oJ3Jlc3VsdHM6bWVzc2FnZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XFxuICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuX3Bvc2l0aW9uRHJvcGRvd24oKTtcXG4gICAgICBzZWxmLl9yZXNpemVEcm9wZG93bigpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCd1bnNlbGVjdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XFxuICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMuX2NvbnRhaW5lclJlc3VsdHNIYW5kbGVyc0JvdW5kID0gdHJ1ZTtcXG4gIH07XFxuXFxuICBBdHRhY2hCb2R5LnByb3RvdHlwZS5fYXR0YWNoUG9zaXRpb25pbmdIYW5kbGVyID1cXG4gICAgICBmdW5jdGlvbiAoZGVjb3JhdGVkLCBjb250YWluZXIpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB2YXIgc2Nyb2xsRXZlbnQgPSAnc2Nyb2xsLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcXG4gICAgdmFyIHJlc2l6ZUV2ZW50ID0gJ3Jlc2l6ZS5zZWxlY3QyLicgKyBjb250YWluZXIuaWQ7XFxuICAgIHZhciBvcmllbnRhdGlvbkV2ZW50ID0gJ29yaWVudGF0aW9uY2hhbmdlLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcXG5cXG4gICAgdmFyICR3YXRjaGVycyA9IHRoaXMuJGNvbnRhaW5lci5wYXJlbnRzKCkuZmlsdGVyKFV0aWxzLmhhc1Njcm9sbCk7XFxuICAgICR3YXRjaGVycy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICBVdGlscy5TdG9yZURhdGEodGhpcywgJ3NlbGVjdDItc2Nyb2xsLXBvc2l0aW9uJywge1xcbiAgICAgICAgeDogJCh0aGlzKS5zY3JvbGxMZWZ0KCksXFxuICAgICAgICB5OiAkKHRoaXMpLnNjcm9sbFRvcCgpXFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICAkd2F0Y2hlcnMub24oc2Nyb2xsRXZlbnQsIGZ1bmN0aW9uIChldikge1xcbiAgICAgIHZhciBwb3NpdGlvbiA9IFV0aWxzLkdldERhdGEodGhpcywgJ3NlbGVjdDItc2Nyb2xsLXBvc2l0aW9uJyk7XFxuICAgICAgJCh0aGlzKS5zY3JvbGxUb3AocG9zaXRpb24ueSk7XFxuICAgIH0pO1xcblxcbiAgICAkKHdpbmRvdykub24oc2Nyb2xsRXZlbnQgKyAnICcgKyByZXNpemVFdmVudCArICcgJyArIG9yaWVudGF0aW9uRXZlbnQsXFxuICAgICAgZnVuY3Rpb24gKGUpIHtcXG4gICAgICBzZWxmLl9wb3NpdGlvbkRyb3Bkb3duKCk7XFxuICAgICAgc2VsZi5fcmVzaXplRHJvcGRvd24oKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX2RldGFjaFBvc2l0aW9uaW5nSGFuZGxlciA9XFxuICAgICAgZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyKSB7XFxuICAgIHZhciBzY3JvbGxFdmVudCA9ICdzY3JvbGwuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xcbiAgICB2YXIgcmVzaXplRXZlbnQgPSAncmVzaXplLnNlbGVjdDIuJyArIGNvbnRhaW5lci5pZDtcXG4gICAgdmFyIG9yaWVudGF0aW9uRXZlbnQgPSAnb3JpZW50YXRpb25jaGFuZ2Uuc2VsZWN0Mi4nICsgY29udGFpbmVyLmlkO1xcblxcbiAgICB2YXIgJHdhdGNoZXJzID0gdGhpcy4kY29udGFpbmVyLnBhcmVudHMoKS5maWx0ZXIoVXRpbHMuaGFzU2Nyb2xsKTtcXG4gICAgJHdhdGNoZXJzLm9mZihzY3JvbGxFdmVudCk7XFxuXFxuICAgICQod2luZG93KS5vZmYoc2Nyb2xsRXZlbnQgKyAnICcgKyByZXNpemVFdmVudCArICcgJyArIG9yaWVudGF0aW9uRXZlbnQpO1xcbiAgfTtcXG5cXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9wb3NpdGlvbkRyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgJHdpbmRvdyA9ICQod2luZG93KTtcXG5cXG4gICAgdmFyIGlzQ3VycmVudGx5QWJvdmUgPSB0aGlzLiRkcm9wZG93bi5oYXNDbGFzcygnc2VsZWN0Mi1kcm9wZG93bi0tYWJvdmUnKTtcXG4gICAgdmFyIGlzQ3VycmVudGx5QmVsb3cgPSB0aGlzLiRkcm9wZG93bi5oYXNDbGFzcygnc2VsZWN0Mi1kcm9wZG93bi0tYmVsb3cnKTtcXG5cXG4gICAgdmFyIG5ld0RpcmVjdGlvbiA9IG51bGw7XFxuXFxuICAgIHZhciBvZmZzZXQgPSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCk7XFxuXFxuICAgIG9mZnNldC5ib3R0b20gPSBvZmZzZXQudG9wICsgdGhpcy4kY29udGFpbmVyLm91dGVySGVpZ2h0KGZhbHNlKTtcXG5cXG4gICAgdmFyIGNvbnRhaW5lciA9IHtcXG4gICAgICBoZWlnaHQ6IHRoaXMuJGNvbnRhaW5lci5vdXRlckhlaWdodChmYWxzZSlcXG4gICAgfTtcXG5cXG4gICAgY29udGFpbmVyLnRvcCA9IG9mZnNldC50b3A7XFxuICAgIGNvbnRhaW5lci5ib3R0b20gPSBvZmZzZXQudG9wICsgY29udGFpbmVyLmhlaWdodDtcXG5cXG4gICAgdmFyIGRyb3Bkb3duID0ge1xcbiAgICAgIGhlaWdodDogdGhpcy4kZHJvcGRvd24ub3V0ZXJIZWlnaHQoZmFsc2UpXFxuICAgIH07XFxuXFxuICAgIHZhciB2aWV3cG9ydCA9IHtcXG4gICAgICB0b3A6ICR3aW5kb3cuc2Nyb2xsVG9wKCksXFxuICAgICAgYm90dG9tOiAkd2luZG93LnNjcm9sbFRvcCgpICsgJHdpbmRvdy5oZWlnaHQoKVxcbiAgICB9O1xcblxcbiAgICB2YXIgZW5vdWdoUm9vbUFib3ZlID0gdmlld3BvcnQudG9wIDwgKG9mZnNldC50b3AgLSBkcm9wZG93bi5oZWlnaHQpO1xcbiAgICB2YXIgZW5vdWdoUm9vbUJlbG93ID0gdmlld3BvcnQuYm90dG9tID4gKG9mZnNldC5ib3R0b20gKyBkcm9wZG93bi5oZWlnaHQpO1xcblxcbiAgICB2YXIgY3NzID0ge1xcbiAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0LFxcbiAgICAgIHRvcDogY29udGFpbmVyLmJvdHRvbVxcbiAgICB9O1xcblxcbiAgICAvLyBEZXRlcm1pbmUgd2hhdCB0aGUgcGFyZW50IGVsZW1lbnQgaXMgdG8gdXNlIGZvciBjYWxjdWxhdGluZyB0aGUgb2Zmc2V0XFxuICAgIHZhciAkb2Zmc2V0UGFyZW50ID0gdGhpcy4kZHJvcGRvd25QYXJlbnQ7XFxuXFxuICAgIC8vIEZvciBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudHMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBlbGVtZW50XFxuICAgIC8vIHRoYXQgaXMgZGV0ZXJtaW5pbmcgdGhlIG9mZnNldFxcbiAgICBpZiAoJG9mZnNldFBhcmVudC5jc3MoJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XFxuICAgICAgJG9mZnNldFBhcmVudCA9ICRvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50KCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIHBhcmVudE9mZnNldCA9IHtcXG4gICAgICB0b3A6IDAsXFxuICAgICAgbGVmdDogMFxcbiAgICB9O1xcblxcbiAgICBpZiAoXFxuICAgICAgJC5jb250YWlucyhkb2N1bWVudC5ib2R5LCAkb2Zmc2V0UGFyZW50WzBdKSB8fFxcbiAgICAgICRvZmZzZXRQYXJlbnRbMF0uaXNDb25uZWN0ZWRcXG4gICAgICApIHtcXG4gICAgICBwYXJlbnRPZmZzZXQgPSAkb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xcbiAgICB9XFxuXFxuICAgIGNzcy50b3AgLT0gcGFyZW50T2Zmc2V0LnRvcDtcXG4gICAgY3NzLmxlZnQgLT0gcGFyZW50T2Zmc2V0LmxlZnQ7XFxuXFxuICAgIGlmICghaXNDdXJyZW50bHlBYm92ZSAmJiAhaXNDdXJyZW50bHlCZWxvdykge1xcbiAgICAgIG5ld0RpcmVjdGlvbiA9ICdiZWxvdyc7XFxuICAgIH1cXG5cXG4gICAgaWYgKCFlbm91Z2hSb29tQmVsb3cgJiYgZW5vdWdoUm9vbUFib3ZlICYmICFpc0N1cnJlbnRseUFib3ZlKSB7XFxuICAgICAgbmV3RGlyZWN0aW9uID0gJ2Fib3ZlJztcXG4gICAgfSBlbHNlIGlmICghZW5vdWdoUm9vbUFib3ZlICYmIGVub3VnaFJvb21CZWxvdyAmJiBpc0N1cnJlbnRseUFib3ZlKSB7XFxuICAgICAgbmV3RGlyZWN0aW9uID0gJ2JlbG93JztcXG4gICAgfVxcblxcbiAgICBpZiAobmV3RGlyZWN0aW9uID09ICdhYm92ZScgfHxcXG4gICAgICAoaXNDdXJyZW50bHlBYm92ZSAmJiBuZXdEaXJlY3Rpb24gIT09ICdiZWxvdycpKSB7XFxuICAgICAgY3NzLnRvcCA9IGNvbnRhaW5lci50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0gZHJvcGRvd24uaGVpZ2h0O1xcbiAgICB9XFxuXFxuICAgIGlmIChuZXdEaXJlY3Rpb24gIT0gbnVsbCkge1xcbiAgICAgIHRoaXMuJGRyb3Bkb3duXFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItZHJvcGRvd24tLWJlbG93IHNlbGVjdDItZHJvcGRvd24tLWFib3ZlJylcXG4gICAgICAgIC5hZGRDbGFzcygnc2VsZWN0Mi1kcm9wZG93bi0tJyArIG5ld0RpcmVjdGlvbik7XFxuICAgICAgdGhpcy4kY29udGFpbmVyXFxuICAgICAgICAucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItY29udGFpbmVyLS1iZWxvdyBzZWxlY3QyLWNvbnRhaW5lci0tYWJvdmUnKVxcbiAgICAgICAgLmFkZENsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tJyArIG5ld0RpcmVjdGlvbik7XFxuICAgIH1cXG5cXG4gICAgdGhpcy4kZHJvcGRvd25Db250YWluZXIuY3NzKGNzcyk7XFxuICB9O1xcblxcbiAgQXR0YWNoQm9keS5wcm90b3R5cGUuX3Jlc2l6ZURyb3Bkb3duID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgY3NzID0ge1xcbiAgICAgIHdpZHRoOiB0aGlzLiRjb250YWluZXIub3V0ZXJXaWR0aChmYWxzZSkgKyAncHgnXFxuICAgIH07XFxuXFxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2V0KCdkcm9wZG93bkF1dG9XaWR0aCcpKSB7XFxuICAgICAgY3NzLm1pbldpZHRoID0gY3NzLndpZHRoO1xcbiAgICAgIGNzcy5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XFxuICAgICAgY3NzLndpZHRoID0gJ2F1dG8nO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuJGRyb3Bkb3duLmNzcyhjc3MpO1xcbiAgfTtcXG5cXG4gIEF0dGFjaEJvZHkucHJvdG90eXBlLl9zaG93RHJvcGRvd24gPSBmdW5jdGlvbiAoZGVjb3JhdGVkKSB7XFxuICAgIHRoaXMuJGRyb3Bkb3duQ29udGFpbmVyLmFwcGVuZFRvKHRoaXMuJGRyb3Bkb3duUGFyZW50KTtcXG5cXG4gICAgdGhpcy5fcG9zaXRpb25Ecm9wZG93bigpO1xcbiAgICB0aGlzLl9yZXNpemVEcm9wZG93bigpO1xcbiAgfTtcXG5cXG4gIHJldHVybiBBdHRhY2hCb2R5O1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kcm9wZG93bi9taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCcsW1xcblxcbl0sIGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIGNvdW50UmVzdWx0cyAoZGF0YSkge1xcbiAgICB2YXIgY291bnQgPSAwO1xcblxcbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcXG4gICAgICB2YXIgaXRlbSA9IGRhdGFbZF07XFxuXFxuICAgICAgaWYgKGl0ZW0uY2hpbGRyZW4pIHtcXG4gICAgICAgIGNvdW50ICs9IGNvdW50UmVzdWx0cyhpdGVtLmNoaWxkcmVuKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY291bnQrKztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGNvdW50O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gTWluaW11bVJlc3VsdHNGb3JTZWFyY2ggKGRlY29yYXRlZCwgJGVsZW1lbnQsIG9wdGlvbnMsIGRhdGFBZGFwdGVyKSB7XFxuICAgIHRoaXMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggPSBvcHRpb25zLmdldCgnbWluaW11bVJlc3VsdHNGb3JTZWFyY2gnKTtcXG5cXG4gICAgaWYgKHRoaXMubWluaW11bVJlc3VsdHNGb3JTZWFyY2ggPCAwKSB7XFxuICAgICAgdGhpcy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCA9IEluZmluaXR5O1xcbiAgICB9XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsICRlbGVtZW50LCBvcHRpb25zLCBkYXRhQWRhcHRlcik7XFxuICB9XFxuXFxuICBNaW5pbXVtUmVzdWx0c0ZvclNlYXJjaC5wcm90b3R5cGUuc2hvd1NlYXJjaCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIHBhcmFtcykge1xcbiAgICBpZiAoY291bnRSZXN1bHRzKHBhcmFtcy5kYXRhLnJlc3VsdHMpIDwgdGhpcy5taW5pbXVtUmVzdWx0c0ZvclNlYXJjaCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gZGVjb3JhdGVkLmNhbGwodGhpcywgcGFyYW1zKTtcXG4gIH07XFxuXFxuICByZXR1cm4gTWluaW11bVJlc3VsdHNGb3JTZWFyY2g7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL3NlbGVjdE9uQ2xvc2UnLFtcXG4gICcuLi91dGlscydcXG5dLCBmdW5jdGlvbiAoVXRpbHMpIHtcXG4gIGZ1bmN0aW9uIFNlbGVjdE9uQ2xvc2UgKCkgeyB9XFxuXFxuICBTZWxlY3RPbkNsb3NlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24gKGRlY29yYXRlZCwgY29udGFpbmVyLCAkY29udGFpbmVyKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgZGVjb3JhdGVkLmNhbGwodGhpcywgY29udGFpbmVyLCAkY29udGFpbmVyKTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCdjbG9zZScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBzZWxmLl9oYW5kbGVTZWxlY3RPbkNsb3NlKHBhcmFtcyk7XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdE9uQ2xvc2UucHJvdG90eXBlLl9oYW5kbGVTZWxlY3RPbkNsb3NlID0gZnVuY3Rpb24gKF8sIHBhcmFtcykge1xcbiAgICBpZiAocGFyYW1zICYmIHBhcmFtcy5vcmlnaW5hbFNlbGVjdDJFdmVudCAhPSBudWxsKSB7XFxuICAgICAgdmFyIGV2ZW50ID0gcGFyYW1zLm9yaWdpbmFsU2VsZWN0MkV2ZW50O1xcblxcbiAgICAgIC8vIERvbid0IHNlbGVjdCBhbiBpdGVtIGlmIHRoZSBjbG9zZSBldmVudCB3YXMgdHJpZ2dlcmVkIGZyb20gYSBzZWxlY3Qgb3JcXG4gICAgICAvLyB1bnNlbGVjdCBldmVudFxcbiAgICAgIGlmIChldmVudC5fdHlwZSA9PT0gJ3NlbGVjdCcgfHwgZXZlbnQuX3R5cGUgPT09ICd1bnNlbGVjdCcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgdmFyICRoaWdobGlnaHRlZFJlc3VsdHMgPSB0aGlzLmdldEhpZ2hsaWdodGVkUmVzdWx0cygpO1xcblxcbiAgICAvLyBPbmx5IHNlbGVjdCBoaWdobGlnaHRlZCByZXN1bHRzXFxuICAgIGlmICgkaGlnaGxpZ2h0ZWRSZXN1bHRzLmxlbmd0aCA8IDEpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdmFyIGRhdGEgPSBVdGlscy5HZXREYXRhKCRoaWdobGlnaHRlZFJlc3VsdHNbMF0sICdkYXRhJyk7XFxuXFxuICAgIC8vIERvbid0IHJlLXNlbGVjdCBhbHJlYWR5IHNlbGVjdGVkIHJlc3VsdGVcXG4gICAgaWYgKFxcbiAgICAgIChkYXRhLmVsZW1lbnQgIT0gbnVsbCAmJiBkYXRhLmVsZW1lbnQuc2VsZWN0ZWQpIHx8XFxuICAgICAgKGRhdGEuZWxlbWVudCA9PSBudWxsICYmIGRhdGEuc2VsZWN0ZWQpXFxuICAgICkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdCcsIHtcXG4gICAgICAgIGRhdGE6IGRhdGFcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgcmV0dXJuIFNlbGVjdE9uQ2xvc2U7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdzZWxlY3QyL2Ryb3Bkb3duL2Nsb3NlT25TZWxlY3QnLFtcXG5cXG5dLCBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBDbG9zZU9uU2VsZWN0ICgpIHsgfVxcblxcbiAgQ2xvc2VPblNlbGVjdC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChkZWNvcmF0ZWQsIGNvbnRhaW5lciwgJGNvbnRhaW5lcikge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIGRlY29yYXRlZC5jYWxsKHRoaXMsIGNvbnRhaW5lciwgJGNvbnRhaW5lcik7XFxuXFxuICAgIGNvbnRhaW5lci5vbignc2VsZWN0JywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYuX3NlbGVjdFRyaWdnZXJlZChldnQpO1xcbiAgICB9KTtcXG5cXG4gICAgY29udGFpbmVyLm9uKCd1bnNlbGVjdCcsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgICBzZWxmLl9zZWxlY3RUcmlnZ2VyZWQoZXZ0KTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgQ2xvc2VPblNlbGVjdC5wcm90b3R5cGUuX3NlbGVjdFRyaWdnZXJlZCA9IGZ1bmN0aW9uIChfLCBldnQpIHtcXG4gICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBldnQub3JpZ2luYWxFdmVudDtcXG5cXG4gICAgLy8gRG9uJ3QgY2xvc2UgaWYgdGhlIGNvbnRyb2wga2V5IGlzIGJlaW5nIGhlbGRcXG4gICAgaWYgKG9yaWdpbmFsRXZlbnQgJiYgKG9yaWdpbmFsRXZlbnQuY3RybEtleSB8fCBvcmlnaW5hbEV2ZW50Lm1ldGFLZXkpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMudHJpZ2dlcignY2xvc2UnLCB7XFxuICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcXG4gICAgICBvcmlnaW5hbFNlbGVjdDJFdmVudDogZXZ0XFxuICAgIH0pO1xcbiAgfTtcXG5cXG4gIHJldHVybiBDbG9zZU9uU2VsZWN0O1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9pMThuL2VuJyxbXSxmdW5jdGlvbiAoKSB7XFxuICAvLyBFbmdsaXNoXFxuICByZXR1cm4ge1xcbiAgICBlcnJvckxvYWRpbmc6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gJ1RoZSByZXN1bHRzIGNvdWxkIG5vdCBiZSBsb2FkZWQuJztcXG4gICAgfSxcXG4gICAgaW5wdXRUb29Mb25nOiBmdW5jdGlvbiAoYXJncykge1xcbiAgICAgIHZhciBvdmVyQ2hhcnMgPSBhcmdzLmlucHV0Lmxlbmd0aCAtIGFyZ3MubWF4aW11bTtcXG5cXG4gICAgICB2YXIgbWVzc2FnZSA9ICdQbGVhc2UgZGVsZXRlICcgKyBvdmVyQ2hhcnMgKyAnIGNoYXJhY3Rlcic7XFxuXFxuICAgICAgaWYgKG92ZXJDaGFycyAhPSAxKSB7XFxuICAgICAgICBtZXNzYWdlICs9ICdzJztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XFxuICAgIH0sXFxuICAgIGlucHV0VG9vU2hvcnQ6IGZ1bmN0aW9uIChhcmdzKSB7XFxuICAgICAgdmFyIHJlbWFpbmluZ0NoYXJzID0gYXJncy5taW5pbXVtIC0gYXJncy5pbnB1dC5sZW5ndGg7XFxuXFxuICAgICAgdmFyIG1lc3NhZ2UgPSAnUGxlYXNlIGVudGVyICcgKyByZW1haW5pbmdDaGFycyArICcgb3IgbW9yZSBjaGFyYWN0ZXJzJztcXG5cXG4gICAgICByZXR1cm4gbWVzc2FnZTtcXG4gICAgfSxcXG4gICAgbG9hZGluZ01vcmU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gJ0xvYWRpbmcgbW9yZSByZXN1bHRz4oCmJztcXG4gICAgfSxcXG4gICAgbWF4aW11bVNlbGVjdGVkOiBmdW5jdGlvbiAoYXJncykge1xcbiAgICAgIHZhciBtZXNzYWdlID0gJ1lvdSBjYW4gb25seSBzZWxlY3QgJyArIGFyZ3MubWF4aW11bSArICcgaXRlbSc7XFxuXFxuICAgICAgaWYgKGFyZ3MubWF4aW11bSAhPSAxKSB7XFxuICAgICAgICBtZXNzYWdlICs9ICdzJztcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG1lc3NhZ2U7XFxuICAgIH0sXFxuICAgIG5vUmVzdWx0czogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiAnTm8gcmVzdWx0cyBmb3VuZCc7XFxuICAgIH0sXFxuICAgIHNlYXJjaGluZzogZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiAnU2VhcmNoaW5n4oCmJztcXG4gICAgfSxcXG4gICAgcmVtb3ZlQWxsSXRlbXM6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gJ1JlbW92ZSBhbGwgaXRlbXMnO1xcbiAgICB9XFxuICB9O1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9kZWZhdWx0cycsW1xcbiAgJ2pxdWVyeScsXFxuICAncmVxdWlyZScsXFxuXFxuICAnLi9yZXN1bHRzJyxcXG5cXG4gICcuL3NlbGVjdGlvbi9zaW5nbGUnLFxcbiAgJy4vc2VsZWN0aW9uL211bHRpcGxlJyxcXG4gICcuL3NlbGVjdGlvbi9wbGFjZWhvbGRlcicsXFxuICAnLi9zZWxlY3Rpb24vYWxsb3dDbGVhcicsXFxuICAnLi9zZWxlY3Rpb24vc2VhcmNoJyxcXG4gICcuL3NlbGVjdGlvbi9ldmVudFJlbGF5JyxcXG5cXG4gICcuL3V0aWxzJyxcXG4gICcuL3RyYW5zbGF0aW9uJyxcXG4gICcuL2RpYWNyaXRpY3MnLFxcblxcbiAgJy4vZGF0YS9zZWxlY3QnLFxcbiAgJy4vZGF0YS9hcnJheScsXFxuICAnLi9kYXRhL2FqYXgnLFxcbiAgJy4vZGF0YS90YWdzJyxcXG4gICcuL2RhdGEvdG9rZW5pemVyJyxcXG4gICcuL2RhdGEvbWluaW11bUlucHV0TGVuZ3RoJyxcXG4gICcuL2RhdGEvbWF4aW11bUlucHV0TGVuZ3RoJyxcXG4gICcuL2RhdGEvbWF4aW11bVNlbGVjdGlvbkxlbmd0aCcsXFxuXFxuICAnLi9kcm9wZG93bicsXFxuICAnLi9kcm9wZG93bi9zZWFyY2gnLFxcbiAgJy4vZHJvcGRvd24vaGlkZVBsYWNlaG9sZGVyJyxcXG4gICcuL2Ryb3Bkb3duL2luZmluaXRlU2Nyb2xsJyxcXG4gICcuL2Ryb3Bkb3duL2F0dGFjaEJvZHknLFxcbiAgJy4vZHJvcGRvd24vbWluaW11bVJlc3VsdHNGb3JTZWFyY2gnLFxcbiAgJy4vZHJvcGRvd24vc2VsZWN0T25DbG9zZScsXFxuICAnLi9kcm9wZG93bi9jbG9zZU9uU2VsZWN0JyxcXG5cXG4gICcuL2kxOG4vZW4nXFxuXSwgZnVuY3Rpb24gKCQsIHJlcXVpcmUsXFxuXFxuICAgICAgICAgICAgIFJlc3VsdHNMaXN0LFxcblxcbiAgICAgICAgICAgICBTaW5nbGVTZWxlY3Rpb24sIE11bHRpcGxlU2VsZWN0aW9uLCBQbGFjZWhvbGRlciwgQWxsb3dDbGVhcixcXG4gICAgICAgICAgICAgU2VsZWN0aW9uU2VhcmNoLCBFdmVudFJlbGF5LFxcblxcbiAgICAgICAgICAgICBVdGlscywgVHJhbnNsYXRpb24sIERJQUNSSVRJQ1MsXFxuXFxuICAgICAgICAgICAgIFNlbGVjdERhdGEsIEFycmF5RGF0YSwgQWpheERhdGEsIFRhZ3MsIFRva2VuaXplcixcXG4gICAgICAgICAgICAgTWluaW11bUlucHV0TGVuZ3RoLCBNYXhpbXVtSW5wdXRMZW5ndGgsIE1heGltdW1TZWxlY3Rpb25MZW5ndGgsXFxuXFxuICAgICAgICAgICAgIERyb3Bkb3duLCBEcm9wZG93blNlYXJjaCwgSGlkZVBsYWNlaG9sZGVyLCBJbmZpbml0ZVNjcm9sbCxcXG4gICAgICAgICAgICAgQXR0YWNoQm9keSwgTWluaW11bVJlc3VsdHNGb3JTZWFyY2gsIFNlbGVjdE9uQ2xvc2UsIENsb3NlT25TZWxlY3QsXFxuXFxuICAgICAgICAgICAgIEVuZ2xpc2hUcmFuc2xhdGlvbikge1xcbiAgZnVuY3Rpb24gRGVmYXVsdHMgKCkge1xcbiAgICB0aGlzLnJlc2V0KCk7XFxuICB9XFxuXFxuICBEZWZhdWx0cy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMpO1xcblxcbiAgICBpZiAob3B0aW9ucy5kYXRhQWRhcHRlciA9PSBudWxsKSB7XFxuICAgICAgaWYgKG9wdGlvbnMuYWpheCAhPSBudWxsKSB7XFxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gQWpheERhdGE7XFxuICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmRhdGEgIT0gbnVsbCkge1xcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IEFycmF5RGF0YTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFNlbGVjdERhdGE7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLm1pbmltdW1JbnB1dExlbmd0aCA+IDApIHtcXG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcXG4gICAgICAgICAgTWluaW11bUlucHV0TGVuZ3RoXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5tYXhpbXVtSW5wdXRMZW5ndGggPiAwKSB7XFxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXFxuICAgICAgICAgIE1heGltdW1JbnB1dExlbmd0aFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMubWF4aW11bVNlbGVjdGlvbkxlbmd0aCA+IDApIHtcXG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcXG4gICAgICAgICAgTWF4aW11bVNlbGVjdGlvbkxlbmd0aFxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMudGFncykge1xcbiAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKG9wdGlvbnMuZGF0YUFkYXB0ZXIsIFRhZ3MpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy50b2tlblNlcGFyYXRvcnMgIT0gbnVsbCB8fCBvcHRpb25zLnRva2VuaXplciAhPSBudWxsKSB7XFxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXFxuICAgICAgICAgIFRva2VuaXplclxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKG9wdGlvbnMucXVlcnkgIT0gbnVsbCkge1xcbiAgICAgICAgdmFyIFF1ZXJ5ID0gcmVxdWlyZShvcHRpb25zLmFtZEJhc2UgKyAnY29tcGF0L3F1ZXJ5Jyk7XFxuXFxuICAgICAgICBvcHRpb25zLmRhdGFBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIsXFxuICAgICAgICAgIFF1ZXJ5XFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5pbml0U2VsZWN0aW9uICE9IG51bGwpIHtcXG4gICAgICAgIHZhciBJbml0U2VsZWN0aW9uID0gcmVxdWlyZShvcHRpb25zLmFtZEJhc2UgKyAnY29tcGF0L2luaXRTZWxlY3Rpb24nKTtcXG5cXG4gICAgICAgIG9wdGlvbnMuZGF0YUFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5kYXRhQWRhcHRlcixcXG4gICAgICAgICAgSW5pdFNlbGVjdGlvblxcbiAgICAgICAgKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPT0gbnVsbCkge1xcbiAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPSBSZXN1bHRzTGlzdDtcXG5cXG4gICAgICBpZiAob3B0aW9ucy5hamF4ICE9IG51bGwpIHtcXG4gICAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlcixcXG4gICAgICAgICAgSW5maW5pdGVTY3JvbGxcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyICE9IG51bGwpIHtcXG4gICAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5yZXN1bHRzQWRhcHRlcixcXG4gICAgICAgICAgSGlkZVBsYWNlaG9sZGVyXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAob3B0aW9ucy5zZWxlY3RPbkNsb3NlKSB7XFxuICAgICAgICBvcHRpb25zLnJlc3VsdHNBZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMucmVzdWx0c0FkYXB0ZXIsXFxuICAgICAgICAgIFNlbGVjdE9uQ2xvc2VcXG4gICAgICAgICk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9PSBudWxsKSB7XFxuICAgICAgaWYgKG9wdGlvbnMubXVsdGlwbGUpIHtcXG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gRHJvcGRvd247XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHZhciBTZWFyY2hhYmxlRHJvcGRvd24gPSBVdGlscy5EZWNvcmF0ZShEcm9wZG93biwgRHJvcGRvd25TZWFyY2gpO1xcblxcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBTZWFyY2hhYmxlRHJvcGRvd247XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLm1pbmltdW1SZXN1bHRzRm9yU2VhcmNoICE9PSAwKSB7XFxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLmRyb3Bkb3duQWRhcHRlcixcXG4gICAgICAgICAgTWluaW11bVJlc3VsdHNGb3JTZWFyY2hcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLmNsb3NlT25TZWxlY3QpIHtcXG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyLFxcbiAgICAgICAgICBDbG9zZU9uU2VsZWN0XFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXFxuICAgICAgICBvcHRpb25zLmRyb3Bkb3duQ3NzQ2xhc3MgIT0gbnVsbCB8fFxcbiAgICAgICAgb3B0aW9ucy5kcm9wZG93bkNzcyAhPSBudWxsIHx8XFxuICAgICAgICBvcHRpb25zLmFkYXB0RHJvcGRvd25Dc3NDbGFzcyAhPSBudWxsXFxuICAgICAgKSB7XFxuICAgICAgICB2YXIgRHJvcGRvd25DU1MgPSByZXF1aXJlKG9wdGlvbnMuYW1kQmFzZSArICdjb21wYXQvZHJvcGRvd25Dc3MnKTtcXG5cXG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyLFxcbiAgICAgICAgICBEcm9wZG93bkNTU1xcbiAgICAgICAgKTtcXG4gICAgICB9XFxuXFxuICAgICAgb3B0aW9ucy5kcm9wZG93bkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgIG9wdGlvbnMuZHJvcGRvd25BZGFwdGVyLFxcbiAgICAgICAgQXR0YWNoQm9keVxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9PSBudWxsKSB7XFxuICAgICAgaWYgKG9wdGlvbnMubXVsdGlwbGUpIHtcXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IE11bHRpcGxlU2VsZWN0aW9uO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBTaW5nbGVTZWxlY3Rpb247XFxuICAgICAgfVxcblxcbiAgICAgIC8vIEFkZCB0aGUgcGxhY2Vob2xkZXIgbWl4aW4gaWYgYSBwbGFjZWhvbGRlciB3YXMgc3BlY2lmaWVkXFxuICAgICAgaWYgKG9wdGlvbnMucGxhY2Vob2xkZXIgIT0gbnVsbCkge1xcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyID0gVXRpbHMuRGVjb3JhdGUoXFxuICAgICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlcixcXG4gICAgICAgICAgUGxhY2Vob2xkZXJcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLmFsbG93Q2xlYXIpIHtcXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIsXFxuICAgICAgICAgIEFsbG93Q2xlYXJcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChvcHRpb25zLm11bHRpcGxlKSB7XFxuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyLFxcbiAgICAgICAgICBTZWxlY3Rpb25TZWFyY2hcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChcXG4gICAgICAgIG9wdGlvbnMuY29udGFpbmVyQ3NzQ2xhc3MgIT0gbnVsbCB8fFxcbiAgICAgICAgb3B0aW9ucy5jb250YWluZXJDc3MgIT0gbnVsbCB8fFxcbiAgICAgICAgb3B0aW9ucy5hZGFwdENvbnRhaW5lckNzc0NsYXNzICE9IG51bGxcXG4gICAgICApIHtcXG4gICAgICAgIHZhciBDb250YWluZXJDU1MgPSByZXF1aXJlKG9wdGlvbnMuYW1kQmFzZSArICdjb21wYXQvY29udGFpbmVyQ3NzJyk7XFxuXFxuICAgICAgICBvcHRpb25zLnNlbGVjdGlvbkFkYXB0ZXIgPSBVdGlscy5EZWNvcmF0ZShcXG4gICAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyLFxcbiAgICAgICAgICBDb250YWluZXJDU1NcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIG9wdGlvbnMuc2VsZWN0aW9uQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgb3B0aW9ucy5zZWxlY3Rpb25BZGFwdGVyLFxcbiAgICAgICAgRXZlbnRSZWxheVxcbiAgICAgICk7XFxuICAgIH1cXG5cXG4gICAgLy8gSWYgdGhlIGRlZmF1bHRzIHdlcmUgbm90IHByZXZpb3VzbHkgYXBwbGllZCBmcm9tIGFuIGVsZW1lbnQsIGl0IGlzXFxuICAgIC8vIHBvc3NpYmxlIGZvciB0aGUgbGFuZ3VhZ2Ugb3B0aW9uIHRvIGhhdmUgbm90IGJlZW4gcmVzb2x2ZWRcXG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IHRoaXMuX3Jlc29sdmVMYW5ndWFnZShvcHRpb25zLmxhbmd1YWdlKTtcXG5cXG4gICAgLy8gQWx3YXlzIGZhbGwgYmFjayB0byBFbmdsaXNoIHNpbmNlIGl0IHdpbGwgYWx3YXlzIGJlIGNvbXBsZXRlXFxuICAgIG9wdGlvbnMubGFuZ3VhZ2UucHVzaCgnZW4nKTtcXG5cXG4gICAgdmFyIHVuaXF1ZUxhbmd1YWdlcyA9IFtdO1xcblxcbiAgICBmb3IgKHZhciBsID0gMDsgbCA8IG9wdGlvbnMubGFuZ3VhZ2UubGVuZ3RoOyBsKyspIHtcXG4gICAgICB2YXIgbGFuZ3VhZ2UgPSBvcHRpb25zLmxhbmd1YWdlW2xdO1xcblxcbiAgICAgIGlmICh1bmlxdWVMYW5ndWFnZXMuaW5kZXhPZihsYW5ndWFnZSkgPT09IC0xKSB7XFxuICAgICAgICB1bmlxdWVMYW5ndWFnZXMucHVzaChsYW5ndWFnZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIG9wdGlvbnMubGFuZ3VhZ2UgPSB1bmlxdWVMYW5ndWFnZXM7XFxuXFxuICAgIG9wdGlvbnMudHJhbnNsYXRpb25zID0gdGhpcy5fcHJvY2Vzc1RyYW5zbGF0aW9ucyhcXG4gICAgICBvcHRpb25zLmxhbmd1YWdlLFxcbiAgICAgIG9wdGlvbnMuZGVidWdcXG4gICAgKTtcXG5cXG4gICAgcmV0dXJuIG9wdGlvbnM7XFxuICB9O1xcblxcbiAgRGVmYXVsdHMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBzdHJpcERpYWNyaXRpY3MgKHRleHQpIHtcXG4gICAgICAvLyBVc2VkICd1bmkgcmFuZ2UgKyBuYW1lZCBmdW5jdGlvbicgZnJvbSBodHRwOi8vanNwZXJmLmNvbS9kaWFjcml0aWNzLzE4XFxuICAgICAgZnVuY3Rpb24gbWF0Y2goYSkge1xcbiAgICAgICAgcmV0dXJuIERJQUNSSVRJQ1NbYV0gfHwgYTtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvW15cXFxcdTAwMDAtXFxcXHUwMDdFXS9nLCBtYXRjaCk7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gbWF0Y2hlciAocGFyYW1zLCBkYXRhKSB7XFxuICAgICAgLy8gQWx3YXlzIHJldHVybiB0aGUgb2JqZWN0IGlmIHRoZXJlIGlzIG5vdGhpbmcgdG8gY29tcGFyZVxcbiAgICAgIGlmICgkLnRyaW0ocGFyYW1zLnRlcm0pID09PSAnJykge1xcbiAgICAgICAgcmV0dXJuIGRhdGE7XFxuICAgICAgfVxcblxcbiAgICAgIC8vIERvIGEgcmVjdXJzaXZlIGNoZWNrIGZvciBvcHRpb25zIHdpdGggY2hpbGRyZW5cXG4gICAgICBpZiAoZGF0YS5jaGlsZHJlbiAmJiBkYXRhLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIC8vIENsb25lIHRoZSBkYXRhIG9iamVjdCBpZiB0aGVyZSBhcmUgY2hpbGRyZW5cXG4gICAgICAgIC8vIFRoaXMgaXMgcmVxdWlyZWQgYXMgd2UgbW9kaWZ5IHRoZSBvYmplY3QgdG8gcmVtb3ZlIGFueSBub24tbWF0Y2hlc1xcbiAgICAgICAgdmFyIG1hdGNoID0gJC5leHRlbmQodHJ1ZSwge30sIGRhdGEpO1xcblxcbiAgICAgICAgLy8gQ2hlY2sgZWFjaCBjaGlsZCBvZiB0aGUgb3B0aW9uXFxuICAgICAgICBmb3IgKHZhciBjID0gZGF0YS5jaGlsZHJlbi5sZW5ndGggLSAxOyBjID49IDA7IGMtLSkge1xcbiAgICAgICAgICB2YXIgY2hpbGQgPSBkYXRhLmNoaWxkcmVuW2NdO1xcblxcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IG1hdGNoZXIocGFyYW1zLCBjaGlsZCk7XFxuXFxuICAgICAgICAgIC8vIElmIHRoZXJlIHdhc24ndCBhIG1hdGNoLCByZW1vdmUgdGhlIG9iamVjdCBpbiB0aGUgYXJyYXlcXG4gICAgICAgICAgaWYgKG1hdGNoZXMgPT0gbnVsbCkge1xcbiAgICAgICAgICAgIG1hdGNoLmNoaWxkcmVuLnNwbGljZShjLCAxKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gSWYgYW55IGNoaWxkcmVuIG1hdGNoZWQsIHJldHVybiB0aGUgbmV3IG9iamVjdFxcbiAgICAgICAgaWYgKG1hdGNoLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy8gSWYgdGhlcmUgd2VyZSBubyBtYXRjaGluZyBjaGlsZHJlbiwgY2hlY2sganVzdCB0aGUgcGxhaW4gb2JqZWN0XFxuICAgICAgICByZXR1cm4gbWF0Y2hlcihwYXJhbXMsIG1hdGNoKTtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIG9yaWdpbmFsID0gc3RyaXBEaWFjcml0aWNzKGRhdGEudGV4dCkudG9VcHBlckNhc2UoKTtcXG4gICAgICB2YXIgdGVybSA9IHN0cmlwRGlhY3JpdGljcyhwYXJhbXMudGVybSkudG9VcHBlckNhc2UoKTtcXG5cXG4gICAgICAvLyBDaGVjayBpZiB0aGUgdGV4dCBjb250YWlucyB0aGUgdGVybVxcbiAgICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKHRlcm0pID4gLTEpIHtcXG4gICAgICAgIHJldHVybiBkYXRhO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBJZiBpdCBkb2Vzbid0IGNvbnRhaW4gdGhlIHRlcm0sIGRvbid0IHJldHVybiBhbnl0aGluZ1xcbiAgICAgIHJldHVybiBudWxsO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuZGVmYXVsdHMgPSB7XFxuICAgICAgYW1kQmFzZTogJy4vJyxcXG4gICAgICBhbWRMYW5ndWFnZUJhc2U6ICcuL2kxOG4vJyxcXG4gICAgICBjbG9zZU9uU2VsZWN0OiB0cnVlLFxcbiAgICAgIGRlYnVnOiBmYWxzZSxcXG4gICAgICBkcm9wZG93bkF1dG9XaWR0aDogZmFsc2UsXFxuICAgICAgZXNjYXBlTWFya3VwOiBVdGlscy5lc2NhcGVNYXJrdXAsXFxuICAgICAgbGFuZ3VhZ2U6IHt9LFxcbiAgICAgIG1hdGNoZXI6IG1hdGNoZXIsXFxuICAgICAgbWluaW11bUlucHV0TGVuZ3RoOiAwLFxcbiAgICAgIG1heGltdW1JbnB1dExlbmd0aDogMCxcXG4gICAgICBtYXhpbXVtU2VsZWN0aW9uTGVuZ3RoOiAwLFxcbiAgICAgIG1pbmltdW1SZXN1bHRzRm9yU2VhcmNoOiAwLFxcbiAgICAgIHNlbGVjdE9uQ2xvc2U6IGZhbHNlLFxcbiAgICAgIHNjcm9sbEFmdGVyU2VsZWN0OiBmYWxzZSxcXG4gICAgICBzb3J0ZXI6IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICByZXR1cm4gZGF0YTtcXG4gICAgICB9LFxcbiAgICAgIHRlbXBsYXRlUmVzdWx0OiBmdW5jdGlvbiAocmVzdWx0KSB7XFxuICAgICAgICByZXR1cm4gcmVzdWx0LnRleHQ7XFxuICAgICAgfSxcXG4gICAgICB0ZW1wbGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24gKHNlbGVjdGlvbikge1xcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi50ZXh0O1xcbiAgICAgIH0sXFxuICAgICAgdGhlbWU6ICdkZWZhdWx0JyxcXG4gICAgICB3aWR0aDogJ3Jlc29sdmUnXFxuICAgIH07XFxuICB9O1xcblxcbiAgRGVmYXVsdHMucHJvdG90eXBlLmFwcGx5RnJvbUVsZW1lbnQgPSBmdW5jdGlvbiAob3B0aW9ucywgJGVsZW1lbnQpIHtcXG4gICAgdmFyIG9wdGlvbkxhbmd1YWdlID0gb3B0aW9ucy5sYW5ndWFnZTtcXG4gICAgdmFyIGRlZmF1bHRMYW5ndWFnZSA9IHRoaXMuZGVmYXVsdHMubGFuZ3VhZ2U7XFxuICAgIHZhciBlbGVtZW50TGFuZ3VhZ2UgPSAkZWxlbWVudC5wcm9wKCdsYW5nJyk7XFxuICAgIHZhciBwYXJlbnRMYW5ndWFnZSA9ICRlbGVtZW50LmNsb3Nlc3QoJ1tsYW5nXScpLnByb3AoJ2xhbmcnKTtcXG5cXG4gICAgdmFyIGxhbmd1YWdlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuY2FsbChcXG4gICAgICB0aGlzLl9yZXNvbHZlTGFuZ3VhZ2UoZWxlbWVudExhbmd1YWdlKSxcXG4gICAgICB0aGlzLl9yZXNvbHZlTGFuZ3VhZ2Uob3B0aW9uTGFuZ3VhZ2UpLFxcbiAgICAgIHRoaXMuX3Jlc29sdmVMYW5ndWFnZShkZWZhdWx0TGFuZ3VhZ2UpLFxcbiAgICAgIHRoaXMuX3Jlc29sdmVMYW5ndWFnZShwYXJlbnRMYW5ndWFnZSlcXG4gICAgKTtcXG5cXG4gICAgb3B0aW9ucy5sYW5ndWFnZSA9IGxhbmd1YWdlcztcXG5cXG4gICAgcmV0dXJuIG9wdGlvbnM7XFxuICB9O1xcblxcbiAgRGVmYXVsdHMucHJvdG90eXBlLl9yZXNvbHZlTGFuZ3VhZ2UgPSBmdW5jdGlvbiAobGFuZ3VhZ2UpIHtcXG4gICAgaWYgKCFsYW5ndWFnZSkge1xcbiAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcblxcbiAgICBpZiAoJC5pc0VtcHR5T2JqZWN0KGxhbmd1YWdlKSkge1xcbiAgICAgIHJldHVybiBbXTtcXG4gICAgfVxcblxcbiAgICBpZiAoJC5pc1BsYWluT2JqZWN0KGxhbmd1YWdlKSkge1xcbiAgICAgIHJldHVybiBbbGFuZ3VhZ2VdO1xcbiAgICB9XFxuXFxuICAgIHZhciBsYW5ndWFnZXM7XFxuXFxuICAgIGlmICghJC5pc0FycmF5KGxhbmd1YWdlKSkge1xcbiAgICAgIGxhbmd1YWdlcyA9IFtsYW5ndWFnZV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGFuZ3VhZ2VzID0gbGFuZ3VhZ2U7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJlc29sdmVkTGFuZ3VhZ2VzID0gW107XFxuXFxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGFuZ3VhZ2VzLmxlbmd0aDsgbCsrKSB7XFxuICAgICAgcmVzb2x2ZWRMYW5ndWFnZXMucHVzaChsYW5ndWFnZXNbbF0pO1xcblxcbiAgICAgIGlmICh0eXBlb2YgbGFuZ3VhZ2VzW2xdID09PSAnc3RyaW5nJyAmJiBsYW5ndWFnZXNbbF0uaW5kZXhPZignLScpID4gMCkge1xcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcmVnaW9uIGluZm9ybWF0aW9uIGlmIGl0IGlzIGluY2x1ZGVkXFxuICAgICAgICB2YXIgbGFuZ3VhZ2VQYXJ0cyA9IGxhbmd1YWdlc1tsXS5zcGxpdCgnLScpO1xcbiAgICAgICAgdmFyIGJhc2VMYW5ndWFnZSA9IGxhbmd1YWdlUGFydHNbMF07XFxuXFxuICAgICAgICByZXNvbHZlZExhbmd1YWdlcy5wdXNoKGJhc2VMYW5ndWFnZSk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiByZXNvbHZlZExhbmd1YWdlcztcXG4gIH07XFxuXFxuICBEZWZhdWx0cy5wcm90b3R5cGUuX3Byb2Nlc3NUcmFuc2xhdGlvbnMgPSBmdW5jdGlvbiAobGFuZ3VhZ2VzLCBkZWJ1Zykge1xcbiAgICB2YXIgdHJhbnNsYXRpb25zID0gbmV3IFRyYW5zbGF0aW9uKCk7XFxuXFxuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbGFuZ3VhZ2VzLmxlbmd0aDsgbCsrKSB7XFxuICAgICAgdmFyIGxhbmd1YWdlRGF0YSA9IG5ldyBUcmFuc2xhdGlvbigpO1xcblxcbiAgICAgIHZhciBsYW5ndWFnZSA9IGxhbmd1YWdlc1tsXTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGxhbmd1YWdlID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgLy8gVHJ5IHRvIGxvYWQgaXQgd2l0aCB0aGUgb3JpZ2luYWwgbmFtZVxcbiAgICAgICAgICBsYW5ndWFnZURhdGEgPSBUcmFuc2xhdGlvbi5sb2FkUGF0aChsYW5ndWFnZSk7XFxuICAgICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgLy8gSWYgd2UgY291bGRuJ3QgbG9hZCBpdCwgY2hlY2sgaWYgaXQgd2Fzbid0IHRoZSBmdWxsIHBhdGhcXG4gICAgICAgICAgICBsYW5ndWFnZSA9IHRoaXMuZGVmYXVsdHMuYW1kTGFuZ3VhZ2VCYXNlICsgbGFuZ3VhZ2U7XFxuICAgICAgICAgICAgbGFuZ3VhZ2VEYXRhID0gVHJhbnNsYXRpb24ubG9hZFBhdGgobGFuZ3VhZ2UpO1xcbiAgICAgICAgICB9IGNhdGNoIChleCkge1xcbiAgICAgICAgICAgIC8vIFRoZSB0cmFuc2xhdGlvbiBjb3VsZCBub3QgYmUgbG9hZGVkIGF0IGFsbC4gU29tZXRpbWVzIHRoaXMgaXNcXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG9mIGEgY29uZmlndXJhdGlvbiBwcm9ibGVtLCBvdGhlciB0aW1lcyB0aGlzIGNhbiBiZVxcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugb2YgaG93IFNlbGVjdDIgaGVscHMgbG9hZCBhbGwgcG9zc2libGUgdHJhbnNsYXRpb24gZmlsZXNcXG4gICAgICAgICAgICBpZiAoZGVidWcgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XFxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXFxuICAgICAgICAgICAgICAgICdTZWxlY3QyOiBUaGUgbGFuZ3VhZ2UgZmlsZSBmb3IgXFxcIicgKyBsYW5ndWFnZSArICdcXFwiIGNvdWxkICcgK1xcbiAgICAgICAgICAgICAgICAnbm90IGJlIGF1dG9tYXRpY2FsbHkgbG9hZGVkLiBBIGZhbGxiYWNrIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLidcXG4gICAgICAgICAgICAgICk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QobGFuZ3VhZ2UpKSB7XFxuICAgICAgICBsYW5ndWFnZURhdGEgPSBuZXcgVHJhbnNsYXRpb24obGFuZ3VhZ2UpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsYW5ndWFnZURhdGEgPSBsYW5ndWFnZTtcXG4gICAgICB9XFxuXFxuICAgICAgdHJhbnNsYXRpb25zLmV4dGVuZChsYW5ndWFnZURhdGEpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0cmFuc2xhdGlvbnM7XFxuICB9O1xcblxcbiAgRGVmYXVsdHMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XFxuICAgIHZhciBjYW1lbEtleSA9ICQuY2FtZWxDYXNlKGtleSk7XFxuXFxuICAgIHZhciBkYXRhID0ge307XFxuICAgIGRhdGFbY2FtZWxLZXldID0gdmFsdWU7XFxuXFxuICAgIHZhciBjb252ZXJ0ZWREYXRhID0gVXRpbHMuX2NvbnZlcnREYXRhKGRhdGEpO1xcblxcbiAgICAkLmV4dGVuZCh0cnVlLCB0aGlzLmRlZmF1bHRzLCBjb252ZXJ0ZWREYXRhKTtcXG4gIH07XFxuXFxuICB2YXIgZGVmYXVsdHMgPSBuZXcgRGVmYXVsdHMoKTtcXG5cXG4gIHJldHVybiBkZWZhdWx0cztcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ3NlbGVjdDIvb3B0aW9ucycsW1xcbiAgJ3JlcXVpcmUnLFxcbiAgJ2pxdWVyeScsXFxuICAnLi9kZWZhdWx0cycsXFxuICAnLi91dGlscydcXG5dLCBmdW5jdGlvbiAocmVxdWlyZSwgJCwgRGVmYXVsdHMsIFV0aWxzKSB7XFxuICBmdW5jdGlvbiBPcHRpb25zIChvcHRpb25zLCAkZWxlbWVudCkge1xcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xcblxcbiAgICBpZiAoJGVsZW1lbnQgIT0gbnVsbCkge1xcbiAgICAgIHRoaXMuZnJvbUVsZW1lbnQoJGVsZW1lbnQpO1xcbiAgICB9XFxuXFxuICAgIGlmICgkZWxlbWVudCAhPSBudWxsKSB7XFxuICAgICAgdGhpcy5vcHRpb25zID0gRGVmYXVsdHMuYXBwbHlGcm9tRWxlbWVudCh0aGlzLm9wdGlvbnMsICRlbGVtZW50KTtcXG4gICAgfVxcblxcbiAgICB0aGlzLm9wdGlvbnMgPSBEZWZhdWx0cy5hcHBseSh0aGlzLm9wdGlvbnMpO1xcblxcbiAgICBpZiAoJGVsZW1lbnQgJiYgJGVsZW1lbnQuaXMoJ2lucHV0JykpIHtcXG4gICAgICB2YXIgSW5wdXRDb21wYXQgPSByZXF1aXJlKHRoaXMuZ2V0KCdhbWRCYXNlJykgKyAnY29tcGF0L2lucHV0RGF0YScpO1xcblxcbiAgICAgIHRoaXMub3B0aW9ucy5kYXRhQWRhcHRlciA9IFV0aWxzLkRlY29yYXRlKFxcbiAgICAgICAgdGhpcy5vcHRpb25zLmRhdGFBZGFwdGVyLFxcbiAgICAgICAgSW5wdXRDb21wYXRcXG4gICAgICApO1xcbiAgICB9XFxuICB9XFxuXFxuICBPcHRpb25zLnByb3RvdHlwZS5mcm9tRWxlbWVudCA9IGZ1bmN0aW9uICgkZSkge1xcbiAgICB2YXIgZXhjbHVkZWREYXRhID0gWydzZWxlY3QyJ107XFxuXFxuICAgIGlmICh0aGlzLm9wdGlvbnMubXVsdGlwbGUgPT0gbnVsbCkge1xcbiAgICAgIHRoaXMub3B0aW9ucy5tdWx0aXBsZSA9ICRlLnByb3AoJ211bHRpcGxlJyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9PSBudWxsKSB7XFxuICAgICAgdGhpcy5vcHRpb25zLmRpc2FibGVkID0gJGUucHJvcCgnZGlzYWJsZWQnKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5vcHRpb25zLmRpciA9PSBudWxsKSB7XFxuICAgICAgaWYgKCRlLnByb3AoJ2RpcicpKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGlyID0gJGUucHJvcCgnZGlyJyk7XFxuICAgICAgfSBlbHNlIGlmICgkZS5jbG9zZXN0KCdbZGlyXScpLnByb3AoJ2RpcicpKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGlyID0gJGUuY2xvc2VzdCgnW2Rpcl0nKS5wcm9wKCdkaXInKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgdGhpcy5vcHRpb25zLmRpciA9ICdsdHInO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAkZS5wcm9wKCdkaXNhYmxlZCcsIHRoaXMub3B0aW9ucy5kaXNhYmxlZCk7XFxuICAgICRlLnByb3AoJ211bHRpcGxlJywgdGhpcy5vcHRpb25zLm11bHRpcGxlKTtcXG5cXG4gICAgaWYgKFV0aWxzLkdldERhdGEoJGVbMF0sICdzZWxlY3QyVGFncycpKSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcXG4gICAgICAgIGNvbnNvbGUud2FybihcXG4gICAgICAgICAgJ1NlbGVjdDI6IFRoZSBgZGF0YS1zZWxlY3QyLXRhZ3NgIGF0dHJpYnV0ZSBoYXMgYmVlbiBjaGFuZ2VkIHRvICcgK1xcbiAgICAgICAgICAndXNlIHRoZSBgZGF0YS1kYXRhYCBhbmQgYGRhdGEtdGFncz1cXFwidHJ1ZVxcXCJgIGF0dHJpYnV0ZXMgYW5kIHdpbGwgYmUgJyArXFxuICAgICAgICAgICdyZW1vdmVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBTZWxlY3QyLidcXG4gICAgICAgICk7XFxuICAgICAgfVxcblxcbiAgICAgIFV0aWxzLlN0b3JlRGF0YSgkZVswXSwgJ2RhdGEnLCBVdGlscy5HZXREYXRhKCRlWzBdLCAnc2VsZWN0MlRhZ3MnKSk7XFxuICAgICAgVXRpbHMuU3RvcmVEYXRhKCRlWzBdLCAndGFncycsIHRydWUpO1xcbiAgICB9XFxuXFxuICAgIGlmIChVdGlscy5HZXREYXRhKCRlWzBdLCAnYWpheFVybCcpKSB7XFxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1ZyAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcXG4gICAgICAgIGNvbnNvbGUud2FybihcXG4gICAgICAgICAgJ1NlbGVjdDI6IFRoZSBgZGF0YS1hamF4LXVybGAgYXR0cmlidXRlIGhhcyBiZWVuIGNoYW5nZWQgdG8gJyArXFxuICAgICAgICAgICdgZGF0YS1hamF4LS11cmxgIGFuZCBzdXBwb3J0IGZvciB0aGUgb2xkIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQnICtcXG4gICAgICAgICAgJyBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgU2VsZWN0Mi4nXFxuICAgICAgICApO1xcbiAgICAgIH1cXG5cXG4gICAgICAkZS5hdHRyKCdhamF4LS11cmwnLCBVdGlscy5HZXREYXRhKCRlWzBdLCAnYWpheFVybCcpKTtcXG4gICAgICBVdGlscy5TdG9yZURhdGEoJGVbMF0sICdhamF4LVVybCcsIFV0aWxzLkdldERhdGEoJGVbMF0sICdhamF4VXJsJykpO1xcbiAgICB9XFxuXFxuICAgIHZhciBkYXRhc2V0ID0ge307XFxuXFxuICAgIGZ1bmN0aW9uIHVwcGVyQ2FzZUxldHRlcihfLCBsZXR0ZXIpIHtcXG4gICAgICByZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gUHJlLWxvYWQgYWxsIG9mIHRoZSBhdHRyaWJ1dGVzIHdoaWNoIGFyZSBwcmVmaXhlZCB3aXRoIGBkYXRhLWBcXG4gICAgZm9yICh2YXIgYXR0ciA9IDA7IGF0dHIgPCAkZVswXS5hdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cisrKSB7XFxuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSAkZVswXS5hdHRyaWJ1dGVzW2F0dHJdLm5hbWU7XFxuICAgICAgdmFyIHByZWZpeCA9ICdkYXRhLSc7XFxuXFxuICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUuc3Vic3RyKDAsIHByZWZpeC5sZW5ndGgpID09IHByZWZpeCkge1xcbiAgICAgICAgLy8gR2V0IHRoZSBjb250ZW50cyBvZiB0aGUgYXR0cmlidXRlIGFmdGVyIGBkYXRhLWBcXG4gICAgICAgIHZhciBkYXRhTmFtZSA9IGF0dHJpYnV0ZU5hbWUuc3Vic3RyaW5nKHByZWZpeC5sZW5ndGgpO1xcblxcbiAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGNvbnRlbnRzIGZyb20gdGhlIGNvbnNpc3RlbnQgc291cmNlXFxuICAgICAgICAvLyBUaGlzIGlzIG1vcmUgdGhhbiBsaWtlbHkgdGhlIGpRdWVyeSBkYXRhIGhlbHBlclxcbiAgICAgICAgdmFyIGRhdGFWYWx1ZSA9IFV0aWxzLkdldERhdGEoJGVbMF0sIGRhdGFOYW1lKTtcXG5cXG4gICAgICAgIC8vIGNhbWVsQ2FzZSB0aGUgYXR0cmlidXRlIG5hbWUgdG8gbWF0Y2ggdGhlIHNwZWNcXG4gICAgICAgIHZhciBjYW1lbERhdGFOYW1lID0gZGF0YU5hbWUucmVwbGFjZSgvLShbYS16XSkvZywgdXBwZXJDYXNlTGV0dGVyKTtcXG5cXG4gICAgICAgIC8vIFN0b3JlIHRoZSBkYXRhIGF0dHJpYnV0ZSBjb250ZW50cyBpbnRvIHRoZSBkYXRhc2V0IHNpbmNlXFxuICAgICAgICBkYXRhc2V0W2NhbWVsRGF0YU5hbWVdID0gZGF0YVZhbHVlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBQcmVmZXIgdGhlIGVsZW1lbnQncyBgZGF0YXNldGAgYXR0cmlidXRlIGlmIGl0IGV4aXN0c1xcbiAgICAvLyBqUXVlcnkgMS54IGRvZXMgbm90IGNvcnJlY3RseSBoYW5kbGUgZGF0YSBhdHRyaWJ1dGVzIHdpdGggbXVsdGlwbGUgZGFzaGVzXFxuICAgIGlmICgkLmZuLmpxdWVyeSAmJiAkLmZuLmpxdWVyeS5zdWJzdHIoMCwgMikgPT0gJzEuJyAmJiAkZVswXS5kYXRhc2V0KSB7XFxuICAgICAgZGF0YXNldCA9ICQuZXh0ZW5kKHRydWUsIHt9LCAkZVswXS5kYXRhc2V0LCBkYXRhc2V0KTtcXG4gICAgfVxcblxcbiAgICAvLyBQcmVmZXIgb3VyIGludGVybmFsIGRhdGEgY2FjaGUgaWYgaXQgZXhpc3RzXFxuICAgIHZhciBkYXRhID0gJC5leHRlbmQodHJ1ZSwge30sIFV0aWxzLkdldERhdGEoJGVbMF0pLCBkYXRhc2V0KTtcXG5cXG4gICAgZGF0YSA9IFV0aWxzLl9jb252ZXJ0RGF0YShkYXRhKTtcXG5cXG4gICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcXG4gICAgICBpZiAoJC5pbkFycmF5KGtleSwgZXhjbHVkZWREYXRhKSA+IC0xKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdCh0aGlzLm9wdGlvbnNba2V5XSkpIHtcXG4gICAgICAgICQuZXh0ZW5kKHRoaXMub3B0aW9uc1trZXldLCBkYXRhW2tleV0pO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnNba2V5XSA9IGRhdGFba2V5XTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9O1xcblxcbiAgT3B0aW9ucy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xcbiAgICByZXR1cm4gdGhpcy5vcHRpb25zW2tleV07XFxuICB9O1xcblxcbiAgT3B0aW9ucy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsKSB7XFxuICAgIHRoaXMub3B0aW9uc1trZXldID0gdmFsO1xcbiAgfTtcXG5cXG4gIHJldHVybiBPcHRpb25zO1xcbn0pO1xcblxcblMyLmRlZmluZSgnc2VsZWN0Mi9jb3JlJyxbXFxuICAnanF1ZXJ5JyxcXG4gICcuL29wdGlvbnMnLFxcbiAgJy4vdXRpbHMnLFxcbiAgJy4va2V5cydcXG5dLCBmdW5jdGlvbiAoJCwgT3B0aW9ucywgVXRpbHMsIEtFWVMpIHtcXG4gIHZhciBTZWxlY3QyID0gZnVuY3Rpb24gKCRlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgIGlmIChVdGlscy5HZXREYXRhKCRlbGVtZW50WzBdLCAnc2VsZWN0MicpICE9IG51bGwpIHtcXG4gICAgICBVdGlscy5HZXREYXRhKCRlbGVtZW50WzBdLCAnc2VsZWN0MicpLmRlc3Ryb3koKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLiRlbGVtZW50ID0gJGVsZW1lbnQ7XFxuXFxuICAgIHRoaXMuaWQgPSB0aGlzLl9nZW5lcmF0ZUlkKCRlbGVtZW50KTtcXG5cXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgIHRoaXMub3B0aW9ucyA9IG5ldyBPcHRpb25zKG9wdGlvbnMsICRlbGVtZW50KTtcXG5cXG4gICAgU2VsZWN0Mi5fX3N1cGVyX18uY29uc3RydWN0b3IuY2FsbCh0aGlzKTtcXG5cXG4gICAgLy8gU2V0IHVwIHRoZSB0YWJpbmRleFxcblxcbiAgICB2YXIgdGFiaW5kZXggPSAkZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpIHx8IDA7XFxuICAgIFV0aWxzLlN0b3JlRGF0YSgkZWxlbWVudFswXSwgJ29sZC10YWJpbmRleCcsIHRhYmluZGV4KTtcXG4gICAgJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLCAnLTEnKTtcXG5cXG4gICAgLy8gU2V0IHVwIGNvbnRhaW5lcnMgYW5kIGFkYXB0ZXJzXFxuXFxuICAgIHZhciBEYXRhQWRhcHRlciA9IHRoaXMub3B0aW9ucy5nZXQoJ2RhdGFBZGFwdGVyJyk7XFxuICAgIHRoaXMuZGF0YUFkYXB0ZXIgPSBuZXcgRGF0YUFkYXB0ZXIoJGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XFxuXFxuICAgIHZhciAkY29udGFpbmVyID0gdGhpcy5yZW5kZXIoKTtcXG5cXG4gICAgdGhpcy5fcGxhY2VDb250YWluZXIoJGNvbnRhaW5lcik7XFxuXFxuICAgIHZhciBTZWxlY3Rpb25BZGFwdGVyID0gdGhpcy5vcHRpb25zLmdldCgnc2VsZWN0aW9uQWRhcHRlcicpO1xcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25BZGFwdGVyKCRlbGVtZW50LCB0aGlzLm9wdGlvbnMpO1xcbiAgICB0aGlzLiRzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbi5yZW5kZXIoKTtcXG5cXG4gICAgdGhpcy5zZWxlY3Rpb24ucG9zaXRpb24odGhpcy4kc2VsZWN0aW9uLCAkY29udGFpbmVyKTtcXG5cXG4gICAgdmFyIERyb3Bkb3duQWRhcHRlciA9IHRoaXMub3B0aW9ucy5nZXQoJ2Ryb3Bkb3duQWRhcHRlcicpO1xcbiAgICB0aGlzLmRyb3Bkb3duID0gbmV3IERyb3Bkb3duQWRhcHRlcigkZWxlbWVudCwgdGhpcy5vcHRpb25zKTtcXG4gICAgdGhpcy4kZHJvcGRvd24gPSB0aGlzLmRyb3Bkb3duLnJlbmRlcigpO1xcblxcbiAgICB0aGlzLmRyb3Bkb3duLnBvc2l0aW9uKHRoaXMuJGRyb3Bkb3duLCAkY29udGFpbmVyKTtcXG5cXG4gICAgdmFyIFJlc3VsdHNBZGFwdGVyID0gdGhpcy5vcHRpb25zLmdldCgncmVzdWx0c0FkYXB0ZXInKTtcXG4gICAgdGhpcy5yZXN1bHRzID0gbmV3IFJlc3VsdHNBZGFwdGVyKCRlbGVtZW50LCB0aGlzLm9wdGlvbnMsIHRoaXMuZGF0YUFkYXB0ZXIpO1xcbiAgICB0aGlzLiRyZXN1bHRzID0gdGhpcy5yZXN1bHRzLnJlbmRlcigpO1xcblxcbiAgICB0aGlzLnJlc3VsdHMucG9zaXRpb24odGhpcy4kcmVzdWx0cywgdGhpcy4kZHJvcGRvd24pO1xcblxcbiAgICAvLyBCaW5kIGV2ZW50c1xcblxcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIC8vIEJpbmQgdGhlIGNvbnRhaW5lciB0byBhbGwgb2YgdGhlIGFkYXB0ZXJzXFxuICAgIHRoaXMuX2JpbmRBZGFwdGVycygpO1xcblxcbiAgICAvLyBSZWdpc3RlciBhbnkgRE9NIGV2ZW50IGhhbmRsZXJzXFxuICAgIHRoaXMuX3JlZ2lzdGVyRG9tRXZlbnRzKCk7XFxuXFxuICAgIC8vIFJlZ2lzdGVyIGFueSBpbnRlcm5hbCBldmVudCBoYW5kbGVyc1xcbiAgICB0aGlzLl9yZWdpc3RlckRhdGFFdmVudHMoKTtcXG4gICAgdGhpcy5fcmVnaXN0ZXJTZWxlY3Rpb25FdmVudHMoKTtcXG4gICAgdGhpcy5fcmVnaXN0ZXJEcm9wZG93bkV2ZW50cygpO1xcbiAgICB0aGlzLl9yZWdpc3RlclJlc3VsdHNFdmVudHMoKTtcXG4gICAgdGhpcy5fcmVnaXN0ZXJFdmVudHMoKTtcXG5cXG4gICAgLy8gU2V0IHRoZSBpbml0aWFsIHN0YXRlXFxuICAgIHRoaXMuZGF0YUFkYXB0ZXIuY3VycmVudChmdW5jdGlvbiAoaW5pdGlhbERhdGEpIHtcXG4gICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGlvbjp1cGRhdGUnLCB7XFxuICAgICAgICBkYXRhOiBpbml0aWFsRGF0YVxcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgLy8gSGlkZSB0aGUgb3JpZ2luYWwgc2VsZWN0XFxuICAgICRlbGVtZW50LmFkZENsYXNzKCdzZWxlY3QyLWhpZGRlbi1hY2Nlc3NpYmxlJyk7XFxuICAgICRlbGVtZW50LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcXG5cXG4gICAgLy8gU3luY2hyb25pemUgYW55IG1vbml0b3JlZCBhdHRyaWJ1dGVzXFxuICAgIHRoaXMuX3N5bmNBdHRyaWJ1dGVzKCk7XFxuXFxuICAgIFV0aWxzLlN0b3JlRGF0YSgkZWxlbWVudFswXSwgJ3NlbGVjdDInLCB0aGlzKTtcXG5cXG4gICAgLy8gRW5zdXJlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggJGVsZW1lbnQuZGF0YSgnc2VsZWN0MicpLlxcbiAgICAkZWxlbWVudC5kYXRhKCdzZWxlY3QyJywgdGhpcyk7XFxuICB9O1xcblxcbiAgVXRpbHMuRXh0ZW5kKFNlbGVjdDIsIFV0aWxzLk9ic2VydmFibGUpO1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX2dlbmVyYXRlSWQgPSBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcXG4gICAgdmFyIGlkID0gJyc7XFxuXFxuICAgIGlmICgkZWxlbWVudC5hdHRyKCdpZCcpICE9IG51bGwpIHtcXG4gICAgICBpZCA9ICRlbGVtZW50LmF0dHIoJ2lkJyk7XFxuICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQuYXR0cignbmFtZScpICE9IG51bGwpIHtcXG4gICAgICBpZCA9ICRlbGVtZW50LmF0dHIoJ25hbWUnKSArICctJyArIFV0aWxzLmdlbmVyYXRlQ2hhcnMoMik7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWQgPSBVdGlscy5nZW5lcmF0ZUNoYXJzKDQpO1xcbiAgICB9XFxuXFxuICAgIGlkID0gaWQucmVwbGFjZSgvKDp8XFxcXC58XFxcXFt8XFxcXF18LCkvZywgJycpO1xcbiAgICBpZCA9ICdzZWxlY3QyLScgKyBpZDtcXG5cXG4gICAgcmV0dXJuIGlkO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9wbGFjZUNvbnRhaW5lciA9IGZ1bmN0aW9uICgkY29udGFpbmVyKSB7XFxuICAgICRjb250YWluZXIuaW5zZXJ0QWZ0ZXIodGhpcy4kZWxlbWVudCk7XFxuXFxuICAgIHZhciB3aWR0aCA9IHRoaXMuX3Jlc29sdmVXaWR0aCh0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuZ2V0KCd3aWR0aCcpKTtcXG5cXG4gICAgaWYgKHdpZHRoICE9IG51bGwpIHtcXG4gICAgICAkY29udGFpbmVyLmNzcygnd2lkdGgnLCB3aWR0aCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVzb2x2ZVdpZHRoID0gZnVuY3Rpb24gKCRlbGVtZW50LCBtZXRob2QpIHtcXG4gICAgdmFyIFdJRFRIID0gL153aWR0aDooKFstK10/KFswLTldKlxcXFwuKT9bMC05XSspKHB4fGVtfGV4fCV8aW58Y218bW18cHR8cGMpKS9pO1xcblxcbiAgICBpZiAobWV0aG9kID09ICdyZXNvbHZlJykge1xcbiAgICAgIHZhciBzdHlsZVdpZHRoID0gdGhpcy5fcmVzb2x2ZVdpZHRoKCRlbGVtZW50LCAnc3R5bGUnKTtcXG5cXG4gICAgICBpZiAoc3R5bGVXaWR0aCAhPSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gc3R5bGVXaWR0aDtcXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVXaWR0aCgkZWxlbWVudCwgJ2VsZW1lbnQnKTtcXG4gICAgfVxcblxcbiAgICBpZiAobWV0aG9kID09ICdlbGVtZW50Jykge1xcbiAgICAgIHZhciBlbGVtZW50V2lkdGggPSAkZWxlbWVudC5vdXRlcldpZHRoKGZhbHNlKTtcXG5cXG4gICAgICBpZiAoZWxlbWVudFdpZHRoIDw9IDApIHtcXG4gICAgICAgIHJldHVybiAnYXV0byc7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBlbGVtZW50V2lkdGggKyAncHgnO1xcbiAgICB9XFxuXFxuICAgIGlmIChtZXRob2QgPT0gJ3N0eWxlJykge1xcbiAgICAgIHZhciBzdHlsZSA9ICRlbGVtZW50LmF0dHIoJ3N0eWxlJyk7XFxuXFxuICAgICAgaWYgKHR5cGVvZihzdHlsZSkgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICByZXR1cm4gbnVsbDtcXG4gICAgICB9XFxuXFxuICAgICAgdmFyIGF0dHJzID0gc3R5bGUuc3BsaXQoJzsnKTtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkgPSBpICsgMSkge1xcbiAgICAgICAgdmFyIGF0dHIgPSBhdHRyc1tpXS5yZXBsYWNlKC9cXFxccy9nLCAnJyk7XFxuICAgICAgICB2YXIgbWF0Y2hlcyA9IGF0dHIubWF0Y2goV0lEVEgpO1xcblxcbiAgICAgICAgaWYgKG1hdGNoZXMgIT09IG51bGwgJiYgbWF0Y2hlcy5sZW5ndGggPj0gMSkge1xcbiAgICAgICAgICByZXR1cm4gbWF0Y2hlc1sxXTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG5cXG4gICAgaWYgKG1ldGhvZCA9PSAnY29tcHV0ZWRzdHlsZScpIHtcXG4gICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCRlbGVtZW50WzBdKTtcXG5cXG4gICAgICByZXR1cm4gY29tcHV0ZWRTdHlsZS53aWR0aDtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gbWV0aG9kO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9iaW5kQWRhcHRlcnMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuZGF0YUFkYXB0ZXIuYmluZCh0aGlzLCB0aGlzLiRjb250YWluZXIpO1xcbiAgICB0aGlzLnNlbGVjdGlvbi5iaW5kKHRoaXMsIHRoaXMuJGNvbnRhaW5lcik7XFxuXFxuICAgIHRoaXMuZHJvcGRvd24uYmluZCh0aGlzLCB0aGlzLiRjb250YWluZXIpO1xcbiAgICB0aGlzLnJlc3VsdHMuYmluZCh0aGlzLCB0aGlzLiRjb250YWluZXIpO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9yZWdpc3RlckRvbUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdjaGFuZ2Uuc2VsZWN0MicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLmRhdGFBZGFwdGVyLmN1cnJlbnQoZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHNlbGYudHJpZ2dlcignc2VsZWN0aW9uOnVwZGF0ZScsIHtcXG4gICAgICAgICAgZGF0YTogZGF0YVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLiRlbGVtZW50Lm9uKCdmb2N1cy5zZWxlY3QyJywgZnVuY3Rpb24gKGV2dCkge1xcbiAgICAgIHNlbGYudHJpZ2dlcignZm9jdXMnLCBldnQpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5fc3luY0EgPSBVdGlscy5iaW5kKHRoaXMuX3N5bmNBdHRyaWJ1dGVzLCB0aGlzKTtcXG4gICAgdGhpcy5fc3luY1MgPSBVdGlscy5iaW5kKHRoaXMuX3N5bmNTdWJ0cmVlLCB0aGlzKTtcXG5cXG4gICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0uYXR0YWNoRXZlbnQpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdLmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgdGhpcy5fc3luY0EpO1xcbiAgICB9XFxuXFxuICAgIHZhciBvYnNlcnZlciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8XFxuICAgICAgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHxcXG4gICAgICB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlclxcbiAgICA7XFxuXFxuICAgIGlmIChvYnNlcnZlciAhPSBudWxsKSB7XFxuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgb2JzZXJ2ZXIoZnVuY3Rpb24gKG11dGF0aW9ucykge1xcbiAgICAgICAgc2VsZi5fc3luY0EoKTtcXG4gICAgICAgIHNlbGYuX3N5bmNTKG51bGwsIG11dGF0aW9ucyk7XFxuICAgICAgfSk7XFxuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLiRlbGVtZW50WzBdLCB7XFxuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxcbiAgICAgICAgc3VidHJlZTogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIGlmICh0aGlzLiRlbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIpIHtcXG4gICAgICB0aGlzLiRlbGVtZW50WzBdLmFkZEV2ZW50TGlzdGVuZXIoXFxuICAgICAgICAnRE9NQXR0ck1vZGlmaWVkJyxcXG4gICAgICAgIHNlbGYuX3N5bmNBLFxcbiAgICAgICAgZmFsc2VcXG4gICAgICApO1xcbiAgICAgIHRoaXMuJGVsZW1lbnRbMF0uYWRkRXZlbnRMaXN0ZW5lcihcXG4gICAgICAgICdET01Ob2RlSW5zZXJ0ZWQnLFxcbiAgICAgICAgc2VsZi5fc3luY1MsXFxuICAgICAgICBmYWxzZVxcbiAgICAgICk7XFxuICAgICAgdGhpcy4kZWxlbWVudFswXS5hZGRFdmVudExpc3RlbmVyKFxcbiAgICAgICAgJ0RPTU5vZGVSZW1vdmVkJyxcXG4gICAgICAgIHNlbGYuX3N5bmNTLFxcbiAgICAgICAgZmFsc2VcXG4gICAgICApO1xcbiAgICB9XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3JlZ2lzdGVyRGF0YUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB0aGlzLmRhdGFBZGFwdGVyLm9uKCcqJywgZnVuY3Rpb24gKG5hbWUsIHBhcmFtcykge1xcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVnaXN0ZXJTZWxlY3Rpb25FdmVudHMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG4gICAgdmFyIG5vblJlbGF5RXZlbnRzID0gWyd0b2dnbGUnLCAnZm9jdXMnXTtcXG5cXG4gICAgdGhpcy5zZWxlY3Rpb24ub24oJ3RvZ2dsZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICBzZWxmLnRvZ2dsZURyb3Bkb3duKCk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLnNlbGVjdGlvbi5vbignZm9jdXMnLCBmdW5jdGlvbiAocGFyYW1zKSB7XFxuICAgICAgc2VsZi5mb2N1cyhwYXJhbXMpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5zZWxlY3Rpb24ub24oJyonLCBmdW5jdGlvbiAobmFtZSwgcGFyYW1zKSB7XFxuICAgICAgaWYgKCQuaW5BcnJheShuYW1lLCBub25SZWxheUV2ZW50cykgIT09IC0xKSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVnaXN0ZXJEcm9wZG93bkV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICB0aGlzLmRyb3Bkb3duLm9uKCcqJywgZnVuY3Rpb24gKG5hbWUsIHBhcmFtcykge1xcbiAgICAgIHNlbGYudHJpZ2dlcihuYW1lLCBwYXJhbXMpO1xcbiAgICB9KTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fcmVnaXN0ZXJSZXN1bHRzRXZlbnRzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMucmVzdWx0cy5vbignKicsIGZ1bmN0aW9uIChuYW1lLCBwYXJhbXMpIHtcXG4gICAgICBzZWxmLnRyaWdnZXIobmFtZSwgcGFyYW1zKTtcXG4gICAgfSk7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3JlZ2lzdGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICAgIHRoaXMub24oJ29wZW4nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kY29udGFpbmVyLmFkZENsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgc2VsZi4kY29udGFpbmVyLnJlbW92ZUNsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5vbignZW5hYmxlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJGNvbnRhaW5lci5yZW1vdmVDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWRpc2FibGVkJyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLm9uKCdkaXNhYmxlJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJGNvbnRhaW5lci5hZGRDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWRpc2FibGVkJyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLm9uKCdibHVyJywgZnVuY3Rpb24gKCkge1xcbiAgICAgIHNlbGYuJGNvbnRhaW5lci5yZW1vdmVDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWZvY3VzJyk7XFxuICAgIH0pO1xcblxcbiAgICB0aGlzLm9uKCdxdWVyeScsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICBpZiAoIXNlbGYuaXNPcGVuKCkpIHtcXG4gICAgICAgIHNlbGYudHJpZ2dlcignb3BlbicsIHt9KTtcXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5kYXRhQWRhcHRlci5xdWVyeShwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6YWxsJywge1xcbiAgICAgICAgICBkYXRhOiBkYXRhLFxcbiAgICAgICAgICBxdWVyeTogcGFyYW1zXFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgIHRoaXMub24oJ3F1ZXJ5OmFwcGVuZCcsIGZ1bmN0aW9uIChwYXJhbXMpIHtcXG4gICAgICB0aGlzLmRhdGFBZGFwdGVyLnF1ZXJ5KHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czphcHBlbmQnLCB7XFxuICAgICAgICAgIGRhdGE6IGRhdGEsXFxuICAgICAgICAgIHF1ZXJ5OiBwYXJhbXNcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9KTtcXG5cXG4gICAgdGhpcy5vbigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgICAgdmFyIGtleSA9IGV2dC53aGljaDtcXG5cXG4gICAgICBpZiAoc2VsZi5pc09wZW4oKSkge1xcbiAgICAgICAgaWYgKGtleSA9PT0gS0VZUy5FU0MgfHwga2V5ID09PSBLRVlTLlRBQiB8fFxcbiAgICAgICAgICAgIChrZXkgPT09IEtFWVMuVVAgJiYgZXZ0LmFsdEtleSkpIHtcXG4gICAgICAgICAgc2VsZi5jbG9zZShldnQpO1xcblxcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLRVlTLkVOVEVSKSB7XFxuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpzZWxlY3QnLCB7fSk7XFxuXFxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfSBlbHNlIGlmICgoa2V5ID09PSBLRVlTLlNQQUNFICYmIGV2dC5jdHJsS2V5KSkge1xcbiAgICAgICAgICBzZWxmLnRyaWdnZXIoJ3Jlc3VsdHM6dG9nZ2xlJywge30pO1xcblxcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBLRVlTLlVQKSB7XFxuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpwcmV2aW91cycsIHt9KTtcXG5cXG4gICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gS0VZUy5ET1dOKSB7XFxuICAgICAgICAgIHNlbGYudHJpZ2dlcigncmVzdWx0czpuZXh0Jywge30pO1xcblxcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgaWYgKGtleSA9PT0gS0VZUy5FTlRFUiB8fCBrZXkgPT09IEtFWVMuU1BBQ0UgfHxcXG4gICAgICAgICAgICAoa2V5ID09PSBLRVlTLkRPV04gJiYgZXZ0LmFsdEtleSkpIHtcXG4gICAgICAgICAgc2VsZi5vcGVuKCk7XFxuXFxuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuX3N5bmNBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLm9wdGlvbnMuc2V0KCdkaXNhYmxlZCcsIHRoaXMuJGVsZW1lbnQucHJvcCgnZGlzYWJsZWQnKSk7XFxuXFxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xcbiAgICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XFxuICAgICAgICB0aGlzLmNsb3NlKCk7XFxuICAgICAgfVxcblxcbiAgICAgIHRoaXMudHJpZ2dlcignZGlzYWJsZScsIHt9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLnRyaWdnZXIoJ2VuYWJsZScsIHt9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLl9pc0NoYW5nZU11dGF0aW9uID0gZnVuY3Rpb24gKGV2dCwgbXV0YXRpb25zKSB7XFxuICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XFxuICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG4gICAgLy8gSWdub3JlIGFueSBtdXRhdGlvbiBldmVudHMgcmFpc2VkIGZvciBlbGVtZW50cyB0aGF0IGFyZW4ndCBvcHRpb25zIG9yXFxuICAgIC8vIG9wdGdyb3Vwcy4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIHdoZW4gdGhlIHNlbGVjdCBlbGVtZW50IGlzIGRlc3Ryb3llZFxcbiAgICBpZiAoXFxuICAgICAgZXZ0ICYmIGV2dC50YXJnZXQgJiYgKFxcbiAgICAgICAgZXZ0LnRhcmdldC5ub2RlTmFtZSAhPT0gJ09QVElPTicgJiYgZXZ0LnRhcmdldC5ub2RlTmFtZSAhPT0gJ09QVEdST1VQJ1xcbiAgICAgIClcXG4gICAgKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICghbXV0YXRpb25zKSB7XFxuICAgICAgLy8gSWYgbXV0YXRpb24gZXZlbnRzIGFyZW4ndCBzdXBwb3J0ZWQsIHRoZW4gd2UgY2FuIG9ubHkgYXNzdW1lIHRoYXQgdGhlXFxuICAgICAgLy8gY2hhbmdlIGFmZmVjdGVkIHRoZSBzZWxlY3Rpb25zXFxuICAgICAgY2hhbmdlZCA9IHRydWU7XFxuICAgIH0gZWxzZSBpZiAobXV0YXRpb25zLmFkZGVkTm9kZXMgJiYgbXV0YXRpb25zLmFkZGVkTm9kZXMubGVuZ3RoID4gMCkge1xcbiAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgbXV0YXRpb25zLmFkZGVkTm9kZXMubGVuZ3RoOyBuKyspIHtcXG4gICAgICAgIHZhciBub2RlID0gbXV0YXRpb25zLmFkZGVkTm9kZXNbbl07XFxuXFxuICAgICAgICBpZiAobm9kZS5zZWxlY3RlZCkge1xcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSBpZiAobXV0YXRpb25zLnJlbW92ZWROb2RlcyAmJiBtdXRhdGlvbnMucmVtb3ZlZE5vZGVzLmxlbmd0aCA+IDApIHtcXG4gICAgICBjaGFuZ2VkID0gdHJ1ZTtcXG4gICAgfSBlbHNlIGlmICgkLmlzQXJyYXkobXV0YXRpb25zKSkge1xcbiAgICAgICQuZWFjaChtdXRhdGlvbnMsIGZ1bmN0aW9uKGV2dCwgbXV0YXRpb24pIHtcXG4gICAgICAgIGlmIChzZWxmLl9pc0NoYW5nZU11dGF0aW9uKGV2dCwgbXV0YXRpb24pKSB7XFxuICAgICAgICAgIC8vIFdlJ3ZlIGZvdW5kIGEgY2hhbmdlIG11dGF0aW9uLlxcbiAgICAgICAgICAvLyBMZXQncyBlc2NhcGUgZnJvbSB0aGUgbG9vcCBhbmQgY29udGludWVcXG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gY2hhbmdlZDtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5fc3luY1N1YnRyZWUgPSBmdW5jdGlvbiAoZXZ0LCBtdXRhdGlvbnMpIHtcXG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLl9pc0NoYW5nZU11dGF0aW9uKGV2dCwgbXV0YXRpb25zKTtcXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xcblxcbiAgICAvLyBPbmx5IHJlLXB1bGwgdGhlIGRhdGEgaWYgd2UgdGhpbmsgdGhlcmUgaXMgYSBjaGFuZ2VcXG4gICAgaWYgKGNoYW5nZWQpIHtcXG4gICAgICB0aGlzLmRhdGFBZGFwdGVyLmN1cnJlbnQoZnVuY3Rpb24gKGN1cnJlbnREYXRhKSB7XFxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3NlbGVjdGlvbjp1cGRhdGUnLCB7XFxuICAgICAgICAgIGRhdGE6IGN1cnJlbnREYXRhXFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogT3ZlcnJpZGUgdGhlIHRyaWdnZXIgbWV0aG9kIHRvIGF1dG9tYXRpY2FsbHkgdHJpZ2dlciBwcmUtZXZlbnRzIHdoZW5cXG4gICAqIHRoZXJlIGFyZSBldmVudHMgdGhhdCBjYW4gYmUgcHJldmVudGVkLlxcbiAgICovXFxuICBTZWxlY3QyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcXG4gICAgdmFyIGFjdHVhbFRyaWdnZXIgPSBTZWxlY3QyLl9fc3VwZXJfXy50cmlnZ2VyO1xcbiAgICB2YXIgcHJlVHJpZ2dlck1hcCA9IHtcXG4gICAgICAnb3Blbic6ICdvcGVuaW5nJyxcXG4gICAgICAnY2xvc2UnOiAnY2xvc2luZycsXFxuICAgICAgJ3NlbGVjdCc6ICdzZWxlY3RpbmcnLFxcbiAgICAgICd1bnNlbGVjdCc6ICd1bnNlbGVjdGluZycsXFxuICAgICAgJ2NsZWFyJzogJ2NsZWFyaW5nJ1xcbiAgICB9O1xcblxcbiAgICBpZiAoYXJncyA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgYXJncyA9IHt9O1xcbiAgICB9XFxuXFxuICAgIGlmIChuYW1lIGluIHByZVRyaWdnZXJNYXApIHtcXG4gICAgICB2YXIgcHJlVHJpZ2dlck5hbWUgPSBwcmVUcmlnZ2VyTWFwW25hbWVdO1xcbiAgICAgIHZhciBwcmVUcmlnZ2VyQXJncyA9IHtcXG4gICAgICAgIHByZXZlbnRlZDogZmFsc2UsXFxuICAgICAgICBuYW1lOiBuYW1lLFxcbiAgICAgICAgYXJnczogYXJnc1xcbiAgICAgIH07XFxuXFxuICAgICAgYWN0dWFsVHJpZ2dlci5jYWxsKHRoaXMsIHByZVRyaWdnZXJOYW1lLCBwcmVUcmlnZ2VyQXJncyk7XFxuXFxuICAgICAgaWYgKHByZVRyaWdnZXJBcmdzLnByZXZlbnRlZCkge1xcbiAgICAgICAgYXJncy5wcmV2ZW50ZWQgPSB0cnVlO1xcblxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICBhY3R1YWxUcmlnZ2VyLmNhbGwodGhpcywgbmFtZSwgYXJncyk7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUudG9nZ2xlRHJvcGRvd24gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5pc09wZW4oKSkge1xcbiAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aGlzLm9wZW4oKTtcXG4gICAgfVxcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICh0aGlzLmlzT3BlbigpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLmlzRGlzYWJsZWQoKSkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0aGlzLnRyaWdnZXIoJ3F1ZXJ5Jywge30pO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGV2dCkge1xcbiAgICBpZiAoIXRoaXMuaXNPcGVuKCkpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgdGhpcy50cmlnZ2VyKCdjbG9zZScsIHsgb3JpZ2luYWxFdmVudCA6IGV2dCB9KTtcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIEhlbHBlciBtZXRob2QgdG8gYWJzdHJhY3QgdGhlIFxcXCJlbmFibGVkXFxcIiAobm90IFxcXCJkaXNhYmxlZFxcXCIpIHN0YXRlIG9mIHRoaXNcXG4gICAqIG9iamVjdC5cXG4gICAqXFxuICAgKiBAcmV0dXJuIHt0cnVlfSBpZiB0aGUgaW5zdGFuY2UgaXMgbm90IGRpc2FibGVkLlxcbiAgICogQHJldHVybiB7ZmFsc2V9IGlmIHRoZSBpbnN0YW5jZSBpcyBkaXNhYmxlZC5cXG4gICAqL1xcbiAgU2VsZWN0Mi5wcm90b3R5cGUuaXNFbmFibGVkID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gIXRoaXMuaXNEaXNhYmxlZCgpO1xcbiAgfTtcXG5cXG4gIC8qKlxcbiAgICogSGVscGVyIG1ldGhvZCB0byBhYnN0cmFjdCB0aGUgXFxcImRpc2FibGVkXFxcIiBzdGF0ZSBvZiB0aGlzIG9iamVjdC5cXG4gICAqXFxuICAgKiBAcmV0dXJuIHt0cnVlfSBpZiB0aGUgZGlzYWJsZWQgb3B0aW9uIGlzIHRydWUuXFxuICAgKiBAcmV0dXJuIHtmYWxzZX0gaWYgdGhlIGRpc2FibGVkIG9wdGlvbiBpcyBmYWxzZS5cXG4gICAqL1xcbiAgU2VsZWN0Mi5wcm90b3R5cGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5nZXQoJ2Rpc2FibGVkJyk7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuaXNPcGVuID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy4kY29udGFpbmVyLmhhc0NsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tb3BlbicpO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLmhhc0ZvY3VzID0gZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gdGhpcy4kY29udGFpbmVyLmhhc0NsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tZm9jdXMnKTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uIChkYXRhKSB7XFxuICAgIC8vIE5vIG5lZWQgdG8gcmUtdHJpZ2dlciBmb2N1cyBldmVudHMgaWYgd2UgYXJlIGFscmVhZHkgZm9jdXNlZFxcbiAgICBpZiAodGhpcy5oYXNGb2N1cygpKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcygnc2VsZWN0Mi1jb250YWluZXItLWZvY3VzJyk7XFxuICAgIHRoaXMudHJpZ2dlcignZm9jdXMnLCB7fSk7XFxuICB9O1xcblxcbiAgU2VsZWN0Mi5wcm90b3R5cGUuZW5hYmxlID0gZnVuY3Rpb24gKGFyZ3MpIHtcXG4gICAgaWYgKHRoaXMub3B0aW9ucy5nZXQoJ2RlYnVnJykgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XFxuICAgICAgY29uc29sZS53YXJuKFxcbiAgICAgICAgJ1NlbGVjdDI6IFRoZSBgc2VsZWN0MihcXFwiZW5hYmxlXFxcIilgIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsJyArXFxuICAgICAgICAnIGJlIHJlbW92ZWQgaW4gbGF0ZXIgU2VsZWN0MiB2ZXJzaW9ucy4gVXNlICRlbGVtZW50LnByb3AoXFxcImRpc2FibGVkXFxcIiknICtcXG4gICAgICAgICcgaW5zdGVhZC4nXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICBpZiAoYXJncyA9PSBudWxsIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XFxuICAgICAgYXJncyA9IFt0cnVlXTtcXG4gICAgfVxcblxcbiAgICB2YXIgZGlzYWJsZWQgPSAhYXJnc1swXTtcXG5cXG4gICAgdGhpcy4kZWxlbWVudC5wcm9wKCdkaXNhYmxlZCcsIGRpc2FibGVkKTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnZGVidWcnKSAmJlxcbiAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS53YXJuKSB7XFxuICAgICAgY29uc29sZS53YXJuKFxcbiAgICAgICAgJ1NlbGVjdDI6IERhdGEgY2FuIG5vIGxvbmdlciBiZSBzZXQgdXNpbmcgYHNlbGVjdDIoXFxcImRhdGFcXFwiKWAuIFlvdSAnICtcXG4gICAgICAgICdzaG91bGQgY29uc2lkZXIgc2V0dGluZyB0aGUgdmFsdWUgaW5zdGVhZCB1c2luZyBgJGVsZW1lbnQudmFsKClgLidcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIHZhciBkYXRhID0gW107XFxuXFxuICAgIHRoaXMuZGF0YUFkYXB0ZXIuY3VycmVudChmdW5jdGlvbiAoY3VycmVudERhdGEpIHtcXG4gICAgICBkYXRhID0gY3VycmVudERhdGE7XFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4gZGF0YTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoYXJncykge1xcbiAgICBpZiAodGhpcy5vcHRpb25zLmdldCgnZGVidWcnKSAmJiB3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcXG4gICAgICBjb25zb2xlLndhcm4oXFxuICAgICAgICAnU2VsZWN0MjogVGhlIGBzZWxlY3QyKFxcXCJ2YWxcXFwiKWAgbWV0aG9kIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUnICtcXG4gICAgICAgICcgcmVtb3ZlZCBpbiBsYXRlciBTZWxlY3QyIHZlcnNpb25zLiBVc2UgJGVsZW1lbnQudmFsKCkgaW5zdGVhZC4nXFxuICAgICAgKTtcXG4gICAgfVxcblxcbiAgICBpZiAoYXJncyA9PSBudWxsIHx8IGFyZ3MubGVuZ3RoID09PSAwKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuJGVsZW1lbnQudmFsKCk7XFxuICAgIH1cXG5cXG4gICAgdmFyIG5ld1ZhbCA9IGFyZ3NbMF07XFxuXFxuICAgIGlmICgkLmlzQXJyYXkobmV3VmFsKSkge1xcbiAgICAgIG5ld1ZhbCA9ICQubWFwKG5ld1ZhbCwgZnVuY3Rpb24gKG9iaikge1xcbiAgICAgICAgcmV0dXJuIG9iai50b1N0cmluZygpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIHRoaXMuJGVsZW1lbnQudmFsKG5ld1ZhbCkudHJpZ2dlcignaW5wdXQnKS50cmlnZ2VyKCdjaGFuZ2UnKTtcXG4gIH07XFxuXFxuICBTZWxlY3QyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLiRjb250YWluZXIucmVtb3ZlKCk7XFxuXFxuICAgIGlmICh0aGlzLiRlbGVtZW50WzBdLmRldGFjaEV2ZW50KSB7XFxuICAgICAgdGhpcy4kZWxlbWVudFswXS5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIHRoaXMuX3N5bmNBKTtcXG4gICAgfVxcblxcbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXIgIT0gbnVsbCkge1xcbiAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcXG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XFxuICAgIH0gZWxzZSBpZiAodGhpcy4kZWxlbWVudFswXS5yZW1vdmVFdmVudExpc3RlbmVyKSB7XFxuICAgICAgdGhpcy4kZWxlbWVudFswXVxcbiAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUF0dHJNb2RpZmllZCcsIHRoaXMuX3N5bmNBLCBmYWxzZSk7XFxuICAgICAgdGhpcy4kZWxlbWVudFswXVxcbiAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVJbnNlcnRlZCcsIHRoaXMuX3N5bmNTLCBmYWxzZSk7XFxuICAgICAgdGhpcy4kZWxlbWVudFswXVxcbiAgICAgICAgLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU5vZGVSZW1vdmVkJywgdGhpcy5fc3luY1MsIGZhbHNlKTtcXG4gICAgfVxcblxcbiAgICB0aGlzLl9zeW5jQSA9IG51bGw7XFxuICAgIHRoaXMuX3N5bmNTID0gbnVsbDtcXG5cXG4gICAgdGhpcy4kZWxlbWVudC5vZmYoJy5zZWxlY3QyJyk7XFxuICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnLFxcbiAgICBVdGlscy5HZXREYXRhKHRoaXMuJGVsZW1lbnRbMF0sICdvbGQtdGFiaW5kZXgnKSk7XFxuXFxuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3NlbGVjdDItaGlkZGVuLWFjY2Vzc2libGUnKTtcXG4gICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICdmYWxzZScpO1xcbiAgICBVdGlscy5SZW1vdmVEYXRhKHRoaXMuJGVsZW1lbnRbMF0pO1xcbiAgICB0aGlzLiRlbGVtZW50LnJlbW92ZURhdGEoJ3NlbGVjdDInKTtcXG5cXG4gICAgdGhpcy5kYXRhQWRhcHRlci5kZXN0cm95KCk7XFxuICAgIHRoaXMuc2VsZWN0aW9uLmRlc3Ryb3koKTtcXG4gICAgdGhpcy5kcm9wZG93bi5kZXN0cm95KCk7XFxuICAgIHRoaXMucmVzdWx0cy5kZXN0cm95KCk7XFxuXFxuICAgIHRoaXMuZGF0YUFkYXB0ZXIgPSBudWxsO1xcbiAgICB0aGlzLnNlbGVjdGlvbiA9IG51bGw7XFxuICAgIHRoaXMuZHJvcGRvd24gPSBudWxsO1xcbiAgICB0aGlzLnJlc3VsdHMgPSBudWxsO1xcbiAgfTtcXG5cXG4gIFNlbGVjdDIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyICRjb250YWluZXIgPSAkKFxcbiAgICAgICc8c3BhbiBjbGFzcz1cXFwic2VsZWN0MiBzZWxlY3QyLWNvbnRhaW5lclxcXCI+JyArXFxuICAgICAgICAnPHNwYW4gY2xhc3M9XFxcInNlbGVjdGlvblxcXCI+PC9zcGFuPicgK1xcbiAgICAgICAgJzxzcGFuIGNsYXNzPVxcXCJkcm9wZG93bi13cmFwcGVyXFxcIiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCI+PC9zcGFuPicgK1xcbiAgICAgICc8L3NwYW4+J1xcbiAgICApO1xcblxcbiAgICAkY29udGFpbmVyLmF0dHIoJ2RpcicsIHRoaXMub3B0aW9ucy5nZXQoJ2RpcicpKTtcXG5cXG4gICAgdGhpcy4kY29udGFpbmVyID0gJGNvbnRhaW5lcjtcXG5cXG4gICAgdGhpcy4kY29udGFpbmVyLmFkZENsYXNzKCdzZWxlY3QyLWNvbnRhaW5lci0tJyArIHRoaXMub3B0aW9ucy5nZXQoJ3RoZW1lJykpO1xcblxcbiAgICBVdGlscy5TdG9yZURhdGEoJGNvbnRhaW5lclswXSwgJ2VsZW1lbnQnLCB0aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgcmV0dXJuICRjb250YWluZXI7XFxuICB9O1xcblxcbiAgcmV0dXJuIFNlbGVjdDI7XFxufSk7XFxuXFxuUzIuZGVmaW5lKCdqcXVlcnktbW91c2V3aGVlbCcsW1xcbiAgJ2pxdWVyeSdcXG5dLCBmdW5jdGlvbiAoJCkge1xcbiAgLy8gVXNlZCB0byBzaGltIGpRdWVyeS5tb3VzZXdoZWVsIGZvciBub24tZnVsbCBidWlsZHMuXFxuICByZXR1cm4gJDtcXG59KTtcXG5cXG5TMi5kZWZpbmUoJ2pxdWVyeS5zZWxlY3QyJyxbXFxuICAnanF1ZXJ5JyxcXG4gICdqcXVlcnktbW91c2V3aGVlbCcsXFxuXFxuICAnLi9zZWxlY3QyL2NvcmUnLFxcbiAgJy4vc2VsZWN0Mi9kZWZhdWx0cycsXFxuICAnLi9zZWxlY3QyL3V0aWxzJ1xcbl0sIGZ1bmN0aW9uICgkLCBfLCBTZWxlY3QyLCBEZWZhdWx0cywgVXRpbHMpIHtcXG4gIGlmICgkLmZuLnNlbGVjdDIgPT0gbnVsbCkge1xcbiAgICAvLyBBbGwgbWV0aG9kcyB0aGF0IHNob3VsZCByZXR1cm4gdGhlIGVsZW1lbnRcXG4gICAgdmFyIHRoaXNNZXRob2RzID0gWydvcGVuJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knXTtcXG5cXG4gICAgJC5mbi5zZWxlY3QyID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnKSB7XFxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgaW5zdGFuY2VPcHRpb25zID0gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMpO1xcblxcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgU2VsZWN0MigkKHRoaXMpLCBpbnN0YW5jZU9wdGlvbnMpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICByZXR1cm4gdGhpcztcXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgdmFyIHJldDtcXG4gICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG5cXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IFV0aWxzLkdldERhdGEodGhpcywgJ3NlbGVjdDInKTtcXG5cXG4gICAgICAgICAgaWYgKGluc3RhbmNlID09IG51bGwgJiYgd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXFxuICAgICAgICAgICAgICAnVGhlIHNlbGVjdDIoXFxcXCcnICsgb3B0aW9ucyArICdcXFxcJykgbWV0aG9kIHdhcyBjYWxsZWQgb24gYW4gJyArXFxuICAgICAgICAgICAgICAnZWxlbWVudCB0aGF0IGlzIG5vdCB1c2luZyBTZWxlY3QyLidcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldCA9IGluc3RhbmNlW29wdGlvbnNdLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIGJlIHJldHVybmluZyBgdGhpc2BcXG4gICAgICAgIGlmICgkLmluQXJyYXkob3B0aW9ucywgdGhpc01ldGhvZHMpID4gLTEpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gcmV0O1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBTZWxlY3QyOiAnICsgb3B0aW9ucyk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgaWYgKCQuZm4uc2VsZWN0Mi5kZWZhdWx0cyA9PSBudWxsKSB7XFxuICAgICQuZm4uc2VsZWN0Mi5kZWZhdWx0cyA9IERlZmF1bHRzO1xcbiAgfVxcblxcbiAgcmV0dXJuIFNlbGVjdDI7XFxufSk7XFxuXFxuICAvLyBSZXR1cm4gdGhlIEFNRCBsb2FkZXIgY29uZmlndXJhdGlvbiBzbyBpdCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoaXMgZmlsZVxcbiAgcmV0dXJuIHtcXG4gICAgZGVmaW5lOiBTMi5kZWZpbmUsXFxuICAgIHJlcXVpcmU6IFMyLnJlcXVpcmVcXG4gIH07XFxufSgpKTtcXG5cXG4gIC8vIEF1dG9sb2FkIHRoZSBqUXVlcnkgYmluZGluZ3NcXG4gIC8vIFdlIGtub3cgdGhhdCBhbGwgb2YgdGhlIG1vZHVsZXMgZXhpc3QgYWJvdmUgdGhpcywgc28gd2UncmUgc2FmZVxcbiAgdmFyIHNlbGVjdDIgPSBTMi5yZXF1aXJlKCdqcXVlcnkuc2VsZWN0MicpO1xcblxcbiAgLy8gSG9sZCB0aGUgQU1EIG1vZHVsZSByZWZlcmVuY2VzIG9uIHRoZSBqUXVlcnkgZnVuY3Rpb24gdGhhdCB3YXMganVzdCBsb2FkZWRcXG4gIC8vIFRoaXMgYWxsb3dzIFNlbGVjdDIgdG8gdXNlIHRoZSBpbnRlcm5hbCBsb2FkZXIgb3V0c2lkZSBvZiB0aGlzIGZpbGUsIHN1Y2hcXG4gIC8vIGFzIGluIHRoZSBsYW5ndWFnZSBmaWxlcy5cXG4gIGpRdWVyeS5mbi5zZWxlY3QyLmFtZCA9IFMyO1xcblxcbiAgLy8gUmV0dXJuIHRoZSBTZWxlY3QyIGluc3RhbmNlIGZvciBhbnlvbmUgd2hvIGlzIGltcG9ydGluZyBpdC5cXG4gIHJldHVybiBzZWxlY3QyO1xcbn0pKTtcXG5cIiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNyYykge1xuXHRmdW5jdGlvbiBsb2coZXJyb3IpIHtcblx0XHQodHlwZW9mIGNvbnNvbGUgIT09IFwidW5kZWZpbmVkXCIpXG5cdFx0JiYgKGNvbnNvbGUuZXJyb3IgfHwgY29uc29sZS5sb2cpKFwiW1NjcmlwdCBMb2FkZXJdXCIsIGVycm9yKTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciBJRSA9PCA4XG5cdGZ1bmN0aW9uIGlzSUUoKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiBhdHRhY2hFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJ1bmRlZmluZWRcIjtcblx0fVxuXG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiICYmIGlzSUUoKSkge1xuXHRcdFx0ZXhlY1NjcmlwdChzcmMpO1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIGV2YWwgIT09IFwidW5kZWZpbmVkXCIpIHtcblx0XHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRsb2coXCJFdmFsRXJyb3I6IE5vIGV2YWwgZnVuY3Rpb24gYXZhaWxhYmxlXCIpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRsb2coZXJyb3IpO1xuXHR9XG59XG4iLCJyZXF1aXJlKFwiISEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC1zZWxlY3QvZGlzdC9qcy9ib290c3RyYXAtc2VsZWN0LmpzXCIpK1wiXFxuXFxuLy8gU0NSSVBULUxPQURFUiBGT09URVJcXG4vLyMgc291cmNlVVJMPXNjcmlwdDovLy9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL3NvdXJjZS1tYXAtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9qb2hhbm5lcy9EZXZlbG9wbWVudC9MaWJzL3R1dG9tdmMvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC1zZWxlY3QvZGlzdC9qcy9ib290c3RyYXAtc2VsZWN0LmpzXCIpIiwicmVxdWlyZShcIiEhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlci9pbmRleC5qcyEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvc291cmNlLW1hcC1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzXCIpIiwicmVxdWlyZShcIiEhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL2pvaGFubmVzL0RldmVsb3BtZW50L0xpYnMvdHV0b212Yy9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlci9pbmRleC5qcyEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zZWxlY3QyL2Rpc3QvanMvc2VsZWN0Mi5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zb3VyY2UtbWFwLWxvYWRlci9pbmRleC5qcyEvVXNlcnMvam9oYW5uZXMvRGV2ZWxvcG1lbnQvTGlicy90dXRvbXZjL25vZGVfbW9kdWxlcy9zZWxlY3QyL2Rpc3QvanMvc2VsZWN0Mi5qc1wiKSIsImltcG9ydCB7V1BBdHRhY2htZW50Rm9ybUlucHV0fSBmcm9tIFwiLi4vd3AvZm9ybS9pbnB1dHMvV1BBdHRhY2htZW50Rm9ybUlucHV0XCI7XG5qUXVlcnkoIGRvY3VtZW50ICkucmVhZHkoIGZ1bmN0aW9uICgpXG57XG5cdGpRdWVyeSggXCIud3BhdHRhY2htZW50Zm9ybWlucHV0XCIgKS5lYWNoKCBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0bmV3IFdQQXR0YWNobWVudEZvcm1JbnB1dCggalF1ZXJ5KCB0aGlzICksIGpRdWVyeSggdGhpcyApLmRhdGEoKSApO1xuXHR9ICk7XG4vL1x0alF1ZXJ5KCBcIi53cGF0dGFjaG1lbnRmb3JtaW5wdXQgLmJ0bi1yZW1vdmVcIiApLmNsaWNrKCBmdW5jdGlvbiAoIGUgKVxuLy9cdHtcbi8vXHRcdGUucHJldmVudERlZmF1bHQoKTtcbi8vXHRcdHZhciAkZWwgPSAkKCB0aGlzICk7XG4vL1x0XHQkZWwuY2xvc2VzdCggXCIubGlzdC1ncm91cC1pdGVtXCIgKS5yZW1vdmUoKTtcbi8vXG4vL1x0XHRuZXcgV1BBdHRhY2htZW50Rm9ybUlucHV0KCAkKCAkKCB0aGlzICkuZGF0YSggXCJ0YXJnZXRcIiApICksIFwicmVuZGVyXCIgKTtcbi8vXHR9ICk7XG4vL1x0alF1ZXJ5KCBcIi53cGF0dGFjaG1lbnRmb3JtaW5wdXQgLmJ0bi1hZGRcIiApLmNsaWNrKCBmdW5jdGlvbiAoIGUgKVxuLy9cdHtcbi8vXHRcdG5ldyBXUEF0dGFjaG1lbnRGb3JtSW5wdXQoICQoICQoIHRoaXMgKS5kYXRhKCBcInRhcmdldFwiICkgKSwgXCJvcGVuXCIgKTtcbi8vXHR9ICk7XG59ICk7IiwialF1ZXJ5KCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5KCBcImJvZHlcIiApLm9uKCBcImNsaWNrXCIsIFwiLndwZWRpdG9yLXBsYWNlaG9sZGVyLW92ZXJsYXlcIiwgKCBlICkgPT4ge1xuXHRcdGxldCAkY3VycmVudFRhcmdldCA9IGUuY3VycmVudFRhcmdldDtcblx0XHRsZXQgJGVsICAgICAgICAgICAgPSBqUXVlcnkoICRjdXJyZW50VGFyZ2V0LmNsb3Nlc3QoIFwiLndwZWRpdG9yLXBsYWNlaG9sZGVyXCIgKSApO1xuXHRcdGxldCBjb250ZW50ICAgICAgICA9ICRlbC5maW5kKCBcInRleHRhcmVhXCIgKS52YWwoKTtcblx0XHRjb25zb2xlLmxvZyggY29udGVudCApO1xuXHRcdGpRdWVyeS5hamF4KCAkZWwuZGF0YSggXCJhamF4LXVybFwiICksIHtcblx0XHRcdGRhdGE6ICAge1xuXHRcdFx0XHRjb250ZW50OmNvbnRlbnQsXG5cdFx0XHRcdFwiaWRcIjogICAkZWwuZGF0YSggXCJpZFwiICksXG5cdFx0XHR9LFxuXHRcdFx0c3VjY2VzczooIHJlc3VsdCApID0+IHtcblx0XHRcdFx0Y29uc29sZS5sb2coIHJlc3VsdCApO1xuXHRcdFx0XHQkZWwuaHRtbCggcmVzdWx0Lmh0bWwgKTtcblx0XHRcdFx0dGlueW1jZS5pbml0KCByZXN1bHQuc2V0dGluZ3MgKTtcblx0XHRcdFx0cXVpY2t0YWdzKCB7aWQ6JGVsLmRhdGEoIFwiaWRcIiApfSApO1xuXHRcdFx0XHR3aW5kb3cud3BBY3RpdmVFZGl0b3IgPSAkZWwuZGF0YSggXCJpZFwiICk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6ICBlcnJvciA9PiBjb25zb2xlLmVycm9yKCBlcnJvciApXG5cdFx0fSApO1xuXHR9ICk7XG59ICk7IiwiaW1wb3J0IHtNZXRhQm94fSBmcm9tIFwiLi4vd3AvZm9ybS9ncm91cHMvTWV0YUJveFwiO1xuXG5qUXVlcnkoIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkoIFwiLnR1dG9tdmMtc2V0dGluZ3MsLnR1dG9tdmMtbWV0YWJveCwudHV0b212Yy11c2VyX21ldGFib3hcIiApLmVhY2goIGZ1bmN0aW9uKCBpLCBlbCApIHtcblx0XHRuZXcgTWV0YUJveCggalF1ZXJ5KCBlbCApICk7XG5cdH0gKTtcbn0gKTsiLCJpbXBvcnQge1dQQXR0YWNobWVudEZvcm1JbnB1dH0gZnJvbSBcIi4uL2lucHV0cy9XUEF0dGFjaG1lbnRGb3JtSW5wdXRcIjtcblxuZXhwb3J0IGNsYXNzIE1ldGFCb3hcbntcblx0cHJpdmF0ZSBfJGVsOiBKUXVlcnk7XG5cblx0Y29uc3RydWN0b3IoICRlbDogSlF1ZXJ5IClcblx0e1xuXHRcdHRoaXMuXyRlbCA9ICRlbDtcblxuXHRcdC8vIFRPRE86IENoZWNrIGlmIHRoaXMgaXMgdXNlZC4gSWYgbm90LiBSZW1vdmUgdGhlIEFqYXggQ29tbWFuZHMgaW4gU3lzdGVtQXBwRmFjYWRlLlxuXHRcdHRoaXMuXyRlbC5vbiggXCJjaGFuZ2VcIiwgXCIuZmlzc2lsZS1mb3JtLWdyb3VwLW51a2VcIiwgKCBlICkgPT4gdGhpcy5wYXJzZSgpICk7XG5cdFx0Y29uc29sZS5sb2coIFwiTWV0YUJveFwiICk7XG5cdFx0Y29uc29sZS5sb2coIFR1dG9NVkMgKTtcblx0fVxuXG5cdHByaXZhdGUgcmVuZGVyKCBodG1sIClcblx0e1xuXHRcdHRoaXMuXyRlbC5odG1sKCBodG1sICk7XG5cdFx0dGhpcy5fJGVsLmZpbmQoIFwiLmZvcm0taW5wdXQtZWxlbWVudC5zZWxlY3QyXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnNlbGVjdDIoIGpRdWVyeSggdGhpcyApLmRhdGEoKSApO1xuXHRcdH0gKTtcblx0XHR0aGlzLl8kZWwuZmluZCggXCIuc2VsZWN0cGlja2VyXCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnNlbGVjdHBpY2tlciggalF1ZXJ5KCB0aGlzICkuZGF0YSgpICk7XG5cdFx0fSApO1xuXHRcdHRoaXMuXyRlbC5maW5kKCBcIi53cGF0dGFjaG1lbnRmb3JtaW5wdXRcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0bmV3IFdQQXR0YWNobWVudEZvcm1JbnB1dCggalF1ZXJ5KCB0aGlzICksIGpRdWVyeSggdGhpcyApLmRhdGEoKSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHByaXZhdGUgZGVzdHJveSgpXG5cdHtcblx0XHR0aGlzLl8kZWwuZmluZCggXCJ0ZXh0YXJlYS53cC1lZGl0b3ItYXJlYVwiICkuZWFjaCggKCBpLCBlbCApID0+IHtcblx0XHRcdGNvbnNvbGUubG9nKCBcIkRFU09UUlk6XCIsIGpRdWVyeSggZWwgKS5hdHRyKCBcImlkXCIgKSApO1xuXHRcdFx0dGlueW1jZS5yZW1vdmUoIFwiI1wiICsgalF1ZXJ5KCBlbCApLmF0dHIoIFwiaWRcIiApICk7XG4vL1x0XHRcdHRpbnltY2UuZXhlY0NvbW1hbmQoICdtY2VSZW1vdmVDb250cm9sJywgdHJ1ZSwgalF1ZXJ5KCBlbCApLmF0dHIoIFwiaWRcIiApICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cHJpdmF0ZSBwYXJzZSgpXG5cdHtcblx0XHRpZiggdGhpcy4kZm9ybS5sZW5ndGggKVxuXHRcdHtcblx0XHRcdGlmKCB0eXBlb2YgdGlueW1jZSAhPT0gJ3VuZGVmaW5lZCcgKVxuXHRcdFx0e1xuXHRcdFx0XHR0aW55bWNlLnRyaWdnZXJTYXZlKCk7XG5cdFx0XHR9XG5cdFx0XHRsZXQgZGF0YSA9IG5ldyBGb3JtRGF0YSggdGhpcy4kZm9ybVsgMCBdICk7XG5cdFx0XHRkYXRhLmFwcGVuZCggXCJhY3Rpb25cIiwgVHV0b01WQy5wYXJzZUFjdGlvbiApO1xuXHRcdFx0ZGF0YS5hcHBlbmQoIFwibm9uY2VcIiwgVHV0b01WQy5wYXJzZU5vbmNlICk7XG5cdFx0XHRsZXQgdXJsICAgICAgICAgPSBUdXRvTVZDLnBhcnNlVVJMICsgXCImaWQ9XCIgKyB0aGlzLmlkICsgXCImdHlwZT1cIiArIHRoaXMudHlwZTtcblx0XHRcdGNvbnNvbGUubG9nKHVybCk7XG5cdFx0XHR2YXIgYWpheFJlcXVlc3QgPSBqUXVlcnkuYWpheCggdXJsLCB7XG5cdFx0XHRcdGRhdGE6ICAgICAgIGRhdGEsXG5cdFx0XHRcdG1ldGhvZDogICAgIFwiUE9TVFwiLFxuXHRcdFx0XHRjb250ZW50VHlwZTpmYWxzZSxcblx0XHRcdFx0cHJvY2Vzc0RhdGE6ZmFsc2UsXG5cdFx0XHRcdHN1Y2Nlc3M6ICAgICggcmVzdWx0ICkgPT4ge1xuXHRcdFx0XHRcdGlmKCByZXN1bHQgKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKHJlc3VsdCk7XG5cdFx0XHRcdFx0XHRsZXQgJG1ldGFib3ggPSBqUXVlcnkoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlciggJG1ldGFib3guaHRtbCgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcjogICAgICByZXN1bHQgPT4gY29uc29sZS5lcnJvciggcmVzdWx0IClcblx0XHRcdH0gKTtcblx0XHR9XG5cdH1cblxuXHQvKiBTRVQgQU5EIEdFVCAqL1xuXHRnZXQgaWQoKTogc3RyaW5nXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fJGVsLmF0dHIoIFwiaWRcIiApO1xuXHR9XG5cblx0Z2V0ICRmb3JtKCk6IEpRdWVyeVxuXHR7XG5cdFx0cmV0dXJuIGpRdWVyeSggdGhpcy5fJGVsLmNsb3Nlc3QoIFwiZm9ybVwiICkgKTtcblx0fVxuXG5cdGdldCB0eXBlKCk6IHN0cmluZ1xuXHR7XG5cdFx0aWYoIHRoaXMuXyRlbC5oYXNDbGFzcyggXCJ0dXRvbXZjLW1ldGFib3hcIiApICkgcmV0dXJuIFwibWV0YWJveFwiO1xuXHRcdGlmKCB0aGlzLl8kZWwuaGFzQ2xhc3MoIFwidHV0b212Yy11c2VyX21ldGFib3hcIiApICkgcmV0dXJuIFwidXNlcl9tZXRhYm94XCI7XG5cdFx0aWYoIHRoaXMuXyRlbC5oYXNDbGFzcyggXCJ0dXRvbXZjLXNldHRpbmdzXCIgKSApIHJldHVybiBcInNldHRpbmdzXCI7XG5cdH1cbn1cbiIsImV4cG9ydCBjbGFzcyBXUEF0dGFjaG1lbnRGb3JtSW5wdXRcbntcblx0cHVibGljICRlbDogSlF1ZXJ5O1xuXHRwdWJsaWMgb3B0aW9uczogSVdQQXR0YWNobWVudEZvcm1JbnB1dE9wdGlvbnMgPSB7XG5cdFx0bWF4OiAgICAgICAtMSxcblx0XHR0aXRsZTogICAgIFwiXCIsXG5cdFx0YnV0dG9uVGV4dDpcIlwiLFxuXHRcdHR5cGU6ICAgICAgbnVsbCxcblx0XHRmcmFtZTogICAgIFwic2VsZWN0XCJcblx0fTtcblx0cHVibGljIHdwTWVkaWE6IGFueTtcblx0cHVibGljIHRlbXBsYXRlOiBhbnk7XG5cblx0Y29uc3RydWN0b3IoICRlbDogSlF1ZXJ5LCBvcHRpb25zOiBPYmplY3QgKVxuXHR7XG5cdFx0dGhpcy4kZWwgICAgICA9ICRlbDtcblx0XHQvLyBNb2RlbFxuXHRcdHRoaXMub3B0aW9ucyAgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zICk7XG5cdFx0Ly8gVmlld1xuXHRcdHRoaXMudGVtcGxhdGUgPSBfLnRlbXBsYXRlKCB0aGlzLiRlbC5maW5kKCBcInRleHRhcmVhLnVuZGVyc2NvcmUtdGVtcGxhdGVcIiApLnZhbCgpICk7XG5cdFx0dGhpcy53cE1lZGlhICA9IHdwLm1lZGlhKCB7XG5cdFx0XHR0aXRsZTogICB0aGlzLm9wdGlvbnMudGl0bGUsXG5cdFx0XHRtdWx0aXBsZTp0aGlzLm9wdGlvbnMubWF4IDwgMCB8fCB0aGlzLm9wdGlvbnMubWF4ID4gMSA/IHRydWUgOiBmYWxzZSxcblx0XHRcdGxpYnJhcnk6IHRoaXMub3B0aW9ucy50eXBlID8ge3R5cGU6dGhpcy5vcHRpb25zLnR5cGV9IDogdW5kZWZpbmVkLFxuXHRcdFx0YnV0dG9uOiAge3RleHQ6dGhpcy5vcHRpb25zLmJ1dHRvblRleHR9LFxuXHRcdFx0ZnJhbWU6ICAgdGhpcy5vcHRpb25zLmZyYW1lXG5cdFx0fSApO1xuXHRcdC8vIENvbnRyb2xsZXJcblx0XHR0aGlzLndwTWVkaWEub24oIFwic2VsZWN0XCIsICgpID0+IHRoaXMub25XUE1lZGlhU2VsZWN0KCkgKTtcblx0XHR0aGlzLiRlbC5vbiggXCJjbGlja1wiLCBcIi5idG4tYWRkXCIsICgpID0+IHRoaXMub3BlbigpICk7XG5cdFx0dGhpcy4kZWwub24oIFwiY2xpY2tcIiwgXCIuYnRuLXJlbW92ZVwiLCAoIGUgKSA9PiB0aGlzLm9uUmVtb3ZlQ2xpY2soIGUgKSApO1xuXG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fVxuXG5cdHB1YmxpYyByZW5kZXIoKVxuXHR7XG5cdFx0aWYoIHRoaXMuY291bnQgPj0gdGhpcy5vcHRpb25zLm1heCAmJiB0aGlzLm9wdGlvbnMubWF4ID49IDAgKSB0aGlzLiRlbC5maW5kKCBcIi5idG4tYWRkXCIgKS5wcm9wKCBcImRpc2FibGVkXCIsIFwiZGlzYWJsZWRcIiApO1xuXHRcdGVsc2UgdGhpcy4kZWwuZmluZCggXCIuYnRuLWFkZFwiICkucHJvcCggXCJkaXNhYmxlZFwiLCBudWxsICk7XG5cdH1cblxuXHRwdWJsaWMgb3BlbigpXG5cdHtcblx0XHR0aGlzLndwTWVkaWEub3BlbigpO1xuXHR9O1xuXG5cdHB1YmxpYyBhZGQoIGF0dGFjaG1lbnRNb2RlbDogV1BNZWRpYUF0dGFjaG1lbnRNb2RlbCApXG5cdHtcblx0XHR2YXIgX190aGlzICAgICAgICAgID0gdGhpcztcblx0XHRhdHRhY2htZW50TW9kZWwuc3JjID0gYXR0YWNobWVudE1vZGVsLmljb247XG5cdFx0aWYoICFhdHRhY2htZW50TW9kZWwud2lkdGggKSBhdHRhY2htZW50TW9kZWwud2lkdGggPSBcIlwiO1xuXHRcdGlmKCAhYXR0YWNobWVudE1vZGVsLmhlaWdodCApIGF0dGFjaG1lbnRNb2RlbC5oZWlnaHQgPSBcIlwiO1xuXHRcdGlmKCBhdHRhY2htZW50TW9kZWwuc2l6ZXMgKVxuXHRcdHtcblx0XHRcdGlmKCBhdHRhY2htZW50TW9kZWwuc2l6ZXMudGh1bWJuYWlsICYmIGF0dGFjaG1lbnRNb2RlbC5zaXplcy50aHVtYm5haWwudXJsIClcblx0XHRcdHtcblx0XHRcdFx0YXR0YWNobWVudE1vZGVsLnNyYyA9IGF0dGFjaG1lbnRNb2RlbC5zaXplcy50aHVtYm5haWwudXJsO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiggYXR0YWNobWVudE1vZGVsLnNpemVzLmZ1bGwgJiYgYXR0YWNobWVudE1vZGVsLnNpemVzLmZ1bGwudXJsIClcblx0XHRcdHtcblx0XHRcdFx0YXR0YWNobWVudE1vZGVsLnNyYyA9IGF0dGFjaG1lbnRNb2RlbC5zaXplcy5mdWxsLnVybDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyICRlbCA9IGpRdWVyeSggdGhpcy50ZW1wbGF0ZSggYXR0YWNobWVudE1vZGVsICkgKTtcblx0XHR0aGlzLiRlbC5maW5kKCBcIi5saXN0LWdyb3VwXCIgKS5hcHBlbmQoICRlbCApO1xuXHR9O1xuXG5cdC8qIFNFVCBBTkQgR0VUICovXG5cdHB1YmxpYyBnZXQgY291bnQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuJGVsLmZpbmQoIFwiLmxpc3QtZ3JvdXAtaXRlbVwiICkubGVuZ3RoO1xuXHR9XG5cblx0LyogRVZFTlQgSEFORExFUlMgKi9cblx0cHJpdmF0ZSBvbldQTWVkaWFTZWxlY3QoKVxuXHR7XG5cdFx0dmFyIHNlbGVjdGlvbiA9IHRoaXMud3BNZWRpYS5zdGF0ZSgpLmdldCggJ3NlbGVjdGlvbicgKTtcblx0XHR2YXIgX190aGlzICAgID0gdGhpcztcblx0XHRzZWxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGF0dGFjaG1lbnQgKVxuXHRcdHtcblx0XHRcdGlmKCBfX3RoaXMub3B0aW9ucy5tYXggPCAwIHx8IF9fdGhpcy5jb3VudCA8IF9fdGhpcy5vcHRpb25zLm1heCApXG5cdFx0XHR7XG5cdFx0XHRcdF9fdGhpcy5hZGQoIGF0dGFjaG1lbnQudG9KU09OKCkgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHR0aGlzLnJlbmRlcigpO1xuXHR9O1xuXG5cdHByaXZhdGUgb25SZW1vdmVDbGljayggZSApXG5cdHtcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dmFyICRlbCA9IGpRdWVyeSggZS5jdXJyZW50VGFyZ2V0ICk7XG5cdFx0JGVsLmNsb3Nlc3QoIFwiLmxpc3QtZ3JvdXAtaXRlbVwiICkucmVtb3ZlKCk7XG5cdFx0dGhpcy5yZW5kZXIoKTtcblx0fVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIElXUEF0dGFjaG1lbnRGb3JtSW5wdXRPcHRpb25zXG57XG5cdG1heDogbnVtYmVyO1xuXHR0aXRsZTogc3RyaW5nO1xuXHRidXR0b25UZXh0OiBzdHJpbmc7XG5cdHR5cGU6IHN0cmluZztcblx0ZnJhbWU6IHN0cmluZztcbn0iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiaW1wb3J0IFwiLi4vbGVzcy90dXRvbXZjLmxlc3NcIjtcbmltcG9ydCBcInNjcmlwdC1sb2FkZXIhYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzXCI7XG5pbXBvcnQgXCJzY3JpcHQtbG9hZGVyIXNlbGVjdDIvZGlzdC9qcy9zZWxlY3QyLmpzXCI7XG5pbXBvcnQgXCJzY3JpcHQtbG9hZGVyIWJvb3RzdHJhcC1zZWxlY3QvZGlzdC9qcy9ib290c3RyYXAtc2VsZWN0LmpzXCI7XG5pbXBvcnQgXCIuL3BsdWdpbnMvalF1ZXJ5V1BBdHRhY2htZW50Rm9ybUlucHV0XCI7XG5pbXBvcnQgXCIuL3BsdWdpbnMvalF1ZXJ5V1BFZGl0b3JGb3JtSW5wdXRcIjtcbmltcG9ydCBcIi4vcGx1Z2lucy9qUXVlcnlXUE1ldGFCb3hcIjtcblxuKGZ1bmN0aW9uKCAkIClcbntcblx0JCggZG9jdW1lbnQgKS5yZWFkeSggZnVuY3Rpb24oKVxuXHR7XG5cdFx0Ly8gU2VsZWN0MkZvcm1JbnB1dFxuXHRcdCQoIFwiLmZvcm0taW5wdXQtZWxlbWVudC5zZWxlY3QyXCIgKS5lYWNoKCBmdW5jdGlvbigpXG5cdFx0e1xuXHRcdFx0JCggdGhpcyApLnNlbGVjdDIoICQoIHRoaXMgKS5kYXRhKCkgKTtcblx0XHR9ICk7XG5cdH0gKTtcbn0pKCBqUXVlcnkgKTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=